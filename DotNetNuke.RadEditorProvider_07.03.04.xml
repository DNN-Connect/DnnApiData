<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<root file="DotNetNuke.RadEditorProvider.dll" version="07.03.04" generated="2017-06-19 14:14:54Z" generationTime="5.5864099">
  <namespace name="DotNetNuke.Providers.RadEditorProvider">
    <class name="ConfigInfo">
      <declaration><![CDATA[public class ConfigInfo]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ConfigInfo(string Key, string Value, bool IsSeparator)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="32" sc="9" el="37" ec="10">Components\ConfigInfo.cs</location>
            <body hash="647671e8043b2b4580766d6b2eab34e3"><![CDATA[public ConfigInfo(string Key, string Value, bool IsSeparator)
        {
            this.Value = Value;
            this.Key = Key;
            this.IsSeparator = IsSeparator;
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="IsSeparator">
          <declaration><![CDATA[public bool IsSeparator]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Key">
          <declaration><![CDATA[public string Key]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Value">
          <declaration><![CDATA[public string Value]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="DialogParams">
      <declaration><![CDATA[public class DialogParams]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public DialogParams()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Clicks">
          <declaration><![CDATA[public string Clicks]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="DateCreated">
          <declaration><![CDATA[public string DateCreated]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="EnableUrlLanguage">
          <declaration><![CDATA[public bool EnableUrlLanguage]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="HomeDirectory">
          <declaration><![CDATA[public string HomeDirectory]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="LastClick">
          <declaration><![CDATA[public string LastClick]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="LinkAction">
          <declaration><![CDATA[public string LinkAction]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="LinkClickUrl">
          <declaration><![CDATA[public string LinkClickUrl]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="LinkUrl">
          <declaration><![CDATA[public string LinkUrl]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="LogEndDate">
          <declaration><![CDATA[public string LogEndDate]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="LogStartDate">
          <declaration><![CDATA[public string LogStartDate]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="ModuleId">
          <declaration><![CDATA[public int ModuleId]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="PortalGuid">
          <declaration><![CDATA[public string PortalGuid]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="PortalId">
          <declaration><![CDATA[public int PortalId]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="TabId">
          <declaration><![CDATA[public int TabId]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Track">
          <declaration><![CDATA[public bool Track]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="TrackingLog">
          <declaration><![CDATA[public string TrackingLog]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="TrackUser">
          <declaration><![CDATA[public bool TrackUser]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="DotNetNukeDialogHandler">
      <declaration><![CDATA[public class DotNetNukeDialogHandler : DialogHandler]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public DotNetNukeDialogHandler()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static DotNetNukeDialogHandler()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="40" sc="9" el="40" ec="153">DotNetNukeDialogHandler.cs</location>
            <body hash="23e8b895c874d89003e4cf3916543985"><![CDATA[private static Regex LocalizeRegex = new Regex("\\[\\$LocalizeString\\(['\"](.+?)['\"]\\)\\]", RegexOptions.IgnoreCase | RegexOptions.Compiled)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="GetLocalizeContent">
          <declaration><![CDATA[private string GetLocalizeContent(string key)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="76" sc="9" el="84" ec="10">DotNetNukeDialogHandler.cs</location>
            <body hash="a27e3a99de3418fff3c1aa96633039cc"><![CDATA[{
            var content = Localization.GetString(string.Format("{0}_{1}", DialogName, key), ResourceFile);
            if(string.IsNullOrEmpty(content))
            {
                content = Localization.GetString(string.Format("Common_{0}", key), ResourceFile);
            }

            return content;
        }]]></body>
          </codeblock>
        </method>
        <method name="OnInit">
          <declaration><![CDATA[protected override void OnInit(EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="43" sc="3" el="52" ec="4">DotNetNukeDialogHandler.cs</location>
            <body hash="f577c697ad6c31e37567f271de098c9f"><![CDATA[{
			base.OnInit(e);

			PortalSettings settings = PortalController.Instance.GetCurrentPortalSettings();
			CultureInfo pageLocale = Localization.GetPageLocale(settings);
			if (settings != null && pageLocale != null)
			{
				Localization.SetThreadCultures(pageLocale, settings);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Render">
          <declaration><![CDATA[protected override void Render(System.Web.UI.HtmlTextWriter writer)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="55" sc="9" el="73" ec="10">DotNetNukeDialogHandler.cs</location>
            <body hash="7686ae4ae76f2025e5f383788cbc0567"><![CDATA[{
            var  content = new StringBuilder();
            var stringWriter = new StringWriter(content);
            var htmlWriter = new HtmlTextWriter(stringWriter);
            base.Render(htmlWriter);

            var matches = LocalizeRegex.Matches(content.ToString());
            foreach (Match match in matches)
            {
                var key = match.Groups[1].Value;
                var localizedContent = GetLocalizeContent(key);

                content.Replace(match.Value, string.IsNullOrEmpty(localizedContent) ? key : localizedContent);
            }

	        content.Replace("[$protocol$]", Request.IsSecureConnection ? "https://" : "http://");

            writer.Write(content);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="LocalizeRegex">
          <declaration><![CDATA[private static Regex LocalizeRegex = new Regex("\\[\\$LocalizeString\\(['\"](.+?)['\"]\\)\\]", RegexOptions.IgnoreCase | RegexOptions.Compiled);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ResourceFile">
          <declaration><![CDATA[private const string ResourceFile = "~/DesktopModules/Admin/RadEditorProvider/App_LocalResources/RadEditor.Dialogs.resx";]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="EditorProvider">
      <declaration><![CDATA[public class EditorProvider : HtmlEditorProvider]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private readonly DnnEditor _editor = new DnnEditor();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1194" sc="3" el="1218" ec="10">Components\EditorProvider.cs</location>
            <body hash="e95808b6b40d214f01cdd99e45e2e842"><![CDATA[private readonly DnnEditor _editor = new DnnEditor();
        private readonly Panel _panel = new Panel();
        private bool _ShowPortalLinks = true;

        //must override properties
        private const string ConfigFileName = moduleFolderPath + "/ConfigFile/ConfigFile.xml";
            
        //other provider specific properties

        private bool _languageSet;
        private bool _linksUseRelativeUrls = true;
        private string _linksType = "Normal";
        private string _localeFile = moduleFolderPath + "/App_LocalResources/RadEditor.Main.resx";
        private string _scripttoload = "";
        private const string ToolsFileName = moduleFolderPath + "/ToolsFile/ToolsFile.xml";

        public EditorProvider()
        {
            RootImageDirectory = PortalSettings.HomeDirectory;

            _panel.Init += Panel_Init;
            _panel.Load += Panel_Load;
            _panel.PreRender += Panel_PreRender;
            _editor.Load += RadEditor_Load;
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AddChildLinks">
          <declaration><![CDATA[private void AddChildLinks(int TabId, ref EditorLink links)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="503" sc="9" el="522" ec="10">Components\EditorProvider.cs</location>
            <body hash="1e53d78620c60cd2acbd1a30cae085f4"><![CDATA[{
            List<TabInfo> tabs = TabController.GetPortalTabs(PortalSettings.PortalId, Null.NullInteger, false, "", true, false, true, true, false);
            foreach (TabInfo objTab in tabs)
            {
                if (objTab.ParentId == TabId)
                {
                    //these are viewable children (current user's rights)
                    if (objTab.HasChildren)
                    {
                        //has more children
                        EditorLink tempVar = AddLink(objTab, ref links);
                        AddChildLinks(objTab.TabID, ref tempVar);
                    }
                    else
                    {
                        AddLink(objTab, ref links);
                    }
                }
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="AddLink">
          <declaration><![CDATA[private EditorLink AddLink(TabInfo objTab, ref EditorLink parent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="470" sc="9" el="500" ec="10">Components\EditorProvider.cs</location>
            <body hash="ebc11946cb50ed2b93a8b2c9f333ca28"><![CDATA[{
            string linkUrl = string.Empty;
            if (! objTab.DisableLink)
            {
	            switch (_linksType.ToUpperInvariant())
	            {
					case "USETABNAME":
						var nameLinkFormat = "http://{0}/Default.aspx?TabName={1}";
						linkUrl = string.Format(nameLinkFormat, PortalSettings.PortalAlias.HTTPAlias, HttpUtility.UrlEncode(objTab.TabName));
						break;
					case "USETABID":
						var idLinkFormat = "http://{0}/Default.aspx?TabId={1}";
						linkUrl = string.Format(idLinkFormat, PortalSettings.PortalAlias.HTTPAlias, objTab.TabID);
						break;
					default:
						linkUrl = objTab.FullUrl;
						break;
	            }
                if (_linksUseRelativeUrls && (linkUrl.StartsWith("http://") || linkUrl.StartsWith("https://")))
                {
                    int linkIndex = linkUrl.IndexOf("/", 8);
                    if (linkIndex > 0)
                    {
                        linkUrl = linkUrl.Substring(linkIndex);
                    }
                }
            }
            var newLink = new EditorLink(objTab.LocalizedTabName.Replace("\\", "\\\\"), linkUrl);
            parent.ChildLinks.Add(newLink);
            return newLink;
        }]]></body>
          </codeblock>
        </method>
        <method name="AddPortalLinks">
          <declaration><![CDATA[private void AddPortalLinks()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="525" sc="9" el="548" ec="10">Components\EditorProvider.cs</location>
            <body hash="de6ba336fe9e4369e8ce2bb940486dca"><![CDATA[{
            var portalLinks = new EditorLink(Localization.GetString("PortalLinks", Localization.GlobalResourceFile), string.Empty);
            _editor.Links.Add(portalLinks);

            //Add links to custom link menu
            List<TabInfo> tabs = TabController.GetPortalTabs(PortalSettings.PortalId, Null.NullInteger, false, "", true, false, true, true, false);
            foreach (TabInfo objTab in tabs)
            {
                //check permissions and visibility of current tab
                if (objTab.Level == 0)
                {
                    if (objTab.HasChildren)
                    {
                        //is a root tab, and has children
                        EditorLink tempVar = AddLink(objTab, ref portalLinks);
                        AddChildLinks(objTab.TabID, ref tempVar);
                    }
                    else
                    {
                        AddLink(objTab, ref portalLinks);
                    }
                }
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="AddSlash">
          <declaration><![CDATA[private string AddSlash(string Folderpath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="370" sc="9" el="379" ec="10">Components\EditorProvider.cs</location>
            <body hash="bbe581092882f991d1909da29837c440"><![CDATA[{
            if (Folderpath.StartsWith("/"))
            {
                return Folderpath.Replace("//", "/");
            }
            else
            {
                return "/" + Folderpath;
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="AddToolbar">
          <declaration><![CDATA[public override void AddToolbar()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="444" sc="9" el="446" ec="10">Components\EditorProvider.cs</location>
            <body hash="482200aaad5d2ca50e02d250fc561c3c"><![CDATA[{
            //must override...
        }]]></body>
          </codeblock>
        </method>
        <method name="ApplySearchPatternFilter">
          <declaration><![CDATA[private string[] ApplySearchPatternFilter(string[] patterns)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="903" sc="9" el="925" ec="10">Components\EditorProvider.cs</location>
            <body hash="bf2f1f492067d6463fc9b68cd1614f85"><![CDATA[{
            FileExtensionWhitelist hostWhiteList = Host.AllowedExtensionWhitelist;

            if (patterns.Length == 1 && patterns[0] == "*.*")
            {
                //todisplaystring converts to a "*.xxx, *.yyy" format which is then split for return
                return hostWhiteList.ToDisplayString().Split(',');
            }
            else
            {
                var returnPatterns = new List<string>();

                foreach (string pattern in patterns)
                {
                    if (hostWhiteList.IsAllowedExtension(pattern.Substring(1)))
                    {
                        returnPatterns.Add(pattern);
                    }
                }

                return returnPatterns.ToArray();
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="EnsurecDefaultToolsFileExists">
          <declaration><![CDATA[internal static void EnsurecDefaultToolsFileExists()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="242" sc="9" el="244" ec="10">Components\EditorProvider.cs</location>
            <body hash="2e2ba711e0ddc483d8b31b256d696a1e"><![CDATA[{
            EnsureDefaultFileExists(HttpContext.Current.Server.MapPath(ToolsFileName));
        }]]></body>
          </codeblock>
        </method>
        <method name="EnsureDefaultConfigFileExists">
          <declaration><![CDATA[internal static void EnsureDefaultConfigFileExists()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="237" sc="9" el="239" ec="10">Components\EditorProvider.cs</location>
            <body hash="06713ca5959d38c6cd8b9477b2b3aa8c"><![CDATA[{
            EnsureDefaultFileExists(HttpContext.Current.Server.MapPath(ConfigFileName));
        }]]></body>
          </codeblock>
        </method>
        <method name="EnsureDefaultFileExists">
          <declaration><![CDATA[private static void EnsureDefaultFileExists(string path)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="247" sc="9" el="258" ec="10">Components\EditorProvider.cs</location>
            <body hash="8680e507c5fbbbbea264edbd79a2d102"><![CDATA[{
            if (!File.Exists(path))
            {
                string filePath = Path.GetDirectoryName(path);
                string name = "default." + Path.GetFileName(path);
                string defaultConfigFile = Path.Combine(filePath, name);

                //if defaultConfigFile is missing there is a big problem
                //let the error propogate to the module level
                File.Copy(defaultConfigFile, path);
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="GetValidConfigFile">
          <declaration><![CDATA[protected XmlDocument GetValidConfigFile()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1151" sc="9" el="1162" ec="10">Components\EditorProvider.cs</location>
            <body hash="f5501af87ce76196d7f565125ac8db23"><![CDATA[{
            var xmlConfigFile = new XmlDocument();
            try
            {
                xmlConfigFile.Load(GetXmlFilePath(ConfigFile));
            }
            catch (Exception ex)
            {
                throw new Exception("Invalid Configuration File:" + ConfigFile, ex);
            }
            return xmlConfigFile;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetXmlFilePath">
          <declaration><![CDATA[private string GetXmlFilePath(string path)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1133" sc="9" el="1148" ec="10">Components\EditorProvider.cs</location>
            <body hash="441651488a82b0cc889833dd3c5c659e"><![CDATA[{
            //In case the file is declared as "http://someservername/somefile.xml"
            if (path.StartsWith("http://") || path.StartsWith("https://"))
            {
                return path;
            }
            string convertedPath = Context.Request.MapPath(path);
            if (File.Exists(convertedPath))
            {
                return convertedPath;
            }
            else
            {
                return path;
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="Initialize">
          <declaration><![CDATA[public override void Initialize()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="555" sc="9" el="900" ec="10">Components\EditorProvider.cs</location>
            <body hash="ee81e1e6e28beecd98373f4c12a8aa24"><![CDATA[{
            _editor.ToolsFile = ToolsFile;
            _editor.EnableViewState = false;   

            _editor.ExternalDialogsPath = moduleFolderPath + "Dialogs/";
            _editor.OnClientCommandExecuting = "OnClientCommandExecuting";


            if (! string.IsNullOrEmpty(ConfigFile))
            {
                XmlDocument xmlDoc = GetValidConfigFile();
                var colorConverter = new WebColorConverter();
                var items = new ArrayList();

                if (xmlDoc != null)
                {
                    foreach (XmlNode node in xmlDoc.DocumentElement.ChildNodes)
                    {
                        if (node.Attributes == null || node.Attributes["name"] == null || node.InnerText.Length == 0)
                        {
                            continue;
                        }

                        string propertyName = node.Attributes["name"].Value;
                        string propValue = node.InnerText;
                        //use reflection to set all string and bool properties
                        SetEditorProperty(propertyName, propValue);
                        //the following collections are handled by the tools file now:
                        //CssFiles, Colors, Symbols, Links, FontNames, FontSizes, Paragraphs, RealFontSizes
                        //CssClasses, Snippets, Languages
                        switch (propertyName)
                        {
                            case "AutoResizeHeight":
                                {
                                    _editor.AutoResizeHeight = bool.Parse(node.InnerText);
                                    break;
                                }
                            case "BorderWidth":
                                {
                                    _editor.BorderWidth = Unit.Parse(node.InnerText);
                                    break;
                                }
                            case "EnableResize":
                                {
                                    _editor.EnableResize = bool.Parse(node.InnerText);
                                    break;
                                }
                            case "NewLineBr":
                                {
                                    //use NewLineMode as NewLineBR has been obsoleted
                                    if (bool.Parse(node.InnerText)==true)
                                    {
                                        _editor.NewLineMode = EditorNewLineModes.Br;
                                        }
                                    else
                                    {
                                        _editor.NewLineMode = EditorNewLineModes.P; 
                                    }
                                    break;
                                }
                            case "Height":
                                {
                                    _editor.Height = Unit.Parse(node.InnerText);
                                    break;
                                }
                            case "Width":
                                {
                                    _editor.Width = Unit.Parse(node.InnerText);
                                    break;
                                }
                            case "ScriptToLoad":
                                {
                                    string path = Context.Request.MapPath(PortalSettings.ActiveTab.SkinPath) + node.InnerText;
                                    if (File.Exists(path))
                                    {
                                        _scripttoload = PortalSettings.ActiveTab.SkinPath + node.InnerText;
                                    }
                                    break;
                                }
                            case "ContentFilters":
                                {
                                    _editor.ContentFilters = (EditorFilters) (Enum.Parse(typeof (EditorFilters), node.InnerText));
                                    break;
                                }
                            case "ToolbarMode":
                                {
                                    _editor.ToolbarMode = (EditorToolbarMode) (Enum.Parse(typeof (EditorToolbarMode), node.InnerText, true));
                                    break;
                                }
                            case "EditModes":
                                {
                                    _editor.EditModes = (EditModes) (Enum.Parse(typeof (EditModes), node.InnerText, true));
                                    break;
                                }
                            case "StripFormattingOptions":
                                {
                                    _editor.StripFormattingOptions = (EditorStripFormattingOptions) (Enum.Parse(typeof (EditorStripFormattingOptions), node.InnerText, true));
                                    break;
                                }
                            case "MaxImageSize":
                                {
                                    _editor.ImageManager.MaxUploadFileSize = int.Parse(node.InnerText);
                                    break;
                                }
                            case "MaxFlashSize":
                                {
                                    _editor.FlashManager.MaxUploadFileSize = int.Parse(node.InnerText);
                                    break;
                                }
                            case "MaxMediaSize":
                                {
                                    _editor.MediaManager.MaxUploadFileSize = int.Parse(node.InnerText);
                                    break;
                                }
                            case "MaxDocumentSize":
                                {
                                    _editor.DocumentManager.MaxUploadFileSize = int.Parse(node.InnerText);
                                    break;
                                }
                            case "MaxTemplateSize":
                                {
                                    _editor.TemplateManager.MaxUploadFileSize = int.Parse(node.InnerText);
                                    break;
                                }
                            case "MaxSilverlightSize":
                                {
                                    _editor.SilverlightManager.MaxUploadFileSize = int.Parse(node.InnerText);
                                    break;
                                }
                            case "FileBrowserContentProviderTypeName":
                                {
                                    _editor.ImageManager.ContentProviderTypeName = node.InnerText;
                                    _editor.FlashManager.ContentProviderTypeName = node.InnerText;
                                    _editor.MediaManager.ContentProviderTypeName = node.InnerText;
                                    _editor.DocumentManager.ContentProviderTypeName = node.InnerText;
                                    _editor.TemplateManager.ContentProviderTypeName = node.InnerText;
                                    _editor.SilverlightManager.ContentProviderTypeName = node.InnerText;
                                    break;
                                }
                            case "SpellAllowAddCustom":
                                {
                                    // RadSpell properties
                                    _editor.SpellCheckSettings.AllowAddCustom = bool.Parse(node.InnerText);
                                    break;
                                }
                            case "SpellCustomDictionarySourceTypeName":
                                {
                                    _editor.SpellCheckSettings.CustomDictionarySourceTypeName = node.InnerText;
                                    break;
                                }
                            case "SpellCustomDictionarySuffix":
                                {
                                    _editor.SpellCheckSettings.CustomDictionarySuffix = node.InnerText;
                                    break;
                                }
                            case "SpellDictionaryPath":
                                {
                                    _editor.SpellCheckSettings.DictionaryPath = node.InnerText;
                                    break;
                                }
                            case "SpellDictionaryLanguage":
                                {
                                    _editor.SpellCheckSettings.DictionaryLanguage = node.InnerText;
                                    break;
                                }
                            case "SpellEditDistance":
                                {
                                    _editor.SpellCheckSettings.EditDistance = int.Parse(node.InnerText);
                                    break;
                                }
                            case "SpellFragmentIgnoreOptions":
                                {
                                    //SpellCheckSettings.FragmentIgnoreOptions = (FragmentIgnoreOptions)Enum.Parse(typeof(FragmentIgnoreOptions), node.InnerText, true);
                                    break;
                                }
                            case "SpellCheckProvider":
                                {
                                    _editor.SpellCheckSettings.SpellCheckProvider = (SpellCheckProvider) (Enum.Parse(typeof (SpellCheckProvider), node.InnerText, true));
                                    break;
                                }
                            case "SpellWordIgnoreOptions":
                                {
                                    _editor.SpellCheckSettings.WordIgnoreOptions = (WordIgnoreOptions) (Enum.Parse(typeof (WordIgnoreOptions), node.InnerText, true));
                                    break;
                                }
                            case "ImagesPath":
                                {
                                    PopulateFolder(node.InnerText, "ImageManager");
                                    break;
                                }
                            case "FlashPath":
                                {
                                    PopulateFolder(node.InnerText, "FlashManager");
                                    break;
                                }
                            case "MediaPath":
                                {
                                    PopulateFolder(node.InnerText, "MediaManager");
                                    break;
                                }
                            case "DocumentsPath":
                                {
                                    PopulateFolder(node.InnerText, "DocumentManager");
                                    break;
                                }
                            case "TemplatePath":
                                {
                                    PopulateFolder(node.InnerText, "TemplateManager");
                                    break;
                                }
                            case "SilverlightPath":
                                {
                                    PopulateFolder(node.InnerText, "SilverlightManager");
                                    break;
                                }
                            case "ContentAreaMode":
                                {
                                    _editor.ContentAreaMode = (EditorContentAreaMode)Enum.Parse(typeof(EditorContentAreaMode), node.InnerText);
                                    break;
                                }
                            case "LinksType":
                                {
                                    try
                                    {
                                        _linksType = node.InnerText;
                                    }
                                    catch
                                    {
                                    }
                                    break;
                                }
                            case "LinksUseRelativeUrls":
                                {
                                    try
                                    {
                                        _linksUseRelativeUrls = bool.Parse(node.InnerText);
                                    }
                                    catch
                                    {
                                    }
                                    break;
                                }
                            case "ShowPortalLinks":
                                {
                                    try
                                    {
                                        _ShowPortalLinks = bool.Parse(node.InnerText);
                                    }
                                    catch
                                    {
                                    }
                                    break;
                                }
                            case "CssFile":
                                {
                                    string path = Context.Request.MapPath(PortalSettings.ActiveTab.SkinPath) + node.InnerText;
                                    if (File.Exists(path))
                                    {
                                        _editor.CssFiles.Clear();
                                        _editor.CssFiles.Add(PortalSettings.ActiveTab.SkinPath + node.InnerText);
                                    }
                                    else
                                    {
                                        path = Context.Request.MapPath(PortalSettings.HomeDirectory) + node.InnerText;
                                        if (File.Exists(path))
                                        {
                                            _editor.CssFiles.Clear();
                                            _editor.CssFiles.Add(PortalSettings.HomeDirectory + node.InnerText);
                                        }
                                    }

                                    break;
                                }
                            default:
                                {
                                    // end of RadSpell properties
                                    if (propertyName.EndsWith("Filters"))
                                    {
                                        items.Clear();

                                        if (node.HasChildNodes)
                                        {
                                            if (node.ChildNodes.Count == 1)
                                            {
                                                if (node.ChildNodes[0].NodeType == XmlNodeType.Text)
                                                {
                                                    items.Add(node.InnerText);
                                                }
                                                else if (node.ChildNodes[0].NodeType == XmlNodeType.Element)
                                                {
                                                    items.Add(node.ChildNodes[0].InnerText);
                                                }
                                            }
                                            else
                                            {
                                                foreach (XmlNode itemnode in node.ChildNodes)
                                                {
                                                    items.Add(itemnode.InnerText);
                                                }
                                            }
                                        }

                                        var itemsArray = (string[]) (items.ToArray(typeof (string)));
                                        switch (propertyName)
                                        {
                                            case "ImagesFilters":
                                                _editor.ImageManager.SearchPatterns = ApplySearchPatternFilter(itemsArray);
                                                break;

                                            case "FlashFilters":
                                                _editor.FlashManager.SearchPatterns = ApplySearchPatternFilter(itemsArray);
                                                break;

                                            case "MediaFilters":
                                                _editor.MediaManager.SearchPatterns = ApplySearchPatternFilter(itemsArray);
                                                break;

                                            case "DocumentsFilters":
                                                _editor.DocumentManager.SearchPatterns = ApplySearchPatternFilter(itemsArray);
                                                break;

                                            case "TemplateFilters":
                                                _editor.TemplateManager.SearchPatterns = ApplySearchPatternFilter(itemsArray);
                                                break;

                                            case "SilverlightFilters":
                                                _editor.SilverlightManager.SearchPatterns = ApplySearchPatternFilter(itemsArray);
                                                break;
                                        }
                                    }

                                    break;
                                }
                        }
                    }
                }
                else
                {
                    //could not load config
                }
            }
            else
            {
                //could not load config (config file property empty?)
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="IsLocaleAvailable">
          <declaration><![CDATA[private bool IsLocaleAvailable(string Locale)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1106" sc="9" el="1126" ec="10">Components\EditorProvider.cs</location>
            <body hash="e7d7d3c48bac008965ea14b3801b04f5"><![CDATA[{
            string path;

            if (Locale.ToLower() == "en-us")
            {
                path = HttpContext.Current.Server.MapPath(_localeFile);
            }
            else
            {
                path = HttpContext.Current.Server.MapPath(_localeFile.ToLower().Replace(".resx", "." + Locale + ".resx"));
            }

            if (File.Exists(path))
            {
                //resource file exists
                return true;
            }

            //does not exist
            return false;
        }]]></body>
          </codeblock>
        </method>
        <method name="Panel_Init">
          <declaration><![CDATA[protected void Panel_Init(object sender, EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="928" sc="9" el="1001" ec="10">Components\EditorProvider.cs</location>
            <body hash="7ff72fde60eba39a17f6b33b7b59e785"><![CDATA[{
            //fix for allowing childportal (tabid must be in querystring!)
            string PortalPath = "";
            try
            {
                PortalPath = _editor.TemplateManager.ViewPaths[0];
            }
            catch
            {
            }
            PortalPath = PortalPath.Replace(PortalSettings.HomeDirectory, "").Replace("//", "/");
			var parentModule = ControlUtilities.FindParentControl<PortalModuleBase>(HtmlEditorControl);
			int moduleId = Convert.ToInt32(((parentModule == null) ? Null.NullInteger : parentModule.ModuleId));
            string strSaveTemplateDialogPath = _panel.Page.ResolveUrl(moduleFolderPath + "Dialogs/SaveTemplate.aspx?Path=" + PortalPath + "&TabId=" + PortalSettings.ActiveTab.TabID + "&ModuleId=" + moduleId);

			AJAX.AddScriptManager(_panel.Page);
        	var scriptManager = AJAX.GetScriptManager(_panel.Page);

            string strRegisterClientScriptPath = _panel.Page.ResolveUrl(moduleFolderPath + "js/ClientScripts.js");
            ScriptManager.RegisterClientScriptInclude(_panel.Page, _panel.Page.GetType(), "ClientScripts", strRegisterClientScriptPath);

            string strRegisterDialogScriptPath = _panel.Page.ResolveUrl(moduleFolderPath + "js/RegisterDialogs.js");
            ScriptManager.RegisterClientScriptInclude(_panel.Page, _panel.Page.GetType(), "RegisterDialogs", strRegisterDialogScriptPath);

            _editor.ContentAreaCssFile = "~/DesktopModules/Admin/RadEditorProvider/Css/EditorContentAreaOverride.css";

            if (_editor.ToolbarMode == EditorToolbarMode.Default && string.Equals(_editor.Skin, "Default", StringComparison.OrdinalIgnoreCase))
            {
                var editorOverrideCSSPath = _panel.Page.ResolveUrl("~/DesktopModules/Admin/RadEditorProvider/Css/EditorOverride.css");
                var setEditorOverrideCSSPath = "<script type=\"text/javascript\">var __editorOverrideCSSPath = \"" + editorOverrideCSSPath + "\";</script>";
                _panel.Page.ClientScript.RegisterClientScriptBlock(GetType(), "EditorOverrideCSSPath", setEditorOverrideCSSPath);

                string styleOverrideScriptPath = _panel.Page.ResolveUrl(moduleFolderPath + "js/overrideCSS.js");
                ScriptManager.RegisterClientScriptInclude(_panel.Page, _panel.Page.GetType(), "OverrideCSS", styleOverrideScriptPath);
                //_editor.Skin = "Black";
	            _editor.PreventDefaultStylesheet = true;
            }
            else
            {
                var setEditorOverrideCSSPath = "<script type=\"text/javascript\">var __editorOverrideCSSPath = null;</script>";
                _panel.Page.ClientScript.RegisterClientScriptBlock(GetType(), "EditorOverrideCSSPath", setEditorOverrideCSSPath);
            }

            if (!string.IsNullOrEmpty(_scripttoload))
            {
                ScriptManager.RegisterClientScriptInclude(_panel, _panel.GetType(), "ScriptToLoad", _panel.Page.ResolveUrl(_scripttoload));
            }

            //add save template dialog var
        	var saveTemplateDialogJs = 
				"<script type=\"text/javascript\">var __textEditorSaveTemplateDialog = \"" + strSaveTemplateDialogPath + "\";</script>";
			_panel.Page.ClientScript.RegisterClientScriptBlock(GetType(), "SaveTemplateDialog", saveTemplateDialogJs);

            //add css classes for save template tool
            /*
            _panel.Controls.Add(
                new LiteralControl("<style type=\"text/css\">.reTool_text .SaveTemplate, .reTool .SaveTemplate { background-image: url('" + _panel.Page.ResolveUrl(moduleFolderPath + "images/save.png") +
                                   "') !important; }</style>"));
            _panel.Controls.Add(
                new LiteralControl("<style type=\"text/css\">.reTool .TemplateOptions { background-image: url('" + _panel.Page.ResolveUrl(moduleFolderPath + "images/templates.png") +
                                   "') !important; }</style>"));
            _panel.Controls.Add(
                new LiteralControl("<style type=\"text/css\">.reTool_text .TemplateManager, .reTool .TemplateManager { background-image: url('" +
                                   _panel.Page.ResolveUrl(moduleFolderPath + "images/templates.png") + "') !important; background-position: left top !important; }</style>"));
            _panel.Controls.Add(
                new LiteralControl("<style type=\"text/css\">.reTool .InsertOptions { background-image: url('" + _panel.Page.ResolveUrl(moduleFolderPath + "images/Attachment.png") +
                                   "') !important; }</style>"));
             */

            _editor.OnClientSubmit = "OnDnnEditorClientSubmit";

            //add editor control to panel
            _panel.Controls.Add(_editor);
        }]]></body>
          </codeblock>
        </method>
        <method name="Panel_Load">
          <declaration><![CDATA[protected void Panel_Load(object sender, EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1004" sc="9" el="1023" ec="10">Components\EditorProvider.cs</location>
            <body hash="04625700f0a15998cedab4d61a6eaaa5"><![CDATA[{
            //register the override CSS file to take care of the DNN default skin problems

            //string cssOverrideUrl = _panel.Page.ResolveUrl(moduleFolderPath + "/Css/EditorOverride.css");
            //ScriptManager pageScriptManager = ScriptManager.GetCurrent(_panel.Page);
            //if ((pageScriptManager != null) && (pageScriptManager.IsInAsyncPostBack))
            //{
            //    _panel.Controls.Add(
            //        new LiteralControl(string.Format("<link title='RadEditor Stylesheet' type='text/css' rel='stylesheet' href='{0}'></link>", _panel.Page.Server.HtmlEncode(cssOverrideUrl))));
            //}
            //else if (_panel.Page.Header != null)
            //{
            //    var link = new HtmlLink();
            //    link.Href = cssOverrideUrl;
            //    link.Attributes.Add("type", "text/css");
            //    link.Attributes.Add("rel", "stylesheet");
            //    link.Attributes.Add("title", "RadEditor Stylesheet");
            //    _panel.Page.Header.Controls.Add(link);
            //}
        }]]></body>
          </codeblock>
        </method>
        <method name="Panel_PreRender">
          <declaration><![CDATA[protected void Panel_PreRender(object sender, EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1026" sc="9" el="1045" ec="10">Components\EditorProvider.cs</location>
            <body hash="f31a45dad068d0fd8312512e686c4f27"><![CDATA[{
            try
            {
                var parentModule = ControlUtilities.FindParentControl<PortalModuleBase>(HtmlEditorControl);
                int moduleid = Convert.ToInt32(((parentModule == null) ? -1 : parentModule.ModuleId));
                int portalId = Convert.ToInt32(((parentModule == null) ? -1 : parentModule.PortalId));
                int tabId = Convert.ToInt32(((parentModule == null) ? -1 : parentModule.TabId));
                ClientAPI.RegisterClientVariable(HtmlEditorControl.Page, "editorModuleId", moduleid.ToString(), true);
                ClientAPI.RegisterClientVariable(HtmlEditorControl.Page, "editorTabId", tabId.ToString(), true);
                ClientAPI.RegisterClientVariable(HtmlEditorControl.Page, "editorPortalId", portalId.ToString(), true);
                ClientAPI.RegisterClientVariable(HtmlEditorControl.Page, "sslEnabled", PortalSettings.SSLEnabled.ToString().ToLowerInvariant(), true);
                ClientAPI.RegisterClientVariable(HtmlEditorControl.Page, "editorHomeDirectory", PortalSettings.HomeDirectory, true);
                ClientAPI.RegisterClientVariable(HtmlEditorControl.Page, "editorPortalGuid", PortalSettings.GUID.ToString(), true);
                ClientAPI.RegisterClientVariable(HtmlEditorControl.Page, "editorEnableUrlLanguage", PortalSettings.EnableUrlLanguage.ToString(), true);
            }
            catch (Exception ex)
            {
                throw ex;
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="PopulateFolder">
          <declaration><![CDATA[private void PopulateFolder(string folderPath, string toolname)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="394" sc="9" el="441" ec="10">Components\EditorProvider.cs</location>
            <body hash="94bcc2b54cff323bff9cab9de175c825"><![CDATA[{
            var ReadPaths = new ArrayList();
            var WritePaths = new ArrayList();

            if (folderPath == "[PORTAL]")
            {
                ReadPaths.Add(RootImageDirectory);
                WritePaths.Add(RootImageDirectory);
            }
			else if (folderPath.ToUpperInvariant() == "[USERFOLDER]")
			{
				var userFolderPath = FolderManager.Instance.GetUserFolder(UserController.Instance.GetCurrentUserInfo()).FolderPath;
				var path = RemoveEndSlash(RootImageDirectory) + AddSlash(userFolderPath);
				WritePaths.Add(path);
				ReadPaths.Add(path);
			}
            else if (folderPath.Length > 0)
            {
                string path = RemoveEndSlash(RootImageDirectory) + AddSlash(folderPath);
                WritePaths.Add(path);
                ReadPaths.Add(path);
            }

            var _readPaths = (string[]) (ReadPaths.ToArray(typeof (string)));
            var _writePaths = (string[]) (WritePaths.ToArray(typeof (string)));

            switch (toolname)
            {
                case "ImageManager":
                    SetFolderPaths(_editor.ImageManager, _readPaths, _writePaths, true, true);
                    break;
                case "FlashManager":
                    SetFolderPaths(_editor.FlashManager, _readPaths, _writePaths, true, true);
                    break;
                case "MediaManager":
                    SetFolderPaths(_editor.MediaManager, _readPaths, _writePaths, true, true);
                    break;
                case "DocumentManager":
                    SetFolderPaths(_editor.DocumentManager, _readPaths, _writePaths, true, true);
                    break;
                case "TemplateManager":
                    SetFolderPaths(_editor.TemplateManager, _readPaths, _writePaths, true, true);
                    break;
                case "SilverlightManager":
                    SetFolderPaths(_editor.SilverlightManager, _readPaths, _writePaths, true, true);
                    break;
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="RadEditor_Load">
          <declaration><![CDATA[protected void RadEditor_Load(object sender, EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1048" sc="9" el="1103" ec="10">Components\EditorProvider.cs</location>
            <body hash="493794a7034c57cba7d8140917a79118"><![CDATA[{
            Page editorPage = _panel.Page;

            //if not use relative links, we need a parameter in query string to let html module not parse
            //absolute urls to relative;
            if (!_linksUseRelativeUrls && editorPage.Request.QueryString["nuru"] == null)
            {
                var redirectUrl = string.Format("{0}{1}nuru=1", editorPage.Request.RawUrl, editorPage.Request.RawUrl.Contains("?") ? "&" : "?");
                editorPage.Response.Redirect(redirectUrl);
            }

            //set language
            if (! _languageSet) //language might have been set by config file
            {
                string localizationLang = "en-US"; //use teleriks internal fallback language

                //first check portal settings
                if (IsLocaleAvailable(PortalSettings.DefaultLanguage))
                {
                    //use only if resource file exists
                    localizationLang = PortalSettings.DefaultLanguage;
                }

                //then check if language cookie is present
                if (editorPage.Request.Cookies["language"] != null)
                {
                    string cookieValue = editorPage.Request.Cookies.Get("language").Value;
                    if (IsLocaleAvailable(cookieValue))
                    {
                        //only use locale if resource file is present
                        localizationLang = cookieValue;
                    }
                }

                //set new value
                if (! string.IsNullOrEmpty(localizationLang))
                {
                    _editor.Language = localizationLang;
                }
            }

            _editor.LocalizationPath = moduleFolderPath + "/App_LocalResources/";

            if (_ShowPortalLinks)
            {
                AddPortalLinks();
            }

            //set editor /spell properties to work with child portals
            _editor.SpellCheckSettings.DictionaryPath = moduleFolderPath + "RadSpell/";
            //again: fix for allowing childportals (tabid must be in querystring!)
            _editor.DialogHandlerUrl = _panel.Page.ResolveUrl(moduleFolderPath + "DialogHandler.aspx?tabid=" + PortalSettings.ActiveTab.TabID);
            //_editor.SpellCheckSettings.AjaxUrl = moduleFolderPath.Replace("~", "") & "SpellCheckHandler.ashx?tabid=" & PortalSettings.ActiveTab.TabID.ToString()
            _editor.SpellCheckSettings.AjaxUrl = _panel.Page.ResolveUrl(moduleFolderPath + "SpellCheckHandler.ashx?tabid=" + PortalSettings.ActiveTab.TabID);
	        _editor.DialogOpener.AdditionalQueryString = "&linkstype=" + _linksType + "&nuru=" + HttpContext.Current.Request.QueryString["nuru"];
        }]]></body>
          </codeblock>
        </method>
        <method name="RemoveEndSlash">
          <declaration><![CDATA[private string RemoveEndSlash(string Folderpath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="382" sc="9" el="391" ec="10">Components\EditorProvider.cs</location>
            <body hash="34d6114af029deb4bb777072847ff758"><![CDATA[{
            if (Folderpath.EndsWith("/"))
            {
                return Folderpath.Substring(0, Folderpath.LastIndexOf("/"));
            }
            else
            {
                return Folderpath;
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="SetEditorProperty">
          <declaration><![CDATA[private void SetEditorProperty(string propertyName, string propValue)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1165" sc="9" el="1190" ec="10">Components\EditorProvider.cs</location>
            <body hash="6a3909ff04ec444f66f105efda2e1918"><![CDATA[{
            PropertyInfo pi = _editor.GetType().GetProperty(propertyName);
            if (pi != null)
            {
                if (pi.PropertyType.Equals(typeof (string)))
                {
                    pi.SetValue(_editor, propValue, null);
                }
                else if (pi.PropertyType.Equals(typeof (bool)))
                {
                    pi.SetValue(_editor, bool.Parse(propValue), null);
                }
                else if (pi.PropertyType.Equals(typeof (Unit)))
                {
                    pi.SetValue(_editor, Unit.Parse(propValue), null);
                }
                else if (pi.PropertyType.Equals(typeof (int)))
                {
                    pi.SetValue(_editor, int.Parse(propValue), null);
                }
            }
            if (propertyName == "Language")
            {
                _languageSet = true;
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="SetFolderPaths">
          <declaration><![CDATA[private void SetFolderPaths(FileManagerDialogConfiguration manager, string[] readPaths, string[] writePaths, bool setDeletePath, bool setUploadPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="449" sc="9" el="467" ec="10">Components\EditorProvider.cs</location>
            <body hash="a1153f17825655d3712a53421627a1e2"><![CDATA[{
            manager.ViewPaths = readPaths;
            if (setUploadPath)
            {
                manager.UploadPaths = writePaths;
            }
            else
            {
                manager.UploadPaths = null;
            }
            if (setDeletePath)
            {
                manager.DeletePaths = writePaths;
            }
            else
            {
                manager.DeletePaths = null;
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_editor">
          <declaration><![CDATA[private readonly DnnEditor _editor = new DnnEditor();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_languageSet">
          <declaration><![CDATA[private bool _languageSet;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_linksType">
          <declaration><![CDATA[private string _linksType = "Normal";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_linksUseRelativeUrls">
          <declaration><![CDATA[private bool _linksUseRelativeUrls = true;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_localeFile">
          <declaration><![CDATA[private string _localeFile = "~/DesktopModules/Admin/RadEditorProvider//App_LocalResources/RadEditor.Main.resx";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_panel">
          <declaration><![CDATA[private readonly System.Web.UI.WebControls.Panel _panel = new System.Web.UI.WebControls.Panel();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_scripttoload">
          <declaration><![CDATA[private string _scripttoload = "";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_ShowPortalLinks">
          <declaration><![CDATA[private bool _ShowPortalLinks = true;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ConfigFileName">
          <declaration><![CDATA[private const string ConfigFileName = "~/DesktopModules/Admin/RadEditorProvider//ConfigFile/ConfigFile.xml";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="moduleFolderPath">
          <declaration><![CDATA[private const string moduleFolderPath = "~/DesktopModules/Admin/RadEditorProvider/";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ProviderType">
          <declaration><![CDATA[private const string ProviderType = "htmlEditor";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ToolsFileName">
          <declaration><![CDATA[private const string ToolsFileName = "~/DesktopModules/Admin/RadEditorProvider//ToolsFile/ToolsFile.xml";]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="AdditionalToolbars">
          <declaration><![CDATA[public override ArrayList AdditionalToolbars]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="ConfigFile">
          <declaration><![CDATA[public string ConfigFile]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="134" sc="13" el="233" ec="14">Components\EditorProvider.cs</location>
            <body hash="08b67adba7a1c05b5c3d5cffa6d49cf2"><![CDATA[{
                //get current user
                UserInfo objUserInfo = UserController.Instance.GetCurrentUserInfo();
                //load default tools file
                string tempConfigFile = ConfigFileName;
                //get absolute path of default tools file
                string path = HttpContext.Current.Server.MapPath(tempConfigFile).ToLower();

                string rolepath = "";
                string tabpath = "";
                string portalpath = "";

                //lookup host specific config file
                if (objUserInfo != null)
                {
                    if (objUserInfo.IsSuperUser)
                    {
                        var hostPart = ".RoleId." + DotNetNuke.Common.Globals.glbRoleSuperUser;
                        rolepath = path.Replace(".xml", hostPart + ".xml");
                        tabpath = path.Replace(".xml", hostPart + ".TabId." + PortalSettings.ActiveTab.TabID + ".xml");
                        portalpath = path.Replace(".xml", hostPart + ".PortalId." + PortalSettings.PortalId + ".xml");

                        if (File.Exists(tabpath))
                        {
                            return tempConfigFile.ToLower().Replace(".xml", hostPart + ".TabId." + PortalSettings.ActiveTab.TabID + ".xml");
                        }
                        if (File.Exists(portalpath))
                        {
                            return tempConfigFile.ToLower().Replace(".xml", hostPart + ".PortalId." + PortalSettings.PortalId + ".xml");
                        }
                        if (File.Exists(rolepath))
                        {
                            return tempConfigFile.ToLower().Replace(".xml", hostPart + ".xml");
                        }
                    }

                    //lookup admin specific config file
                    if (PortalSecurity.IsInRole(PortalSettings.AdministratorRoleName))
                    {
                        var adminPart = ".RoleId." + PortalSettings.AdministratorRoleId;
                        rolepath = path.Replace(".xml", adminPart + ".xml");
                        tabpath = path.Replace(".xml", adminPart + ".TabId." + PortalSettings.ActiveTab.TabID + ".xml");
                        portalpath = path.Replace(".xml", adminPart + ".PortalId." + PortalSettings.PortalId + ".xml");

                        if (File.Exists(tabpath))
                        {
                            return tempConfigFile.ToLower().Replace(".xml", adminPart + ".TabId." + PortalSettings.ActiveTab.TabID + ".xml");
                        }
                        if (File.Exists(portalpath))
                        {
                            return tempConfigFile.ToLower().Replace(".xml", adminPart + ".PortalId." + PortalSettings.PortalId + ".xml");
                        }
                        if (File.Exists(rolepath))
                        {
                            return tempConfigFile.ToLower().Replace(".xml", adminPart + ".xml");
                        }
                    }

                    //lookup user roles specific config file
                    foreach (var role in RoleController.Instance.GetUserRoles(objUserInfo, true))
                    {
                        var rolePart = ".RoleId." + role.RoleID;
                        rolepath = path.Replace(".xml", rolePart + ".xml");
                        tabpath = path.Replace(".xml", rolePart + ".TabId." + PortalSettings.ActiveTab.TabID + ".xml");
                        portalpath = path.Replace(".xml", rolePart + ".PortalId." + PortalSettings.PortalId + ".xml");

                        if (File.Exists(tabpath))
                        {
                            return tempConfigFile.ToLower().Replace(".xml", rolePart + ".TabId." + PortalSettings.ActiveTab.TabID + ".xml");
                        }
                        if (File.Exists(portalpath))
                        {
                            return tempConfigFile.ToLower().Replace(".xml", rolePart + ".PortalId." + PortalSettings.PortalId + ".xml");
                        }
                        if (File.Exists(rolepath))
                        {
                            return tempConfigFile.ToLower().Replace(".xml", rolePart + ".xml");
                        }
                    }
                }

                //lookup tab specific config file
                tabpath = path.Replace(".xml", ".TabId." + PortalSettings.ActiveTab.TabID + ".xml");
                if (File.Exists(tabpath))
                {
                    return tempConfigFile.ToLower().Replace(".xml", ".TabId." + PortalSettings.ActiveTab.TabID + ".xml");
                }

                //lookup portal specific config file
                portalpath = path.Replace(".xml", ".PortalId." + PortalSettings.PortalId + ".xml");
                if (File.Exists(portalpath))
                {
                    return tempConfigFile.ToLower().Replace(".xml", ".PortalId." + PortalSettings.PortalId + ".xml");
                }

                //nothing else found, return default file
                EnsureDefaultFileExists(path);

                return tempConfigFile;
            }]]></body>
          </codeblock>
        </property>
        <property name="ControlID">
          <declaration><![CDATA[public override string ControlID]]></declaration>
          <documentation>
            <summary>
 </summary>
          </documentation>
          <codeblock>
            <location sl="70" sc="13" el="72" ec="14">Components\EditorProvider.cs</location>
            <body hash="92cdd21a8b0ff2fc9f7f1416b991375e"><![CDATA[{
                return _editor.ID;
            }]]></body>
          </codeblock>
          <codeblock>
            <location sl="74" sc="13" el="76" ec="14">Components\EditorProvider.cs</location>
            <body hash="4d7e6aeac694ea58dca65746a8da0191"><![CDATA[{
                _editor.ID = value;
            }]]></body>
          </codeblock>
        </property>
        <property name="Height">
          <declaration><![CDATA[public override System.Web.UI.WebControls.Unit Height]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="82" sc="13" el="84" ec="14">Components\EditorProvider.cs</location>
            <body hash="6e8b236c4a2399db447120f8beb32752"><![CDATA[{
                return _editor.Height;
            }]]></body>
          </codeblock>
          <codeblock>
            <location sl="86" sc="13" el="91" ec="14">Components\EditorProvider.cs</location>
            <body hash="fc7d433a83b657881fb5565505a211bf"><![CDATA[{
                if (! value.IsEmpty)
                {
                    _editor.Height = value;
                }
            }]]></body>
          </codeblock>
        </property>
        <property name="HtmlEditorControl">
          <declaration><![CDATA[public override System.Web.UI.Control HtmlEditorControl]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="97" sc="13" el="99" ec="14">Components\EditorProvider.cs</location>
            <body hash="fcccb5dddb6f783cf45977e72ad0a03a"><![CDATA[{
                return _panel;
            }]]></body>
          </codeblock>
        </property>
        <property name="RootImageDirectory">
          <declaration><![CDATA[public override string RootImageDirectory]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Text">
          <declaration><![CDATA[public override string Text]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="107" sc="13" el="109" ec="14">Components\EditorProvider.cs</location>
            <body hash="697547392fc0eaeeaa98d35cbdccaaa9"><![CDATA[{
                return _editor.Content;
            }]]></body>
          </codeblock>
          <codeblock>
            <location sl="111" sc="13" el="113" ec="14">Components\EditorProvider.cs</location>
            <body hash="9f7d5309df426e0abce7f7a375fc53c3"><![CDATA[{
                _editor.Content = value;
            }]]></body>
          </codeblock>
        </property>
        <property name="ToolsFile">
          <declaration><![CDATA[public string ToolsFile]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="263" sc="13" el="362" ec="14">Components\EditorProvider.cs</location>
            <body hash="9e3a6f096197caf1be07949d9c0d489c"><![CDATA[{
                //get current user
                UserInfo objUserInfo = UserController.Instance.GetCurrentUserInfo();
                //load default tools file
                string tempToolsFile = ToolsFileName;
                //get absolute path of default tools file
                string path = HttpContext.Current.Server.MapPath(tempToolsFile).ToLower();

                string rolepath = "";
                string tabpath = "";
                string portalpath = "";

                //lookup host specific tools file
                if (objUserInfo != null)
                {
                    if (objUserInfo.IsSuperUser)
                    {
                        var hostPart = ".RoleId." + DotNetNuke.Common.Globals.glbRoleSuperUser;
                        rolepath = path.Replace(".xml", hostPart + ".xml");
                        tabpath = path.Replace(".xml", hostPart + ".TabId." + PortalSettings.ActiveTab.TabID + ".xml");
                        portalpath = path.Replace(".xml", hostPart + ".PortalId." + PortalSettings.PortalId + ".xml");

                        if (File.Exists(tabpath))
                        {
                            return tempToolsFile.ToLower().Replace(".xml", hostPart + ".TabId." + PortalSettings.ActiveTab.TabID + ".xml");
                        }
                        if (File.Exists(portalpath))
                        {
                            return tempToolsFile.ToLower().Replace(".xml", hostPart + ".PortalId." + PortalSettings.PortalId + ".xml");
                        }
                        if (File.Exists(rolepath))
                        {
                            return tempToolsFile.ToLower().Replace(".xml", hostPart + ".xml");
                        }
                    }

                    //lookup admin specific tools file
                    if (PortalSecurity.IsInRole(PortalSettings.AdministratorRoleName))
                    {
                        var adminPart = ".RoleId." + PortalSettings.AdministratorRoleId;
                        rolepath = path.Replace(".xml", adminPart + ".xml");
                        tabpath = path.Replace(".xml", adminPart + ".TabId." + PortalSettings.ActiveTab.TabID + ".xml");
                        portalpath = path.Replace(".xml", adminPart + ".PortalId." + PortalSettings.PortalId + ".xml");

                        if (File.Exists(tabpath))
                        {
                            return tempToolsFile.ToLower().Replace(".xml", adminPart + ".TabId." + PortalSettings.ActiveTab.TabID + ".xml");
                        }
                        if (File.Exists(portalpath))
                        {
                            return tempToolsFile.ToLower().Replace(".xml", adminPart + ".PortalId." + PortalSettings.PortalId + ".xml");
                        }
                        if (File.Exists(rolepath))
                        {
                            return tempToolsFile.ToLower().Replace(".xml", adminPart + ".xml");
                        }
                    }

                    //lookup user roles specific tools file
                    foreach (var role in RoleController.Instance.GetUserRoles(objUserInfo, false))
                    {
                        var rolePart = ".RoleId." + role.RoleID;
                        rolepath = path.Replace(".xml", rolePart + ".xml");
                        tabpath = path.Replace(".xml", rolePart + ".TabId." + PortalSettings.ActiveTab.TabID + ".xml");
                        portalpath = path.Replace(".xml", rolePart + ".PortalId." + PortalSettings.PortalId + ".xml");

                        if (File.Exists(tabpath))
                        {
                            return tempToolsFile.ToLower().Replace(".xml", rolePart + ".TabId." + PortalSettings.ActiveTab.TabID + ".xml");
                        }
                        if (File.Exists(portalpath))
                        {
                            return tempToolsFile.ToLower().Replace(".xml", rolePart + ".PortalId." + PortalSettings.PortalId + ".xml");
                        }
                        if (File.Exists(rolepath))
                        {
                            return tempToolsFile.ToLower().Replace(".xml", rolePart + ".xml");
                        }
                    }
                }

                //lookup tab specific tools file
                tabpath = path.Replace(".xml", ".TabId." + PortalSettings.ActiveTab.TabID + ".xml");
                if (File.Exists(tabpath))
                {
                    return tempToolsFile.ToLower().Replace(".xml", ".TabId." + PortalSettings.ActiveTab.TabID + ".xml");
                }

                //lookup portal specific tools file
                portalpath = path.Replace(".xml", ".PortalId." + PortalSettings.PortalId + ".xml");
                if (File.Exists(portalpath))
                {
                    return tempToolsFile.ToLower().Replace(".xml", ".PortalId." + PortalSettings.PortalId + ".xml");
                }

                //nothing else found, return default file
                EnsureDefaultFileExists(path);

                return tempToolsFile;
            }]]></body>
          </codeblock>
        </property>
        <property name="Width">
          <declaration><![CDATA[public override System.Web.UI.WebControls.Unit Width]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="119" sc="13" el="121" ec="14">Components\EditorProvider.cs</location>
            <body hash="0423d61eb5d8a9350f2daad86c798102"><![CDATA[{
                return _editor.Width;
            }]]></body>
          </codeblock>
          <codeblock>
            <location sl="123" sc="13" el="128" ec="14">Components\EditorProvider.cs</location>
            <body hash="77817a943e4b07aa27f7c6273b938c37"><![CDATA[{
                if (! value.IsEmpty)
                {
                    _editor.Width = value;
                }
            }]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ErrorCodes">
      <declaration><![CDATA[public enum ErrorCodes]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="AddFolder_NoPermission">
          <declaration><![CDATA[public const ErrorCodes AddFolder_NoPermission = 0;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="AddFolder_NotInsecureFolder">
          <declaration><![CDATA[public const ErrorCodes AddFolder_NotInsecureFolder = 1;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="CannotCopyFolder_ChildrenVisible">
          <declaration><![CDATA[public const ErrorCodes CannotCopyFolder_ChildrenVisible = 13;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="CannotDeleteFolder_ChildrenVisible">
          <declaration><![CDATA[public const ErrorCodes CannotDeleteFolder_ChildrenVisible = 12;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="CannotMoveFolder_ChildrenVisible">
          <declaration><![CDATA[public const ErrorCodes CannotMoveFolder_ChildrenVisible = 11;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="CopyFolder_NoPermission">
          <declaration><![CDATA[public const ErrorCodes CopyFolder_NoPermission = 2;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="CopyFolder_NotInsecureFolder">
          <declaration><![CDATA[public const ErrorCodes CopyFolder_NotInsecureFolder = 3;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DeleteFolder_NoPermission">
          <declaration><![CDATA[public const ErrorCodes DeleteFolder_NoPermission = 4;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DeleteFolder_NotInsecureFolder">
          <declaration><![CDATA[public const ErrorCodes DeleteFolder_NotInsecureFolder = 5;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DeleteFolder_Protected">
          <declaration><![CDATA[public const ErrorCodes DeleteFolder_Protected = 6;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DeleteFolder_Root">
          <declaration><![CDATA[public const ErrorCodes DeleteFolder_Root = 7;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DirectoryAlreadyExists">
          <declaration><![CDATA[public const ErrorCodes DirectoryAlreadyExists = 14;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="FileDoesNotExist">
          <declaration><![CDATA[public const ErrorCodes FileDoesNotExist = 9;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="FolderDoesNotExist">
          <declaration><![CDATA[public const ErrorCodes FolderDoesNotExist = 10;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="General_PermissionDenied">
          <declaration><![CDATA[public const ErrorCodes General_PermissionDenied = 17;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="InvalidCharactersInPath">
          <declaration><![CDATA[public const ErrorCodes InvalidCharactersInPath = 15;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="NewFileAlreadyExists">
          <declaration><![CDATA[public const ErrorCodes NewFileAlreadyExists = 16;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="RenameFolder_Root">
          <declaration><![CDATA[public const ErrorCodes RenameFolder_Root = 8;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="FileManagerException">
      <declaration><![CDATA[public class FileManagerException : Exception]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public FileManagerException()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="29" sc="3" el="31" ec="4">Components\FileManagerException.cs</location>
            <body hash="1df510ac298b10c14598637ba3ed984b"><![CDATA[public FileManagerException() : base()
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public FileManagerException(string message) : base(message)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="33" sc="3" el="35" ec="4">Components\FileManagerException.cs</location>
            <body hash="85abdb33814638d09458b4e3493c4219"><![CDATA[public FileManagerException(string message) : base(message)
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public FileManagerException(string message, Exception innerException) : base(message, innerException)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="37" sc="3" el="39" ec="4">Components\FileManagerException.cs</location>
            <body hash="4e789e83e84ad2661bd33e18f5dc7bc7"><![CDATA[public FileManagerException(string message, Exception innerException) : base(message, innerException)
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public FileManagerException(ref SerializationInfo info, ref StreamingContext context) : base(info, context)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="41" sc="3" el="43" ec="4">Components\FileManagerException.cs</location>
            <body hash="f610ac4d1f78720338d86f84d3be4924"><![CDATA[public FileManagerException(ref System.Runtime.Serialization.SerializationInfo info, ref System.Runtime.Serialization.StreamingContext context) : base(info, context)
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="FileSystemValidation">
      <declaration><![CDATA[public class FileSystemValidation]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public bool EnableDetailedLogging = true;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="52" sc="3" el="52" ec="44">Components\FileSystemValidation.cs</location>
            <body hash="88eae122e7cec61a26e7c014ac420e8e"><![CDATA[public bool EnableDetailedLogging = true]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static FileSystemValidation()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="50" sc="3" el="50" ec="104">Components\FileSystemValidation.cs</location>
            <body hash="0242da8ee5fd9b0e06519022af8fdc82"><![CDATA[private static readonly ILog Logger = LoggerSource.Instance.GetLogger(typeof (FileSystemValidation))]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CanAddToFolder">
          <declaration><![CDATA[public virtual bool CanAddToFolder(FolderInfo dnnFolder)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="673" sc="3" el="680" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="ca81631cf89775ceecc9fcc63327157b"><![CDATA[{
            if(!FolderPermissionController.CanAddFolder(dnnFolder))
            {
                return false;
            }

		    return true;
		}]]></body>
          </codeblock>
        </method>
        <method name="CanDeleteFolder">
          <declaration><![CDATA[public virtual bool CanDeleteFolder(FolderInfo dnnFolder)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="683" sc="3" el="690" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="bf90317442c8b2b6ebc959591254b0cb"><![CDATA[{
			if (! (FolderPermissionController.CanDeleteFolder(dnnFolder)))
			{
				return false;
			}

			return true;
		}]]></body>
          </codeblock>
        </method>
        <method name="CanViewFilesInFolder">
          <declaration><![CDATA[public virtual bool CanViewFilesInFolder(string path)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="648" sc="3" el="650" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="19ea0528d5bf71f764785d61ef61c726"><![CDATA[{
			return CanViewFilesInFolder(GetUserFolder(path));
		}]]></body>
          </codeblock>
        </method>
        <method name="CanViewFilesInFolder">
          <declaration><![CDATA[public virtual bool CanViewFilesInFolder(FolderInfo dnnFolder)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="653" sc="3" el="670" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="1c312fc90dd198d95a627f04733e45dd"><![CDATA[{
			if ((dnnFolder == null))
			{
				return false;
			}

			if (! (CanViewFolder(dnnFolder)))
			{
				return false;
			}

			if (! (FolderPermissionController.CanViewFolder(dnnFolder)))
			{
				return false;
			}

			return true;
		}]]></body>
          </codeblock>
        </method>
        <method name="CanViewFolder">
          <declaration><![CDATA[public virtual bool CanViewFolder(string path)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="638" sc="3" el="640" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="84fc6f93b96f5921a34b92c13cd9d5c2"><![CDATA[{
		    return GetUserFolder(path) != null;
		}]]></body>
          </codeblock>
        </method>
        <method name="CanViewFolder">
          <declaration><![CDATA[public virtual bool CanViewFolder(FolderInfo dnnFolder)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="643" sc="3" el="645" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="61e8edfa3e79696c6a8c89e5728b12d4"><![CDATA[{
            return GetUserFolder(dnnFolder.FolderPath) != null;
		}]]></body>
          </codeblock>
        </method>
        <method name="Check_CanAddToFolder">
          <declaration><![CDATA[private string Check_CanAddToFolder(string virtualPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="696" sc="3" el="698" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="1ec8bb618a9b3104798cbb392a055408"><![CDATA[{
			return Check_CanAddToFolder(virtualPath,  EnableDetailedLogging);
		}]]></body>
          </codeblock>
        </method>
        <method name="Check_CanAddToFolder">
          <declaration><![CDATA[private string Check_CanAddToFolder(string virtualPath, bool logDetail)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="701" sc="9" el="716" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="e5cb6ac830e106900d13d4e4d5cd0738"><![CDATA[{
            var dnnFolder = GetDNNFolder(virtualPath);

			if (dnnFolder == null)
			{
                return LogDetailError(ErrorCodes.FolderDoesNotExist, ToVirtualPath(virtualPath), logDetail);
			}

			//check permissions
			if (! (FolderPermissionController.CanAddFolder(dnnFolder)))
			{
				return LogDetailError(ErrorCodes.AddFolder_NoPermission, ToVirtualPath(dnnFolder.FolderPath), logDetail);
			}

			return string.Empty;
		}]]></body>
          </codeblock>
        </method>
        <method name="Check_CanCopyFolder">
          <declaration><![CDATA[private string Check_CanCopyFolder(string virtualPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="719" sc="3" el="721" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="c8da998bc25e6c0650e7f5e0c4167b66"><![CDATA[{
			return Check_CanCopyFolder(virtualPath,  EnableDetailedLogging);
		}]]></body>
          </codeblock>
        </method>
        <method name="Check_CanCopyFolder">
          <declaration><![CDATA[private string Check_CanCopyFolder(string virtualPath, bool logDetail)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="724" sc="3" el="739" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="ddd2a775d4596c9bf1742af4dd9607bd"><![CDATA[{
            var dnnFolder = GetDNNFolder(virtualPath);

            if (dnnFolder == null)
			{
                return LogDetailError(ErrorCodes.FolderDoesNotExist, virtualPath, logDetail);
			}

			//check permissions 
			if (! (FolderPermissionController.CanCopyFolder(dnnFolder)))
			{
				return LogDetailError(ErrorCodes.CopyFolder_NoPermission, ToVirtualPath(dnnFolder.FolderPath), logDetail);
			}

			return string.Empty;
		}]]></body>
          </codeblock>
        </method>
        <method name="Check_CanDeleteFolder">
          <declaration><![CDATA[private string Check_CanDeleteFolder(string virtualPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="742" sc="3" el="744" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="aa195376acf8894401a7d0aa77e467fd"><![CDATA[{
			return Check_CanDeleteFolder(virtualPath, false, EnableDetailedLogging);
		}]]></body>
          </codeblock>
        </method>
        <method name="Check_CanDeleteFolder">
          <declaration><![CDATA[private string Check_CanDeleteFolder(string virtualPath, bool isFileCheck)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="747" sc="3" el="749" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="13e19b7438a0c1542698683022cccdfc"><![CDATA[{
			return Check_CanDeleteFolder(virtualPath, isFileCheck, EnableDetailedLogging);
		}]]></body>
          </codeblock>
        </method>
        <method name="Check_CanDeleteFolder">
          <declaration><![CDATA[private string Check_CanDeleteFolder(string virtualPath, bool isFileCheck, bool logDetail)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="752" sc="3" el="783" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="92bb6896d6ed2874653b9789b3259c82"><![CDATA[{
            var dnnFolder = GetDNNFolder(virtualPath);
            
            if (dnnFolder == null)
			{
                return LogDetailError(ErrorCodes.FolderDoesNotExist, virtualPath, logDetail);
			}

			//skip additional folder checks when it is a file
			if (! isFileCheck)
			{
				//Don't allow delete of root folder, root is a protected folder, but show a special message
				if (dnnFolder.FolderPath == DBHomeDirectory)
				{
					return LogDetailError(ErrorCodes.DeleteFolder_Root, ToVirtualPath(dnnFolder.FolderPath));
				}

				//Don't allow deleting of any protected folder
				if (dnnFolder.IsProtected)
				{
					return LogDetailError(ErrorCodes.DeleteFolder_Protected, ToVirtualPath(dnnFolder.FolderPath), logDetail);
				}
			}

			//check permissions 
			if (! (FolderPermissionController.CanDeleteFolder(dnnFolder)))
			{
				return LogDetailError(ErrorCodes.DeleteFolder_NoPermission, ToVirtualPath(dnnFolder.FolderPath), logDetail);
			}

			return string.Empty;
		}]]></body>
          </codeblock>
        </method>
        <method name="Check_DiskSpace">
          <declaration><![CDATA[private object Check_DiskSpace(string virtualPathAndName, long contentLength)]]></declaration>
          <documentation>
            <summary>
 Validates disk space available
 </summary>
 <param name="virtualPathAndName">The system path. ie: C:\WebSites\DotNetNuke_Community\Portals\0\sample.gif</param>
 <param name="contentLength">Content Length</param>
 <returns>The error message or empty string</returns>
 <remarks></remarks></documentation>
          <codeblock>
            <location sl="829" sc="3" el="843" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="9b452f0a9134cea6237341a720858be4"><![CDATA[{
			try
			{
                if (!PortalController.Instance.HasSpaceAvailable(PortalController.Instance.GetCurrentPortalSettings().PortalId, contentLength))
				{
					return string.Format(Localization.GetString("DiskSpaceExceeded"), ToEndUserPath(virtualPathAndName));
				}
			}
			catch (Exception ex)
			{
				return LogUnknownError(ex, virtualPathAndName, contentLength.ToString(CultureInfo.InvariantCulture));
			}

			return string.Empty;
		}]]></body>
          </codeblock>
        </method>
        <method name="Check_FileName">
          <declaration><![CDATA[private string Check_FileName(string virtualPathAndName)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="790" sc="3" el="819" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="de034342e22022dbd89d29fd274c8e12"><![CDATA[{
			try
			{
				string fileName = Path.GetFileName(virtualPathAndName);
                if (string.IsNullOrEmpty(fileName))
                    Logger.DebugFormat("filename is empty, call stack: {0}", new StackTrace().ToString());

    		    var rawExtension = Path.GetExtension(fileName);
			    if (rawExtension != null)
			    {
			        string extension = rawExtension.Replace(".", "").ToLowerInvariant();
			        string validExtensions = Entities.Host.Host.FileExtensions.ToLowerInvariant();

			        if (fileName != null && (string.IsNullOrEmpty(extension) || ("," + validExtensions + ",").IndexOf("," + extension + ",", StringComparison.Ordinal) == -1 || Regex.IsMatch(fileName, @"\..+;")))
			        {
			            if (HttpContext.Current != null)
			            {
			                return string.Format(Localization.GetString("RestrictedFileType"), ToEndUserPath(virtualPathAndName), validExtensions.Replace(",", ", *."));
			            }
			            return "RestrictedFileType";
			        }
			    }
			}
			catch (Exception ex)
			{
				return LogUnknownError(ex, virtualPathAndName);
			}

			return string.Empty;
		}]]></body>
          </codeblock>
        </method>
        <method name="CombineVirtualPath">
          <declaration><![CDATA[public static string CombineVirtualPath(string virtualPath, string folderOrFileName)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="518" sc="3" el="528" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="de203bdfffdc2d8885aa1e2ea013603e"><![CDATA[{
			string returnValue = Path.Combine(virtualPath, folderOrFileName);
			returnValue = returnValue.Replace("\\", "/");

			if (string.IsNullOrEmpty(Path.GetExtension(returnValue)) && ! (returnValue.EndsWith("/")))
			{
				returnValue = returnValue + "/";
			}

			return returnValue;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetChildUserFolders">
          <declaration><![CDATA[public virtual IDictionary<string, FolderInfo> GetChildUserFolders(string parentPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="560" sc="3" el="571" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="23b51f0b7e4b058ee5c8b6f7f3f1b87b"><![CDATA[{
			string dbPath = ToDBPath(parentPath);
			IDictionary<string, FolderInfo> returnValue = new Dictionary<string, FolderInfo>();

            var dnnParentFolder = FolderManager.Instance.GetFolder(PortalSettings.PortalId, dbPath);
            var dnnChildFolders = FolderManager.Instance.GetFolders(dnnParentFolder).Where(folder => (HasPermission(folder, "BROWSE,READ")));
	        foreach (var dnnChildFolder in dnnChildFolders)
	        {
	            returnValue.Add(dnnChildFolder.FolderPath,(FolderInfo)dnnChildFolder);
	        }			
            return returnValue;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetDestinationFolder">
          <declaration><![CDATA[public static string GetDestinationFolder(string virtualPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="574" sc="3" el="599" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="29e9a1597defffb219249e26991cd172"><![CDATA[{
			string splitPath = virtualPath;
			if (splitPath.Substring(splitPath.Length - 1) == "/")
			{
				splitPath = splitPath.Remove(splitPath.Length - 1, 1);
			}

			if (splitPath == HomeDirectory)
			{
				return splitPath;
			}

			string[] pathList = splitPath.Split('/');
			if (pathList.Length > 0)
			{
				string folderName = pathList[pathList.Length - 1];

				string folderSubString = splitPath.Substring(splitPath.Length - folderName.Length);
				if (folderSubString == folderName)
				{
					return splitPath.Substring(0, splitPath.Length - folderName.Length);
				}
			}

			return string.Empty;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetDNNFolder">
          <declaration><![CDATA[private FolderInfo GetDNNFolder(string path)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="877" sc="3" el="879" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="f8fe342598fe94a9f2841a34b4ee17e6"><![CDATA[{
			return DNNFolderCtrl.GetFolder(PortalSettings.PortalId, ToDBPath(path), false);
		}]]></body>
          </codeblock>
        </method>
        <method name="GetFileSize">
          <declaration><![CDATA[private int GetFileSize(string virtualPathAndFile)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="850" sc="3" el="874" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="54100a04fc0ba8b00c99587e50e4ce0f"><![CDATA[{
			int returnValue = -1;

			if  (File.Exists(virtualPathAndFile))
			{
				FileStream openFile = null;
				try
				{
					openFile = File.OpenRead(virtualPathAndFile);
                    returnValue = (int)openFile.Length;
				}
				finally
				{
					if (openFile != null)
					{
						openFile.Close();
						openFile.Dispose();
					}
                    else
					    returnValue = -1;
				}
			}

			return returnValue;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetPermissionErrorText">
          <declaration><![CDATA[private string GetPermissionErrorText()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1014" sc="3" el="1016" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="b6e1196cde49cd8e6acb5d7aabae95cf"><![CDATA[{
			return GetString("ErrorCodes." + ErrorCodes.General_PermissionDenied);
		}]]></body>
          </codeblock>
        </method>
        <method name="GetString">
          <declaration><![CDATA[public string GetString(string key)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="982" sc="3" el="985" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="215605cc3ef2eafd42aacb798c1b17c6"><![CDATA[{
			string resourceFile = "/DesktopModules/Admin/RadEditorProvider/" + Localization.LocalResourceDirectory + "/FileManager.resx";
			return Localization.GetString(key, resourceFile);
		}]]></body>
          </codeblock>
        </method>
        <method name="GetSystemErrorText">
          <declaration><![CDATA[private string GetSystemErrorText(params string[] @params)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1001" sc="3" el="1011" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="0d0e1b9c0b9e7f707f8836ede53a0dd7"><![CDATA[{
			try
			{
				return GetString("SystemError.Text") + " " + string.Join(" | ", @params);
			}
			catch (Exception ex)
			{
                Logger.Error(ex);
				return "An unknown error occurred." + " " + string.Join(" | ", @params);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="GetUnknownText">
          <declaration><![CDATA[private string GetUnknownText()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="988" sc="3" el="998" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="8bfaf639db07359ff7046bfa9714680d"><![CDATA[{
			try
			{
				return GetString("SystemError.Text");
			}
			catch (Exception ex)
			{
                Logger.Error(ex);
				return "An unknown error occurred.";
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="GetUserFolder">
          <declaration><![CDATA[public virtual FolderInfo GetUserFolder(string path)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="554" sc="3" el="557" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="96ac986f1a3deae54dd6d45ce5af5747"><![CDATA[{
		    var returnFolder = FolderManager.Instance.GetFolder(PortalSettings.PortalId, ToDBPath(path));
		    return HasPermission(returnFolder, "BROWSE,READ") ? (FolderInfo)returnFolder : null;
		}]]></body>
          </codeblock>
        </method>
        <method name="HasPermission">
          <declaration><![CDATA[public static bool HasPermission(IFolderInfo folder, string permissionKey)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="606" sc="9" el="615" ec="10">Components\FileSystemValidation.cs</location>
            <body hash="a0d03c59a6177826483c2d327ff7d6dd"><![CDATA[{
            var hasPermission = PortalSettings.Current.UserInfo.IsSuperUser;

            if (!hasPermission && folder != null)
            {
                hasPermission = FolderPermissionController.HasFolderPermission(folder.FolderPermissions, permissionKey);
            }

            return hasPermission;
        }]]></body>
          </codeblock>
        </method>
        <method name="LogDetailError">
          <declaration><![CDATA[public string LogDetailError(ErrorCodes errorCode)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="904" sc="3" el="906" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="46a737985953efef604ef0bdffdb16e8"><![CDATA[{
			return LogDetailError(errorCode, string.Empty, EnableDetailedLogging);
		}]]></body>
          </codeblock>
        </method>
        <method name="LogDetailError">
          <declaration><![CDATA[public string LogDetailError(ErrorCodes errorCode, string virtualPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="909" sc="3" el="911" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="bfd2f077c879bfe7c1c0ec2b9d9eb55d"><![CDATA[{
			return LogDetailError(errorCode, virtualPath, EnableDetailedLogging);
		}]]></body>
          </codeblock>
        </method>
        <method name="LogDetailError">
          <declaration><![CDATA[public string LogDetailError(ErrorCodes errorCode, string virtualPath, bool logError)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="914" sc="3" el="975" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="50cf75d3a932f86aa0516b72a06ff9d1"><![CDATA[{
			string endUserPath = string.Empty;
			if (! (string.IsNullOrEmpty(virtualPath)))
			{
				endUserPath = (string)ToEndUserPath(virtualPath);
			}

			string returnValue = GetPermissionErrorText();
			string logMsg = string.Empty;

			switch (errorCode)
			{
				case ErrorCodes.AddFolder_NoPermission:
				case ErrorCodes.AddFolder_NotInsecureFolder:
				case ErrorCodes.CopyFolder_NoPermission:
				case ErrorCodes.CopyFolder_NotInsecureFolder:
				case ErrorCodes.DeleteFolder_NoPermission:
				case ErrorCodes.DeleteFolder_NotInsecureFolder:
				case ErrorCodes.DeleteFolder_Protected:
				case ErrorCodes.CannotMoveFolder_ChildrenVisible:
				case ErrorCodes.CannotDeleteFolder_ChildrenVisible:
				case ErrorCodes.CannotCopyFolder_ChildrenVisible:
					logMsg = GetString("ErrorCodes." + errorCode);
					break;
				case ErrorCodes.DeleteFolder_Root:
				case ErrorCodes.RenameFolder_Root:
					logMsg = GetString("ErrorCodes." + errorCode);
					returnValue = string.Format("{0} [{1}]", GetString("ErrorCodes." + errorCode), endUserPath);
					break;
				case ErrorCodes.FileDoesNotExist:
				case ErrorCodes.FolderDoesNotExist:
					logMsg = string.Empty;
					returnValue = string.Format("{0} [{1}]", GetString("ErrorCodes." + errorCode), endUserPath);
					break;
			}

			if (! (string.IsNullOrEmpty(logMsg)))
			{
				var log = new LogInfo {LogTypeKey = EventLogController.EventLogType.ADMIN_ALERT.ToString()};

			    log.AddProperty("From", "TelerikHtmlEditorProvider Message");

				if (PortalSettings.ActiveTab != null)
				{
					log.AddProperty("TabID", PortalSettings.ActiveTab.TabID.ToString(CultureInfo.InvariantCulture));
					log.AddProperty("TabName", PortalSettings.ActiveTab.TabName);
				}

				Entities.Users.UserInfo user = Entities.Users.UserController.Instance.GetCurrentUserInfo();
				if (user != null)
				{
					log.AddProperty("UserID", user.UserID.ToString(CultureInfo.InvariantCulture));
					log.AddProperty("UserName", user.Username);
				}

				log.AddProperty("Message", logMsg);
				log.AddProperty("Path", virtualPath);
				LogController.Instance.AddLog(log);
			}

			return returnValue;
		}]]></body>
          </codeblock>
        </method>
        <method name="LogUnknownError">
          <declaration><![CDATA[protected internal string LogUnknownError(Exception ex, params string[] @params)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="896" sc="3" el="901" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="930dbc38efb6faa79fded18df49259d2"><![CDATA[{
			string returnValue = GetUnknownText();
			var exc = new FileManagerException(GetSystemErrorText(@params), ex);
			Exceptions.LogException(exc);
			return returnValue;
		}]]></body>
          </codeblock>
        </method>
        <method name="OnCopyFile">
          <declaration><![CDATA[public virtual string OnCopyFile(string virtualPathAndFile, string virtualNewPathAndFile)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="319" sc="3" el="341" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="0c3751285c4ac7c45209a86bf2db89f8"><![CDATA[{
		    try
			{
				int existingFileSize = GetFileSize(virtualPathAndFile);
				if (existingFileSize < 0)
				{
					return LogDetailError(ErrorCodes.FileDoesNotExist, virtualPathAndFile, true);
				}

				string virtualPath = RemoveFileName(virtualPathAndFile);
				string returnValue = Check_CanCopyFolder(virtualPath, true);
				if (! (string.IsNullOrEmpty(returnValue)))
				{
					return returnValue;
				}

				return OnCreateFile(virtualNewPathAndFile, existingFileSize);
			}
			catch (Exception ex)
			{
				return LogUnknownError(ex, virtualPathAndFile, virtualNewPathAndFile);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="OnCopyFolder">
          <declaration><![CDATA[public virtual string OnCopyFolder(string virtualPath, string virtualDestinationPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="137" sc="3" el="159" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="0d14927c696127356acd0b9e78f97435"><![CDATA[{
			string returnValue;
			try
			{
				returnValue = Check_CanCopyFolder(virtualPath);
				if (! (string.IsNullOrEmpty(returnValue)))
				{
					return returnValue;
				}

				returnValue = Check_CanAddToFolder(virtualDestinationPath);
				if (! (string.IsNullOrEmpty(returnValue)))
				{
					return returnValue;
				}
			}
			catch (Exception ex)
			{
				return LogUnknownError(ex, virtualPath, virtualDestinationPath);
			}

			return returnValue;
		}]]></body>
          </codeblock>
        </method>
        <method name="OnCreateFile">
          <declaration><![CDATA[public virtual string OnCreateFile(string virtualPathAndFile, long contentLength)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="224" sc="3" el="253" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="2886f324979b94a9e3171a26a2522f60"><![CDATA[{
			string returnValue;
			try
			{
				var virtualPath = RemoveFileName(virtualPathAndFile);
				returnValue = Check_CanAddToFolder(virtualPath, true);
				if (! (string.IsNullOrEmpty(returnValue)))
				{
					return returnValue;
				}

				returnValue = Check_FileName(virtualPathAndFile);
				if (! (string.IsNullOrEmpty(returnValue)))
				{
					return returnValue;
				}

				returnValue = (string)Check_DiskSpace(virtualPathAndFile, contentLength);
				if (! (string.IsNullOrEmpty(returnValue)))
				{
					return returnValue;
				}
			}
			catch (Exception ex)
			{
				return LogUnknownError(ex, virtualPathAndFile, contentLength.ToString(CultureInfo.InvariantCulture));
			}

			return returnValue;
		}]]></body>
          </codeblock>
        </method>
        <method name="OnCreateFolder">
          <declaration><![CDATA[public virtual string OnCreateFolder(string virtualPath, string folderName)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="57" sc="3" el="69" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="9907a25b29d9a455dc46f39389a764f6"><![CDATA[{
			string returnValue;
			try
			{
				returnValue = Check_CanAddToFolder(virtualPath);
			}
			catch (Exception ex)
			{
				return LogUnknownError(ex, virtualPath, folderName);
			}

			return returnValue;
		}]]></body>
          </codeblock>
        </method>
        <method name="OnDeleteFile">
          <declaration><![CDATA[public virtual string OnDeleteFile(string virtualPathAndFile)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="256" sc="3" el="270" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="32f088d0f07c81cc77587d43666c71b4"><![CDATA[{
			string returnValue;
			try
			{
				string virtualPath = RemoveFileName(virtualPathAndFile);

				returnValue = Check_CanDeleteFolder(virtualPath, true);
			}
			catch (Exception ex)
			{
				return LogUnknownError(ex, virtualPathAndFile);
			}

			return returnValue;
		}]]></body>
          </codeblock>
        </method>
        <method name="OnDeleteFolder">
          <declaration><![CDATA[public virtual string OnDeleteFolder(string virtualPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="72" sc="3" el="84" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="163bea9a861e04451333cc660932aa7f"><![CDATA[{
			string returnValue;
			try
			{
				returnValue = Check_CanDeleteFolder(virtualPath);
			}
			catch (Exception ex)
			{
				return LogUnknownError(ex, virtualPath);
			}

			return returnValue;
		}]]></body>
          </codeblock>
        </method>
        <method name="OnFileCreated">
          <declaration><![CDATA[public virtual void OnFileCreated(string virtualPathAndFile, int contentLength)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="200" sc="9" el="221" ec="10">Components\FileSystemValidation.cs</location>
            <body hash="ef11bda4b853dca8818d436bb7449602"><![CDATA[{
            try
            {
                //rename secure files
                var folder = GetDNNFolder(virtualPathAndFile);
                if (folder.StorageLocation == (int)FolderController.StorageLocationTypes.SecureFileSystem)
                {
                    var securedFile = virtualPathAndFile + Globals.glbProtectedExtension;
                    var absolutePathAndFile = HttpContext.Current.Request.MapPath(virtualPathAndFile);
                    var securedFileAbsolute = HttpContext.Current.Request.MapPath(securedFile);

                    File.Move(absolutePathAndFile, securedFileAbsolute);
                }

                FolderManager.Instance.Synchronize(folder.PortalID, folder.FolderPath, false, true);
            }
            catch (Exception ex)
            {
                LogUnknownError(ex, virtualPathAndFile, contentLength.ToString(CultureInfo.InvariantCulture));
            }

        }]]></body>
          </codeblock>
        </method>
        <method name="OnFolderCreated">
          <declaration><![CDATA[public virtual void OnFolderCreated(string virtualFolderPath, string virtualParentPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="181" sc="9" el="197" ec="10">Components\FileSystemValidation.cs</location>
            <body hash="b84ae5aca10947d83f1c996912d3ecce"><![CDATA[{
            try
            {
                //rename secure files
                var folder = GetDNNFolder(virtualFolderPath);
                var parent = GetDNNFolder(virtualParentPath);

                folder.StorageLocation = parent.StorageLocation;
                folder.FolderMappingID = parent.FolderMappingID;
                DNNFolderCtrl.UpdateFolder(folder);
            }
            catch (Exception ex)
            {
                LogUnknownError(ex, virtualFolderPath);
            }

        }]]></body>
          </codeblock>
        </method>
        <method name="OnFolderRenamed">
          <declaration><![CDATA[public virtual void OnFolderRenamed(string oldFolderPath, string newFolderPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="166" sc="9" el="178" ec="10">Components\FileSystemValidation.cs</location>
            <body hash="adf8b507594a00ab392b729f3bbf8550"><![CDATA[{
            try
            {
                var folder = GetDNNFolder(oldFolderPath);
                folder.FolderPath = ToDBPath(newFolderPath);
                DNNFolderCtrl.UpdateFolder(folder);
            }
            catch (Exception ex)
            {
                LogUnknownError(ex, newFolderPath);
            }

        }]]></body>
          </codeblock>
        </method>
        <method name="OnMoveFile">
          <declaration><![CDATA[public virtual string OnMoveFile(string virtualPathAndFile, string virtualNewPathAndFile)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="299" sc="3" el="316" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="01c97b8ed480ce80a0ffa136e7a00c3b"><![CDATA[{
		    try
			{
				string virtualPath = RemoveFileName(virtualPathAndFile);

				string returnValue = Check_CanDeleteFolder(virtualPath, true);
				if (! (string.IsNullOrEmpty(returnValue)))
				{
					return returnValue;
				}

				return OnCreateFile(virtualNewPathAndFile, 0);
			}
			catch (Exception ex)
			{
				return LogUnknownError(ex, virtualPathAndFile, virtualNewPathAndFile);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="OnMoveFolder">
          <declaration><![CDATA[public virtual string OnMoveFolder(string virtualPath, string virtualDestinationPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="87" sc="3" el="109" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="4ad605b8b4573b4e7f41527c3524ff5b"><![CDATA[{
			string returnValue;
			try
			{
				returnValue = Check_CanDeleteFolder(virtualPath);
				if (! (string.IsNullOrEmpty(returnValue)))
				{
					return returnValue;
				}

				returnValue = Check_CanAddToFolder(virtualDestinationPath);
				if (! (string.IsNullOrEmpty(returnValue)))
				{
					return returnValue;
				}
			}
			catch (Exception ex)
			{
				return LogUnknownError(ex, virtualPath, virtualDestinationPath);
			}

			return returnValue;
		}]]></body>
          </codeblock>
        </method>
        <method name="OnRenameFile">
          <declaration><![CDATA[public virtual string OnRenameFile(string virtualPathAndFile)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="273" sc="3" el="296" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="89abc98e52420f3f4df34db7e5fd13c1"><![CDATA[{
		    try
			{
				string virtualPath = RemoveFileName(virtualPathAndFile);

				string returnValue = Check_CanAddToFolder(virtualPath, true);
				if (! (string.IsNullOrEmpty(returnValue)))
				{
					return returnValue;
				}

				returnValue = Check_CanDeleteFolder(virtualPath, true);
				if (! (string.IsNullOrEmpty(returnValue)))
				{
					return returnValue;
				}

				return returnValue;
			}
			catch (Exception ex)
			{
				return LogUnknownError(ex, virtualPathAndFile);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="OnRenameFolder">
          <declaration><![CDATA[public virtual string OnRenameFolder(string virtualPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="112" sc="3" el="134" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="d4675246bfc02eaea204f2a31009e4ec"><![CDATA[{
			string returnValue;
			try
			{
				returnValue = Check_CanAddToFolder(GetDestinationFolder(virtualPath));
				if (! (string.IsNullOrEmpty(returnValue)))
				{
					return returnValue;
				}

				returnValue = Check_CanDeleteFolder(virtualPath);
				if (! (string.IsNullOrEmpty(returnValue)))
				{
					return returnValue;
				}
			}
			catch (Exception ex)
			{
				return LogUnknownError(ex, virtualPath);
			}

			return returnValue;
		}]]></body>
          </codeblock>
        </method>
        <method name="RemoveFileName">
          <declaration><![CDATA[public static string RemoveFileName(string path)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="531" sc="3" el="542" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="cb62dc9c4c50bbf02229c07e5a3cb7b5"><![CDATA[{
			if (! (string.IsNullOrEmpty(Path.GetExtension(path))))
			{
			    var directoryName = Path.GetDirectoryName(path);
			    if (directoryName != null)
			    {
			        path = directoryName.Replace("\\", "/") + "/";
			    }
			}

            return path;
		}]]></body>
          </codeblock>
        </method>
        <method name="TelerikPermissions">
          <declaration><![CDATA[public static PathPermissions TelerikPermissions(IFolderInfo folder)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="618" sc="9" el="635" ec="10">Components\FileSystemValidation.cs</location>
            <body hash="689dafa65ebd40553556c07bd17a4765"><![CDATA[{
            var folderPermissions = PathPermissions.Read;

            if (FolderPermissionController.CanViewFolder((FolderInfo)folder))
            {
                if (FolderPermissionController.CanAddFolder((FolderInfo)folder))
                {
                    folderPermissions = folderPermissions | PathPermissions.Upload;
                }

                if (FolderPermissionController.CanDeleteFolder((FolderInfo)folder))
                {
                    folderPermissions = folderPermissions | PathPermissions.Delete;
                }
            }

            return folderPermissions;
        }]]></body>
          </codeblock>
        </method>
        <method name="ToDBPath">
          <declaration><![CDATA[public static string ToDBPath(string path)]]></declaration>
          <documentation>
            <summary>
 Results in a path that can be used in database calls
 </summary>
 <param name="path"></param>
 <returns></returns>
 <remarks></remarks></documentation>
          <codeblock>
            <location sl="480" sc="3" el="515" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="bdccb95b7e004b942eb5439283ecb23b"><![CDATA[{
			string returnValue = path;

			returnValue = returnValue.Replace("\\", "/");
			returnValue = RemoveFileName(returnValue);

			if (returnValue.StartsWith(HomeDirectory))
			{
				returnValue = returnValue.Substring(HomeDirectory.Length);
			}

			if (returnValue.StartsWith(EndUserHomeDirectory))
			{
				returnValue = returnValue.Substring(EndUserHomeDirectory.Length);
			}

			//folders in dnn db do not start with /
			if (returnValue.StartsWith("/"))
			{
				returnValue = returnValue.Remove(0, 1);
			}

			//Root directory is an empty string
			if (returnValue == "/" || returnValue == "\\")
			{
				returnValue = string.Empty;
			}

			//root folder (empty string) does not contain / - all other folders must contain a slash at the end
			if (! (string.IsNullOrEmpty(returnValue)) && ! (returnValue.EndsWith("/")))
			{
				returnValue = returnValue + "/";
			}

			return returnValue;
		}]]></body>
          </codeblock>
        </method>
        <method name="ToEndUserPath">
          <declaration><![CDATA[public static object ToEndUserPath(string path)]]></declaration>
          <documentation>
            <summary>
 Results in the path displayed to the end user
 </summary>
 <param name="path"></param>
 <returns></returns>
 <remarks></remarks></documentation>
          <codeblock>
            <location sl="448" sc="3" el="471" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="10675f7677a6d70d86c57bc0199bda80"><![CDATA[{
			path = path.Replace("\\", "/");

			if (path.StartsWith(HomeDirectory))
			{
				path = EndUserHomeDirectory + path.Substring(HomeDirectory.Length);
			}

			if (! (path.StartsWith(EndUserHomeDirectory)))
			{
				if (! (path.StartsWith("/")))
				{
					path = "/" + path;
				}
				path = EndUserHomeDirectory + path;
			}

			if (string.IsNullOrEmpty(Path.GetExtension(path)) && ! (path.EndsWith("/")))
			{
				path = path + "/";
			}

			return path;
		}]]></body>
          </codeblock>
        </method>
        <method name="ToVirtualPath">
          <declaration><![CDATA[public static string ToVirtualPath(string path)]]></declaration>
          <documentation>
            <summary>
 Results in a virtual path to a folder or file
 </summary>
 <param name="path"></param>
 <returns></returns>
 <remarks></remarks></documentation>
          <codeblock>
            <location sl="420" sc="3" el="439" ec="4">Components\FileSystemValidation.cs</location>
            <body hash="5b1d3d6eefa046b943e149fde06dd4de"><![CDATA[{
			path = path.Replace("\\", "/");

			if (path.StartsWith(EndUserHomeDirectory))
			{
				path = HomeDirectory + path.Substring(EndUserHomeDirectory.Length);
			}

			if (! (path.StartsWith(HomeDirectory)))
			{
				path = CombineVirtualPath(HomeDirectory, path);
			}

			if (string.IsNullOrEmpty(Path.GetExtension(path)) && ! (path.EndsWith("/")))
			{
				path = path + "/";
			}

			return path.Replace("\\", "/");
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_DNNFolderCtrl">
          <declaration><![CDATA[private FolderController _DNNFolderCtrl;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="EnableDetailedLogging">
          <declaration><![CDATA[public bool EnableDetailedLogging = true;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Logger">
          <declaration><![CDATA[private static readonly ILog Logger = LoggerSource.Instance.GetLogger(typeof(FileSystemValidation));]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="DBHomeDirectory">
          <declaration><![CDATA[public static string DBHomeDirectory]]></declaration>
          <documentation>
            <summary>
 Gets the DotNetNuke Portal Directory Root as stored in the database
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks></documentation>
          <codeblock>
            <location sl="408" sc="4" el="410" ec="5">Components\FileSystemValidation.cs</location>
            <body hash="22ffd13033b5826c604c8c3014fe1316"><![CDATA[{
				return string.Empty;
			}]]></body>
          </codeblock>
        </property>
        <property name="DNNFolderCtrl">
          <declaration><![CDATA[private FolderController DNNFolderCtrl]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="EndUserHomeDirectory">
          <declaration><![CDATA[public static string EndUserHomeDirectory]]></declaration>
          <documentation>
            <summary>
 Gets the DotNetNuke Portal Directory Root localized text to display to the end user
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks></documentation>
          <codeblock>
            <location sl="378" sc="4" el="396" ec="5">Components\FileSystemValidation.cs</location>
            <body hash="2168b93614b3c58ac50acc26a08772b4"><![CDATA[{
				//Dim text As String = Localization.Localization.GetString("PortalRoot.Text")
				//If (String.IsNullOrEmpty(text)) Then
				//    Return "Portal Root"
				//End If

				//Return text.Replace("/", " ").Replace("\", " ").Trim()

				string homeDir = PortalController.Instance.GetCurrentPortalSettings().HomeDirectory;
				homeDir = homeDir.Replace("\\", "/");

				if (homeDir.EndsWith("/"))
				{
					homeDir = homeDir.Remove(homeDir.Length - 1, 1);
				}

				return homeDir;

			}]]></body>
          </codeblock>
        </property>
        <property name="HomeDirectory">
          <declaration><![CDATA[public static string HomeDirectory]]></declaration>
          <documentation>
            <summary>
 Gets the DotNetNuke Portal Directory Virtual path
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks></documentation>
          <codeblock>
            <location sl="356" sc="4" el="366" ec="5">Components\FileSystemValidation.cs</location>
            <body hash="79fd88b35e33441dba40d8eb1b87f279"><![CDATA[{
				string homeDir = PortalController.Instance.GetCurrentPortalSettings().HomeDirectory;
				homeDir = homeDir.Replace("\\", "/");

				if (homeDir.EndsWith("/"))
				{
					homeDir = homeDir.Remove(homeDir.Length - 1, 1);
				}

				return homeDir;
			}]]></body>
          </codeblock>
        </property>
        <property name="PortalSettings">
          <declaration><![CDATA[private PortalSettings PortalSettings]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="890" sc="4" el="892" ec="5">Components\FileSystemValidation.cs</location>
            <body hash="2412c34ada6a6072f3ada85a58cdfd4d"><![CDATA[{
				return PortalSettings.Current;
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="HtmTemplateFileHandler">
      <declaration><![CDATA[public class HtmTemplateFileHandler : System.Web.IHttpHandler]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public HtmTemplateFileHandler()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ProcessRequest">
          <declaration><![CDATA[public void ProcessRequest(System.Web.HttpContext context)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="33" sc="3" el="37" ec="4">Components\HtmTemplateFileHandler.cs</location>
            <body hash="3a72def640e4550426a70915659945d5"><![CDATA[{
		    context.Response.Clear();
		    context.Response.ContentType = "text/html";
		    context.Response.Write(FileSystemUtils.ReadFile(context.Request.PhysicalPath));
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="IsReusable">
          <declaration><![CDATA[public bool IsReusable]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="42" sc="4" el="44" ec="5">Components\HtmTemplateFileHandler.cs</location>
            <body hash="63b35ed46fefbd08e3765d5f12ecf65d"><![CDATA[{
				return false;
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ImageTester">
      <declaration><![CDATA[public class ImageTester : System.Web.UI.Page]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ImageTester()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="OnInit">
          <declaration><![CDATA[protected override void OnInit(EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="83" sc="2" el="88" ec="3">ImageTester.aspx.cs</location>
            <body hash="e40adb86f9d34be4955dd1a3260f97d6"><![CDATA[{
		base.OnInit(e);

//INSTANT C# NOTE: Converted event handler wireups:
		this.Load += new System.EventHandler(Page_Load);
	}]]></body>
          </codeblock>
        </method>
        <method name="Page_Load">
          <declaration><![CDATA[protected void Page_Load(object sender, EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="60" sc="3" el="79" ec="4">ImageTester.aspx.cs</location>
            <body hash="752647e7dcc19921fce21cae1b2c4ac3"><![CDATA[{

			string strResult = "NOTFOUND";

			string strFile = Request.QueryString["file"];
			if (strFile != null)
			{
				string path = strFile.Replace("http://", "");
				path = path.Substring(path.IndexOf("/"));
				strFile = Server.MapPath(path);
				if (System.IO.File.Exists(strFile))
				{
					strResult = "OK";
				}
			}

			Response.Write(strResult);
			Response.Flush();

		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="LinkClickUrlHandler">
      <declaration><![CDATA[public class LinkClickUrlHandler : BaseHttpHandler]]></declaration>
      <documentation>
        <summary>
 Returns a LinkClickUrl if provided a tabid and LinkUrl.
 </summary>
 <remarks>This uses the new BaseHttpHandler which encapsulates most common scenarios including the retrieval of AJAX request data.
 See http://blog.theaccidentalgeek.com/post/2008/10/28/An-Updated-Abstract-Boilerplate-HttpHandler.aspx for more information on
 the BaseHttpHandler.
 </remarks></documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private IPortalAliasController _portalAliasController = ServiceLocator<IPortalAliasController, PortalAliasController>.Instance;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="72" sc="3" el="74" ec="65">LinkClickUrlHandler.ashx.cs</location>
            <body hash="6cf135a73c05b21941b6a7f8caf50251"><![CDATA[private IPortalAliasController _portalAliasController = PortalAliasController.Instance;
		private UrlController _urlController = new UrlController();
		private FileController _fileController = new FileController();]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static LinkClickUrlHandler()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="70" sc="3" el="70" ec="103">LinkClickUrlHandler.ashx.cs</location>
            <body hash="71e47acc504e565f8f54e4daa791e8c4"><![CDATA[private static readonly ILog Logger = LoggerSource.Instance.GetLogger(typeof (LinkClickUrlHandler))]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="GetDomain">
          <declaration><![CDATA[private string GetDomain()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="209" sc="9" el="215" ec="10">LinkClickUrlHandler.ashx.cs</location>
            <body hash="2791e6a873c694984f53d9d09a58b826"><![CDATA[{
            var scheme = Context.Request.Url.Scheme;
            var host = Context.Request.Url.Host;
            var port = Context.Request.Url.IsDefaultPort ? string.Empty : ":" + Context.Request.Url.Port;
            
            return string.Format("{0}://{1}{2}", scheme, host, port);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetLinkClickURL">
          <declaration><![CDATA[private string GetLinkClickURL(ref DialogParams dialogParams, ref string link)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="79" sc="3" el="84" ec="4">LinkClickUrlHandler.ashx.cs</location>
            <body hash="cb2921f96eeeab4c26af2becee77d274"><![CDATA[{
			link = GetLinkUrl(ref dialogParams, link);

			return GetDomain() + Globals.LinkClick(link, dialogParams.TabId, dialogParams.ModuleId, true, false, dialogParams.PortalId, dialogParams.EnableUrlLanguage, dialogParams.PortalGuid);

		}]]></body>
          </codeblock>
        </method>
        <method name="GetLinkUrl">
          <declaration><![CDATA[private string GetLinkUrl(ref DialogParams dialogParams, string link)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="87" sc="3" el="148" ec="4">LinkClickUrlHandler.ashx.cs</location>
            <body hash="57cd68c9cb4ce88512e925a82d3a4c84"><![CDATA[{
            var aliasList = _portalAliasController.GetPortalAliasesByPortalId(dialogParams.PortalId);

			if (dialogParams.LinkUrl.Contains(dialogParams.HomeDirectory))
			{
				string filePath = dialogParams.LinkUrl.Substring(dialogParams.LinkUrl.IndexOf(dialogParams.HomeDirectory)).Replace(dialogParams.HomeDirectory, "");
				var linkedFileId = FileManager.Instance.GetFile(dialogParams.PortalId, HttpUtility.UrlDecode(filePath)).FileId;
				link = string.Format("fileID={0}", linkedFileId);
			}
			else
			{
				foreach (PortalAliasInfo portalAlias in aliasList)
				{
					dialogParams.LinkUrl = dialogParams.LinkUrl.Replace(Globals.AddHTTP(portalAlias.HTTPAlias), "");
				}

				string tabPath = dialogParams.LinkUrl.Replace("http://", "").Replace("/", "//").Replace(".aspx", "");
				string cultureCode = Localization.SystemLocale;
                //get language info from url.
                var dicLocales = LocaleController.Instance.GetLocales(dialogParams.PortalId);
                foreach (var part in tabPath.Split(new char[]{'/'}, StringSplitOptions.RemoveEmptyEntries))
                {
                    if (dicLocales != null && part.IndexOf("-") > -1)
                    {
                        foreach (KeyValuePair<string, Locale> key in dicLocales)
                        {
                            if (key.Key.ToLower().Equals(part.ToLower()))
                            {
                                cultureCode = key.Value.Code;
                                tabPath = tabPath.Replace("//" + part, string.Empty);
                                break;
                            }
                        }
                    }
                }

				//Try HumanFriendlyUrl TabPath
				link = TabController.GetTabByTabPath(dialogParams.PortalId, tabPath, cultureCode).ToString();

				if (link == Null.NullInteger.ToString())
				{
					//Try getting the tabId from the querystring
					string[] arrParams = dialogParams.LinkUrl.Split('/');
					for (int i = 0; i < arrParams.Length; i++)
					{
						if (arrParams[i].ToLowerInvariant() == "tabid")
						{
							link = arrParams[i + 1];
							break;
						}
					}
                    if (link == Null.NullInteger.ToString())
					{
						link = dialogParams.LinkUrl;
					}
				}

			}

			return link;

		}]]></body>
          </codeblock>
        </method>
        <method name="GetUrlLoggingInfo">
          <declaration><![CDATA[private string GetUrlLoggingInfo(ArrayList urlLog)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="177" sc="3" el="206" ec="4">LinkClickUrlHandler.ashx.cs</location>
            <body hash="a32b5f3c7ef59d334dcdb5b172cb5a20"><![CDATA[{
			StringBuilder fullTableContent = new StringBuilder();
			int maxCount = ((urlLog.Count > 100) ? 100 : urlLog.Count);

			fullTableContent.Append("<div class='UrlLoggingInfo' style='width: 100%;'>");

			if (urlLog.Count > 100)
			{
				fullTableContent.Append("<span>Your search returned <strong>" + urlLog.Count.ToString() + "</strong> results. Showing only the first 100 records ordered by date.</span><br /><br />");
			}

			fullTableContent.Append("<table><tr><th>Date</th><th>User</th></tr>");

			if (maxCount == 0)
			{
				fullTableContent.Append("<tr><td colspan='2'>Your search did not return any results.</td></tr>");
			}
			else
			{
				for (var x = 0; x < maxCount; x++)
				{
					UrlLogInfo log = (UrlLogInfo)urlLog[x];
					fullTableContent.Append("<tr><td>" + log.ClickDate + "</td><td>" + log.FullName + "</td></tr>");
				}
			}

			fullTableContent.Append("</table></div>");

			return fullTableContent.ToString();
		}]]></body>
          </codeblock>
        </method>
        <method name="GetURLType">
          <declaration><![CDATA[private string GetURLType(TabType tabType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="151" sc="3" el="174" ec="4">LinkClickUrlHandler.ashx.cs</location>
            <body hash="3b46244c5b39c84e2d71636a6c067ddf"><![CDATA[{
//INSTANT C# NOTE: The following VB 'Select Case' included either a non-ordinal switch expression or non-ordinal, range-type, or non-constant 'Case' expressions and was converted to C# 'if-else' logic:
//			Select Case tabType
//ORIGINAL LINE: Case Entities.Tabs.TabType.File
			if (tabType == Entities.Tabs.TabType.File)
			{
					return "F";
			}
//ORIGINAL LINE: Case Entities.Tabs.TabType.Member
			else if (tabType == Entities.Tabs.TabType.Member)
			{
					return "M";
			}
//ORIGINAL LINE: Case Entities.Tabs.TabType.Normal, Entities.Tabs.TabType.Tab
			else if ((tabType == Entities.Tabs.TabType.Normal) || (tabType == Entities.Tabs.TabType.Tab))
			{
					return "T";
			}
//ORIGINAL LINE: Case Else
			else
			{
					return "U";
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="HandleRequest">
          <declaration><![CDATA[public override void HandleRequest()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="222" sc="3" el="367" ec="4">LinkClickUrlHandler.ashx.cs</location>
            <body hash="073bf8cf6d298c0215af853bfa58bef6"><![CDATA[{
			string output = null;
			DialogParams dialogParams = Content.FromJson<DialogParams>(); // This uses the new JSON Extensions in DotNetNuke.Common.Utilities.JsonExtensionsWeb

			string link = dialogParams.LinkUrl;
			dialogParams.LinkClickUrl = link;

			if (dialogParams != null)
			{

				if (! (dialogParams.LinkAction == "GetLinkInfo"))
				{
					if (dialogParams.Track)
					{
						string tempVar = dialogParams.LinkUrl;
						dialogParams.LinkClickUrl = GetLinkClickURL(ref dialogParams, ref tempVar);
						dialogParams.LinkUrl = tempVar;
						UrlTrackingInfo linkTrackingInfo = _urlController.GetUrlTracking(dialogParams.PortalId, dialogParams.LinkUrl, dialogParams.ModuleId);

						if (linkTrackingInfo != null)
						{
							dialogParams.Track = linkTrackingInfo.TrackClicks;
							dialogParams.TrackUser = linkTrackingInfo.LogActivity;
							dialogParams.DateCreated = linkTrackingInfo.CreatedDate.ToString();
							dialogParams.LastClick = linkTrackingInfo.LastClick.ToString();
							dialogParams.Clicks = linkTrackingInfo.Clicks.ToString();
						}
						else
						{
							dialogParams.Track = false;
							dialogParams.TrackUser = false;
						}
						dialogParams.LinkUrl = link;

					}
				}

				switch (dialogParams.LinkAction)
				{
					case "GetLoggingInfo": //also meant for the tracking tab but this is to retrieve the user information
						DateTime logStartDate = DateTime.MinValue;
						DateTime logEndDate = DateTime.MinValue;
						string logText = "<table><tr><th>Date</th><th>User</th></tr><tr><td colspan='2'>The selected date-range did<br /> not return any results.</td></tr>";

						if (DateTime.TryParse(dialogParams.LogStartDate, out logStartDate))
						{
							if (! (DateTime.TryParse(dialogParams.LogEndDate, out logEndDate)))
							{
								logEndDate = logStartDate.AddDays(1);
							}

							UrlController _urlController = new UrlController();
							ArrayList urlLog = _urlController.GetUrlLog(dialogParams.PortalId, GetLinkUrl(ref dialogParams, dialogParams.LinkUrl), dialogParams.ModuleId, logStartDate, logEndDate);

							if (urlLog != null)
							{
								logText = GetUrlLoggingInfo(urlLog);
							}

						}

						dialogParams.TrackingLog = logText;

						break;
					case "GetLinkInfo":
						if (dialogParams.Track)
						{
                            link = link.Replace(@"\", @"/");

							//this section is for when the user clicks ok in the dialog box, we actually create a record for the linkclick urls.
							if (! (dialogParams.LinkUrl.ToLower().Contains("linkclick.aspx")))
							{
								dialogParams.LinkClickUrl = GetLinkClickURL(ref dialogParams, ref link);
							}

							_urlController.UpdateUrl(dialogParams.PortalId, link, GetURLType(Globals.GetURLType(link)), dialogParams.TrackUser, true, dialogParams.ModuleId, false);

						}
						else
						{
							//this section is meant for retrieving/displaying the original links and determining if the links are being tracked(making sure the track checkbox properly checked)
							UrlTrackingInfo linkTrackingInfo = null;

							if (dialogParams.LinkUrl.Contains("fileticket"))
							{
								var queryString = dialogParams.LinkUrl.Split('=');
								var encryptedFileId = queryString[1].Split('&')[0];

								string fileID = UrlUtils.DecryptParameter(encryptedFileId, dialogParams.PortalGuid);
								FileInfo savedFile = _fileController.GetFileById(Int32.Parse(fileID), dialogParams.PortalId);

								linkTrackingInfo = _urlController.GetUrlTracking(dialogParams.PortalId, string.Format("fileID={0}", fileID), dialogParams.ModuleId);
								
							}
                            else if (dialogParams.LinkUrl.ToLowerInvariant().Contains("linkclick.aspx"))
                            {
                                try
								{
									if (dialogParams.LinkUrl.Contains("?"))
									{
										link = dialogParams.LinkUrl.Split('?')[1].Split('&')[0];
										if(link.Contains("="))
										{
											link = link.Split('=')[1];
										}
									}

								    int tabId;
								    if (int.TryParse(link, out tabId)) //if it's a tabid get the tab path
									{
                                        dialogParams.LinkClickUrl = TabController.Instance.GetTab(tabId, dialogParams.PortalId, true).FullUrl;
										linkTrackingInfo = _urlController.GetUrlTracking(dialogParams.PortalId, tabId.ToString(), dialogParams.ModuleId);
									}
									else
									{
										dialogParams.LinkClickUrl = HttpContext.Current.Server.UrlDecode(link); //get the actual link
										linkTrackingInfo = _urlController.GetUrlTracking(dialogParams.PortalId, dialogParams.LinkClickUrl, dialogParams.ModuleId);
									}

								}
								catch (Exception ex)
								{
								    Logger.Error(ex);
									dialogParams.LinkClickUrl = dialogParams.LinkUrl;
								}
                            }

						    if (linkTrackingInfo == null)
							{
								dialogParams.Track = false;
								dialogParams.TrackUser = false;
							}
							else
							{
								dialogParams.Track = linkTrackingInfo.TrackClicks;
								dialogParams.TrackUser = linkTrackingInfo.LogActivity;
							}

						}
						break;
				}
				output = dialogParams.ToJson();
			}

			Response.Write(output);
		}]]></body>
          </codeblock>
        </method>
        <method name="ValidateParameters">
          <declaration><![CDATA[public override bool ValidateParameters()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="380" sc="3" el="383" ec="4">LinkClickUrlHandler.ashx.cs</location>
            <body hash="33299de20ffb390c26a8eb6a47c729fd"><![CDATA[{
			//TODO: This should be updated to validate the Content paramater and return false if the content can't be converted to a DialogParams
			return true;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_fileController">
          <declaration><![CDATA[private FileController _fileController = new FileController();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_portalAliasController">
          <declaration><![CDATA[private IPortalAliasController _portalAliasController = ServiceLocator<IPortalAliasController, PortalAliasController>.Instance;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_urlController">
          <declaration><![CDATA[private UrlController _urlController = new UrlController();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Logger">
          <declaration><![CDATA[private static readonly ILog Logger = LoggerSource.Instance.GetLogger(typeof(LinkClickUrlHandler));]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="ContentMimeType">
          <declaration><![CDATA[public override string ContentMimeType]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="372" sc="4" el="376" ec="5">LinkClickUrlHandler.ashx.cs</location>
            <body hash="def5e0de5bafd07f5fa1a3a0716ca8b4"><![CDATA[{
				//Normally we could use the ContentEncoding property, but because of an IE bug we have to ensure
				//that the UTF-8 is capitalized which requires inclusion in the mimetype property as shown here
				return "application/json; charset=UTF-8";
			}]]></body>
          </codeblock>
        </property>
        <property name="HasPermission">
          <declaration><![CDATA[public override bool HasPermission]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="388" sc="4" el="391" ec="5">LinkClickUrlHandler.ashx.cs</location>
            <body hash="b06cadca705b3a7c7eed7fcc138aa813"><![CDATA[{
				//TODO: This should be updated to ensure the user has appropriate permissions for the passed in TabId.
				return Context.User.Identity.IsAuthenticated;
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="PageDropDownList">
      <declaration><![CDATA[public class PageDropDownList : RadComboBox]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public PageDropDownList()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="OnPreRender">
          <declaration><![CDATA[protected override void OnPreRender(EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="53" sc="3" el="99" ec="4">Components\PageDropDownList.cs</location>
            <body hash="2a8a40c2c518cbd8d9aa27b861ca3801"><![CDATA[{
			base.OnPreRender(e);

			Entities.Users.UserInfo userInfo = Entities.Users.UserController.Instance.GetCurrentUserInfo();
			if (! Page.IsPostBack && userInfo != null && userInfo.UserID != Null.NullInteger)
			{
				//check view permissions - Yes?
				var portalSettings = PortalController.Instance.GetCurrentPortalSettings();
			    var pageCulture = Thread.CurrentThread.CurrentCulture.Name;
				if (string.IsNullOrEmpty(pageCulture))
				{
                    pageCulture = PortalController.GetActivePortalLanguage(portalSettings.PortalId);
				}

                List<TabInfo> tabs = TabController.GetTabsBySortOrder(portalSettings.PortalId, pageCulture, true);
				var sortedTabList = TabController.GetPortalTabs(tabs, Null.NullInteger, false, Null.NullString, true, false, true, true, true);

				Items.Clear();
				foreach (var _tab in sortedTabList)
				{
					var linkUrl = string.Empty;
					switch (LinksType.ToUpperInvariant())
					{
						case "USETABNAME":
							var nameLinkFormat = "http://{0}/Default.aspx?TabName={1}";
							linkUrl = string.Format(nameLinkFormat, portalSettings.PortalAlias.HTTPAlias, HttpUtility.UrlEncode(_tab.TabName));
							break;
						case "USETABID":
							var idLinkFormat = "http://{0}/Default.aspx?TabId={1}";
							linkUrl = string.Format(idLinkFormat, portalSettings.PortalAlias.HTTPAlias, _tab.TabID);
							break;
						default:
							linkUrl = _tab.FullUrl;
							break;
					}
					RadComboBoxItem tabItem = new RadComboBoxItem(_tab.IndentedTabName, linkUrl);
					tabItem.Enabled = ! _tab.DisableLink;

					Items.Add(tabItem);
				}

				Items.Insert(0, new Telerik.Web.UI.RadComboBoxItem("", ""));
			}

			Width = Unit.Pixel(245);

		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="LinksType">
          <declaration><![CDATA[private string LinksType]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="43" sc="4" el="50" ec="5">Components\PageDropDownList.cs</location>
            <body hash="8fff7a75ac98976ceba3df415d0be273"><![CDATA[{
				if (HttpContext.Current.Request.QueryString["linkstype"] != null)
				{
					return HttpContext.Current.Request.QueryString["linkstype"];
				}

				return "Normal";
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ProviderConfig">
      <declaration><![CDATA[public class ProviderConfig : PortalModuleBase, IActionable]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ProviderConfig()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AddChildren">
          <declaration><![CDATA[private void AddChildren(ref RadTreeNode treenode)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1574" sc="3" el="1587" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="3841c3f68bcdd9e64f96a129896eb59f"><![CDATA[{
            var tabs = TabController.Instance.GetTabsByPortal(PortalSettings.PortalId);
			foreach (var objTab in tabs.Values)
			{
				if (objTab.ParentId == int.Parse(treenode.Value))
				{
					RadTreeNode node = new RadTreeNode();
					node.Text = objTab.TabName;
					node.Value = objTab.TabID.ToString();
					treenode.Nodes.Add(node);
					AddChildren(ref node);
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="BindConfigForm">
          <declaration><![CDATA[private void BindConfigForm()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1208" sc="3" el="1464" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="1678667d9bc4421da6b74ab13c63c40a"><![CDATA[{
			ArrayList foldersToShow = new ArrayList();

			ArrayList folders = new ArrayList();
			folders = DotNetNuke.Common.Utilities.FileSystemUtils.GetFoldersByUser(PortalSettings.PortalId, true, true, "READ");

			plhConfig.Controls.Clear();

			Panel pnlContent = new Panel();
			pnlContent.CssClass = "pcContent";

			HtmlGenericControl fsContent = null;
			int i = 0;

			foreach (ConfigInfo objConfig in DefaultConfig)
			{
				string key = objConfig.Key;
				string value = objConfig.Value;

				if (objConfig.IsSeparator)
				{
					if (i > 0)
					{
						// it's currently a separator, so if its not the first item it needs to close the previous 'feildset'
						pnlContent.Controls.Add(fsContent);
					}

					i += 1;

				    var localizedTitle = Localization.GetString(key + ".Title", LocalResourceFile);
                    if(string.IsNullOrEmpty(localizedTitle))
                    {
                        localizedTitle = key;
                    }

                    pnlContent.Controls.Add(new LiteralControl("<h2 id='Panel-ProviderConfig-" + i.ToString() + "' class='dnnFormSectionHead'><a class='dnnSectionExpanded' href=\"\">" + localizedTitle + "</a></h2>"));
					fsContent = new HtmlGenericControl("fieldset");
				}
				else
				{
					Panel pnlRow = new Panel(); // a row starts here and ends at the right before next, where it is added to the fieldset)
					pnlRow.CssClass = "dnnFormItem";
					pnlRow.Controls.Add(BuildLabel(key));

					switch (key.ToLower())
					{
						case "stripformattingoptions":
						{
							CheckBoxList ctl = new CheckBoxList();
							ctl.ID = "ctl_rc_" + key;
							ctl.RepeatColumns = 2;
							ctl.CssClass = "dnnCBItem";

							foreach (string objEnum in Enum.GetNames(typeof(Telerik.Web.UI.EditorStripFormattingOptions)))
							{
								if (objEnum != "All" && objEnum != "None")
								{
									ctl.Items.Add(new ListItem(objEnum, objEnum));
								}
							}

							pnlRow.Controls.Add(ctl);
							break;
						}
						case "toolbarmode":
						{
							RadioButtonList ctl = new RadioButtonList();
							ctl.ID = "ctl_rc_" + key;
							ctl.RepeatColumns = 2;
							ctl.CssClass = "dnnFormRadioButtons";

							foreach (string objEnum in Enum.GetNames(typeof(Telerik.Web.UI.EditorToolbarMode)))
							{
								ctl.Items.Add(new ListItem(objEnum, objEnum));
							}

							pnlRow.Controls.Add(ctl);
							break;
						}
						case "editmodes":
						{
							CheckBoxList ctl = new CheckBoxList();
							ctl.ID = "ctl_rc_" + key;
							ctl.RepeatColumns = 1;
							ctl.CssClass = "dnnCBItem";

							foreach (string objEnum in Enum.GetNames(typeof(Telerik.Web.UI.EditModes)))
							{
								if (objEnum != "All")
								{
									ctl.Items.Add(new ListItem(objEnum, objEnum));
								}
							}

							pnlRow.Controls.Add(ctl);
							break;
						}
						case "contentfilters":
						{
							CheckBoxList ctl = new CheckBoxList();
							ctl.ID = "ctl_rc_" + key;
							ctl.RepeatColumns = 2;
							ctl.CssClass = "dnnCBItem";

							foreach (string objEnum in Enum.GetNames(typeof(Telerik.Web.UI.EditorFilters)))
							{
								if (objEnum != "None" && objEnum != "DefaultFilters")
								{
									ctl.Items.Add(new ListItem(objEnum, objEnum));
								}
							}

							pnlRow.Controls.Add(ctl);
							break;
						}
						case "imagespath":
						case "mediapath":
						case "documentspath":
						case "flashpath":
						case "silverlightpath":
						case "templatepath":
						{
							DnnComboBox ctl = new DnnComboBox();
							ctl.ID = "ctl_rc_" + key;
							//ctl.Width = Unit.Pixel(253)
							ctl.Items.Clear();

							foreach (FolderInfo oFolder in folders)
							{
								if (! (oFolder.FolderPath.ToLower().StartsWith("cache")))
								{
									if (oFolder.FolderPath == "")
									{
										ctl.AddItem(Localization.GetString("PortalRoot", LocalResourceFile), "/");

										ctl.AddItem(Localization.GetString("UserFolder", LocalResourceFile), "[UserFolder]");
									}
									else
									{
										ctl.AddItem(oFolder.FolderPath, oFolder.FolderPath);
									}
								}
							}

							pnlRow.Controls.Add(ctl);
							break;
						}
						case "skin":
						{
							DnnComboBox ctl = new DnnComboBox();
							ctl.ID = "ctl_rc_" + key;
							ctl.AddItem("Default", "Default");
                            ctl.AddItem("Black", "Black");
                            ctl.AddItem("Sunset", "Sunset");
                            ctl.AddItem("Hay", "Hay");
                            ctl.AddItem("Forest", "Forest");
                            ctl.AddItem("Vista", "Vista");

							pnlRow.Controls.Add(ctl);
							break;
						}
						case "linkstype":
						{
							DnnComboBox ctl = new DnnComboBox();
							ctl.ID = "ctl_rc_" + key;
							ctl.AddItem(LocalizeString("LinksType_Normal"), "Normal");
							ctl.AddItem(LocalizeString("LinksType_UseTabName"), "UseTabName");
							ctl.AddItem(LocalizeString("LinksType_UseTabId"), "UseTabId");

							pnlRow.Controls.Add(ctl);
						}
							break;
						case "enableresize":
						case "allowscripts":
						case "showportallinks":
						case "autoresizeheight":
						case "linksuserelativeurls":
						case "newlinebr":
						{
							CheckBox ctl = new CheckBox();
							ctl.ID = "ctl_rc_" + key;
							ctl.CssClass = "dnnCBItem";

							pnlRow.Controls.Add(ctl);
							break;
						}
						case "borderwidth":
						case "height":
						case "width":
						case "toolswidth":
						{
						    TextBox ctl = new TextBox();
						    ctl.Text = "5";
						    ctl.CssClass = "SpinnerStepOne";
                            ctl.ID = "ctl_rc_" + key;
                            pnlRow.Controls.Add(ctl);
							break;
						}
						case "maxflashsize":
						case "maxsilverlightsize":
						case "maxtemplatesize":
						case "maximagesize":
						case "maxdocumentsize":
						case "maxmediasize":
						{
						    TextBox ctl = new TextBox();
						    ctl.Text = "1024";
						    ctl.CssClass = "SpinnerStep1024";
                            ctl.ID = "ctl_rc_" + key;
                            pnlRow.Controls.Add(ctl);
							break;
						}
						case "contentareamode":
						{
							DnnComboBox ctl = new DnnComboBox();
							ctl.ID = "ctl_rc_" + key;

							foreach (string name in Enum.GetNames(typeof(EditorContentAreaMode)))
							{
								if (name != "All")
								{
									ctl.AddItem(name, name);
								}
							}

							pnlRow.Controls.Add(ctl);
							break;
						}
                        case "language":
					    {
					        var ctl = new DnnLanguageComboBox();
					        ctl.ID = "ctl_rc_" + key;
                            ctl.LanguagesListType = LanguagesListType.All;
					        ctl.IncludeNoneSpecified = true;
					        ctl.CssClass = "languageComboBox";
                            pnlRow.Controls.Add(ctl);
					        break;
					    }
					    default:
						{
							TextBox ctl = new TextBox();
							ctl.ID = "ctl_rc_" + key;
							ctl.Text = value;

							pnlRow.Controls.Add(ctl);
							break;
						}
					}

					fsContent.Controls.Add(pnlRow);
				}
			}

			pnlContent.Controls.Add(fsContent);

			plhConfig.Controls.Add(pnlContent);
		}]]></body>
          </codeblock>
        </method>
        <method name="BindCurrentEditor">
          <declaration><![CDATA[private void BindCurrentEditor()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="391" sc="3" el="400" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="222708187f5f5f95af351921bd5f45ff"><![CDATA[{
			string editorType = GetSelectedEditor();
			editorState.Text = editorType;

			//Me.pnlTabContent.Visible = (editorType = radEditorProviderName)

			//If editorType = radEditorProviderName Then
			//    pnlTabContent.Visible = True
			//End If
		}]]></body>
          </codeblock>
        </method>
        <method name="BindEditorList">
          <declaration><![CDATA[private void BindEditorList()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="403" sc="3" el="416" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="34390763c7967afd56f177293ebef69e"><![CDATA[{
			editorList.DataSource = GetEditorsList();
			editorList.DataBind();

			string current = GetSelectedEditor();
			var item = editorList.FindItemByText(current);
			if (item != null)
			{
				editorList.SelectedIndex = -1;
				item.Selected = true;
			}

            MessagePanel.Visible = GetSelectedEditor() != radEditorProviderName;
		}]]></body>
          </codeblock>
        </method>
        <method name="BindFile">
          <declaration><![CDATA[private void BindFile()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1483" sc="3" el="1538" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="b9e49d4a3a819e2f953b2c425223dcbf"><![CDATA[{
			//ulActions.Visible = True
			this.pnlEditor.Visible = true;
			this.pnlForm.Visible = false;

			string configpath = this.treeTools.SelectedNode.Value;
			string toolspath = configpath.ToLower().Replace("config", "tools");

			try
			{
				this.treePages.FindNodeByValue(configpath).ExpandParentNodes();
				this.treePages.FindNodeByValue(configpath).Selected = true;
			}
			catch
			{
			}

			if (File.Exists(configpath))
			{
				BindSelectedConfig(configpath);
				ViewState["EditorConfigPath"] = configpath;

				cmdUpdate.Enabled = (! (configpath.ToLower().EndsWith("configfile.xml.original.xml")));
				cmdCreate.Enabled = true;
				cmdDelete.Enabled = (! (configpath.ToLower().EndsWith("configfile.xml.original.xml")) && ! (configpath.ToLower().EndsWith("configfile.xml")));

				if (File.Exists(toolspath))
				{
					StreamReader tr = new StreamReader(toolspath);
					this.txtTools.Text = tr.ReadToEnd();
					tr.Close();
					tr.Dispose();
				}
				else
				{
					//load default toolsfile
					string orgPath = Server.MapPath(this.TemplateSourceDirectory + "/ToolsFile/ToolsFile.xml.Original.xml");
					if (File.Exists(orgPath))
					{
						File.Copy(orgPath, toolspath);
					}

					if (File.Exists(toolspath))
					{
						StreamReader tr = new StreamReader(toolspath);
						this.txtTools.Text = tr.ReadToEnd();
						tr.Close();
						tr.Dispose();
					}
					else
					{
						this.txtTools.Text = "Could not load tools file...";
					}
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="BindRoles">
          <declaration><![CDATA[private void BindRoles()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="419" sc="6" el="438" ec="7">ProviderConfig.ascx.cs</location>
            <body hash="b3e569aa8e368700f1332f4faff1ff4c"><![CDATA[{
            var roles = RoleController.Instance.GetRoles(PortalId, 
                                                            r => r.SecurityMode != SecurityMode.SocialGroup 
                                                                && r.Status == RoleStatus.Approved);

            roles.Insert(0, new RoleInfo { 
                                        RoleID = int.Parse(Globals.glbRoleAllUsers), 
                                        RoleName = Globals.glbRoleAllUsersName 
                                   });
            roles.Insert(1, new RoleInfo
            {
                RoleID = int.Parse(Globals.glbRoleSuperUser),
                RoleName = Globals.glbRoleSuperUserName
            });

            rblMode.DataSource = roles;
	        rblMode.DataTextField = "RoleName";
	        rblMode.DataValueField = "RoleId";
            rblMode.DataBind();
	    }]]></body>
          </codeblock>
        </method>
        <method name="BindSelectedConfig">
          <declaration><![CDATA[private void BindSelectedConfig(string strPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="812" sc="3" el="1137" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="afd39c2b5e33acb3484e36f63e66807a"><![CDATA[{
			string strCompare = treeTools.SelectedNode.Value.ToLower();
			string strValue = strPath.ToLower();

			if (strValue == strCompare)
			{
				List<ConfigInfo> currentconfig = new List<ConfigInfo>();

				XmlDocument xmlConfig = new XmlDocument();
				xmlConfig.Load(strPath);

				XmlNode rootNode = xmlConfig.DocumentElement.SelectSingleNode("/configuration");
				if (rootNode != null)
				{

					string key = Null.NullString;
					string setting = Null.NullString;

					foreach (XmlNode childnode in rootNode.ChildNodes)
					{
						key = childnode.Attributes["name"].Value;

						if (childnode.HasChildNodes)
						{
							if (childnode.ChildNodes.Count == 1)
							{
								if (childnode.ChildNodes[0].NodeType == XmlNodeType.Text)
								{
									setting = childnode.InnerText;
								}
								else if (childnode.ChildNodes[0].NodeType == XmlNodeType.Element)
								{
									setting = childnode.ChildNodes[0].InnerText;
								}
							}
							else
							{
								string strSetting = "";
								foreach (XmlNode itemnode in childnode.ChildNodes)
								{
									strSetting += itemnode.InnerText + ";";
								}
								setting = strSetting;
							}
						}

						if (setting.EndsWith(";"))
						{
							setting = setting.Substring(0, setting.Length - 1);
						}

						currentconfig.Add(new ConfigInfo(key, setting, false));

						key = "";
						setting = "";
					}

					foreach (ConfigInfo objConfig in currentconfig)
					{
						switch (objConfig.Key.ToLower())
						{
							case "stripformattingoptions":
							case "contentfilters":
							{
								CheckBoxList ctl = (CheckBoxList)(FindControlRecursive(plhConfig, "ctl_rc_" + objConfig.Key));

								if (ctl != null)
								{
									try
									{
										ctl.ClearSelection();
										if (objConfig.Value.Contains(","))
										{
											foreach (string strSetting in objConfig.Value.Split(char.Parse(",")))
											{
												foreach (ListItem item in ctl.Items)
												{
													if (item.Value.ToLower() == strSetting.ToLower())
													{
														item.Selected = true;
														break;
													}
												}
											}
										}
										else
										{
											if (objConfig.Value.ToLower() == "all" || objConfig.Value.ToLower() == "defaultfilters")
											{
												foreach (ListItem item in ctl.Items)
												{
													item.Selected = true;
												}
											}
											else if (objConfig.Value.ToLower() == "none")
											{
												foreach (ListItem item in ctl.Items)
												{
													item.Selected = false;
												}
											}
											else
											{
												foreach (ListItem item in ctl.Items)
												{
													if (item.Value.ToLower() == objConfig.Value.ToLower())
													{
														item.Selected = true;
														break;
													}
												}
											}
										}
									}
									catch
									{
									}
								}

								break;
							}
							case "toolbarmode":
							{
								RadioButtonList ctl = (RadioButtonList)(FindControlRecursive(plhConfig, "ctl_rc_" + objConfig.Key));

								if (ctl != null)
								{
									try
									{
										ctl.SelectedValue = objConfig.Value;
									}
									catch
									{
									}
								}
								break;
							}
							case "editmodes":
							{
								CheckBoxList ctl = (CheckBoxList)(FindControlRecursive(plhConfig, "ctl_rc_" + objConfig.Key));

								if (ctl != null)
								{
									try
									{
										ctl.ClearSelection();
										if (objConfig.Value.Contains(","))
										{
											foreach (string strSetting in objConfig.Value.Split(char.Parse(",")))
											{
												foreach (ListItem item in ctl.Items)
												{
													if (item.Value.ToLower() == strSetting.ToLower())
													{
														item.Selected = true;
														break;
													}
												}
											}
										}
										else
										{
											if (objConfig.Value.ToLower() == "all")
											{
												foreach (ListItem item in ctl.Items)
												{
													item.Selected = true;
												}
											}
											else
											{
												foreach (ListItem item in ctl.Items)
												{
													if (item.Value.ToLower() == objConfig.Value.ToLower())
													{
														item.Selected = true;
														break;
													}
												}
											}
										}
									}
									catch
									{
									}
								}
								break;
							}
							case "imagespath":
							case "mediapath":
							case "documentspath":
							case "flashpath":
							case "silverlightpath":
							case "templatepath":
							{
								DnnComboBox ctl = (DnnComboBox)(FindControlRecursive(plhConfig, "ctl_rc_" + objConfig.Key));

								if (ctl != null)
								{
									try
									{
										ctl.SelectedValue = objConfig.Value;
									}
									catch
									{
									}
								}
								break;
							}
							case "skin":
							case "contentareamode":
							{
								DnnComboBox ctl = (DnnComboBox)(FindControlRecursive(plhConfig, "ctl_rc_" + objConfig.Key));

								if (ctl != null)
								{
									try
									{
										ctl.SelectedValue = objConfig.Value;
									}
									catch
									{
									}
								}
								break;
							}
							case "borderwidth":
							case "maxflashsize":
							case "height":
							case "maxsilverlightsize":
							case "maxtemplatesize":
							case "maximagesize":
							case "width":
							case "maxdocumentsize":
							case "maxmediasize":
							case "toolswidth":
							{
								TextBox ctl = (TextBox)(FindControlRecursive(plhConfig, "ctl_rc_" + objConfig.Key));

								if (ctl != null)
								{
									try
									{
										ctl.Text = Convert.ToInt32(objConfig.Value.Replace("px", "")).ToString();
									}
									catch
									{
									}
								}
								break;
							}
							case "linkstype":
							{
								var ctl = (DnnComboBox) (FindControlRecursive(plhConfig, "ctl_rc_" + objConfig.Key));

								if (ctl != null)
								{
									try
									{
										ctl.SelectedValue = objConfig.Value;
									}
									catch
									{
									}
								}
							}
								break;
							case "enableresize":
							case "allowscripts":
							case "showportallinks":
							case "autoresizeheight":
							case "linksuserelativeurls":
							case "newlinebr":
							{
								CheckBox ctl = (CheckBox)(FindControlRecursive(plhConfig, "ctl_rc_" + objConfig.Key));

								if (ctl != null)
								{
									try
									{
										ctl.Checked = bool.Parse(objConfig.Value);
									}
									catch
									{
									}
								}
								break;
							}
                            case "language":
						    {
                                var ctl = (DnnLanguageComboBox)(FindControlRecursive(plhConfig, "ctl_rc_" + objConfig.Key));

                                if (ctl != null)
                                {
                                    try
                                    {
                                        ctl.BindData(true);
                                        ctl.SetLanguage(objConfig.Value);
                                    }
                                    catch
                                    {
                                    }
                                }
						        break;
						    }
						    default:
							{
								TextBox ctl = (TextBox)(FindControlRecursive(plhConfig, "ctl_rc_" + objConfig.Key));

								if (ctl != null)
								{
									try
									{
										ctl.Text = objConfig.Value;
									}
									catch
									{
									}
								}
								break;
							}
						}
					}
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="btnEnable_Click">
          <declaration><![CDATA[protected void btnEnable_Click(object sender, EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="298" sc="3" el="310" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="ae59d850ccea331b1ea52b4724aab958"><![CDATA[{
			switch (editorList.SelectedValue)
			{
				case radEditorProviderName:
					EnableRadEditor();
					break;
				default:
					EnableOtherEditor(editorList.SelectedValue);
					break;
			}

            MessagePanel.Visible = GetSelectedEditor() != radEditorProviderName;
		}]]></body>
          </codeblock>
        </method>
        <method name="BuildLabel">
          <declaration><![CDATA[private PropertyLabelControl BuildLabel(string resourceKey)]]></declaration>
          <documentation>
            <summary>
 This method will build a dnn property label (Same as used in the user profile edit area) that can be added to a control.
 </summary>
 <param name="resourceKey"></param>
 <returns></returns>
 <remarks></remarks></documentation>
          <codeblock>
            <location sl="1473" sc="3" el="1480" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="59a8b831f4c3d4c9e6a495818c6e9cdf"><![CDATA[{
			var propLabel = new PropertyLabelControl();
			propLabel.ID = resourceKey + "_Label";
			propLabel.ShowHelp = true;
			propLabel.ResourceKey = resourceKey;

			return propLabel;
		}]]></body>
          </codeblock>
        </method>
        <method name="chkPortal_CheckedChanged">
          <declaration><![CDATA[protected void chkPortal_CheckedChanged(object sender, EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="293" sc="3" el="295" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="45604db87b839ef27eb087ea7b5531e2"><![CDATA[{
			divTabs.Visible = (chkPortal.Checked == false);
		}]]></body>
          </codeblock>
        </method>
        <method name="cmdCreate_Click">
          <declaration><![CDATA[private void cmdCreate_Click(object sender, EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="242" sc="3" el="290" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="b534efc142906085b52bb955495be038"><![CDATA[{
			string orgConfigPath = this.treeTools.SelectedNode.Value;
			string orgToolsPath = orgConfigPath.ToLower().Replace("config", "tools");

			string newConfigPath = Server.MapPath(this.TemplateSourceDirectory) + "\\ConfigFile\\ConfigFile";
			string newToolsPath = Server.MapPath(this.TemplateSourceDirectory) + "\\ToolsFile\\ToolsFile";

			if ( !string.IsNullOrEmpty(rblMode.SelectedValue) && rblMode.SelectedValue != Globals.glbRoleAllUsers)
			{
				newConfigPath += ".RoleId." + rblMode.SelectedValue;
				newToolsPath += ".RoleId." + rblMode.SelectedValue;
			}

			if (chkPortal.Checked)
			{
				newConfigPath += ".PortalId." + PortalSettings.PortalId.ToString();
				newToolsPath += ".PortalId." + PortalSettings.PortalId.ToString();
			}
			else
			{
				if (treePages.SelectedNode != null)
				{
					newConfigPath += ".TabId." + treePages.SelectedNode.Value;
					newToolsPath += ".TabId." + treePages.SelectedNode.Value;
				}
			}

			newConfigPath += ".xml";
			newToolsPath += ".xml";

			if (! (System.IO.File.Exists(newConfigPath)))
			{
				System.IO.File.Copy(orgConfigPath, newConfigPath, true);
			}

			if (! (System.IO.File.Exists(newToolsPath)))
			{
				System.IO.File.Copy(orgToolsPath, newToolsPath, true);
			}

			//reload tree    
			LoadConfiguration();

			//select new config
			this.treeTools.FindNodeByValue(newConfigPath).Selected = true;

			//re-bind new config
			BindFile();
		}]]></body>
          </codeblock>
        </method>
        <method name="DisableRadEditor">
          <declaration><![CDATA[private void DisableRadEditor()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="371" sc="3" el="388" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="2f96fab1451ecbb0796bc73cee39d5c7"><![CDATA[{
			XmlDocument xmlConfig = DNNConfig;

			if (xmlConfig != null && xmlConfig.DocumentElement != null)
			{
				XmlNode editorProviderNode = xmlConfig.DocumentElement.SelectSingleNode(htmlEditorNode);
				//check if already added and if not, add definition
				XmlNode radNode = editorProviderNode.SelectSingleNode("providers/add[@name='" + radEditorProviderName + "']");
				if (radNode != null)
				{
					radNode.ParentNode.RemoveChild(radNode);
				}

				Config.Save(xmlConfig);

				BindCurrentEditor();
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="EnableOtherEditor">
          <declaration><![CDATA[private void EnableOtherEditor(string name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="315" sc="3" el="336" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="d848fb6b8380a50d80a09f53f1e4e33e"><![CDATA[{
			XmlDocument xmlConfig = DNNConfig;

			if (xmlConfig != null && xmlConfig.DocumentElement != null)
			{

				XmlNode editorProviderNode = xmlConfig.DocumentElement.SelectSingleNode(htmlEditorNode);
				editorProviderNode.Attributes["defaultProvider"].Value = name;
				editorState.Text = name;

				XmlNode radNode = editorProviderNode.SelectSingleNode("providers/add[@name='" + radEditorProviderName + "']");
				if (radNode != null)
				{
					radNode.ParentNode.RemoveChild(radNode);
				}

				Config.Save(xmlConfig);

				BindCurrentEditor();

			}
		}]]></body>
          </codeblock>
        </method>
        <method name="EnableRadEditor">
          <declaration><![CDATA[private void EnableRadEditor()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="339" sc="3" el="368" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="9247f2ecb5cb607f34839956525845f1"><![CDATA[{
			XmlDocument xmlConfig = DNNConfig;

			if (xmlConfig != null && xmlConfig.DocumentElement != null)
			{
				XmlNode editorProviderNode = xmlConfig.DocumentElement.SelectSingleNode(htmlEditorNode);
				editorProviderNode.Attributes["defaultProvider"].Value = radEditorProviderName;
				//check if already added and if not, add definition
				XmlNode radNode = editorProviderNode.SelectSingleNode("providers/add[@name='" + radEditorProviderName + "']");
				if (radNode == null)
				{
					radNode = xmlConfig.CreateElement("add");
					XmlAttribute xmlAttr = xmlConfig.CreateAttribute("name");
					xmlAttr.Value = radEditorProviderName;
					radNode.Attributes.Append(xmlAttr);
					xmlAttr = xmlConfig.CreateAttribute("type");
					xmlAttr.Value = "DotNetNuke.Providers.RadEditorProvider.EditorProvider, DotNetNuke.RadEditorProvider";
					radNode.Attributes.Append(xmlAttr);
					xmlAttr = xmlConfig.CreateAttribute("providerPath");
					xmlAttr.Value = "~/DesktopModules/Admin/RadEditorProvider";
					radNode.Attributes.Append(xmlAttr);
					editorProviderNode.SelectSingleNode("providers").AppendChild(radNode);
				}

				Config.Save(xmlConfig);

				BindCurrentEditor();

			}
		}]]></body>
          </codeblock>
        </method>
        <method name="FindControlRecursive">
          <declaration><![CDATA[protected System.Web.UI.Control FindControlRecursive(System.Web.UI.Control objRoot, string id)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1541" sc="3" el="1555" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="4fe3b4a07ff5ea358f0406b361ee6a1b"><![CDATA[{
			if (objRoot.ID == id)
			{
				return objRoot;
			}
			foreach (Control c in objRoot.Controls)
			{
				Control t = FindControlRecursive(c, id);
				if (t != null)
				{
					return t;
				}
			}
			return null;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetEditorsList">
          <declaration><![CDATA[private List<string> GetEditorsList()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="441" sc="3" el="468" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="aef1c46ae4fe9711cc9a4ff4e39cd18b"><![CDATA[{
			List<string> editors = new List<string>();
			XmlDocument xmlConfig = DNNConfig;
			if (xmlConfig != null && xmlConfig.DocumentElement != null)
			{
				XmlNodeList editorNodes = xmlConfig.DocumentElement.SelectNodes(htmlEditorNode + "/providers/add");
				if (editorNodes != null)
				{
					int i = 0;
					while (i < editorNodes.Count)
					{
						XmlNode node = editorNodes[i];
						if (node.Attributes["name"] != null)
						{
							editors.Add(node.Attributes["name"].Value);
						}
						i = i + 1;
					}
				}
			}

			if (! (editors.Contains(radEditorProviderName)))
			{
				editors.Add(radEditorProviderName);
			}

			return editors;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetSelectedEditor">
          <declaration><![CDATA[private string GetSelectedEditor()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="471" sc="3" el="481" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="44214a4be7a76d37f97572e4ce13b458"><![CDATA[{
			XmlDocument xmlConfig = DNNConfig;

			if (xmlConfig != null && xmlConfig.DocumentElement != null)
			{
				XmlNode editorProviderNode = xmlConfig.DocumentElement.SelectSingleNode(htmlEditorNode);
				return editorProviderNode.Attributes["defaultProvider"].Value;
			}

			return "";
		}]]></body>
          </codeblock>
        </method>
        <method name="InitializeDefaultConfig">
          <declaration><![CDATA[private List<ConfigInfo> InitializeDefaultConfig()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1140" sc="3" el="1205" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="8af2d64aaafb6e5db52647bb6f8d312e"><![CDATA[{
			string strPath = Server.MapPath(this.TemplateSourceDirectory + "/ConfigFile/configfile.xml.original.xml");

			List<ConfigInfo> config = new List<ConfigInfo>();

			XmlDocument xmlConfig = new XmlDocument();
			xmlConfig.Load(strPath);

			XmlNode rootNode = xmlConfig.DocumentElement.SelectSingleNode("/configuration");
			if (rootNode != null)
			{

				string key = Null.NullString;
				string setting = Null.NullString;

				foreach (XmlNode childnode in rootNode.ChildNodes)
				{

					key = childnode.Attributes["name"].Value;

					if (childnode.HasChildNodes)
					{
						if (childnode.ChildNodes.Count == 1)
						{
							if (childnode.ChildNodes[0].NodeType == XmlNodeType.Text)
							{
								setting = childnode.InnerText;
							}
							else if (childnode.ChildNodes[0].NodeType == XmlNodeType.Element)
							{
								setting = childnode.ChildNodes[0].InnerText;
							}
						}
						else
						{
							string strSetting = "";
							foreach (XmlNode itemnode in childnode.ChildNodes)
							{
								strSetting += itemnode.InnerText + ";";
							}
							setting = strSetting;
						}
					}

					if (setting.EndsWith(";"))
					{
						setting = setting.Substring(0, setting.Length - 1);
					}

					if (childnode.Attributes["IsSeparator"] != null)
					{
						config.Add(new ConfigInfo(key, "", true));
					}
					else
					{
						config.Add(new ConfigInfo(key, setting, false));
					}

					key = "";
					setting = "";
				}

			}

			return config;
		}]]></body>
          </codeblock>
        </method>
        <method name="LoadConfiguration">
          <declaration><![CDATA[private void LoadConfiguration()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1590" sc="3" el="1695" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="9ef45726c2828f5bc93780f2af2c5e92"><![CDATA[{
			this.treeTools.Nodes.Clear();

			pnlEditor.Visible = false;
			pnlForm.Visible = false;

			var rootnode = new RadTreeNode("Default Configuration");
			rootnode.Expanded = true;

            EditorProvider.EnsureDefaultConfigFileExists();
            EditorProvider.EnsurecDefaultToolsFileExists();

			foreach (string file in Directory.GetFiles(Server.MapPath(this.TemplateSourceDirectory + "/ConfigFile")))
			{
				if (file.ToLower().EndsWith("configfile.xml.original.xml"))
				{
                    rootnode.Value = file;
				}
				else
				{
					//fix for codeplex issue #187
					bool blnAddNode = true;

					string nodename = file.Substring(file.LastIndexOf("\\") + 1).Replace(".xml", "").ToLowerInvariant();
					if (nodename.StartsWith("configfile") && file.EndsWith(".xml"))
					{

						string nodeTitle = "Everyone";

						string strTargetGroup = nodename.Replace("configfile.", "");
						string strTargetTab = "";

						if (strTargetGroup.Length > 0)
						{
						    var roleMatch = Regex.Match(strTargetGroup, "^RoleId\\.([-\\d]+)", RegexOptions.IgnoreCase);
							if (roleMatch.Success)
							{
							    var roleId = roleMatch.Groups[1].Value;
                                rblMode.SelectedValue = roleId;
							    strTargetTab = strTargetGroup.Replace(roleMatch.Value + ".", string.Empty);
							    var role = RoleController.Instance.GetRoleById(PortalId, Convert.ToInt32(roleId));
							    if (role != null)
							    {
							        nodeTitle = role.RoleName;
							    }
							    else
							    {
							        blnAddNode = false; //do not show the node if the role is not in current portal, or the role is not valid any more(such as deleted).
							    }
							}
						}

						if (strTargetTab.Length > 0)
						{
							if (SimulateIsNumeric.IsNumeric(strTargetTab.ToLower().Replace("tabid.", "")))
							{
								try
								{
                                    TabInfo t = TabController.Instance.GetTab(Convert.ToInt32(strTargetTab.ToLower().Replace("tabid.", "")), PortalSettings.PortalId, false);
									if (t != null)
									{
										if (t.PortalID != PortalSettings.PortalId)
										{
											//fix for codeplex issue #187
											blnAddNode = false;
										}
										nodeTitle += " (Page \"" + t.TabName + "\" only)";
									}
								}
								catch
								{
								}
							}
							if (SimulateIsNumeric.IsNumeric(strTargetTab.ToLower().Replace("portalid.", "")))
							{
								try
								{
                                    PortalInfo p = PortalController.Instance.GetPortal(Convert.ToInt32(strTargetTab.ToLower().Replace("portalid.", "")));
									if (p != null)
									{
										if (p.PortalID != PortalSettings.PortalId)
										{
											//fix for codeplex issue #187
											blnAddNode = false;
										}
										nodeTitle += " (Current Portal only)";
									}
								}
								catch
								{
								}
							}
						}

						if (blnAddNode)
						{
							rootnode.Nodes.Add(new RadTreeNode(nodeTitle, file));
						}

					}

				}
			}

			this.treeTools.Nodes.Add(rootnode);
		}]]></body>
          </codeblock>
        </method>
        <method name="LoadPages">
          <declaration><![CDATA[private void LoadPages()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1558" sc="3" el="1571" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="be963c837851c40056c3a1cf8236467b"><![CDATA[{
			treePages.Nodes.Clear();

            var tabs = TabController.Instance.GetTabsByPortal(PortalSettings.PortalId);
			foreach (var oTab in tabs.Values)
			{
				if (oTab.Level == 0)
				{
					var node = new RadTreeNode {Text = oTab.TabName, Value = oTab.TabID.ToString()};
				    treePages.Nodes.Add(node);
					AddChildren(ref node);
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="OnCancelClick">
          <declaration><![CDATA[protected void OnCancelClick(object sender, EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="196" sc="3" el="205" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="f50ea5127dcc2117fff1f86a561e21fa"><![CDATA[{
			pnlEditor.Visible = false;
			pnlForm.Visible = false;
			//ulActions.Visible = False

			LoadConfiguration();
			LoadPages();

			UI.Skins.Skin.AddModuleMessage(this, "All unsaved changes have been discarded.", UI.Skins.Controls.ModuleMessage.ModuleMessageType.BlueInfo);
		}]]></body>
          </codeblock>
        </method>
        <method name="OnCopyClick">
          <declaration><![CDATA[protected void OnCopyClick(object sender, EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="208" sc="3" el="222" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="a2746091b69ed90e783e39ac5302b2de"><![CDATA[{
			pnlEditor.Visible = false;
			pnlForm.Visible = true;
			this.cmdCreate.Visible = true;
			rblMode.SelectedIndex = 0;

		    if (treeTools.SelectedNode != null)
		    {
		        var role = RoleController.Instance.GetRoleByName(PortalId, treeTools.SelectedNode.Text);
		        if (role != null)
		        {
		            rblMode.SelectedValue = role.RoleID.ToString();
		        }
		    }
		}]]></body>
          </codeblock>
        </method>
        <method name="OnDeleteClick">
          <declaration><![CDATA[protected void OnDeleteClick(object sender, EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="225" sc="3" el="239" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="b6b153c214bcac3ec8e06b5da0e71741"><![CDATA[{
			string orgConfigPath = this.treeTools.SelectedNode.Value;
			string orgToolsPath = orgConfigPath.ToLower().Replace("config", "tools");

			if (! (orgConfigPath.ToLower().EndsWith("configfile.xml")))
			{
				System.IO.File.Delete(orgConfigPath);
				System.IO.File.Delete(orgToolsPath);
			}

			pnlEditor.Visible = false;
			pnlForm.Visible = false;
			LoadConfiguration();
			LoadPages();
		}]]></body>
          </codeblock>
        </method>
        <method name="OnInit">
          <declaration><![CDATA[protected override void OnInit(EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="104" sc="9" el="118" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="f264497b53f98927cdd027b896b8a7ae"><![CDATA[{
            base.OnInit(e);

            treeTools.NodeClick += treeTools_NodeClick;
            cmdUpdate.Click += OnUpdateClick;
            cmdCancel.Click += OnCancelClick;
            cmdCopy.Click += OnCopyClick;
            cmdDelete.Click += OnDeleteClick;
            cmdCreate.Click += cmdCreate_Click;
            chkPortal.CheckedChanged += chkPortal_CheckedChanged;
            btnEnable.Click += btnEnable_Click;
 
			Framework.AJAX.RegisterScriptManager();
			BindConfigForm();
		}]]></body>
          </codeblock>
        </method>
        <method name="OnLoad">
          <declaration><![CDATA[protected override void OnLoad(EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="121" sc="9" el="172" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="ce41d64b29610f90880623600b0ed6a9"><![CDATA[{
            base.OnLoad(e);

            try
            {
				//If Not ViewState("EditorConfigPath") Is Nothing Then
				//    Dim path As String = CType(ViewState("EditorConfigPath"), String)
				//    BindSelectedConfig(path)
				//End If

				this.pnlSelectProvider.Visible = false;

				if (Request.IsAuthenticated)
				{
					if (UserInfo.IsSuperUser)
					{

						this.pnlSelectProvider.Visible = true;
						// No reason to show purpose of module, inconsistent w/ rest of UI (in other modules, parts of core)
						//DotNetNuke.UI.Skins.Skin.AddModuleMessage(Me, Localization.GetString("lblNote", LocalResourceFile), Skins.Controls.ModuleMessage.ModuleMessageType.YellowWarning)

						if (! IsPostBack)
						{
							BindEditorList();
						    BindRoles();
						}

						BindCurrentEditor();

						if (! Page.IsPostBack)
						{
							LoadConfiguration();
							LoadPages();
						}

					}
					else
					{
						UI.Skins.Skin.AddModuleMessage(this, Localization.GetString("lblHostOnly", LocalResourceFile), UI.Skins.Controls.ModuleMessage.ModuleMessageType.RedError);
					}
				}
				else
				{
					UI.Skins.Skin.AddModuleMessage(this, Localization.GetString("lblNotAuthorized", LocalResourceFile), UI.Skins.Controls.ModuleMessage.ModuleMessageType.RedError);
				}

			}
			catch (Exception exc)
			{
				Exceptions.ProcessModuleLoadException(this, exc);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="OnUpdateClick">
          <declaration><![CDATA[protected void OnUpdateClick(object sender, EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="180" sc="3" el="193" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="d6be0f3cce2622c6084c1709f0166716"><![CDATA[{
			string orgConfigPath = this.treeTools.SelectedNode.Value;
			string orgToolsPath = orgConfigPath.ToLower().Replace("config", "tools");

			UpdateConfig(orgConfigPath);

			StreamWriter tw = File.CreateText(orgToolsPath);
			tw.Write(txtTools.Text);
			tw.Close();
			tw.Dispose();

			UI.Skins.Skin.AddModuleMessage(this, "The update was successful.", UI.Skins.Controls.ModuleMessage.ModuleMessageType.GreenSuccess);
			//BindFile()
		}]]></body>
          </codeblock>
        </method>
        <method name="treeTools_NodeClick">
          <declaration><![CDATA[protected void treeTools_NodeClick(object sender, RadTreeNodeEventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="175" sc="3" el="177" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="4cc2c6008ed87aa21b64dab44ea57272"><![CDATA[{
			BindFile();
		}]]></body>
          </codeblock>
        </method>
        <method name="UpdateConfig">
          <declaration><![CDATA[private void UpdateConfig(string strPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="484" sc="3" el="809" ec="4">ProviderConfig.ascx.cs</location>
            <body hash="ab0002e5be84b5464d8c41deb35fcc78"><![CDATA[{
			XmlDocument xmlConfig = new XmlDocument();
			xmlConfig.Load(strPath);

			XmlNode rootNode = xmlConfig.DocumentElement.SelectSingleNode("/configuration");
			string setting = Null.NullString;
			List<ConfigInfo> currentConfig = DefaultConfig;
		    var maxFileSize = 0;

			foreach (ConfigInfo objConfig in currentConfig)
			{

				if (objConfig.IsSeparator == false)
				{
					switch (objConfig.Key.ToLower())
					{
						case "stripformattingoptions":
						case "contentfilters":
						{
							CheckBoxList ctl = (CheckBoxList)(FindControlRecursive(plhConfig, "ctl_rc_" + objConfig.Key));

							if (ctl != null)
							{
								try
								{
									string strSetting = "";
									bool blnAllSelected = true;
									foreach (ListItem item in ctl.Items)
									{
										if (item.Selected)
										{
											strSetting += item.Value + ",";
										}
										else
										{
											blnAllSelected = false;
										}
									}
									if (blnAllSelected)
									{
										if (objConfig.Key.ToLower() == "stripformattingoptions")
										{
											strSetting = "All";
										}
										else
										{
											strSetting = "DefaultFilters";
										}
									}
									else
									{
										if (strSetting.EndsWith(","))
										{
											strSetting = strSetting.Substring(0, strSetting.Length - 1);
										}
										if (string.IsNullOrEmpty(strSetting))
										{
											strSetting = "None";
										}
									}

									setting = strSetting;

								}
								catch
								{
								}
							}
							break;
						}
						case "toolbarmode":
						{
							RadioButtonList ctl = (RadioButtonList)(FindControlRecursive(plhConfig, "ctl_rc_" + objConfig.Key));

							if (ctl != null)
							{
								try
								{
									setting = ctl.SelectedValue;
								}
								catch
								{
								}
							}
							break;
						}
						case "editmodes":
						{
							CheckBoxList ctl = (CheckBoxList)(FindControlRecursive(plhConfig, "ctl_rc_" + objConfig.Key));

							if (ctl != null)
							{
								try
								{
									string strSetting = "";
									bool blnAllSelected = true;
									foreach (ListItem item in ctl.Items)
									{
										if (item.Selected)
										{
											strSetting += item.Value + ",";
										}
										else
										{
											blnAllSelected = false;
										}
									}
									if (blnAllSelected)
									{
										strSetting = "All";
									}
									else
									{
										if (strSetting.EndsWith(","))
										{
											strSetting = strSetting.Substring(0, strSetting.Length - 1);
										}
										if (string.IsNullOrEmpty(strSetting))
										{
											strSetting = "All";
										}
									}

									setting = strSetting;

								}
								catch
								{
								}
							}
							break;
						}
						case "imagespath":
						case "mediapath":
						case "documentspath":
						case "flashpath":
						case "silverlightpath":
						case "templatepath":
						{
							DnnComboBox ctl = (DnnComboBox)(FindControlRecursive(plhConfig, "ctl_rc_" + objConfig.Key));

							if (ctl != null)
							{
								try
								{
									setting = ctl.SelectedValue;
								}
								catch
								{
								}
							}
							break;
						}
						case "skin":
						case "contentareamode":
						{
							DnnComboBox ctl = (DnnComboBox)(FindControlRecursive(plhConfig, "ctl_rc_" + objConfig.Key));

							if (ctl != null)
							{
								try
								{
									setting = ctl.SelectedValue;
								}
								catch
								{
								}
							}
							break;
						}
						case "borderwidth":
						case "maxflashsize":
						case "height":
						case "maxsilverlightsize":
						case "maxtemplatesize":
						case "maximagesize":
						case "width":
						case "maxdocumentsize":
						case "maxmediasize":
						case "toolswidth":
						{
							TextBox ctl = (TextBox)(FindControlRecursive(plhConfig, "ctl_rc_" + objConfig.Key));

							if (ctl != null)
							{
								try
								{
									setting = ctl.Text.Replace(".00", "").Replace(".0", "");

                                    if(objConfig.Key.ToLowerInvariant().EndsWith("size"))
                                    {
                                        var allowSize = Convert.ToInt32(ctl.Text);
                                        if(allowSize > maxFileSize)
                                        {
                                            maxFileSize = allowSize;
                                        }
                                    }
								}
								catch
								{
								}
							}
							break;
						}
						case "linkstype":
						{
							var ctl = (DnnComboBox) (FindControlRecursive(plhConfig, "ctl_rc_" + objConfig.Key));

							if (ctl != null)
							{
								try
								{
									setting = ctl.SelectedValue;
								}
								catch
								{
								}
							}
						}
							break;
						case "enableresize":
						case "allowscripts":
						case "showportallinks":
						case "autoresizeheight":
						case "linksuserelativeurls":
						case "newlinebr":
						{
							CheckBox ctl = (CheckBox)(FindControlRecursive(plhConfig, "ctl_rc_" + objConfig.Key));

							if (ctl != null)
							{
								try
								{
									setting = ctl.Checked.ToString();
								}
								catch
								{
								}
							}
							break;
						}
                        case "language":
                        {
                            var ctl = (DnnLanguageComboBox)(FindControlRecursive(plhConfig, "ctl_rc_" + objConfig.Key));

                            if (ctl != null)
                            {
                                try
                                {
                                    setting = ctl.SelectedValue;
                                }
                                catch
                                {
                                }
                            }
                            break;
                        }
						default:
						{
							TextBox ctl = (TextBox)(FindControlRecursive(plhConfig, "ctl_rc_" + objConfig.Key));

							if (ctl != null)
							{
								try
								{
									setting = ctl.Text;
								}
								catch
								{
								}
							}
							break;
						}
					}

					//look for setting node
					XmlNode configNode = rootNode.SelectSingleNode("property[@name='" + objConfig.Key + "']");
					if (configNode != null)
					{
						//node found, remove it
						rootNode.RemoveChild(configNode);
					}

					configNode = xmlConfig.CreateElement("property");
					XmlAttribute xmlAttr = xmlConfig.CreateAttribute("name");
					xmlAttr.Value = objConfig.Key;
					configNode.Attributes.Append(xmlAttr);

					XmlNode settingnode = null;
					if (setting.Contains(";"))
					{
						string[] newsettings = setting.Split(char.Parse(";"));
						foreach (string value in newsettings)
						{
							settingnode = xmlConfig.CreateElement("item");
							settingnode.InnerText = value;
							configNode.AppendChild(settingnode);
						}
					}
					else
					{
						settingnode = xmlConfig.CreateTextNode(setting);
						configNode.AppendChild(settingnode);
					}

					rootNode.AppendChild(configNode);

					setting = "";

				}
			}

			xmlConfig.Save(strPath);

            //update web.config to allow the max file size in http runtime section.
		    var configAllowSize = Config.GetMaxUploadSize();
            if(maxFileSize > configAllowSize)
            {
                var configNav = Config.Load();
                var httpNode = configNav.SelectSingleNode("configuration//system.web//httpRuntime");

                XmlUtils.UpdateAttribute(httpNode, "maxRequestLength", (maxFileSize / 1024).ToString());

                Config.Save(configNav);
            }
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_defaultconfig">
          <declaration><![CDATA[private List<ConfigInfo> _defaultconfig;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_dnnConfig">
          <declaration><![CDATA[private XmlDocument _dnnConfig;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="btnEnable">
          <declaration><![CDATA[protected System.Web.UI.WebControls.LinkButton btnEnable;]]></declaration>
          <documentation>
            <summary>
 btnEnable control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="chkPortal">
          <declaration><![CDATA[protected System.Web.UI.WebControls.CheckBox chkPortal;]]></declaration>
          <documentation>
            <summary>
 chkPortal control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="cmdCancel">
          <declaration><![CDATA[protected System.Web.UI.WebControls.LinkButton cmdCancel;]]></declaration>
          <documentation>
            <summary>
 cmdCancel control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="cmdCopy">
          <declaration><![CDATA[protected System.Web.UI.WebControls.LinkButton cmdCopy;]]></declaration>
          <documentation>
            <summary>
 cmdCopy control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="cmdCreate">
          <declaration><![CDATA[protected System.Web.UI.WebControls.LinkButton cmdCreate;]]></declaration>
          <documentation>
            <summary>
 cmdCreate control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="cmdDelete">
          <declaration><![CDATA[protected System.Web.UI.WebControls.LinkButton cmdDelete;]]></declaration>
          <documentation>
            <summary>
 cmdDelete control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="cmdUpdate">
          <declaration><![CDATA[protected System.Web.UI.WebControls.LinkButton cmdUpdate;]]></declaration>
          <documentation>
            <summary>
 cmdUpdate control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="divTabs">
          <declaration><![CDATA[protected System.Web.UI.HtmlControls.HtmlGenericControl divTabs;]]></declaration>
          <documentation>
            <summary>
 divTabs control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="dnnProviderConfig">
          <declaration><![CDATA[protected System.Web.UI.WebControls.Panel dnnProviderConfig;]]></declaration>
          <documentation>
            <summary>
 dnnProviderConfig control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="editorList">
          <declaration><![CDATA[protected DnnComboBox editorList;]]></declaration>
          <documentation>
            <summary>
 editorList control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="editorState">
          <declaration><![CDATA[protected System.Web.UI.WebControls.Label editorState;]]></declaration>
          <documentation>
            <summary>
 editorState control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="htmlEditorNode">
          <declaration><![CDATA[private const string htmlEditorNode = "/configuration/dotnetnuke/htmlEditor";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="lblMode">
          <declaration><![CDATA[protected System.Web.UI.UserControl lblMode;]]></declaration>
          <documentation>
            <summary>
 lblMode control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="lblPortal">
          <declaration><![CDATA[protected System.Web.UI.UserControl lblPortal;]]></declaration>
          <documentation>
            <summary>
 lblPortal control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="lblSelectedProvider">
          <declaration><![CDATA[protected System.Web.UI.WebControls.Label lblSelectedProvider;]]></declaration>
          <documentation>
            <summary>
 lblSelectedProvider control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="lblTabs">
          <declaration><![CDATA[protected System.Web.UI.UserControl lblTabs;]]></declaration>
          <documentation>
            <summary>
 lblTabs control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="MessagePanel">
          <declaration><![CDATA[protected System.Web.UI.WebControls.Panel MessagePanel;]]></declaration>
          <documentation>
            <summary>
 MessagePanel control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="plhConfig">
          <declaration><![CDATA[protected System.Web.UI.WebControls.PlaceHolder plhConfig;]]></declaration>
          <documentation>
            <summary>
 plhConfig control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="pnlEditor">
          <declaration><![CDATA[protected System.Web.UI.WebControls.Panel pnlEditor;]]></declaration>
          <documentation>
            <summary>
 pnlEditor control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="pnlForm">
          <declaration><![CDATA[protected System.Web.UI.WebControls.Panel pnlForm;]]></declaration>
          <documentation>
            <summary>
 pnlForm control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="pnlSelectProvider">
          <declaration><![CDATA[protected System.Web.UI.WebControls.Panel pnlSelectProvider;]]></declaration>
          <documentation>
            <summary>
 pnlSelectProvider control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="pnlTabContent">
          <declaration><![CDATA[protected System.Web.UI.WebControls.Panel pnlTabContent;]]></declaration>
          <documentation>
            <summary>
 pnlTabContent control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="radEditorProviderName">
          <declaration><![CDATA[private const string radEditorProviderName = "DotNetNuke.RadEditorProvider";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="rblMode">
          <declaration><![CDATA[protected System.Web.UI.WebControls.RadioButtonList rblMode;]]></declaration>
          <documentation>
            <summary>
 rblMode control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="spellCheckRootNodeIIS6">
          <declaration><![CDATA[private const string spellCheckRootNodeIIS6 = "/configuration/system.web";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="spellCheckRootNodeIIS7">
          <declaration><![CDATA[private const string spellCheckRootNodeIIS7 = "/configuration/system.webServer";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="treePages">
          <declaration><![CDATA[protected RadTreeView treePages;]]></declaration>
          <documentation>
            <summary>
 treePages control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="treeTools">
          <declaration><![CDATA[protected RadTreeView treeTools;]]></declaration>
          <documentation>
            <summary>
 treeTools control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="txtTools">
          <declaration><![CDATA[protected System.Web.UI.WebControls.TextBox txtTools;]]></declaration>
          <documentation>
            <summary>
 txtTools control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
      </fields>
      <properties>
        <property name="DefaultConfig">
          <declaration><![CDATA[protected List<ConfigInfo> DefaultConfig]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="69" sc="4" el="83" ec="5">ProviderConfig.ascx.cs</location>
            <body hash="c8204c38fed75a19c7ca2c4776d049cc"><![CDATA[{
				if (DotNetNuke.Common.Utilities.DataCache.GetCache("RAD_DEFAULT_CONFIG") != null)
				{
					_defaultconfig = (List<ConfigInfo>)(DotNetNuke.Common.Utilities.DataCache.GetCache("RAD_DEFAULT_CONFIG"));
				}

				if (_defaultconfig == null)
				{
					_defaultconfig = InitializeDefaultConfig();
					DotNetNuke.Common.Utilities.DataCache.SetCache("RAD_DEFAULT_CONFIG", _defaultconfig);
				}

				return _defaultconfig;

			}]]></body>
          </codeblock>
        </property>
        <property name="DNNConfig">
          <declaration><![CDATA[protected XmlDocument DNNConfig]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="89" sc="4" el="100" ec="5">ProviderConfig.ascx.cs</location>
            <body hash="48a2bb44c8400ed5b8abb4ae614979a4"><![CDATA[{
				if (_dnnConfig == null)
				{
					UserInfo currentUser = UserController.Instance.GetCurrentUserInfo();
					if (currentUser != null && currentUser.IsSuperUser)
					{
						_dnnConfig = Config.Load();
					}
				}

				return _dnnConfig;
			}]]></body>
          </codeblock>
        </property>
        <property name="ModuleActions">
          <declaration><![CDATA[public ModuleActionCollection ModuleActions]]></declaration>
          <documentation>-----------------------------------------------------------------------------
 <summary>
 Registers the module actions required for interfacing with the portal framework
 </summary>
 <value></value>
 <returns></returns>
 <remarks></remarks>
 <history>
 </history>
 -----------------------------------------------------------------------------</documentation>
          <codeblock>
            <location sl="1714" sc="4" el="1718" ec="5">ProviderConfig.ascx.cs</location>
            <body hash="dd32b59e0d97fd308cd57ae9faed10a3"><![CDATA[{
				Entities.Modules.Actions.ModuleActionCollection Actions = new Entities.Modules.Actions.ModuleActionCollection();
				//Actions.Add(GetNextActionID, Localization.GetString(Entities.Modules.Actions.ModuleActionType.AddContent, LocalResourceFile), Entities.Modules.Actions.ModuleActionType.AddContent, "", "", EditUrl(), False, Security.SecurityAccessLevel.Edit, True, False)
				return Actions;
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="RenderTemplate">
      <declaration><![CDATA[public class RenderTemplate : System.Web.UI.Page]]></declaration>
      <documentation>
        <summary>

 </summary>
 <remarks>
 </remarks>
 <history>
 </history></documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public RenderTemplate()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static RenderTemplate()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="43" sc="3" el="43" ec="98">Dialogs\RenderTemplate.aspx.cs</location>
            <body hash="035fffd71c010b88a3e9adc750b28d3e"><![CDATA[private static readonly ILog Logger = LoggerSource.Instance.GetLogger(typeof (RenderTemplate))]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CanViewFile">
          <declaration><![CDATA[protected bool CanViewFile(string dbPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="157" sc="3" el="159" ec="4">Dialogs\RenderTemplate.aspx.cs</location>
            <body hash="506563f69fe4505155b9b7fd299384a7"><![CDATA[{
			return DotNetNuke.Security.Permissions.FolderPermissionController.CanViewFolder(GetDNNFolder(dbPath));
		}]]></body>
          </codeblock>
        </method>
        <method name="GetDNNFolder">
          <declaration><![CDATA[private FolderInfo GetDNNFolder(string dbPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="162" sc="3" el="164" ec="4">Dialogs\RenderTemplate.aspx.cs</location>
            <body hash="8945a0d2f77dc7061ce0ce75db481b12"><![CDATA[{
			return new DotNetNuke.Services.FileSystem.FolderController().GetFolder(PortalController.Instance.GetCurrentPortalSettings().PortalId, dbPath, false);
		}]]></body>
          </codeblock>
        </method>
        <method name="GetFileIDFromURL">
          <declaration><![CDATA[private int GetFileIDFromURL(string url)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="113" sc="3" el="154" ec="4">Dialogs\RenderTemplate.aspx.cs</location>
            <body hash="0d0724966b27b8cf8008e26e57a50b58"><![CDATA[{
			int returnValue = -1;
			//add http
			if (! (url.ToLower().StartsWith("http")))
			{
				if (url.ToLower().StartsWith("/"))
				{
					url = "http:/" + url;
				}
				else
				{
					url = "http://" + url;
				}
			}

			Uri u = new Uri(url);

			if (u != null && u.Query != null)
			{
				NameValueCollection @params = HttpUtility.ParseQueryString(u.Query);

				if (@params != null && @params.Count > 0)
				{
					string fileTicket = @params.Get("fileticket");

					if (! (string.IsNullOrEmpty(fileTicket)))
					{
						try
						{
							returnValue = FileLinkClickController.Instance.GetFileIdFromLinkClick(@params); 
						}
						catch (Exception ex)
						{
							returnValue = -1;
                            Logger.Error(ex);
						}
					}
				}
			}

			return returnValue;
		}]]></body>
          </codeblock>
        </method>
        <method name="OnInit">
          <declaration><![CDATA[protected override void OnInit(EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="187" sc="6" el="191" ec="7">Dialogs\RenderTemplate.aspx.cs</location>
            <body hash="57c0ebd96a7287b045c7e403641a23c9"><![CDATA[{
		    base.OnInit(e);

		    this.Load += Page_Load;
	    }]]></body>
          </codeblock>
        </method>
        <method name="Page_Load">
          <declaration><![CDATA[protected void Page_Load(object sender, EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="48" sc="3" el="106" ec="4">Dialogs\RenderTemplate.aspx.cs</location>
            <body hash="d4fa5f82e92e2cd356733de60ee5962a"><![CDATA[{
			try
			{
				string renderUrl = Request.QueryString["rurl"];

				if (! (string.IsNullOrEmpty(renderUrl)))
				{
					string fileContents = string.Empty;
					FileController fileCtrl = new FileController();
					FileInfo fileInfo = null;
					int portalID = PortalController.Instance.GetCurrentPortalSettings().PortalId;

					if (renderUrl.ToLower().Contains("linkclick.aspx") && renderUrl.ToLower().Contains("fileticket"))
					{
						//File Ticket
						int fileID = GetFileIDFromURL(renderUrl);

						if (fileID > -1)
						{
							fileInfo = fileCtrl.GetFileById(fileID, portalID);
						}
					}
					else
					{
						//File URL
						string dbPath = (string)(string)FileSystemValidation.ToDBPath(renderUrl);
						string fileName = System.IO.Path.GetFileName(renderUrl);

						if (! (string.IsNullOrEmpty(fileName)))
						{
							FolderInfo dnnFolder = GetDNNFolder(dbPath);
							if (dnnFolder != null)
							{
								fileInfo = fileCtrl.GetFile(fileName, portalID, dnnFolder.FolderID);
							}
						}
					}

					if (fileInfo != null)
					{
						if (CanViewFile(fileInfo.Folder) && fileInfo.Extension.ToLower() == "htmtemplate")
						{
							byte[] fileBytes = FileSystemUtils.GetFileContent(fileInfo);
							fileContents = System.Text.Encoding.ASCII.GetString(fileBytes);
						}
					}

					if (! (string.IsNullOrEmpty(fileContents)))
					{
						Content.Text = Server.HtmlEncode(fileContents);
					}
				}
			}
			catch (Exception ex)
			{
				Services.Exceptions.Exceptions.LogException(ex);
				Content.Text = string.Empty;
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="Content">
          <declaration><![CDATA[protected System.Web.UI.WebControls.Literal Content;]]></declaration>
          <documentation>
            <summary>
 Content control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="Head1">
          <declaration><![CDATA[protected System.Web.UI.HtmlControls.HtmlHead Head1;]]></declaration>
          <documentation>
            <summary>
 Head1 control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="Logger">
          <declaration><![CDATA[private static readonly ILog Logger = LoggerSource.Instance.GetLogger(typeof(RenderTemplate));]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="DNNHomeDirectory">
          <declaration><![CDATA[private string DNNHomeDirectory]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="169" sc="4" el="180" ec="5">Dialogs\RenderTemplate.aspx.cs</location>
            <body hash="a6fd1cbc4da6aa42995c3d161d626783"><![CDATA[{
				//todo: host directory
				string homeDir = PortalController.Instance.GetCurrentPortalSettings().HomeDirectory;
				homeDir = homeDir.Replace("\\", "/");

				if (homeDir.EndsWith("/"))
				{
					homeDir = homeDir.Remove(homeDir.Length - 1, 1);
				}

				return homeDir;
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="RenderTemplateUrl">
      <declaration><![CDATA[public class RenderTemplateUrl : System.Web.UI.WebControls.Literal]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public RenderTemplateUrl()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="OnPreRender">
          <declaration><![CDATA[protected override void OnPreRender(EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="30" sc="3" el="33" ec="4">Components\RenderTemplateUrl.cs</location>
            <body hash="c89fbff2e9211f5f384aedb58e7ae8df"><![CDATA[{
			base.OnPreRender(e);
			Text = "<script type=\"text/javascript\">var __dnnTemplateBaseUrl=\"" + Page.ResolveUrl("~/DesktopModules/Admin/RadEditorProvider/Dialogs/RenderTemplate.aspx") + "\";</script>";
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="SaveTemplate">
      <declaration><![CDATA[public class SaveTemplate : PageBase]]></declaration>
      <documentation>
        <summary>

 </summary>
 <remarks>
 </remarks>
 <history>
 </history></documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public SaveTemplate()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="329" sc="6" el="334" ec="7">Dialogs\SaveTemplate.aspx.cs</location>
            <body hash="a55d6affe3907ea7a238a901f25f6d69"><![CDATA[public SaveTemplate()
	    {

    	    this.Init += new System.EventHandler(Page_Init);
		    this.Load += new System.EventHandler(Page_Load);
	    }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AddComma">
          <declaration><![CDATA[private object AddComma(string strExpression)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="275" sc="3" el="284" ec="4">Dialogs\SaveTemplate.aspx.cs</location>
            <body hash="0f4e993c7a6390ff00193a600132180e"><![CDATA[{
			if (strExpression.EndsWith(","))
			{
				return strExpression;
			}
			else
			{
				return strExpression + ",";
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="FixAllowedExtensions">
          <declaration><![CDATA[private void FixAllowedExtensions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="253" sc="3" el="272" ec="4">Dialogs\SaveTemplate.aspx.cs</location>
            <body hash="15648988a18b3de91226a73ed8f4fad4"><![CDATA[{

			bool blnHTML = true;

			string validExtensions = DotNetNuke.Entities.Host.Host.FileExtensions.ToLowerInvariant();

			if (("," + validExtensions + ",").IndexOf(",html,") == -1)
			{
				blnHTML = false;
			}

			if (blnHTML == false)
			{
				validExtensions = (string)AddComma(validExtensions).ToString() + "html";
				HostSettingsController ctl = new HostSettingsController();
				ctl.UpdateHostSetting("FileExtensions", validExtensions);
				Config.Touch();
			}

		}]]></body>
          </codeblock>
        </method>
        <method name="GetString">
          <declaration><![CDATA[public string GetString(string key)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="319" sc="3" el="322" ec="4">Dialogs\SaveTemplate.aspx.cs</location>
            <body hash="8630de42d87c40bc449d8cc3e874c3ba"><![CDATA[{
			string resourceFile = System.IO.Path.Combine(this.TemplateSourceDirectory + "/", DotNetNuke.Services.Localization.Localization.LocalResourceDirectory + "/SaveTemplate.resx");
			return DotNetNuke.Services.Localization.Localization.GetString(key, resourceFile);
		}]]></body>
          </codeblock>
        </method>
        <method name="IsValidUser">
          <declaration><![CDATA[private bool IsValidUser()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="136" sc="9" el="145" ec="10">Dialogs\SaveTemplate.aspx.cs</location>
            <body hash="b5be5ad909110ccd101c6c87da76cd21"><![CDATA[{
			int moduleId = Null.NullInteger;
			bool result = User.Identity.IsAuthenticated && int.TryParse(Request.QueryString["ModuleId"], out moduleId);
	        if (result)
	        {
                var module = ModuleController.Instance.GetModule(moduleId, Null.NullInteger, true);
		        result = module != null && ModulePermissionController.CanEditModuleContent(module);
	        }
	        return result;
        }]]></body>
          </codeblock>
        </method>
        <method name="Page_Init">
          <declaration><![CDATA[protected void Page_Init(object sender, EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="53" sc="3" el="62" ec="4">Dialogs\SaveTemplate.aspx.cs</location>
            <body hash="f997151409ad43f9d33d649c9c933385"><![CDATA[{

			DotNetNuke.Framework.AJAX.RegisterScriptManager();

			if (Request.IsAuthenticated == true)
			{
				Response.Cache.SetCacheability(System.Web.HttpCacheability.ServerAndNoCache);
			}

		}]]></body>
          </codeblock>
        </method>
        <method name="Page_Load">
          <declaration><![CDATA[protected void Page_Load(object sender, EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="65" sc="3" el="133" ec="4">Dialogs\SaveTemplate.aspx.cs</location>
            <body hash="12e2b5431b337faf3c4cb876d684f9fd"><![CDATA[{
			try
			{

				SetResStrings();

				if (!IsPostBack)
				{
                    if (!IsValidUser())
                    {
	                    var url = Globals.AccessDeniedURL();
	                    url = string.Format("{0}{1}popUp=true", url, url.Contains("?") ? "&" : "?");
                        Response.Redirect(url, true);
                    }

				    FixAllowedExtensions();

					int portalID = DotNetNuke.Entities.Portals.PortalController.Instance.GetCurrentPortalSettings().PortalId;
					ArrayList folders = DotNetNuke.Common.Utilities.FileSystemUtils.GetFoldersByUser(portalID, true, true, "Add");

					//filter out only folders below the editor's template path
					string strStartFolder = "";
					try
					{
                        if (!String.IsNullOrEmpty(Request.QueryString["path"]))
						    strStartFolder = Request.QueryString["path"];
					}
					catch
					{
					}
					ArrayList tmpFolders = new ArrayList();
					foreach (DotNetNuke.Services.FileSystem.FolderInfo folder in folders)
					{
						if (folder.FolderPath.StartsWith(strStartFolder))
						{
							tmpFolders.Add(folder);
						}
					}

					if (tmpFolders.Count == 0)
					{
						msgError.InnerHtml = GetString("msgNoFolders.Text");
						divInputArea.Visible = false;
						cmdClose.Visible = true;
					}
					else
					{
						FolderList.Items.Clear();

						FolderList.DataTextField = "FolderPath";
						FolderList.DataValueField = "FolderPath";
						FolderList.DataSource = tmpFolders;
						FolderList.DataBind();

						RadComboBoxItem rootFolder = FolderList.FindItemByText(string.Empty);
						if (rootFolder != null)
						{
							rootFolder.Text = GetString("lblRootFolder.Text");
						}

					}
				}
			}
			catch (Exception ex)
			{
				DotNetNuke.Services.Exceptions.Exceptions.LogException(ex);
				throw ex;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Save_OnClick">
          <declaration><![CDATA[protected void Save_OnClick(object sender, EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="148" sc="3" el="242" ec="4">Dialogs\SaveTemplate.aspx.cs</location>
            <body hash="227b8ce36ec344ab042abb1cbf8b9854"><![CDATA[{
			try
			{
				if (FolderList.Items.Count == 0)
				{
					return;
				}

				DotNetNuke.Entities.Portals.PortalSettings portalSettings = DotNetNuke.Entities.Portals.PortalSettings.Current;

				string fileContents = htmlText2.Text.Trim();
				string newFileName = FileName.Text;
				if (! (newFileName.EndsWith(".html")))
				{
					newFileName = newFileName + ".html";
				}

				string rootFolder = portalSettings.HomeDirectoryMapPath;
				string dbFolderPath = FolderList.SelectedValue;
				string virtualFolder = (string)(string)FileSystemValidation.ToVirtualPath(dbFolderPath);
				rootFolder = rootFolder + FolderList.SelectedValue;
				rootFolder = rootFolder.Replace("/", "\\");

				string errorMessage = string.Empty;
				FolderController folderCtrl = new FolderController();
				FolderInfo folder = folderCtrl.GetFolder(portalSettings.PortalId, dbFolderPath, false);

				if ((folder == null))
				{
					ShowSaveTemplateMessage(GetString("msgFolderDoesNotExist.Text"));
					return;
				}

				// Check file name is valid
				FileSystemValidation dnnValidator = new FileSystemValidation();
				errorMessage = dnnValidator.OnCreateFile(virtualFolder + newFileName, fileContents.Length);
				if (! (string.IsNullOrEmpty(errorMessage)))
				{
					ShowSaveTemplateMessage(errorMessage);
					return;
				}

				FileController fileCtrl = new FileController();
				DotNetNuke.Services.FileSystem.FileInfo existingFile = fileCtrl.GetFile(newFileName, portalSettings.PortalId, folder.FolderID);

				// error if file exists
				if (! Overwrite.Checked && existingFile != null)
				{
					ShowSaveTemplateMessage(GetString("msgFileExists.Text"));
					return;
				}

				FileInfo newFile = existingFile;
				if ((newFile == null))
				{
					newFile = new FileInfo();
				}

				newFile.FileName = newFileName;
				newFile.ContentType = "text/plain";
				newFile.Extension = "html";
				newFile.Size = fileContents.Length;
				newFile.FolderId = folder.FolderID;

				errorMessage = FileSystemUtils.CreateFileFromString(rootFolder, newFile.FileName, fileContents, newFile.ContentType, string.Empty, false);

				if (! (string.IsNullOrEmpty(errorMessage)))
				{
					ShowSaveTemplateMessage(errorMessage);
					return;
				}

				existingFile = fileCtrl.GetFile(newFileName, portalSettings.PortalId, folder.FolderID);
				if (newFile.FileId != existingFile.FileId)
				{
					newFile.FileId = existingFile.FileId;
				}

				if (newFile.FileId != Null.NullInteger)
				{
					fileCtrl.UpdateFile(newFile.FileId, newFile.FileName, newFile.Extension, newFile.Size, newFile.Width, newFile.Height, newFile.ContentType, folder.FolderPath, folder.FolderID);
				}
				else
				{
					fileCtrl.AddFile(portalSettings.PortalId, newFile.FileName, newFile.Extension, newFile.Size, newFile.Width, newFile.Height, newFile.ContentType, folder.FolderPath, folder.FolderID, true);
				}

				ShowSaveTemplateMessage(string.Empty);
			}
			catch (Exception ex)
			{
				DotNetNuke.Services.Exceptions.Exceptions.LogException(ex);
				throw ex;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="SetResStrings">
          <declaration><![CDATA[private void SetResStrings()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="306" sc="3" el="316" ec="4">Dialogs\SaveTemplate.aspx.cs</location>
            <body hash="87cfe04379392704fabf2ac81d8c0013"><![CDATA[{
			this.lblTitle.Text = GetString("lblDialogTitle");
			this.lblFolders.Text = GetString("lblFolders.Text");
			this.lblFileName.Text = GetString("lblFileName.Text");
			this.lblOverwrite.Text = GetString("lblOverwrite.Text");
			this.cmdSave.Text = GetString("cmdSave.Text");
			this.cmdCancel.Text = GetString("cmdCancel.Text");
			this.cmdClose.Text = GetString("cmdClose.Text");
			this.msgSuccess.InnerHtml = GetString("msgSuccess.Text");
			this.msgError.InnerHtml = GetString("msgError.Text");
		}]]></body>
          </codeblock>
        </method>
        <method name="ShowSaveTemplateMessage">
          <declaration><![CDATA[private void ShowSaveTemplateMessage(string errorMessage)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="287" sc="3" el="303" ec="4">Dialogs\SaveTemplate.aspx.cs</location>
            <body hash="8cdd97e78c25754df5156403544942c6"><![CDATA[{
			if (string.IsNullOrEmpty(errorMessage))
			{
				msgSuccess.Visible = true;
				msgError.Visible = false;
			}
			else
			{
				msgSuccess.Visible = false;
				msgError.Visible = true;
				msgError.InnerHtml += errorMessage;
				DotNetNuke.Services.Exceptions.Exceptions.LogException(new FileManagerException("Error creating htmtemplate file [" + errorMessage + "]"));
			}

			divInputArea.Visible = false;
			cmdClose.Visible = true;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="cmdCancel">
          <declaration><![CDATA[protected System.Web.UI.WebControls.Button cmdCancel;]]></declaration>
          <documentation>
            <summary>
 cmdCancel control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="cmdClose">
          <declaration><![CDATA[protected System.Web.UI.WebControls.Button cmdClose;]]></declaration>
          <documentation>
            <summary>
 cmdClose control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="cmdSave">
          <declaration><![CDATA[protected System.Web.UI.WebControls.Button cmdSave;]]></declaration>
          <documentation>
            <summary>
 cmdSave control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="divInputArea">
          <declaration><![CDATA[protected System.Web.UI.HtmlControls.HtmlGenericControl divInputArea;]]></declaration>
          <documentation>
            <summary>
 divInputArea control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="FileName">
          <declaration><![CDATA[protected System.Web.UI.WebControls.TextBox FileName;]]></declaration>
          <documentation>
            <summary>
 FileName control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="FolderList">
          <declaration><![CDATA[protected RadComboBox FolderList;]]></declaration>
          <documentation>
            <summary>
 FolderList control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="form2">
          <declaration><![CDATA[protected System.Web.UI.HtmlControls.HtmlForm form2;]]></declaration>
          <documentation>
            <summary>
 form2 control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="Head1">
          <declaration><![CDATA[protected System.Web.UI.HtmlControls.HtmlHead Head1;]]></declaration>
          <documentation>
            <summary>
 Head1 control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="htmlText">
          <declaration><![CDATA[protected System.Web.UI.WebControls.HiddenField htmlText;]]></declaration>
          <documentation>
            <summary>
 htmlText control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="htmlText2">
          <declaration><![CDATA[protected System.Web.UI.WebControls.TextBox htmlText2;]]></declaration>
          <documentation>
            <summary>
 htmlText2 control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="lblFileName">
          <declaration><![CDATA[protected System.Web.UI.WebControls.Label lblFileName;]]></declaration>
          <documentation>
            <summary>
 lblFileName control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="lblFolders">
          <declaration><![CDATA[protected System.Web.UI.WebControls.Label lblFolders;]]></declaration>
          <documentation>
            <summary>
 lblFolders control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="lblOverwrite">
          <declaration><![CDATA[protected System.Web.UI.WebControls.Label lblOverwrite;]]></declaration>
          <documentation>
            <summary>
 lblOverwrite control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="lblTitle">
          <declaration><![CDATA[protected System.Web.UI.WebControls.Literal lblTitle;]]></declaration>
          <documentation>
            <summary>
 lblTitle control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="msgError">
          <declaration><![CDATA[protected System.Web.UI.HtmlControls.HtmlGenericControl msgError;]]></declaration>
          <documentation>
            <summary>
 msgError control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="msgSuccess">
          <declaration><![CDATA[protected System.Web.UI.HtmlControls.HtmlGenericControl msgSuccess;]]></declaration>
          <documentation>
            <summary>
 msgSuccess control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="Overwrite">
          <declaration><![CDATA[protected System.Web.UI.WebControls.CheckBox Overwrite;]]></declaration>
          <documentation>
            <summary>
 Overwrite control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
        <field name="RadScriptBlock1">
          <declaration><![CDATA[protected RadScriptBlock RadScriptBlock1;]]></declaration>
          <documentation>
            <summary>
 RadScriptBlock1 control.
 </summary>
 <remarks>
 Auto-generated field.
 To modify move field declaration from designer file to code-behind file.
 </remarks></documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="TelerikFileBrowserProvider">
      <declaration><![CDATA[public class TelerikFileBrowserProvider : FileSystemContentProvider]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public TelerikFileBrowserProvider(System.Web.HttpContext context, string[] searchPatterns, string[] viewPaths, string[] uploadPaths, string[] deletePaths, string selectedUrl, string selectedItemTag) : base(context, searchPatterns, viewPaths, uploadPaths, deletePaths, selectedUrl, selectedItemTag)]]></declaration>
          <documentation>
            <summary>
 The current portal will be used for file access.
 </summary>
 <param name="context"></param>
 <param name="searchPatterns"></param>
 <param name="viewPaths"></param>
 <param name="uploadPaths"></param>
 <param name="deletePaths"></param>
 <param name="selectedUrl"></param>
 <param name="selectedItemTag"></param>
 <remarks></remarks></documentation>
          <codeblock>
            <location sl="58" sc="3" el="60" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="17ed7530afff4803b1cc4b7be5f3cdca"><![CDATA[public TelerikFileBrowserProvider(HttpContext context, string[] searchPatterns, string[] viewPaths, string[] uploadPaths, string[] deletePaths, string selectedUrl, string selectedItemTag) : base(context, searchPatterns, viewPaths, uploadPaths, deletePaths, selectedUrl, selectedItemTag)
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static TelerikFileBrowserProvider()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="45" sc="9" el="45" ec="115">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="848bd4ddf9a9d5b389d465930c0821d2"><![CDATA[private static readonly ILog Logger = LoggerSource.Instance.GetLogger(typeof(TelerikFileBrowserProvider))]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AddChildDirectoriesToList">
          <declaration><![CDATA[private DirectoryItem AddChildDirectoriesToList(DirectoryItem radDirectory)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="628" sc="3" el="672" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="cd3eb0c739623e6bb8b41011ddee564b"><![CDATA[{
            var parentFolderPath = radDirectory.FullPath.EndsWith("/") ? radDirectory.FullPath : radDirectory.FullPath + "/";
            if (parentFolderPath.StartsWith(PortalSettings.HomeDirectory))
		    {
                parentFolderPath = parentFolderPath.Remove(0, PortalSettings.HomeDirectory.Length);
		    }

		    var dnnParentFolder = FolderManager.Instance.GetFolder(PortalSettings.PortalId, parentFolderPath);
		    if (!DNNValidator.CanViewFilesInFolder(dnnParentFolder.FolderPath))
		    {
		        return null;
		    }
            radDirectory.Permissions = FileSystemValidation.TelerikPermissions(dnnParentFolder);
		    var dnnChildFolders = FolderManager.Instance.GetFolders(dnnParentFolder).Where(folder => (FileSystemValidation.HasPermission(folder, "BROWSE,READ")));
            var radDirectories = new List<DirectoryItem>();
            foreach (var dnnChildFolder in dnnChildFolders)
            {
                if (!dnnChildFolder.FolderPath.ToLowerInvariant().StartsWith("cache/") 
                    && !dnnChildFolder.FolderPath.ToLowerInvariant().StartsWith("users/")
                    && !dnnChildFolder.FolderPath.ToLowerInvariant().StartsWith("groups/"))
                {
                        var radSubDirectory =
                            TelerikContent.ResolveDirectory(FileSystemValidation.ToVirtualPath(dnnChildFolder.FolderPath));
                        radSubDirectory.Permissions = FileSystemValidation.TelerikPermissions(dnnChildFolder);
                        radDirectories.Add(radSubDirectory);
                }
            }

            radDirectory.Files = IncludeFilesForCurrentFolder(dnnParentFolder);

		    if (parentFolderPath == "")
            {
                var userFolder = FolderManager.Instance.GetUserFolder(PortalSettings.UserInfo);
                if (userFolder.PortalID == PortalSettings.PortalId)
                {
                    var radUserFolder = TelerikContent.ResolveDirectory(FileSystemValidation.ToVirtualPath(userFolder.FolderPath));
                    radUserFolder.Name = DNNValidator.GetString("MyFolder");
                    radUserFolder.Permissions = FileSystemValidation.TelerikPermissions(userFolder);
                    radDirectories.Add(radUserFolder);
                }
            }
            
		    radDirectory.Directories = radDirectories.ToArray();
            return radDirectory;
		}]]></body>
          </codeblock>
        </method>
        <method name="CheckAllChildrenVisible">
          <declaration><![CDATA[private bool CheckAllChildrenVisible(ref FolderInfo folder)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="723" sc="3" el="765" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="4fd9c82645d90b7db5553c24c44a6208"><![CDATA[{
			string virtualPath = FileSystemValidation.ToVirtualPath(folder.FolderPath);

			//check files are visible
			var files = GetDNNFiles(folder.FolderID);
			var visibleFileCount = 0;
			foreach (Services.FileSystem.FileInfo fileItem in files.Values)
			{
                if (CheckSearchPatterns(fileItem.FileName, SearchPatterns))
				{
					visibleFileCount = visibleFileCount + 1;
				}
			}

			if (visibleFileCount != Directory.GetFiles(HttpContext.Current.Request.MapPath(virtualPath)).Length)
			{
				return false;
			}

			//check folders
			if (folder != null)
			{
				IDictionary<string, FolderInfo> childUserFolders = DNNValidator.GetChildUserFolders(virtualPath);

				if (childUserFolders.Count != Directory.GetDirectories(HttpContext.Current.Request.MapPath(virtualPath)).Length)
				{
					return false;
				}

				//check children
				foreach (FolderInfo childFolder in childUserFolders.Values)
				{
					//do recursive check
					FolderInfo tempVar2 = childFolder;
					if (! (CheckAllChildrenVisible(ref tempVar2)))
					{
						return false;
					}
				}
			}

			return true;
		}]]></body>
          </codeblock>
        </method>
        <method name="CheckSearchPatterns">
          <declaration><![CDATA[private bool CheckSearchPatterns(string dnnFileName, string[] searchPatterns)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="843" sc="3" el="862" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="3942604b768c702a5d91992c05984239"><![CDATA[{
			if (searchPatterns == null | searchPatterns.Length < 1)
			{
				return true;
			}

			bool returnValue = false;
			foreach (string pattern in searchPatterns)
			{
				bool result = new System.Text.RegularExpressions.Regex(ConvertToRegexPattern(pattern), System.Text.RegularExpressions.RegexOptions.IgnoreCase).IsMatch(dnnFileName);

				if (result)
				{
					returnValue = true;
					break;
				}
			}

			return returnValue;
		}]]></body>
          </codeblock>
        </method>
        <method name="ConvertToRegexPattern">
          <declaration><![CDATA[private string ConvertToRegexPattern(string pattern)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="865" sc="3" el="870" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="b1f8fea2589f1028c1c12a65489610dc"><![CDATA[{
			string returnValue = System.Text.RegularExpressions.Regex.Escape(pattern);
			returnValue = returnValue.Replace("\\*", ".*");
			returnValue = returnValue.Replace("\\?", ".") + "$";
			return returnValue;
		}]]></body>
          </codeblock>
        </method>
        <method name="CopyDirectory">
          <declaration><![CDATA[public override string CopyDirectory(string path, string newPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="188" sc="3" el="223" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="808a5434165061ea6c6064605e6059aa"><![CDATA[{
			try
			{
				string virtualPath = FileSystemValidation.ToVirtualPath(path);
				string virtualNewPath = FileSystemValidation.ToVirtualPath(newPath);
				string virtualDestinationPath = FileSystemValidation.GetDestinationFolder(virtualNewPath);

				string returnValue = DNNValidator.OnCopyFolder(virtualPath, virtualDestinationPath);
				if (! (string.IsNullOrEmpty(returnValue)))
				{
					return returnValue;
				}

				//Are all items visible to user?
				//todo: copy visible files and folders only?
				FolderInfo folder = DNNValidator.GetUserFolder(virtualPath);
				if (! (CheckAllChildrenVisible(ref folder)))
				{
					return DNNValidator.LogDetailError(ErrorCodes.CannotCopyFolder_ChildrenVisible);
				}

				returnValue = TelerikContent.CopyDirectory(virtualPath, virtualNewPath);

				if (string.IsNullOrEmpty(returnValue))
				{
					//Sync to add new folder & files
					FileSystemUtils.SynchronizeFolder(PortalSettings.PortalId, HttpContext.Current.Request.MapPath(virtualNewPath), FileSystemValidation.ToDBPath(virtualNewPath), true, true, true);
				}

				return returnValue;
			}
			catch (Exception ex)
			{
				return DNNValidator.LogUnknownError(ex, path, newPath);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="CopyFile">
          <declaration><![CDATA[public override string CopyFile(string path, string newPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="364" sc="3" el="395" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="69aa1241e1bb81faf2b9464c6bb2d279"><![CDATA[{
			try
			{
				string virtualPathAndFile = FileSystemValidation.ToVirtualPath(path);
				string virtualNewPathAndFile = FileSystemValidation.ToVirtualPath(newPath);

				string returnValue = DNNValidator.OnCopyFile(virtualPathAndFile, virtualNewPathAndFile);
				if (! (string.IsNullOrEmpty(returnValue)))
				{
					return returnValue;
				}

				//Returns errors or empty string when successful (ie: NewFileAlreadyExists)
				returnValue = TelerikContent.CopyFile(virtualPathAndFile, virtualNewPathAndFile);

				if (string.IsNullOrEmpty(returnValue))
				{
					string virtualNewPath = FileSystemValidation.RemoveFileName(virtualNewPathAndFile);
					FolderInfo dnnFolder = DNNValidator.GetUserFolder(virtualNewPath);
					var dnnFileInfo = new Services.FileSystem.FileInfo();
					FillFileInfo(virtualNewPathAndFile, ref dnnFileInfo);

					DNNFileCtrl.AddFile(PortalSettings.PortalId, dnnFileInfo.FileName, dnnFileInfo.Extension, dnnFileInfo.Size, dnnFileInfo.Width, dnnFileInfo.Height, dnnFileInfo.ContentType, dnnFolder.FolderPath, dnnFolder.FolderID, true);
				}

				return returnValue;
			}
			catch (Exception ex)
			{
				return DNNValidator.LogUnknownError(ex, path, newPath);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="CreateDirectory">
          <declaration><![CDATA[public override string CreateDirectory(string path, string name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="93" sc="3" el="128" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="fd9facb87e8a800d4ff1f45cd9d938bd"><![CDATA[{
			try
			{
                var directoryName = name.Trim();
				var virtualPath = FileSystemValidation.ToVirtualPath(path);

                var returnValue = DNNValidator.OnCreateFolder(virtualPath, directoryName);
				if (! (string.IsNullOrEmpty(returnValue)))
				{
					return returnValue;
				}

				//Returns errors or empty string when successful (ie: DirectoryAlreadyExists, InvalidCharactersInPath)
                returnValue = TelerikContent.CreateDirectory(virtualPath, directoryName);

				if (! (string.IsNullOrEmpty(returnValue)))
				{
					return GetTelerikMessage(returnValue);
				}

				if (string.IsNullOrEmpty(returnValue))
				{
                    var virtualNewPath = FileSystemValidation.CombineVirtualPath(virtualPath, directoryName);
					var newFolderID = DNNFolderCtrl.AddFolder(PortalSettings.PortalId, FileSystemValidation.ToDBPath(virtualNewPath));
					FileSystemUtils.SetFolderPermissions(PortalSettings.PortalId, newFolderID, FileSystemValidation.ToDBPath(virtualNewPath));
                    //make sure that the folder is flagged secure if necessary
                    DNNValidator.OnFolderCreated(virtualNewPath, virtualPath);
				}

				return returnValue;
			}
			catch (Exception ex)
			{
                return DNNValidator.LogUnknownError(ex, path, name);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="DeleteDirectory">
          <declaration><![CDATA[public override string DeleteDirectory(string path)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="226" sc="3" el="256" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="ff4844fddef7942b68d3ba8ad0c1bd73"><![CDATA[{
			try
			{
				string virtualPath = FileSystemValidation.ToVirtualPath(path);

				string returnValue = DNNValidator.OnDeleteFolder(virtualPath);
				if (! (string.IsNullOrEmpty(returnValue)))
				{
					return returnValue;
				}

				//Are all items visible to user?
				FolderInfo folder = DNNValidator.GetUserFolder(virtualPath);
				if (!CheckAllChildrenVisible(ref folder))
				{
					return DNNValidator.LogDetailError(ErrorCodes.CannotDeleteFolder_ChildrenVisible);
				}


				if (string.IsNullOrEmpty(returnValue))
				{
                    FolderManager.Instance.DeleteFolder(folder);
				}

				return returnValue;
			}
			catch (Exception ex)
			{
				return DNNValidator.LogUnknownError(ex, path);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="DeleteFile">
          <declaration><![CDATA[public override string DeleteFile(string path)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="259" sc="3" el="285" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="8a5c5ff631f5f27af30f9e87736c2e9f"><![CDATA[{
			try
			{
				string virtualPathAndFile = FileSystemValidation.ToVirtualPath(path);

				string returnValue = DNNValidator.OnDeleteFile(virtualPathAndFile);
				if (! (string.IsNullOrEmpty(returnValue)))
				{
					return returnValue;
				}

				returnValue = TelerikContent.DeleteFile(virtualPathAndFile);

				if (string.IsNullOrEmpty(returnValue))
				{
					string virtualPath = FileSystemValidation.RemoveFileName(virtualPathAndFile);
					FolderInfo dnnFolder = DNNValidator.GetUserFolder(virtualPath);
					DNNFileCtrl.DeleteFile(PortalSettings.PortalId, Path.GetFileName(virtualPathAndFile), dnnFolder.FolderID, true);
				}

				return returnValue;
			}
			catch (Exception ex)
			{
				return DNNValidator.LogUnknownError(ex, path);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="FillFileInfo">
          <declaration><![CDATA[private void FillFileInfo(string virtualPathAndFile, ref DotNetNuke.Services.FileSystem.FileInfo fileInfo)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="768" sc="3" el="792" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="7f4cb1a743507d8d4d166ddd8c45cb26"><![CDATA[{
			fileInfo.FileName = Path.GetFileName(virtualPathAndFile);
			fileInfo.Extension = Path.GetExtension(virtualPathAndFile);
			if (fileInfo.Extension != null && fileInfo.Extension.StartsWith("."))
			{
				fileInfo.Extension = fileInfo.Extension.Remove(0, 1);
			}

			fileInfo.ContentType = FileSystemUtils.GetContentType(fileInfo.Extension);

			FileStream fileStream = null;
			try
			{
				fileStream = File.OpenRead(HttpContext.Current.Request.MapPath(virtualPathAndFile));
				FillImageInfo(fileStream, ref fileInfo);
			}
			finally
			{
				if (fileStream != null)
				{
					fileStream.Close();
					fileStream.Dispose();
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="FillFileInfo">
          <declaration><![CDATA[private void FillFileInfo(UploadedFile file, ref DotNetNuke.Services.FileSystem.FileInfo fileInfo)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="795" sc="3" el="807" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="abe8f82c4d2214ea329f68abacc7651f"><![CDATA[{
			//The core API expects the path to be stripped off the filename
			fileInfo.FileName = ((file.FileName.Contains("\\")) ? Path.GetFileName(file.FileName) : file.FileName);
			fileInfo.Extension = file.GetExtension();
			if (fileInfo.Extension.StartsWith("."))
			{
				fileInfo.Extension = fileInfo.Extension.Remove(0, 1);
			}

			fileInfo.ContentType = FileSystemUtils.GetContentType(fileInfo.Extension);

			FillImageInfo(file.InputStream, ref fileInfo);
		}]]></body>
          </codeblock>
        </method>
        <method name="FillImageInfo">
          <declaration><![CDATA[private void FillImageInfo(Stream fileStream, ref DotNetNuke.Services.FileSystem.FileInfo fileInfo)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="810" sc="3" el="835" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="d7a89d452eba97868a4b87bb71e1fd06"><![CDATA[{
		    var imageExtensions = new FileExtensionWhitelist(Common.Globals.glbImageFileTypes);
			if (imageExtensions.IsAllowedExtension(fileInfo.Extension))
			{
				System.Drawing.Image img = null;
				try
				{
					img = System.Drawing.Image.FromStream(fileStream);
					fileInfo.Size = fileStream.Length > int.MaxValue ? int.MaxValue : int.Parse(fileStream.Length.ToString(CultureInfo.InvariantCulture));
					fileInfo.Width = img.Width;
					fileInfo.Height = img.Height;
				}
				catch
				{
					// error loading image file
					fileInfo.ContentType = "application/octet-stream";
				}
				finally
				{
					if (img != null)
					{
						img.Dispose();
					}
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="GetDirectoryItemWithDNNPermissions">
          <declaration><![CDATA[private DirectoryItem GetDirectoryItemWithDNNPermissions(string path)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="616" sc="3" el="625" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="83a38cf40b647b0167786e1b4d9ffe26"><![CDATA[{
			var radDirectory = TelerikContent.ResolveDirectory(FileSystemValidation.ToVirtualPath(path));
            if (radDirectory.FullPath == PortalSettings.HomeDirectory)
            {
                radDirectory.Name = DNNValidator.GetString("Root");
            }
            Logger.DebugFormat("GetDirectoryItemWithDNNPermissions - path: {0}, radDirectory: {1}", path, radDirectory);
            //var directoryArray = new[] {radDirectory};
            return AddChildDirectoriesToList(radDirectory);
		}]]></body>
          </codeblock>
        </method>
        <method name="GetDNNFiles">
          <declaration><![CDATA[private IDictionary<string, FileInfo> GetDNNFiles(int dnnFolderID)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="699" sc="3" el="720" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="062a76d6f3c64c6d2f8ed7e6cbb84943"><![CDATA[{
			System.Data.IDataReader drFiles = null;
			IDictionary<string, Services.FileSystem.FileInfo> dnnFiles;

			try
			{
				drFiles = DNNFileCtrl.GetFiles(PortalSettings.PortalId, dnnFolderID);
				dnnFiles = CBO.FillDictionary<string, Services.FileSystem.FileInfo>("FileName", drFiles);
			}
			finally
			{
				if (drFiles != null)
				{
					if (! drFiles.IsClosed)
					{
						drFiles.Close();
					}
				}
			}

			return dnnFiles;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetFile">
          <declaration><![CDATA[public override Stream GetFile(string url)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="65" sc="3" el="80" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="19f92ab37ff53b80a68ab444515ddd14"><![CDATA[{
			//base calls CheckWritePermissions method
            Stream fileContent = null;
		    var folderPath = FileSystemValidation.ToDBPath(url);
		    var fileName = GetFileName(url);
            var folder = DNNValidator.GetUserFolder(folderPath);
            if (folder != null)
            {
                var file = FileManager.Instance.GetFile(folder, fileName);
                if (file != null)
                {
                    fileContent = FileManager.Instance.GetFileContent(file);
                }
            }
            return fileContent;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetFileName">
          <declaration><![CDATA[public override string GetFileName(string url)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="88" sc="3" el="90" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="2cc858d4e24a7191a0d8297b3da3f033"><![CDATA[{
			return TelerikContent.GetFileName(FileSystemValidation.ToVirtualPath(url));
		}]]></body>
          </codeblock>
        </method>
        <method name="GetFileUrl">
          <declaration><![CDATA[private string GetFileUrl(IFileInfo file)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="684" sc="9" el="696" ec="10">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="d4113ed559a754e2a48e285eaa448f41"><![CDATA[{
            var url = FileManager.Instance.GetUrl(file);
            if (NotUseRelativeUrl)
            {
                url = string.Format("{0}{1}{2}{3}",
                                    (HttpContext.Current.Request.IsSecureConnection ? "https://" : "http://"),
                                    HttpContext.Current.Request.Url.Host,
                                    (!HttpContext.Current.Request.Url.IsDefaultPort ? ":" + HttpContext.Current.Request.Url.Port : string.Empty),
                                    url);
            }

            return url;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetPath">
          <declaration><![CDATA[public override string GetPath(string url)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="83" sc="3" el="85" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="2294c524af36d8cf2edcd23f73f58b5a"><![CDATA[{
			return TelerikContent.GetPath(FileSystemValidation.ToVirtualPath(url));
		}]]></body>
          </codeblock>
        </method>
        <method name="GetTelerikMessage">
          <declaration><![CDATA[private string GetTelerikMessage(string key)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="873" sc="3" el="891" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="fd6d5d855e8df0cef8fa3908d4bea0ff"><![CDATA[{
			string returnValue = key;
			switch (key)
			{
				case "DirectoryAlreadyExists":
					returnValue = DNNValidator.GetString("ErrorCodes.DirectoryAlreadyExists");
					break;
				case "InvalidCharactersInPath":
					returnValue = DNNValidator.GetString("ErrorCodes.InvalidCharactersInPath");
					break;
				case "NewFileAlreadyExists":
					returnValue = DNNValidator.GetString("ErrorCodes.NewFileAlreadyExists");
					break;
					//Case ""
					//	Exit Select
			}

			return returnValue;
		}]]></body>
          </codeblock>
        </method>
        <method name="IncludeFilesForCurrentFolder">
          <declaration><![CDATA[private FileItem[] IncludeFilesForCurrentFolder(IFolderInfo dnnParentFolder)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="675" sc="6" el="681" ec="7">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="bc4e370dee0cb70425f78cc26715f25e"><![CDATA[{
	        var files = FolderManager.Instance.GetFiles(dnnParentFolder).Where(f => CheckSearchPatterns(f.FileName, SearchPatterns));
            var folderPermissions = FileSystemValidation.TelerikPermissions(dnnParentFolder);

	        return (from file in files
                    select new FileItem(file.FileName, file.Extension, file.Size, "", GetFileUrl(file), "", folderPermissions)).ToArray();
	    }]]></body>
          </codeblock>
        </method>
        <method name="MoveDirectory">
          <declaration><![CDATA[public override string MoveDirectory(string path, string newPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="131" sc="3" el="185" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="ff3ad63f8f844e05b8d0ebc499470e25"><![CDATA[{
			try
			{
				var virtualPath = FileSystemValidation.ToVirtualPath(path);
				var virtualNewPath = FileSystemValidation.ToVirtualPath(newPath);
				var virtualDestinationPath = FileSystemValidation.GetDestinationFolder(virtualNewPath);

				string returnValue;
			    var isRename = FileSystemValidation.GetDestinationFolder(virtualPath) == virtualDestinationPath;
				if (isRename)
				{
					//rename directory
					returnValue = DNNValidator.OnRenameFolder(virtualPath);
					if (! (string.IsNullOrEmpty(returnValue)))
					{
						return returnValue;
					}
				}
				else
				{
					//move directory
					returnValue = DNNValidator.OnMoveFolder(virtualPath, virtualDestinationPath);
					if (! (string.IsNullOrEmpty(returnValue)))
					{
						return returnValue;
					}
				}

				//Are all items visible to user?
				FolderInfo folder = DNNValidator.GetUserFolder(virtualPath);
				if (! (CheckAllChildrenVisible(ref folder)))
				{
					return DNNValidator.LogDetailError(ErrorCodes.CannotMoveFolder_ChildrenVisible);
				}

			    if (isRename)
                {
                    var dnnFolderToRename = FolderManager.Instance.GetFolder(PortalSettings.PortalId, FileSystemValidation.ToDBPath(virtualPath));
                    var newFolderName = virtualNewPath.TrimEnd('/').Split('/').LastOrDefault();
                    FolderManager.Instance.RenameFolder(dnnFolderToRename, newFolderName);
			    }
			    else // move
                {
                    var dnnFolderToMove = FolderManager.Instance.GetFolder(PortalSettings.PortalId, FileSystemValidation.ToDBPath(virtualPath));
                    var dnnDestinationFolder = FolderManager.Instance.GetFolder(PortalSettings.PortalId, FileSystemValidation.ToDBPath(virtualDestinationPath));
                    FolderManager.Instance.MoveFolder(dnnFolderToMove, dnnDestinationFolder);
			    }

				return returnValue;
			}
			catch (Exception ex)
			{
				return DNNValidator.LogUnknownError(ex, path, newPath);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="MoveFile">
          <declaration><![CDATA[public override string MoveFile(string path, string newPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="288" sc="3" el="361" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="4a8db5a18f19f8f2f6e891fd93845200"><![CDATA[{
			try
			{
				string virtualPathAndFile = FileSystemValidation.ToVirtualPath(path);
				string virtualNewPathAndFile = FileSystemValidation.ToVirtualPath(newPath);

				string virtualPath = FileSystemValidation.RemoveFileName(virtualPathAndFile);
				string virtualNewPath = FileSystemValidation.RemoveFileName(virtualNewPathAndFile);

				string returnValue;
				if (virtualPath == virtualNewPath)
				{
					//rename file
					returnValue = DNNValidator.OnRenameFile(virtualPathAndFile);
					if (! (string.IsNullOrEmpty(returnValue)))
					{
						return returnValue;
					}
				}
				else
				{
					//move file
					returnValue = DNNValidator.OnMoveFile(virtualPathAndFile, virtualNewPathAndFile);
					if (! (string.IsNullOrEmpty(returnValue)))
					{
						return returnValue;
					}
				}

				//Returns errors or empty string when successful (ie: NewFileAlreadyExists)
				//returnValue = TelerikContent.MoveFile(virtualPathAndFile, virtualNewPathAndFile);
                var folderPath = FileSystemValidation.ToDBPath(path);
                var folder = FolderManager.Instance.GetFolder(PortalSettings.PortalId, folderPath);
                if (folder != null)
                {
                    var file = FileManager.Instance.GetFile(folder, GetFileName(virtualPathAndFile));

                    if (file != null)
                    {
                        var destFolderPath = FileSystemValidation.ToDBPath(newPath);
                        var destFolder = FolderManager.Instance.GetFolder(PortalSettings.PortalId, destFolderPath);
                        var destFileName = GetFileName(virtualNewPathAndFile);
                        
                        if (destFolder != null)
                        {
                            if (file.FolderId != destFolder.FolderID
                                 && FileManager.Instance.GetFile(destFolder, file.FileName) != null)
                            {
                                returnValue = "FileExists";
                            }
                            else
                            {
                                FileManager.Instance.MoveFile(file, destFolder);
                                FileManager.Instance.RenameFile(file, destFileName);
                            }
                        }
                    }
                    else
                    {
                        returnValue = "FileNotFound";
                    }
                }
			    if (! (string.IsNullOrEmpty(returnValue)))
				{
					return GetTelerikMessage(returnValue);
				}

				return returnValue;
			}
			catch (Exception ex)
			{
				return DNNValidator.LogUnknownError(ex, path, newPath);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ResolveDirectory">
          <declaration><![CDATA[public override DirectoryItem ResolveDirectory(string path)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="516" sc="3" el="527" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="9be6b6cc7c8bbf62f6acc99547f71653"><![CDATA[{
			try
			{
                Logger.DebugFormat("ResolveDirectory: {0}", path);
                return GetDirectoryItemWithDNNPermissions(path);
			}
			catch (Exception ex)
			{
				DNNValidator.LogUnknownError(ex, path);
				return null;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ResolveRootDirectoryAsList">
          <declaration><![CDATA[public override DirectoryItem[] ResolveRootDirectoryAsList(string path)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="544" sc="3" el="555" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="8c1c8c79a28ede19069672ddb03d202b"><![CDATA[{
			try
			{
                Logger.DebugFormat("ResolveRootDirectoryAsList: {0}", path);
                return GetDirectoryItemWithDNNPermissions(path).Directories;
			}
			catch (Exception ex)
			{
				DNNValidator.LogUnknownError(ex, path);
				return null;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ResolveRootDirectoryAsTree">
          <declaration><![CDATA[public override DirectoryItem ResolveRootDirectoryAsTree(string path)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="530" sc="3" el="541" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="03d96c1dd4b962f81b21285a76728975"><![CDATA[{
            try
            {
                Logger.DebugFormat("ResolveRootDirectoryAsTree: {0}", path);
                return GetDirectoryItemWithDNNPermissions(path);
            }
            catch (Exception ex)
            {
                DNNValidator.LogUnknownError(ex, path);
                return null;
            }
		}]]></body>
          </codeblock>
        </method>
        <method name="ShowMessage">
          <declaration><![CDATA[private void ShowMessage(string message)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="446" sc="9" el="467" ec="10">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="7e900be2602b1cf75dee4605ac00d0ce"><![CDATA[{
            var pageObject = HttpContext.Current.Handler as Page;

            if (pageObject != null)
            {
                ScriptManager.RegisterClientScriptBlock(pageObject, pageObject.GetType(), "showAlertFromServer", @"
                    function showradAlertFromServer(message)
                    {
                        function f()
                        {// MS AJAX Framework is loaded
                            Sys.Application.remove_load(f);
                            // RadFileExplorer already contains a RadWindowManager inside, so radalert can be called without problem
                            radalert(message);
                        }

                        Sys.Application.add_load(f);
                    }", true);

                var script = string.Format("showradAlertFromServer('{0}');", message);
                ScriptManager.RegisterStartupScript(pageObject, pageObject.GetType(), "KEY", script, true);
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="StoreBitmap">
          <declaration><![CDATA[public override string StoreBitmap(Bitmap bitmap, string url, ImageFormat format)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="470" sc="3" el="513" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="b5597a0980cb8344c9c5f5bc7ad2b3cd"><![CDATA[{
			try
			{
				//base calls CheckWritePermissions method			
				string virtualPathAndFile = FileSystemValidation.ToVirtualPath(url);
				string virtualPath = FileSystemValidation.RemoveFileName(virtualPathAndFile);
				string returnValue = DNNValidator.OnCreateFile(virtualPathAndFile, 0);
				if (! (string.IsNullOrEmpty(returnValue)))
				{
					return returnValue;
				}

				returnValue = TelerikContent.StoreBitmap(bitmap, virtualPathAndFile, format);

				var dnnFileInfo = new Services.FileSystem.FileInfo();
				FillFileInfo(virtualPathAndFile, ref dnnFileInfo);

				//check again with real contentLength
				string errMsg = DNNValidator.OnCreateFile(virtualPathAndFile, dnnFileInfo.Size);
				if (! (string.IsNullOrEmpty(errMsg)))
				{
					TelerikContent.DeleteFile(virtualPathAndFile);
					return errMsg;
				}

				FolderInfo dnnFolder = DNNValidator.GetUserFolder(virtualPath);
				Services.FileSystem.FileInfo dnnFile = DNNFileCtrl.GetFile(dnnFileInfo.FileName, PortalSettings.PortalId, dnnFolder.FolderID);

				if (dnnFile != null)
				{
					DNNFileCtrl.UpdateFile(dnnFile.FileId, dnnFileInfo.FileName, dnnFileInfo.Extension, dnnFileInfo.Size, bitmap.Width, bitmap.Height, dnnFileInfo.ContentType, dnnFolder.FolderPath, dnnFolder.FolderID);
				}
				else
				{
					DNNFileCtrl.AddFile(PortalSettings.PortalId, dnnFileInfo.FileName, dnnFileInfo.Extension, dnnFileInfo.Size, bitmap.Width, bitmap.Height, dnnFileInfo.ContentType, dnnFolder.FolderPath, dnnFolder.FolderID, true);
				}

				return returnValue;
			}
			catch (Exception ex)
			{
				return DNNValidator.LogUnknownError(ex, url);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="StoreFile">
          <declaration><![CDATA[public override string StoreFile(System.Web.HttpPostedFile file, string path, string name, params string[] arguments)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="398" sc="3" el="400" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="8166a74dfe43765f1b157021abf47926"><![CDATA[{
			return StoreFile(Telerik.Web.UI.UploadedFile.FromHttpPostedFile(file), path, name, arguments);
		}]]></body>
          </codeblock>
        </method>
        <method name="StoreFile">
          <declaration><![CDATA[public override string StoreFile(UploadedFile file, string path, string name, params string[] arguments)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="403" sc="3" el="443" ec="4">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="2f9f042478eaee805aa1ac3e690272f5"><![CDATA[{
		    try
		    {
                // TODO: Create entries in .resx for these messages
			    Uri uri;
			    if (!Uri.TryCreate(name, UriKind.Relative, out uri))
			    {                    
                    ShowMessage(string.Format("The file {0} cannot be uploaded because it would create an invalid URL. Please, rename the file before upload.", name));
			        return "";
			    }

                var invalidChars = new[] {'<', '>', '*', '%', '&', ':', '\\', '?', '+'};
			    if (invalidChars.Any(uri.ToString().Contains))
			    {
                    ShowMessage(string.Format("The file {0} contains some invalid characters. The file name cannot contain any of the following characters: {1}", name, new String(invalidChars)));
                    return "";
                }

			    string virtualPath = FileSystemValidation.ToVirtualPath(path);

				string returnValue = DNNValidator.OnCreateFile(FileSystemValidation.CombineVirtualPath(virtualPath, name), file.ContentLength);
				if (!string.IsNullOrEmpty(returnValue))
				{
					return returnValue;
				}

                var folder = DNNValidator.GetUserFolder(virtualPath);

			    var fileInfo = new Services.FileSystem.FileInfo();
                FillFileInfo(file, ref fileInfo);

				//Add or update file
				FileManager.Instance.AddFile(folder, name, file.InputStream);

				return returnValue;
			}
			catch (Exception ex)
			{
				return DNNValidator.LogUnknownError(ex, path, name);
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_DNNFileCtrl">
          <declaration><![CDATA[private FileController _DNNFileCtrl;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_DNNFolderCtrl">
          <declaration><![CDATA[private FolderController _DNNFolderCtrl;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_DNNValidator">
          <declaration><![CDATA[private FileSystemValidation _DNNValidator;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_TelerikContent">
          <declaration><![CDATA[private FileSystemContentProvider _TelerikContent;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Logger">
          <declaration><![CDATA[private static readonly ILog Logger = LoggerSource.Instance.GetLogger(typeof(TelerikFileBrowserProvider));]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="DNNFileCtrl">
          <declaration><![CDATA[private FileController DNNFileCtrl]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="DNNFolderCtrl">
          <declaration><![CDATA[private FolderController DNNFolderCtrl]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="DNNValidator">
          <declaration><![CDATA[private FileSystemValidation DNNValidator]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="565" sc="4" el="567" ec="5">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="351394396a66260328e1daa1d582c393"><![CDATA[{
			    return _DNNValidator ?? (_DNNValidator = new FileSystemValidation());
			}]]></body>
          </codeblock>
        </property>
        <property name="NotUseRelativeUrl">
          <declaration><![CDATA[public bool NotUseRelativeUrl]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="606" sc="4" el="608" ec="5">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="c5e1198c78949e20369ec6535501fa69"><![CDATA[{
				return HttpContext.Current.Request.QueryString["nuru"] == "1";
			}]]></body>
          </codeblock>
        </property>
        <property name="PortalSettings">
          <declaration><![CDATA[private PortalSettings PortalSettings]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="573" sc="4" el="575" ec="5">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="d2e42de473ac92f0eb7a790d380ab383"><![CDATA[{
				return Entities.Portals.PortalSettings.Current;
			}]]></body>
          </codeblock>
        </property>
        <property name="TelerikContent">
          <declaration><![CDATA[private FileSystemContentProvider TelerikContent]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="581" sc="8" el="588" ec="5">Components\TelerikFileBrowserProvider.cs</location>
            <body hash="5f16485618181950b7ebef03acb5f53f"><![CDATA[{
			    return _TelerikContent ??
			        (_TelerikContent =
			            new FileSystemContentProvider(Context, SearchPatterns,
			                new[] { FileSystemValidation.HomeDirectory }, new[] { FileSystemValidation.HomeDirectory },
			                new[] { FileSystemValidation.HomeDirectory }, FileSystemValidation.ToVirtualPath(SelectedUrl),
			                FileSystemValidation.ToVirtualPath(SelectedItemTag)));
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="UpgradeController">
      <declaration><![CDATA[public class UpgradeController : IUpgradeable]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public UpgradeController()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="GetModuleDefinitionID">
          <declaration><![CDATA[private int GetModuleDefinitionID()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="102" sc="3" el="118" ec="4">Components\UpgradeController.cs</location>
            <body hash="e8be4c44edb5f7d7fe741084e623a2e0"><![CDATA[{
			// get desktop module
			DesktopModuleInfo desktopModule = DesktopModuleController.GetDesktopModuleByModuleName("DotNetNuke.RadEditorProvider", Null.NullInteger);
			if (desktopModule == null)
			{
				return -1;
			}

			//get module definition
			ModuleDefinitionInfo moduleDefinition = ModuleDefinitionController.GetModuleDefinitionByFriendlyName("RadEditor Manager", desktopModule.DesktopModuleID);
			if (moduleDefinition == null)
			{
				return -1;
			}

			return moduleDefinition.ModuleDefID;
		}]]></body>
          </codeblock>
        </method>
        <method name="UpdateConfigFilesName">
          <declaration><![CDATA[private void UpdateConfigFilesName()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="157" sc="6" el="166" ec="7">Components\UpgradeController.cs</location>
            <body hash="98bf3fb06cbe9972335148ddedae00a4"><![CDATA[{
            foreach (string file in Directory.GetFiles(HttpContext.Current.Server.MapPath(ModuleFolder + "/ConfigFile")))
            {
                var filename = Path.GetFileName(file).ToLowerInvariant();
                if (filename.StartsWith("configfile") && filename.EndsWith(".xml"))
                {
                    UpdateFileNameWithRoleId(file);
                }
            }
	    }]]></body>
          </codeblock>
        </method>
        <method name="UpdateConfigOfLinksType">
          <declaration><![CDATA[private void UpdateConfigOfLinksType()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="121" sc="3" el="130" ec="4">Components\UpgradeController.cs</location>
            <body hash="2b766f300a0de0b8a29b6e48a91b8517"><![CDATA[{
			foreach (string file in Directory.GetFiles(HttpContext.Current.Server.MapPath(ModuleFolder + "/ConfigFile")))
			{
				var filename = Path.GetFileName(file).ToLowerInvariant();
				if (filename.StartsWith("configfile") && filename.EndsWith(".xml"))
				{
					UpdateConfigOfLinksTypeInFile(file);
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="UpdateConfigOfLinksTypeInFile">
          <declaration><![CDATA[private void UpdateConfigOfLinksTypeInFile(string file)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="133" sc="3" el="154" ec="4">Components\UpgradeController.cs</location>
            <body hash="a5e9689f7696fd8bd3be4dbc96eaf635"><![CDATA[{
			try
			{
				var config = new XmlDocument();
				config.Load(file);
				var node = config.SelectSingleNode("/configuration/property[@name='LinksUseTabNames']");
				if (node != null)
				{
					var value = bool.Parse(node.InnerText);
					config.DocumentElement.RemoveChild(node);
					var newNode = config.CreateElement("property");
					newNode.SetAttribute("name", "LinksType");
					newNode.InnerText = value ? "UseTabName" : "Normal";
					config.DocumentElement.AppendChild(newNode);
					config.Save(file);
				}
			}
			catch
			{
				//ignore error here.
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="UpdateFileNameWithRoleId">
          <declaration><![CDATA[private void UpdateFileNameWithRoleId(string file)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="181" sc="6" el="205" ec="7">Components\UpgradeController.cs</location>
            <body hash="f506f17f9c7857c66cbb0e98e5730fdd"><![CDATA[{
	        var newPath = file;
            if(file.ToLowerInvariant().Contains(".host"))
            {
                var rolePart = ".RoleId." + Globals.glbRoleSuperUser;
                newPath = Regex.Replace(file, "\\.host", rolePart, RegexOptions.IgnoreCase);
            }
            else if (file.ToLowerInvariant().Contains(".admin"))
            {
                var portalSettings = new PortalSettings(Host.HostPortalID);
                var rolePart = ".RoleId." + portalSettings.AdministratorRoleId;
                newPath = Regex.Replace(file, "\\.admin", rolePart, RegexOptions.IgnoreCase);
            }
            else if (file.ToLowerInvariant().Contains(".registered"))
            {
                var portalSettings = new PortalSettings(Host.HostPortalID);
                var rolePart = ".RoleId." + portalSettings.RegisteredRoleId;
                newPath = Regex.Replace(file, "\\.registered", rolePart, RegexOptions.IgnoreCase);
            }

	        if (newPath != file)
	        {
	            File.Move(file, newPath);
	        }
	    }]]></body>
          </codeblock>
        </method>
        <method name="UpdateToolsFilesName">
          <declaration><![CDATA[private void UpdateToolsFilesName()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="169" sc="9" el="178" ec="10">Components\UpgradeController.cs</location>
            <body hash="4e00db199a125f135a7cc6499c864b5e"><![CDATA[{
            foreach (string file in Directory.GetFiles(HttpContext.Current.Server.MapPath(ModuleFolder + "/ToolsFile")))
            {
                var filename = Path.GetFileName(file).ToLowerInvariant();
                if (filename.StartsWith("toolsfile") && filename.EndsWith(".xml"))
                {
                    UpdateFileNameWithRoleId(file);
                }
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="UpgradeModule">
          <declaration><![CDATA[public string UpgradeModule(string Version)]]></declaration>
          <documentation>
            <summary>

 </summary>
 <param name="Version"></param>
 <returns></returns>
 <remarks>This is not localizing Page Name or description.</remarks></documentation>
          <codeblock>
            <location sl="53" sc="3" el="99" ec="4">Components\UpgradeController.cs</location>
            <body hash="b189d60f481ec83cd595641cdf593bd2"><![CDATA[{
			try
			{
				switch (Version)
				{
					case "06.00.00":
						string resourceFile = ModuleFolder + "/App_LocalResources/ProviderConfig.ascx.resx";
						string pageName = Localization.GetString("HTMLEditorPageName", resourceFile);
						string pageDescription = Localization.GetString("HTMLEditorPageDescription", resourceFile);

						//Create Rad Editor Config Page (or get existing one)
						TabInfo newPage = Upgrade.AddHostPage(pageName, pageDescription, ModuleFolder + "/images/radeditor_config_small.png",ModuleFolder + "/images/radeditor_config_large.png", true);

						//Add Module To Page
						int moduleDefId = GetModuleDefinitionID();
						Upgrade.AddModuleToPage(newPage, moduleDefId, pageName, ModuleFolder + "/images/radeditor_config_large.png", true);

						foreach (var item in DesktopModuleController.GetDesktopModules(Null.NullInteger))
						{
							DesktopModuleInfo moduleInfo = item.Value;

							if (moduleInfo.ModuleName == "DotNetNuke.RadEditorProvider")
							{
								moduleInfo.Category = "Host";
								DesktopModuleController.SaveDesktopModule(moduleInfo, false, false);
							}
						}
						break;
					case "07.00.06":
						UpdateConfigOfLinksType();
						break;
                    case "07.03.00":
				        UpdateConfigFilesName();
                        UpdateToolsFilesName();
                        break;
				}
			}
			catch (Exception ex)
			{
				ExceptionLogController xlc = new ExceptionLogController();
				xlc.AddLog(ex);

				return "Failed";
			}

			return "Success";
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="ModuleFolder">
          <declaration><![CDATA[private const string ModuleFolder = "~/DesktopModules/Admin/RadEditorProvider";]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="DotNetNuke.RadEditorProvider.Components">
    <class name="DnnEditor">
      <declaration><![CDATA[internal class DnnEditor : RadEditor]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public DnnEditor()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="RegisterCssReferences">
          <declaration><![CDATA[protected override void RegisterCssReferences()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="15" sc="3" el="20" ec="4">Components\DnnEditor.cs</location>
            <body hash="48e0920d1a9e49415a27577bffe0520b"><![CDATA[{
			if (!PreventDefaultStylesheet)
			{
				base.RegisterCssReferences();
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="PreventDefaultStylesheet">
          <declaration><![CDATA[public bool PreventDefaultStylesheet]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
</root>