<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<root file="DotNetNuke.log4net.dll" version="03.00.01" generated="2017-08-10 13:31:12Z" generationTime="37.0904558">
  <namespace name="">
    <class name="&lt;PrivateImplementationDetails&gt;">
      <declaration><![CDATA[internal sealed class <PrivateImplementationDetails>]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="C39436EFC512E2CEA19697D88768BD3291C7E935">
          <declaration><![CDATA[internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=54 C39436EFC512E2CEA19697D88768BD3291C7E935;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="log4net">
    <class name="GlobalContext">
      <declaration><![CDATA[public sealed class GlobalContext]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private GlobalContext()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="62" sc="3" el="64" ec="4">log4net\GlobalContext.cs</location>
            <body hash="5d3344323d0978d37d3d66ef752e226f"><![CDATA[private GlobalContext()
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static GlobalContext()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="69" sc="3" el="98" ec="96">log4net\GlobalContext.cs</location>
            <body hash="87a76b654cde7509de5f08710bbea4da"><![CDATA[{
			Properties[log4net.Core.LoggingEvent.HostNameProperty] = SystemInfo.HostName;
		}

		#region Public Static Properties

		/// <summary>
		/// The global properties map.
		/// </summary>
		/// <value>
		/// The global properties map.
		/// </value>
		/// <remarks>
		/// <para>
		/// The global properties map.
		/// </para>
		/// </remarks>
		public static GlobalContextProperties Properties
		{
			get { return s_properties; }
		}

		#endregion Public Static Properties

		#region Private Static Fields

		/// <summary>
		/// The global context properties instance
		/// </summary>
		private readonly static GlobalContextProperties s_properties = new GlobalContextProperties();]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="s_properties">
          <declaration><![CDATA[private static readonly GlobalContextProperties s_properties;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Properties">
          <declaration><![CDATA[public static GlobalContextProperties Properties]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ILog">
      <declaration><![CDATA[public interface ILog : ILoggerWrapper]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="Debug">
          <declaration><![CDATA[void Debug(object message);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Debug">
          <declaration><![CDATA[void Debug(object message, Exception exception);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="DebugFormat">
          <declaration><![CDATA[void DebugFormat(string format, params object[] args);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="DebugFormat">
          <declaration><![CDATA[void DebugFormat(string format, object arg0);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="DebugFormat">
          <declaration><![CDATA[void DebugFormat(string format, object arg0, object arg1);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="DebugFormat">
          <declaration><![CDATA[void DebugFormat(string format, object arg0, object arg1, object arg2);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="DebugFormat">
          <declaration><![CDATA[void DebugFormat(IFormatProvider provider, string format, params object[] args);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Error">
          <declaration><![CDATA[void Error(object message);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Error">
          <declaration><![CDATA[void Error(object message, Exception exception);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="ErrorFormat">
          <declaration><![CDATA[void ErrorFormat(string format, params object[] args);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="ErrorFormat">
          <declaration><![CDATA[void ErrorFormat(string format, object arg0);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="ErrorFormat">
          <declaration><![CDATA[void ErrorFormat(string format, object arg0, object arg1);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="ErrorFormat">
          <declaration><![CDATA[void ErrorFormat(string format, object arg0, object arg1, object arg2);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="ErrorFormat">
          <declaration><![CDATA[void ErrorFormat(IFormatProvider provider, string format, params object[] args);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Fatal">
          <declaration><![CDATA[void Fatal(object message);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Fatal">
          <declaration><![CDATA[void Fatal(object message, Exception exception);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="FatalFormat">
          <declaration><![CDATA[void FatalFormat(string format, params object[] args);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="FatalFormat">
          <declaration><![CDATA[void FatalFormat(string format, object arg0);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="FatalFormat">
          <declaration><![CDATA[void FatalFormat(string format, object arg0, object arg1);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="FatalFormat">
          <declaration><![CDATA[void FatalFormat(string format, object arg0, object arg1, object arg2);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="FatalFormat">
          <declaration><![CDATA[void FatalFormat(IFormatProvider provider, string format, params object[] args);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Info">
          <declaration><![CDATA[void Info(object message);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Info">
          <declaration><![CDATA[void Info(object message, Exception exception);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="InfoFormat">
          <declaration><![CDATA[void InfoFormat(string format, params object[] args);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="InfoFormat">
          <declaration><![CDATA[void InfoFormat(string format, object arg0);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="InfoFormat">
          <declaration><![CDATA[void InfoFormat(string format, object arg0, object arg1);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="InfoFormat">
          <declaration><![CDATA[void InfoFormat(string format, object arg0, object arg1, object arg2);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="InfoFormat">
          <declaration><![CDATA[void InfoFormat(IFormatProvider provider, string format, params object[] args);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Warn">
          <declaration><![CDATA[void Warn(object message);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Warn">
          <declaration><![CDATA[void Warn(object message, Exception exception);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="WarnFormat">
          <declaration><![CDATA[void WarnFormat(string format, params object[] args);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="WarnFormat">
          <declaration><![CDATA[void WarnFormat(string format, object arg0);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="WarnFormat">
          <declaration><![CDATA[void WarnFormat(string format, object arg0, object arg1);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="WarnFormat">
          <declaration><![CDATA[void WarnFormat(string format, object arg0, object arg1, object arg2);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="WarnFormat">
          <declaration><![CDATA[void WarnFormat(IFormatProvider provider, string format, params object[] args);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="IsDebugEnabled">
          <declaration><![CDATA[bool IsDebugEnabled]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IsErrorEnabled">
          <declaration><![CDATA[bool IsErrorEnabled]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IsFatalEnabled">
          <declaration><![CDATA[bool IsFatalEnabled]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IsInfoEnabled">
          <declaration><![CDATA[bool IsInfoEnabled]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IsWarnEnabled">
          <declaration><![CDATA[bool IsWarnEnabled]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="LogicalThreadContext">
      <declaration><![CDATA[public sealed class LogicalThreadContext]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private LogicalThreadContext()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="92" sc="3" el="94" ec="4">log4net\LogicalThreadContext.cs</location>
            <body hash="2c532570e61091073cb3066350c8747f"><![CDATA[private LogicalThreadContext()
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static LogicalThreadContext()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="140" sc="3" el="145" ec="110">log4net\LogicalThreadContext.cs</location>
            <body hash="cbf20df6f57ab3251ec993a4298c7623"><![CDATA[private readonly static LogicalThreadContextProperties s_properties = new LogicalThreadContextProperties();

		/// <summary>
		/// The thread context stacks instance
		/// </summary>
		private readonly static LogicalThreadContextStacks s_stacks = new LogicalThreadContextStacks(s_properties);]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="s_properties">
          <declaration><![CDATA[private static readonly LogicalThreadContextProperties s_properties = new LogicalThreadContextProperties();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="s_stacks">
          <declaration><![CDATA[private static readonly LogicalThreadContextStacks s_stacks = new LogicalThreadContextStacks(LogicalThreadContext.s_properties);]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Properties">
          <declaration><![CDATA[public static LogicalThreadContextProperties Properties]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Stacks">
          <declaration><![CDATA[public static LogicalThreadContextStacks Stacks]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="LogManager">
      <declaration><![CDATA[public sealed class LogManager]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private LogManager()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="68" sc="3" el="70" ec="4">log4net\LogManager.cs</location>
            <body hash="5d0fe7e9551dddd78b9e9556a3acfc94"><![CDATA[private LogManager()
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static LogManager()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="823" sc="3" el="823" ec="120">log4net\LogManager.cs</location>
            <body hash="dddbcafdb9dfc8499dcd9de5efc97fb9"><![CDATA[private static readonly WrapperMap s_wrapperMap = new WrapperMap(new WrapperCreationHandler(WrapperCreationHandler))]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CreateDomain">
          <deprecation>Use CreateRepository instead of CreateDomain</deprecation>
          <declaration><![CDATA[public static ILoggerRepository CreateDomain(Type repositoryType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="581" sc="3" el="583" ec="4">log4net\LogManager.cs</location>
            <body hash="3271f379a22483c4bffa20200075e005"><![CDATA[{
			return CreateRepository(Assembly.GetCallingAssembly(), repositoryType);
		}]]></body>
          </codeblock>
        </method>
        <method name="CreateDomain">
          <deprecation>Use CreateRepository instead of CreateDomain</deprecation>
          <declaration><![CDATA[public static ILoggerRepository CreateDomain(string repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="627" sc="3" el="629" ec="4">log4net\LogManager.cs</location>
            <body hash="0bafad225efdb0d08eba029c4beabfcc"><![CDATA[{
			return LoggerManager.CreateRepository(repository);
		}]]></body>
          </codeblock>
        </method>
        <method name="CreateDomain">
          <deprecation>Use CreateRepository instead of CreateDomain</deprecation>
          <declaration><![CDATA[public static ILoggerRepository CreateDomain(string repository, Type repositoryType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="672" sc="3" el="674" ec="4">log4net\LogManager.cs</location>
            <body hash="8f94f9180a5452d8b2bf28d5f0446e9d"><![CDATA[{
			return LoggerManager.CreateRepository(repository, repositoryType);
		}]]></body>
          </codeblock>
        </method>
        <method name="CreateDomain">
          <deprecation>Use CreateRepository instead of CreateDomain</deprecation>
          <declaration><![CDATA[public static ILoggerRepository CreateDomain(Assembly repositoryAssembly, Type repositoryType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="716" sc="3" el="718" ec="4">log4net\LogManager.cs</location>
            <body hash="0c53dbc6e7477b1cac47f560e0c24f24"><![CDATA[{
			return LoggerManager.CreateRepository(repositoryAssembly, repositoryType);
		}]]></body>
          </codeblock>
        </method>
        <method name="CreateRepository">
          <declaration><![CDATA[public static ILoggerRepository CreateRepository(Type repositoryType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="601" sc="3" el="603" ec="4">log4net\LogManager.cs</location>
            <body hash="3271f379a22483c4bffa20200075e005"><![CDATA[{
			return CreateRepository(Assembly.GetCallingAssembly(), repositoryType);
		}]]></body>
          </codeblock>
        </method>
        <method name="CreateRepository">
          <declaration><![CDATA[public static ILoggerRepository CreateRepository(string repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="648" sc="3" el="650" ec="4">log4net\LogManager.cs</location>
            <body hash="0bafad225efdb0d08eba029c4beabfcc"><![CDATA[{
			return LoggerManager.CreateRepository(repository);
		}]]></body>
          </codeblock>
        </method>
        <method name="CreateRepository">
          <declaration><![CDATA[public static ILoggerRepository CreateRepository(string repository, Type repositoryType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="692" sc="3" el="694" ec="4">log4net\LogManager.cs</location>
            <body hash="8f94f9180a5452d8b2bf28d5f0446e9d"><![CDATA[{
			return LoggerManager.CreateRepository(repository, repositoryType);
		}]]></body>
          </codeblock>
        </method>
        <method name="CreateRepository">
          <declaration><![CDATA[public static ILoggerRepository CreateRepository(Assembly repositoryAssembly, Type repositoryType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="736" sc="3" el="738" ec="4">log4net\LogManager.cs</location>
            <body hash="0c53dbc6e7477b1cac47f560e0c24f24"><![CDATA[{
			return LoggerManager.CreateRepository(repositoryAssembly, repositoryType);
		}]]></body>
          </codeblock>
        </method>
        <method name="Exists">
          <declaration><![CDATA[public static ILog Exists(string name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="90" sc="3" el="92" ec="4">log4net\LogManager.cs</location>
            <body hash="7407fcf674fbaf30f95d7464b0458085"><![CDATA[{
			return Exists(Assembly.GetCallingAssembly(), name);
		}]]></body>
          </codeblock>
        </method>
        <method name="Exists">
          <declaration><![CDATA[public static ILog Exists(string repository, string name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="148" sc="3" el="150" ec="4">log4net\LogManager.cs</location>
            <body hash="8d14b0fdf638651bc2732929b072372e"><![CDATA[{
			return WrapLogger(LoggerManager.Exists(repository, name));
		}]]></body>
          </codeblock>
        </method>
        <method name="Exists">
          <declaration><![CDATA[public static ILog Exists(Assembly repositoryAssembly, string name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="169" sc="3" el="171" ec="4">log4net\LogManager.cs</location>
            <body hash="6b14d73617fda7ffd96d7ca6df7f8223"><![CDATA[{
			return WrapLogger(LoggerManager.Exists(repositoryAssembly, name));
		}]]></body>
          </codeblock>
        </method>
        <method name="Flush">
          <declaration><![CDATA[public static bool Flush(int millisecondsTimeout)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="760" sc="13" el="774" ec="14">log4net\LogManager.cs</location>
            <body hash="820ff4b170d26cab22083c8c7535660b"><![CDATA[{
#if !NETSTANDARD1_3 // Excluded because GetCallingAssembly() is not available in CoreFX (https://github.com/dotnet/corefx/issues/2221).
                Appender.IFlushable flushableRepository = LoggerManager.GetRepository(Assembly.GetCallingAssembly()) as Appender.IFlushable;
                if (flushableRepository == null)
                {
                    return false;
                }
                else
                {
                    return flushableRepository.Flush(millisecondsTimeout);
                }
#else
                return false;
#endif
            }]]></body>
          </codeblock>
        </method>
        <method name="GetAllRepositories">
          <declaration><![CDATA[public static ILoggerRepository[] GetAllRepositories()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="750" sc="3" el="752" ec="4">log4net\LogManager.cs</location>
            <body hash="1c364c7abff2d80c451af43460da8844"><![CDATA[{
			return LoggerManager.GetAllRepositories();
		}]]></body>
          </codeblock>
        </method>
        <method name="GetCurrentLoggers">
          <declaration><![CDATA[public static ILog[] GetCurrentLoggers()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="103" sc="3" el="105" ec="4">log4net\LogManager.cs</location>
            <body hash="7ef021064c731aec6a5ee6c271e3ddf0"><![CDATA[{
			return GetCurrentLoggers(Assembly.GetCallingAssembly());
		}]]></body>
          </codeblock>
        </method>
        <method name="GetCurrentLoggers">
          <declaration><![CDATA[public static ILog[] GetCurrentLoggers(string repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="182" sc="3" el="184" ec="4">log4net\LogManager.cs</location>
            <body hash="fadda279198a53efeb0ae4fd88f98462"><![CDATA[{
			return WrapLoggers(LoggerManager.GetCurrentLoggers(repository));
		}]]></body>
          </codeblock>
        </method>
        <method name="GetCurrentLoggers">
          <declaration><![CDATA[public static ILog[] GetCurrentLoggers(Assembly repositoryAssembly)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="195" sc="3" el="197" ec="4">log4net\LogManager.cs</location>
            <body hash="648c7592a79143d7a37cb61ab5dd5a89"><![CDATA[{
			return WrapLoggers(LoggerManager.GetCurrentLoggers(repositoryAssembly));
		}]]></body>
          </codeblock>
        </method>
        <method name="GetLogger">
          <declaration><![CDATA[public static ILog GetLogger(string name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="126" sc="3" el="128" ec="4">log4net\LogManager.cs</location>
            <body hash="adf088c7a1128149b64f06538a12a956"><![CDATA[{
			return GetLogger(Assembly.GetCallingAssembly(), name);
		}]]></body>
          </codeblock>
        </method>
        <method name="GetLogger">
          <declaration><![CDATA[public static ILog GetLogger(string repository, string name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="219" sc="3" el="221" ec="4">log4net\LogManager.cs</location>
            <body hash="5719f1ffe407521884a0b3ae040b4d4a"><![CDATA[{
			return WrapLogger(LoggerManager.GetLogger(repository, name));
		}]]></body>
          </codeblock>
        </method>
        <method name="GetLogger">
          <declaration><![CDATA[public static ILog GetLogger(Assembly repositoryAssembly, string name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="243" sc="3" el="245" ec="4">log4net\LogManager.cs</location>
            <body hash="6491361a1ba1a048ca9a067b5acac4c5"><![CDATA[{
			return WrapLogger(LoggerManager.GetLogger(repositoryAssembly, name));
		}]]></body>
          </codeblock>
        </method>
        <method name="GetLogger">
          <declaration><![CDATA[public static ILog GetLogger(Type type)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="256" sc="3" el="262" ec="4">log4net\LogManager.cs</location>
            <body hash="18030c1f5980dda82094d6678fddf721"><![CDATA[{
#if NETSTANDARD1_3
			return GetLogger(type.GetTypeInfo().Assembly, type.FullName);
#else
			return GetLogger(Assembly.GetCallingAssembly(), type.FullName);
#endif
		}]]></body>
          </codeblock>
        </method>
        <method name="GetLogger">
          <declaration><![CDATA[public static ILog GetLogger(string repository, Type type)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="274" sc="3" el="276" ec="4">log4net\LogManager.cs</location>
            <body hash="65b9d31f10e0186c6720dffc1747027d"><![CDATA[{
			return WrapLogger(LoggerManager.GetLogger(repository, type));
		}]]></body>
          </codeblock>
        </method>
        <method name="GetLogger">
          <declaration><![CDATA[public static ILog GetLogger(Assembly repositoryAssembly, Type type)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="288" sc="3" el="290" ec="4">log4net\LogManager.cs</location>
            <body hash="cb648c944db7a027ae90c21dfc596c4e"><![CDATA[{
			return WrapLogger(LoggerManager.GetLogger(repositoryAssembly, type));
		}]]></body>
          </codeblock>
        </method>
        <method name="GetLoggerRepository">
          <deprecation>Use GetRepository instead of GetLoggerRepository</deprecation>
          <declaration><![CDATA[public static ILoggerRepository GetLoggerRepository()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="471" sc="3" el="473" ec="4">log4net\LogManager.cs</location>
            <body hash="640a46884b1a26105313d6f33f62173e"><![CDATA[{
			return GetRepository(Assembly.GetCallingAssembly());
		}]]></body>
          </codeblock>
        </method>
        <method name="GetLoggerRepository">
          <deprecation>Use GetRepository instead of GetLoggerRepository</deprecation>
          <declaration><![CDATA[public static ILoggerRepository GetLoggerRepository(string repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="489" sc="3" el="491" ec="4">log4net\LogManager.cs</location>
            <body hash="fd0b53dc25f32f5043b32ea8cf7445bb"><![CDATA[{
			return GetRepository(repository);
		}]]></body>
          </codeblock>
        </method>
        <method name="GetLoggerRepository">
          <deprecation>Use GetRepository instead of GetLoggerRepository</deprecation>
          <declaration><![CDATA[public static ILoggerRepository GetLoggerRepository(Assembly repositoryAssembly)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="506" sc="3" el="508" ec="4">log4net\LogManager.cs</location>
            <body hash="386da14dce1f8add36f5fa0eb2834c22"><![CDATA[{
			return GetRepository(repositoryAssembly);
		}]]></body>
          </codeblock>
        </method>
        <method name="GetRepository">
          <declaration><![CDATA[public static ILoggerRepository GetRepository()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="523" sc="3" el="525" ec="4">log4net\LogManager.cs</location>
            <body hash="640a46884b1a26105313d6f33f62173e"><![CDATA[{
			return GetRepository(Assembly.GetCallingAssembly());
		}]]></body>
          </codeblock>
        </method>
        <method name="GetRepository">
          <declaration><![CDATA[public static ILoggerRepository GetRepository(string repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="540" sc="3" el="542" ec="4">log4net\LogManager.cs</location>
            <body hash="4b30dc43fadec1a98d7282300bc043dd"><![CDATA[{
			return LoggerManager.GetRepository(repository);
		}]]></body>
          </codeblock>
        </method>
        <method name="GetRepository">
          <declaration><![CDATA[public static ILoggerRepository GetRepository(Assembly repositoryAssembly)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="556" sc="3" el="558" ec="4">log4net\LogManager.cs</location>
            <body hash="55e8680ce7ad7ab4891d5dd25f1109a9"><![CDATA[{
			return LoggerManager.GetRepository(repositoryAssembly);
		}]]></body>
          </codeblock>
        </method>
        <method name="ResetConfiguration">
          <declaration><![CDATA[public static void ResetConfiguration()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="414" sc="3" el="416" ec="4">log4net\LogManager.cs</location>
            <body hash="7a21087a4ae94f574bbabdd3886b2284"><![CDATA[{
			ResetConfiguration(Assembly.GetCallingAssembly());
		}]]></body>
          </codeblock>
        </method>
        <method name="ResetConfiguration">
          <declaration><![CDATA[public static void ResetConfiguration(string repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="434" sc="3" el="436" ec="4">log4net\LogManager.cs</location>
            <body hash="40c1e5328846b9359572cf3a41586efd"><![CDATA[{
			LoggerManager.ResetConfiguration(repository);
		}]]></body>
          </codeblock>
        </method>
        <method name="ResetConfiguration">
          <declaration><![CDATA[public static void ResetConfiguration(Assembly repositoryAssembly)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="453" sc="3" el="455" ec="4">log4net\LogManager.cs</location>
            <body hash="c9bd7f7e2589ce1d3ac2d6ddefb02237"><![CDATA[{
			LoggerManager.ResetConfiguration(repositoryAssembly);
		}]]></body>
          </codeblock>
        </method>
        <method name="Shutdown">
          <declaration><![CDATA[public static void Shutdown()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="316" sc="3" el="318" ec="4">log4net\LogManager.cs</location>
            <body hash="84ad5be84f6bdf8f56a2738726da8c24"><![CDATA[{
			LoggerManager.Shutdown();
		}]]></body>
          </codeblock>
        </method>
        <method name="ShutdownRepository">
          <declaration><![CDATA[public static void ShutdownRepository()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="341" sc="3" el="343" ec="4">log4net\LogManager.cs</location>
            <body hash="1bf41b9c7dd453c065b4cb51da9ab7ca"><![CDATA[{
			ShutdownRepository(Assembly.GetCallingAssembly());
		}]]></body>
          </codeblock>
        </method>
        <method name="ShutdownRepository">
          <declaration><![CDATA[public static void ShutdownRepository(string repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="367" sc="3" el="369" ec="4">log4net\LogManager.cs</location>
            <body hash="08a69139e59982859ad583f379f95f29"><![CDATA[{
			LoggerManager.ShutdownRepository(repository);
		}]]></body>
          </codeblock>
        </method>
        <method name="ShutdownRepository">
          <declaration><![CDATA[public static void ShutdownRepository(Assembly repositoryAssembly)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="394" sc="3" el="396" ec="4">log4net\LogManager.cs</location>
            <body hash="6df2b44d53a845d556f531c6a6e46a2d"><![CDATA[{
			LoggerManager.ShutdownRepository(repositoryAssembly);
		}]]></body>
          </codeblock>
        </method>
        <method name="WrapLogger">
          <declaration><![CDATA[private static ILog WrapLogger(ILogger logger)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="786" sc="3" el="788" ec="4">log4net\LogManager.cs</location>
            <body hash="975a490acc2c1dd6db09e57651b02682"><![CDATA[{
			return (ILog)s_wrapperMap.GetWrapper(logger);
		}]]></body>
          </codeblock>
        </method>
        <method name="WrapLoggers">
          <declaration><![CDATA[private static ILog[] WrapLoggers(ILogger[] loggers)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="796" sc="3" el="803" ec="4">log4net\LogManager.cs</location>
            <body hash="ebfeac2ba953ffaa4a3d204101f407bf"><![CDATA[{
			ILog[] results = new ILog[loggers.Length];
			for(int i=0; i<loggers.Length; i++)
			{
				results[i] = WrapLogger(loggers[i]);
			}
			return results;
		}]]></body>
          </codeblock>
        </method>
        <method name="WrapperCreationHandler">
          <declaration><![CDATA[private static ILoggerWrapper WrapperCreationHandler(ILogger logger)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="812" sc="3" el="814" ec="4">log4net\LogManager.cs</location>
            <body hash="00933b9531c07f5ca1f7bd6265667df4"><![CDATA[{
			return new LogImpl(logger);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="s_wrapperMap">
          <declaration><![CDATA[private static readonly WrapperMap s_wrapperMap = new WrapperMap(new WrapperCreationHandler(LogManager.WrapperCreationHandler));]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="MDC">
      <declaration><![CDATA[public sealed class MDC]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private MDC()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="61" sc="3" el="63" ec="4">log4net\MDC.cs</location>
            <body hash="8bda21f4bec2e9575b73b03ac968cf6d"><![CDATA[private MDC()
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Clear">
          <declaration><![CDATA[public static void Clear()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="163" sc="3" el="165" ec="4">log4net\MDC.cs</location>
            <body hash="8f79fb893a20959056bfd0e4dbfaf73d"><![CDATA[{
			ThreadContext.Properties.Clear();
		}]]></body>
          </codeblock>
        </method>
        <method name="Get">
          <declaration><![CDATA[public static string Get(string key)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="88" sc="3" el="95" ec="4">log4net\MDC.cs</location>
            <body hash="d25a227e36d1f4b0aa5e38aa6c57067b"><![CDATA[{
			object obj = ThreadContext.Properties[key];
			if (obj == null)
			{
				return null;
			}
			return obj.ToString();
		}]]></body>
          </codeblock>
        </method>
        <method name="Remove">
          <declaration><![CDATA[public static void Remove(string key)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="143" sc="3" el="145" ec="4">log4net\MDC.cs</location>
            <body hash="c29233aad835d742b0dd8bed937bde20"><![CDATA[{
			ThreadContext.Properties.Remove(key);
		}]]></body>
          </codeblock>
        </method>
        <method name="Set">
          <declaration><![CDATA[public static void Set(string key, string value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="122" sc="3" el="124" ec="4">log4net\MDC.cs</location>
            <body hash="e556d7cf7670e800cbf298a5f6b94273"><![CDATA[{
			ThreadContext.Properties[key] = value;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="NDC">
      <declaration><![CDATA[public sealed class NDC]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private NDC()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="79" sc="3" el="81" ec="4">log4net\NDC.cs</location>
            <body hash="cbc2f5f22c7e6b06102479b2c44f2ad7"><![CDATA[private NDC()
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Clear">
          <declaration><![CDATA[public static void Clear()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="133" sc="3" el="135" ec="4">log4net\NDC.cs</location>
            <body hash="b41766a5a9e9225672a6f744de3b6c0c"><![CDATA[{
			ThreadContext.Stacks["NDC"].Clear();
		}]]></body>
          </codeblock>
        </method>
        <method name="CloneStack">
          <declaration><![CDATA[public static Stack CloneStack()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="156" sc="3" el="158" ec="4">log4net\NDC.cs</location>
            <body hash="4ec8e97facc40b940ded2fac29a60c36"><![CDATA[{
			return ThreadContext.Stacks["NDC"].InternalStack;
		}]]></body>
          </codeblock>
        </method>
        <method name="Inherit">
          <declaration><![CDATA[public static void Inherit(Stack stack)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="183" sc="3" el="185" ec="4">log4net\NDC.cs</location>
            <body hash="11092c47b1232b30b669dcac44561d9b"><![CDATA[{
			ThreadContext.Stacks["NDC"].InternalStack = stack;
		}]]></body>
          </codeblock>
        </method>
        <method name="Pop">
          <declaration><![CDATA[public static string Pop()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="209" sc="3" el="211" ec="4">log4net\NDC.cs</location>
            <body hash="c92d1205cf454a3bae213e2a2ac7818e"><![CDATA[{
			return ThreadContext.Stacks["NDC"].Pop();
		}]]></body>
          </codeblock>
        </method>
        <method name="Push">
          <declaration><![CDATA[public static IDisposable Push(string message)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="245" sc="3" el="247" ec="4">log4net\NDC.cs</location>
            <body hash="2f1854d72f5ce584833f27a819679cc1"><![CDATA[{
			return ThreadContext.Stacks["NDC"].Push(message);
		}]]></body>
          </codeblock>
        </method>
        <method name="PushFormat">
          <declaration><![CDATA[public static IDisposable PushFormat(string messageFormat, params object[] args)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="283" sc="3" el="285" ec="4">log4net\NDC.cs</location>
            <body hash="17c1c10a9837fc112cfeb6b4bfe7c064"><![CDATA[{
			return Push(string.Format(messageFormat, args));
		}]]></body>
          </codeblock>
        </method>
        <method name="Remove">
          <declaration><![CDATA[public static void Remove()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="304" sc="3" el="305" ec="4">log4net\NDC.cs</location>
            <body hash="d2c65ffc45d1c7103cabbde916faf7e7"><![CDATA[{
		}]]></body>
          </codeblock>
        </method>
        <method name="SetMaxDepth">
          <declaration><![CDATA[public static void SetMaxDepth(int maxDepth)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="328" sc="3" el="345" ec="4">log4net\NDC.cs</location>
            <body hash="7829683c67bcea8e6c2f519de98ab633"><![CDATA[{
			if (maxDepth >= 0)
			{
				log4net.Util.ThreadContextStack stack = ThreadContext.Stacks["NDC"];

				if (maxDepth == 0)
				{
					stack.Clear();
				}
				else
				{
					while(stack.Count > maxDepth)
					{
						stack.Pop();
					}
				}
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Depth">
          <declaration><![CDATA[public static int Depth]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ThreadContext">
      <declaration><![CDATA[public sealed class ThreadContext]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private ThreadContext()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="82" sc="3" el="84" ec="4">log4net\ThreadContext.cs</location>
            <body hash="c3b6112c30ca0b9623003608fb744702"><![CDATA[private ThreadContext()
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static ThreadContext()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="130" sc="3" el="135" ec="96">log4net\ThreadContext.cs</location>
            <body hash="2b30d0d21cf64916af8e44745944d6e7"><![CDATA[private readonly static ThreadContextProperties s_properties = new ThreadContextProperties();

		/// <summary>
		/// The thread context stacks instance
		/// </summary>
		private readonly static ThreadContextStacks s_stacks = new ThreadContextStacks(s_properties);]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="s_properties">
          <declaration><![CDATA[private static readonly ThreadContextProperties s_properties = new ThreadContextProperties();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="s_stacks">
          <declaration><![CDATA[private static readonly ThreadContextStacks s_stacks = new ThreadContextStacks(ThreadContext.s_properties);]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Properties">
          <declaration><![CDATA[public static ThreadContextProperties Properties]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Stacks">
          <declaration><![CDATA[public static ThreadContextStacks Stacks]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="log4net.Appender">
    <class name="AdoNetAppender">
      <declaration><![CDATA[public class AdoNetAppender : BufferingAppenderSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public AdoNetAppender()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="135" sc="3" el="142" ec="4">log4net\Appender\AdoNetAppender.cs</location>
            <body hash="d5b5a585bfbe9cac4fe33feb2d04e980"><![CDATA[public AdoNetAppender()
		{
			ConnectionType = "System.Data.OleDb.OleDbConnection, System.Data, Version=1.0.3300.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
			UseTransactions = true;
			CommandType = System.Data.CommandType.Text;
			m_parameters = new ArrayList();
			ReconnectOnError = false;
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static AdoNetAppender()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="855" sc="3" el="855" ec="71">log4net\Appender\AdoNetAppender.cs</location>
            <body hash="3b4bb18ac7a1fef3a2d5780593d0933e"><![CDATA[private readonly static Type declaringType = typeof(AdoNetAppender)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public override void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="408" sc="3" el="417" ec="4">log4net\Appender\AdoNetAppender.cs</location>
            <body hash="f5ace89966d82e80d664b8227efe7bc9"><![CDATA[{
			base.ActivateOptions();

			if (SecurityContext == null)
			{
				SecurityContext = SecurityContextProvider.DefaultProvider.CreateSecurityContext(this);
			}

			InitializeDatabaseConnection();
		}]]></body>
          </codeblock>
        </method>
        <method name="AddParameter">
          <declaration><![CDATA[public void AddParameter(AdoNetAppenderParameter parameter)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="515" sc="3" el="517" ec="4">log4net\Appender\AdoNetAppender.cs</location>
            <body hash="fd016264a0b057a3866e9f51e6580596"><![CDATA[{
			m_parameters.Add(parameter);
		}]]></body>
          </codeblock>
        </method>
        <method name="CreateConnection">
          <declaration><![CDATA[protected virtual IDbConnection CreateConnection(Type connectionType, string connectionString)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="633" sc="3" el="637" ec="4">log4net\Appender\AdoNetAppender.cs</location>
            <body hash="912928169d1894801d8607b0e2865911"><![CDATA[{
			IDbConnection connection = (IDbConnection)Activator.CreateInstance(connectionType);
			connection.ConnectionString = connectionString;
			return connection;
		}]]></body>
          </codeblock>
        </method>
        <method name="DiposeConnection">
          <declaration><![CDATA[private void DiposeConnection()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="758" sc="3" el="771" ec="4">log4net\Appender\AdoNetAppender.cs</location>
            <body hash="eda1d94bd9e4fb20a67edd6648b1bcbe"><![CDATA[{
			if (Connection != null)
			{
				try
				{
					Connection.Close();
				}
				catch (Exception ex)
				{
					LogLog.Warn(declaringType, "Exception while disposing cached connection object", ex);
				}
				Connection = null;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="GetLogStatement">
          <declaration><![CDATA[protected virtual string GetLogStatement(LoggingEvent logEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="609" sc="3" el="621" ec="4">log4net\Appender\AdoNetAppender.cs</location>
            <body hash="0c387a4a3089fa34e41f893c977c7930"><![CDATA[{
			if (Layout == null)
			{
				ErrorHandler.Error("AdoNetAppender: No Layout specified.");
				return "";
			}
			else
			{
				StringWriter writer = new StringWriter(System.Globalization.CultureInfo.InvariantCulture);
				Layout.Format(writer, logEvent);
				return writer.ToString();
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="InitializeDatabaseConnection">
          <declaration><![CDATA[private void InitializeDatabaseConnection()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="723" sc="3" el="749" ec="4">log4net\Appender\AdoNetAppender.cs</location>
            <body hash="7f3be7c6d85eacf3fee40d7827e9787a"><![CDATA[{
			string connectionStringContext = "Unable to determine connection string context.";
			string resolvedConnectionString = string.Empty;

			try
			{
				DiposeConnection();

				// Set the connection string
				resolvedConnectionString = ResolveConnectionString(out connectionStringContext);

				Connection = CreateConnection(ResolveConnectionType(), resolvedConnectionString);

				using (SecurityContext.Impersonate(this))
				{
					// Open the database connection
					Connection.Open();
				}
			}
			catch (Exception e)
			{
				// Sadly, your connection string is bad.
				ErrorHandler.Error("Could not open database connection [" + resolvedConnectionString + "]. Connection string context [" + connectionStringContext + "].", e);

				Connection = null;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="OnClose">
          <declaration><![CDATA[protected override void OnClose()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="432" sc="3" el="435" ec="4">log4net\Appender\AdoNetAppender.cs</location>
            <body hash="fab16547f0fd7a6c36618efc57c19697"><![CDATA[{
			base.OnClose();
			DiposeConnection();
		}]]></body>
          </codeblock>
        </method>
        <method name="ResolveConnectionString">
          <declaration><![CDATA[protected virtual string ResolveConnectionString(out string connectionStringContext)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="649" sc="3" el="685" ec="4">log4net\Appender\AdoNetAppender.cs</location>
            <body hash="c76273ffa4711132c464b766c2e9048b"><![CDATA[{
			if (ConnectionString != null && ConnectionString.Length > 0)
			{
				connectionStringContext = "ConnectionString";
				return ConnectionString;
			}

#if NET_2_0
			if (!String.IsNullOrEmpty(ConnectionStringName))
			{
				ConnectionStringSettings settings = ConfigurationManager.ConnectionStrings[ConnectionStringName];
				if (settings != null)
				{
					connectionStringContext = "ConnectionStringName";
					return settings.ConnectionString;
				}
				else
				{
					throw new LogException("Unable to find [" + ConnectionStringName + "] ConfigurationManager.ConnectionStrings item");
				}
			}
#endif

			if (AppSettingsKey != null && AppSettingsKey.Length > 0)
			{
				connectionStringContext = "AppSettingsKey";
				string appSettingsConnectionString = SystemInfo.GetAppSetting(AppSettingsKey);
				if (appSettingsConnectionString == null || appSettingsConnectionString.Length == 0)
				{
					throw new LogException("Unable to find [" + AppSettingsKey + "] AppSettings key.");
				}
				return appSettingsConnectionString;
			}

			connectionStringContext = "Unable to resolve connection string from ConnectionString, ConnectionStrings, or AppSettings.";
			return string.Empty;
		}]]></body>
          </codeblock>
        </method>
        <method name="ResolveConnectionType">
          <declaration><![CDATA[protected virtual Type ResolveConnectionType()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="703" sc="3" el="713" ec="4">log4net\Appender\AdoNetAppender.cs</location>
            <body hash="08b583911e6b9c8577414dc53e36bb7b"><![CDATA[{
			try
			{
				return SystemInfo.GetTypeFromString(ConnectionType, true, false);
			}
			catch (Exception ex)
			{
				ErrorHandler.Error("Failed to load connection type [" + ConnectionType + "]", ex);
				throw;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="SendBuffer">
          <declaration><![CDATA[protected override void SendBuffer(LoggingEvent[] events)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="452" sc="3" el="499" ec="4">log4net\Appender\AdoNetAppender.cs</location>
            <body hash="d001f8781c25fb35668a7ca6e153a5d4"><![CDATA[{
			if (ReconnectOnError && (Connection == null || Connection.State != ConnectionState.Open))
			{
				LogLog.Debug(declaringType, "Attempting to reconnect to database. Current Connection State: " + ((Connection == null) ? SystemInfo.NullText : Connection.State.ToString()));

				InitializeDatabaseConnection();
			}

			// Check that the connection exists and is open
			if (Connection != null && Connection.State == ConnectionState.Open)
			{
				if (UseTransactions)
				{
					// Create transaction
					// NJC - Do this on 2 lines because it can confuse the debugger
					using (IDbTransaction dbTran = Connection.BeginTransaction())
					{
						try
						{
							SendBuffer(dbTran, events);

							// commit transaction
							dbTran.Commit();
						}
						catch (Exception ex)
						{
							// rollback the transaction
							try
							{
								dbTran.Rollback();
							}
							catch (Exception)
							{
								// Ignore exception
							}

							// Can't insert into the database. That's a bad thing
							ErrorHandler.Error("Exception while writing to database", ex);
						}
					}
				}
				else
				{
					// Send without transaction
					SendBuffer(null, events);
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="SendBuffer">
          <declaration><![CDATA[protected virtual void SendBuffer(IDbTransaction dbTran, LoggingEvent[] events)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="537" sc="3" el="595" ec="4">log4net\Appender\AdoNetAppender.cs</location>
            <body hash="e44ae4a400569c6dd8e6f36439255971"><![CDATA[{
			// string.IsNotNullOrWhiteSpace() does not exist in ancient .NET frameworks
			if (CommandText != null && CommandText.Trim() != "")
			{
				using (IDbCommand dbCmd = Connection.CreateCommand())
				{
					// Set the command string
					dbCmd.CommandText = CommandText;

					// Set the command type
					dbCmd.CommandType = CommandType;
					// Send buffer using the prepared command object
					if (dbTran != null)
					{
						dbCmd.Transaction = dbTran;
					}
					// prepare the command, which is significantly faster
					dbCmd.Prepare();
					// run for all events
					foreach (LoggingEvent e in events)
					{
						// clear parameters that have been set
						dbCmd.Parameters.Clear();

						// Set the parameter values
						foreach (AdoNetAppenderParameter param in m_parameters)
						{
							param.Prepare(dbCmd);
							param.FormatValue(dbCmd, e);
						}

						// Execute the query
						dbCmd.ExecuteNonQuery();
					}
				}
			}
			else
			{
				// create a new command
				using (IDbCommand dbCmd = Connection.CreateCommand())
				{
					if (dbTran != null)
					{
						dbCmd.Transaction = dbTran;
					}
					// run for all events
					foreach (LoggingEvent e in events)
					{
						// Get the command text from the Layout
						string logStatement = GetLogStatement(e);

						LogLog.Debug(declaringType, "LogStatement [" + logStatement + "]");

						dbCmd.CommandText = logStatement;
						dbCmd.ExecuteNonQuery();
					}
				}
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(AdoNetAppender);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_appSettingsKey">
          <declaration><![CDATA[private string m_appSettingsKey;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_commandText">
          <declaration><![CDATA[private string m_commandText;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_commandType">
          <declaration><![CDATA[private CommandType m_commandType;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_connectionString">
          <declaration><![CDATA[private string m_connectionString;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_connectionStringName">
          <declaration><![CDATA[private string m_connectionStringName;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_connectionType">
          <declaration><![CDATA[private string m_connectionType;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_dbConnection">
          <declaration><![CDATA[private IDbConnection m_dbConnection;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_parameters">
          <declaration><![CDATA[protected ArrayList m_parameters;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_reconnectOnError">
          <declaration><![CDATA[private bool m_reconnectOnError;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_securityContext">
          <declaration><![CDATA[private SecurityContext m_securityContext;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_useTransactions">
          <declaration><![CDATA[private bool m_useTransactions;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="AppSettingsKey">
          <declaration><![CDATA[public string AppSettingsKey]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="CommandText">
          <declaration><![CDATA[public string CommandText]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="CommandType">
          <declaration><![CDATA[public CommandType CommandType]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Connection">
          <declaration><![CDATA[protected IDbConnection Connection]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="ConnectionString">
          <declaration><![CDATA[public string ConnectionString]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="ConnectionStringName">
          <declaration><![CDATA[public string ConnectionStringName]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="ConnectionType">
          <declaration><![CDATA[public string ConnectionType]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="ReconnectOnError">
          <declaration><![CDATA[public bool ReconnectOnError]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="SecurityContext">
          <declaration><![CDATA[public SecurityContext SecurityContext]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="UseTransactions">
          <declaration><![CDATA[public bool UseTransactions]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="AdoNetAppenderParameter">
      <declaration><![CDATA[public class AdoNetAppenderParameter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private bool m_inferType = true;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="883" sc="3" el="1124" ec="35">log4net\Appender\AdoNetAppender.cs</location>
            <body hash="3eb4235e6ae7a62e3c92bb3de8027dc0"><![CDATA[public AdoNetAppenderParameter()
		{
			Precision = 0;
			Scale = 0;
			Size = 0;
		}

		#endregion // Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Gets or sets the name of this parameter.
		/// </summary>
		/// <value>
		/// The name of this parameter.
		/// </value>
		/// <remarks>
		/// <para>
		/// The name of this parameter. The parameter name
		/// must match up to a named parameter to the SQL stored procedure
		/// or prepared statement.
		/// </para>
		/// </remarks>
		public string ParameterName
		{
			get { return m_parameterName; }
			set { m_parameterName = value; }
		}

		/// <summary>
		/// Gets or sets the database type for this parameter.
		/// </summary>
		/// <value>
		/// The database type for this parameter.
		/// </value>
		/// <remarks>
		/// <para>
		/// The database type for this parameter. This property should
		/// be set to the database type from the <see cref="DbType"/>
		/// enumeration. See <see cref="IDataParameter.DbType"/>.
		/// </para>
		/// <para>
		/// This property is optional. If not specified the ADO.NET provider 
		/// will attempt to infer the type from the value.
		/// </para>
		/// </remarks>
		/// <seealso cref="IDataParameter.DbType" />
		public DbType DbType
		{
			get { return m_dbType; }
			set
			{
				m_dbType = value;
				m_inferType = false;
			}
		}

		/// <summary>
		/// Gets or sets the precision for this parameter.
		/// </summary>
		/// <value>
		/// The precision for this parameter.
		/// </value>
		/// <remarks>
		/// <para>
		/// The maximum number of digits used to represent the Value.
		/// </para>
		/// <para>
		/// This property is optional. If not specified the ADO.NET provider 
		/// will attempt to infer the precision from the value.
		/// </para>
		/// </remarks>
		/// <seealso cref="IDbDataParameter.Precision" />
		public byte Precision
		{
			get { return m_precision; }
			set { m_precision = value; }
		}

		/// <summary>
		/// Gets or sets the scale for this parameter.
		/// </summary>
		/// <value>
		/// The scale for this parameter.
		/// </value>
		/// <remarks>
		/// <para>
		/// The number of decimal places to which Value is resolved.
		/// </para>
		/// <para>
		/// This property is optional. If not specified the ADO.NET provider 
		/// will attempt to infer the scale from the value.
		/// </para>
		/// </remarks>
		/// <seealso cref="IDbDataParameter.Scale" />
		public byte Scale
		{
			get { return m_scale; }
			set { m_scale = value; }
		}

		/// <summary>
		/// Gets or sets the size for this parameter.
		/// </summary>
		/// <value>
		/// The size for this parameter.
		/// </value>
		/// <remarks>
		/// <para>
		/// The maximum size, in bytes, of the data within the column.
		/// </para>
		/// <para>
		/// This property is optional. If not specified the ADO.NET provider 
		/// will attempt to infer the size from the value.
		/// </para>
		/// <para>
		/// For BLOB data types like VARCHAR(max) it may be impossible to infer the value automatically, use -1 as the size in this case.
		/// </para>
		/// </remarks>
		/// <seealso cref="IDbDataParameter.Size" />
		public int Size
		{
			get { return m_size; }
			set { m_size = value; }
		}

		/// <summary>
		/// Gets or sets the <see cref="IRawLayout"/> to use to 
		/// render the logging event into an object for this 
		/// parameter.
		/// </summary>
		/// <value>
		/// The <see cref="IRawLayout"/> used to render the
		/// logging event into an object for this parameter.
		/// </value>
		/// <remarks>
		/// <para>
		/// The <see cref="IRawLayout"/> that renders the value for this
		/// parameter.
		/// </para>
		/// <para>
		/// The <see cref="RawLayoutConverter"/> can be used to adapt
		/// any <see cref="ILayout"/> into a <see cref="IRawLayout"/>
		/// for use in the property.
		/// </para>
		/// </remarks>
		public IRawLayout Layout
		{
			get { return m_layout; }
			set { m_layout = value; }
		}

		#endregion // Public Instance Properties

		#region Public Instance Methods

		/// <summary>
		/// Prepare the specified database command object.
		/// </summary>
		/// <param name="command">The command to prepare.</param>
		/// <remarks>
		/// <para>
		/// Prepares the database command object by adding
		/// this parameter to its collection of parameters.
		/// </para>
		/// </remarks>
		virtual public void Prepare(IDbCommand command)
		{
			// Create a new parameter
			IDbDataParameter param = command.CreateParameter();

			// Set the parameter properties
			param.ParameterName = ParameterName;

			if (!m_inferType)
			{
				param.DbType = DbType;
			}
			if (Precision != 0)
			{
				param.Precision = Precision;
			}
			if (Scale != 0)
			{
				param.Scale = Scale;
			}
			if (Size != 0)
			{
				param.Size = Size;
			}

			// Add the parameter to the collection of params
			command.Parameters.Add(param);
		}

		/// <summary>
		/// Renders the logging event and set the parameter value in the command.
		/// </summary>
		/// <param name="command">The command containing the parameter.</param>
		/// <param name="loggingEvent">The event to be rendered.</param>
		/// <remarks>
		/// <para>
		/// Renders the logging event using this parameters layout
		/// object. Sets the value of the parameter on the command object.
		/// </para>
		/// </remarks>
		virtual public void FormatValue(IDbCommand command, LoggingEvent loggingEvent)
		{
			// Lookup the parameter
			IDbDataParameter param = (IDbDataParameter)command.Parameters[ParameterName];

			// Format the value
			object formattedValue = Layout.Format(loggingEvent);

			// If the value is null then convert to a DBNull
			if (formattedValue == null)
			{
				formattedValue = DBNull.Value;
			}

			param.Value = formattedValue;
		}

		#endregion // Public Instance Methods

		#region Private Instance Fields

		/// <summary>
		/// The name of this parameter.
		/// </summary>
		private string m_parameterName;

		/// <summary>
		/// The database type for this parameter.
		/// </summary>
		private DbType m_dbType;

		/// <summary>
		/// Flag to infer type rather than use the DbType
		/// </summary>
		private bool m_inferType = true;]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="FormatValue">
          <declaration><![CDATA[public virtual void FormatValue(IDbCommand command, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1091" sc="3" el="1105" ec="4">log4net\Appender\AdoNetAppender.cs</location>
            <body hash="f4ba95264398bd2cb03d3e7d936682cf"><![CDATA[{
			// Lookup the parameter
			IDbDataParameter param = (IDbDataParameter)command.Parameters[ParameterName];

			// Format the value
			object formattedValue = Layout.Format(loggingEvent);

			// If the value is null then convert to a DBNull
			if (formattedValue == null)
			{
				formattedValue = DBNull.Value;
			}

			param.Value = formattedValue;
		}]]></body>
          </codeblock>
        </method>
        <method name="Prepare">
          <declaration><![CDATA[public virtual void Prepare(IDbCommand command)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1051" sc="3" el="1077" ec="4">log4net\Appender\AdoNetAppender.cs</location>
            <body hash="9f1675e369c4d7a96e560baf434af184"><![CDATA[{
			// Create a new parameter
			IDbDataParameter param = command.CreateParameter();

			// Set the parameter properties
			param.ParameterName = ParameterName;

			if (!m_inferType)
			{
				param.DbType = DbType;
			}
			if (Precision != 0)
			{
				param.Precision = Precision;
			}
			if (Scale != 0)
			{
				param.Scale = Scale;
			}
			if (Size != 0)
			{
				param.Size = Size;
			}

			// Add the parameter to the collection of params
			command.Parameters.Add(param);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_dbType">
          <declaration><![CDATA[private DbType m_dbType;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_inferType">
          <declaration><![CDATA[private bool m_inferType = true;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_layout">
          <declaration><![CDATA[private IRawLayout m_layout;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_parameterName">
          <declaration><![CDATA[private string m_parameterName;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_precision">
          <declaration><![CDATA[private byte m_precision;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_scale">
          <declaration><![CDATA[private byte m_scale;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_size">
          <declaration><![CDATA[private int m_size;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="DbType">
          <declaration><![CDATA[public DbType DbType]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="935" sc="4" el="938" ec="5">log4net\Appender\AdoNetAppender.cs</location>
            <body hash="96b2cf7f80bdbd1d5b3673ac6f9316b2"><![CDATA[{
				m_dbType = value;
				m_inferType = false;
			}]]></body>
          </codeblock>
        </property>
        <property name="Layout">
          <declaration><![CDATA[public IRawLayout Layout]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="ParameterName">
          <declaration><![CDATA[public string ParameterName]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Precision">
          <declaration><![CDATA[public byte Precision]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Scale">
          <declaration><![CDATA[public byte Scale]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Size">
          <declaration><![CDATA[public int Size]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="AnsiColorTerminalAppender">
      <declaration><![CDATA[public class AnsiColorTerminalAppender : AppenderSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private bool m_writeToErrorStream = false;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="228" sc="3" el="428" ec="60">log4net\Appender\AnsiColorTerminalAppender.cs</location>
            <body hash="aeec952d18d44d0663f2834fdb05eded"><![CDATA[public AnsiColorTerminalAppender() 
		{
		}

		#endregion Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Target is the value of the console output stream.
		/// </summary>
		/// <value>
		/// Target is the value of the console output stream.
		/// This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
		/// </value>
		/// <remarks>
		/// <para>
		/// Target is the value of the console output stream.
		/// This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
		/// </para>
		/// </remarks>
		virtual public string Target
		{
			get { return m_writeToErrorStream ? ConsoleError : ConsoleOut; }
			set
			{
				string trimmedTargetName = value.Trim();

				if (SystemInfo.EqualsIgnoringCase(ConsoleError, trimmedTargetName))
				{
					m_writeToErrorStream = true;
				} 
				else 
				{
					m_writeToErrorStream = false;
				}
			}
		}

		/// <summary>
		/// Add a mapping of level to color
		/// </summary>
		/// <param name="mapping">The mapping to add</param>
		/// <remarks>
		/// <para>
		/// Add a <see cref="LevelColors"/> mapping to this appender.
		/// Each mapping defines the foreground and background colours
		/// for a level.
		/// </para>
		/// </remarks>
		public void AddMapping(LevelColors mapping)
		{
			m_levelMapping.Add(mapping);
		}

		#endregion Public Instance Properties

		#region Override implementation of AppenderSkeleton

		/// <summary>
		/// This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent)"/> method.
		/// </summary>
		/// <param name="loggingEvent">The event to log.</param>
		/// <remarks>
		/// <para>
		/// Writes the event to the console.
		/// </para>
		/// <para>
		/// The format of the output will depend on the appender's layout.
		/// </para>
		/// </remarks>
		override protected void Append(log4net.Core.LoggingEvent loggingEvent) 
		{
			string loggingMessage = RenderLoggingEvent(loggingEvent);

			// see if there is a specified lookup.
			LevelColors levelColors = m_levelMapping.Lookup(loggingEvent.Level) as LevelColors;
			if (levelColors != null)
			{
				// Prepend the Ansi Color code
				loggingMessage = levelColors.CombinedColor + loggingMessage;
			}

			// on most terminals there are weird effects if we don't clear the background color
			// before the new line.  This checks to see if it ends with a newline, and if
			// so, inserts the clear codes before the newline, otherwise the clear codes
			// are inserted afterwards.
			if (loggingMessage.Length > 1)
			{
				if (loggingMessage.EndsWith("\r\n") || loggingMessage.EndsWith("\n\r")) 
				{
					loggingMessage = loggingMessage.Insert(loggingMessage.Length - 2, PostEventCodes);
				} 
				else if (loggingMessage.EndsWith("\n") || loggingMessage.EndsWith("\r")) 
				{
					loggingMessage = loggingMessage.Insert(loggingMessage.Length - 1, PostEventCodes);
				} 
				else 
				{
					loggingMessage = loggingMessage + PostEventCodes;
				}
			}
			else
			{
				if (loggingMessage[0] == '\n' || loggingMessage[0] == '\r') 
				{
					loggingMessage = PostEventCodes + loggingMessage;
				} 
				else 
				{
					loggingMessage = loggingMessage + PostEventCodes;
				}
			}

#if NETCF_1_0
			// Write to the output stream
			Console.Write(loggingMessage);
#else
			if (m_writeToErrorStream)
			{
				// Write to the error stream
				Console.Error.Write(loggingMessage);
			}
			else
			{
				// Write to the output stream
				Console.Write(loggingMessage);
			}
#endif
		
		}

		/// <summary>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </summary>
		/// <value><c>true</c></value>
		/// <remarks>
		/// <para>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </para>
		/// </remarks>
		override protected bool RequiresLayout
		{
			get { return true; }
		}

		/// <summary>
		/// Initialize the options for this appender
		/// </summary>
		/// <remarks>
		/// <para>
		/// Initialize the level to color mappings set on this appender.
		/// </para>
		/// </remarks>
		public override void ActivateOptions()
		{
			base.ActivateOptions();
			m_levelMapping.ActivateOptions();
		}

		#endregion Override implementation of AppenderSkeleton

		#region Public Static Fields

		/// <summary>
		/// The <see cref="AnsiColorTerminalAppender.Target"/> to use when writing to the Console 
		/// standard output stream.
		/// </summary>
		/// <remarks>
		/// <para>
		/// The <see cref="AnsiColorTerminalAppender.Target"/> to use when writing to the Console 
		/// standard output stream.
		/// </para>
		/// </remarks>
		public const string ConsoleOut = "Console.Out";

		/// <summary>
		/// The <see cref="AnsiColorTerminalAppender.Target"/> to use when writing to the Console 
		/// standard error output stream.
		/// </summary>
		/// <remarks>
		/// <para>
		/// The <see cref="AnsiColorTerminalAppender.Target"/> to use when writing to the Console 
		/// standard error output stream.
		/// </para>
		/// </remarks>
		public const string ConsoleError = "Console.Error";

		#endregion Public Static Fields

		#region Private Instances Fields

		/// <summary>
		/// Flag to write output to the error stream rather than the standard output stream
		/// </summary>
		private bool m_writeToErrorStream = false;

		/// <summary>
		/// Mapping from level object to color value
		/// </summary>
		private LevelMapping m_levelMapping = new LevelMapping();]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public override void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="383" sc="3" el="386" ec="4">log4net\Appender\AnsiColorTerminalAppender.cs</location>
            <body hash="087e34ab2916da3c08b5a21ce68bd8db"><![CDATA[{
			base.ActivateOptions();
			m_levelMapping.ActivateOptions();
		}]]></body>
          </codeblock>
        </method>
        <method name="AddMapping">
          <declaration><![CDATA[public void AddMapping(AnsiColorTerminalAppender.LevelColors mapping)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="279" sc="3" el="281" ec="4">log4net\Appender\AnsiColorTerminalAppender.cs</location>
            <body hash="9683e4fc6ec5e4d8a9d684ec86bdb867"><![CDATA[{
			m_levelMapping.Add(mapping);
		}]]></body>
          </codeblock>
        </method>
        <method name="Append">
          <declaration><![CDATA[protected override void Append(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="300" sc="3" el="358" ec="4">log4net\Appender\AnsiColorTerminalAppender.cs</location>
            <body hash="5be68dccf29f5b992f5f9e122b9feafd"><![CDATA[{
			string loggingMessage = RenderLoggingEvent(loggingEvent);

			// see if there is a specified lookup.
			LevelColors levelColors = m_levelMapping.Lookup(loggingEvent.Level) as LevelColors;
			if (levelColors != null)
			{
				// Prepend the Ansi Color code
				loggingMessage = levelColors.CombinedColor + loggingMessage;
			}

			// on most terminals there are weird effects if we don't clear the background color
			// before the new line.  This checks to see if it ends with a newline, and if
			// so, inserts the clear codes before the newline, otherwise the clear codes
			// are inserted afterwards.
			if (loggingMessage.Length > 1)
			{
				if (loggingMessage.EndsWith("\r\n") || loggingMessage.EndsWith("\n\r")) 
				{
					loggingMessage = loggingMessage.Insert(loggingMessage.Length - 2, PostEventCodes);
				} 
				else if (loggingMessage.EndsWith("\n") || loggingMessage.EndsWith("\r")) 
				{
					loggingMessage = loggingMessage.Insert(loggingMessage.Length - 1, PostEventCodes);
				} 
				else 
				{
					loggingMessage = loggingMessage + PostEventCodes;
				}
			}
			else
			{
				if (loggingMessage[0] == '\n' || loggingMessage[0] == '\r') 
				{
					loggingMessage = PostEventCodes + loggingMessage;
				} 
				else 
				{
					loggingMessage = loggingMessage + PostEventCodes;
				}
			}

#if NETCF_1_0
			// Write to the output stream
			Console.Write(loggingMessage);
#else
			if (m_writeToErrorStream)
			{
				// Write to the error stream
				Console.Error.Write(loggingMessage);
			}
			else
			{
				// Write to the output stream
				Console.Write(loggingMessage);
			}
#endif
		
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="ConsoleError">
          <declaration><![CDATA[public const string ConsoleError = "Console.Error";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ConsoleOut">
          <declaration><![CDATA[public const string ConsoleOut = "Console.Out";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_levelMapping">
          <declaration><![CDATA[private LevelMapping m_levelMapping = new LevelMapping();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_writeToErrorStream">
          <declaration><![CDATA[private bool m_writeToErrorStream = false;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="PostEventCodes">
          <declaration><![CDATA[private const string PostEventCodes = "\u001b[0m";]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="RequiresLayout">
          <declaration><![CDATA[protected override bool RequiresLayout]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Target">
          <declaration><![CDATA[public virtual string Target]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="253" sc="4" el="264" ec="5">log4net\Appender\AnsiColorTerminalAppender.cs</location>
            <body hash="14679ba172aaa54987739e9f39fdb7c3"><![CDATA[{
				string trimmedTargetName = value.Trim();

				if (SystemInfo.EqualsIgnoringCase(ConsoleError, trimmedTargetName))
				{
					m_writeToErrorStream = true;
				} 
				else 
				{
					m_writeToErrorStream = false;
				}
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="AppenderCollection">
      <declaration><![CDATA[public class AppenderCollection : ICollection, IEnumerable, IList, ICloneable]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_count = 0;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="70" sc="3" el="111" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="75aa957623c1b239e8abf2d2962416d5"><![CDATA[private int m_count = 0;
		private int m_version = 0;

		#endregion
	
		#region Static Wrappers

		/// <summary>
		/// Creates a read-only wrapper for a <c>AppenderCollection</c> instance.
		/// </summary>
		/// <param name="list">list to create a readonly wrapper arround</param>
		/// <returns>
		/// An <c>AppenderCollection</c> wrapper that is read-only.
		/// </returns>
		public static AppenderCollection ReadOnly(AppenderCollection list)
		{
			if(list==null) throw new ArgumentNullException("list");

			return new ReadOnlyAppenderCollection(list);
		}

		#endregion

		#region Static Fields

		/// <summary>
		/// An empty readonly static AppenderCollection
		/// </summary>
		public static readonly AppenderCollection EmptyCollection = ReadOnly(new AppenderCollection(0));

		#endregion

		#region Constructors

		/// <summary>
		/// Initializes a new instance of the <c>AppenderCollection</c> class
		/// that is empty and has the default initial capacity.
		/// </summary>
		public AppenderCollection()
		{
			m_array = new IAppender[DEFAULT_CAPACITY];
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_count = 0;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="70" sc="3" el="123" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="4e2f3d3179ccce382fa720814a12490f"><![CDATA[private int m_count = 0;
		private int m_version = 0;

		#endregion
	
		#region Static Wrappers

		/// <summary>
		/// Creates a read-only wrapper for a <c>AppenderCollection</c> instance.
		/// </summary>
		/// <param name="list">list to create a readonly wrapper arround</param>
		/// <returns>
		/// An <c>AppenderCollection</c> wrapper that is read-only.
		/// </returns>
		public static AppenderCollection ReadOnly(AppenderCollection list)
		{
			if(list==null) throw new ArgumentNullException("list");

			return new ReadOnlyAppenderCollection(list);
		}

		#endregion

		#region Static Fields

		/// <summary>
		/// An empty readonly static AppenderCollection
		/// </summary>
		public static readonly AppenderCollection EmptyCollection = ReadOnly(new AppenderCollection(0));

		#endregion

		#region Constructors

		/// <summary>
		/// Initializes a new instance of the <c>AppenderCollection</c> class
		/// that is empty and has the default initial capacity.
		/// </summary>
		public AppenderCollection()
		{
			m_array = new IAppender[DEFAULT_CAPACITY];
		}
		
		/// <summary>
		/// Initializes a new instance of the <c>AppenderCollection</c> class
		/// that has the specified initial capacity.
		/// </summary>
		/// <param name="capacity">
		/// The number of elements that the new <c>AppenderCollection</c> is initially capable of storing.
		/// </param>
		public AppenderCollection(int capacity)
		{
			m_array = new IAppender[capacity];
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_count = 0;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="70" sc="3" el="134" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="7c6b1e3d0601411f29c54ee41997183b"><![CDATA[private int m_count = 0;
		private int m_version = 0;

		#endregion
	
		#region Static Wrappers

		/// <summary>
		/// Creates a read-only wrapper for a <c>AppenderCollection</c> instance.
		/// </summary>
		/// <param name="list">list to create a readonly wrapper arround</param>
		/// <returns>
		/// An <c>AppenderCollection</c> wrapper that is read-only.
		/// </returns>
		public static AppenderCollection ReadOnly(AppenderCollection list)
		{
			if(list==null) throw new ArgumentNullException("list");

			return new ReadOnlyAppenderCollection(list);
		}

		#endregion

		#region Static Fields

		/// <summary>
		/// An empty readonly static AppenderCollection
		/// </summary>
		public static readonly AppenderCollection EmptyCollection = ReadOnly(new AppenderCollection(0));

		#endregion

		#region Constructors

		/// <summary>
		/// Initializes a new instance of the <c>AppenderCollection</c> class
		/// that is empty and has the default initial capacity.
		/// </summary>
		public AppenderCollection()
		{
			m_array = new IAppender[DEFAULT_CAPACITY];
		}
		
		/// <summary>
		/// Initializes a new instance of the <c>AppenderCollection</c> class
		/// that has the specified initial capacity.
		/// </summary>
		/// <param name="capacity">
		/// The number of elements that the new <c>AppenderCollection</c> is initially capable of storing.
		/// </param>
		public AppenderCollection(int capacity)
		{
			m_array = new IAppender[capacity];
		}

		/// <summary>
		/// Initializes a new instance of the <c>AppenderCollection</c> class
		/// that contains elements copied from the specified <c>AppenderCollection</c>.
		/// </summary>
		/// <param name="c">The <c>AppenderCollection</c> whose elements are copied to the new collection.</param>
		public AppenderCollection(AppenderCollection c)
		{
			m_array = new IAppender[c.Count];
			AddRange(c);
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_count = 0;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="70" sc="3" el="145" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="4139f9e61bd733473435fcdab4e23b6e"><![CDATA[private int m_count = 0;
		private int m_version = 0;

		#endregion
	
		#region Static Wrappers

		/// <summary>
		/// Creates a read-only wrapper for a <c>AppenderCollection</c> instance.
		/// </summary>
		/// <param name="list">list to create a readonly wrapper arround</param>
		/// <returns>
		/// An <c>AppenderCollection</c> wrapper that is read-only.
		/// </returns>
		public static AppenderCollection ReadOnly(AppenderCollection list)
		{
			if(list==null) throw new ArgumentNullException("list");

			return new ReadOnlyAppenderCollection(list);
		}

		#endregion

		#region Static Fields

		/// <summary>
		/// An empty readonly static AppenderCollection
		/// </summary>
		public static readonly AppenderCollection EmptyCollection = ReadOnly(new AppenderCollection(0));

		#endregion

		#region Constructors

		/// <summary>
		/// Initializes a new instance of the <c>AppenderCollection</c> class
		/// that is empty and has the default initial capacity.
		/// </summary>
		public AppenderCollection()
		{
			m_array = new IAppender[DEFAULT_CAPACITY];
		}
		
		/// <summary>
		/// Initializes a new instance of the <c>AppenderCollection</c> class
		/// that has the specified initial capacity.
		/// </summary>
		/// <param name="capacity">
		/// The number of elements that the new <c>AppenderCollection</c> is initially capable of storing.
		/// </param>
		public AppenderCollection(int capacity)
		{
			m_array = new IAppender[capacity];
		}

		/// <summary>
		/// Initializes a new instance of the <c>AppenderCollection</c> class
		/// that contains elements copied from the specified <c>AppenderCollection</c>.
		/// </summary>
		/// <param name="c">The <c>AppenderCollection</c> whose elements are copied to the new collection.</param>
		public AppenderCollection(AppenderCollection c)
		{
			m_array = new IAppender[c.Count];
			AddRange(c);
		}

		/// <summary>
		/// Initializes a new instance of the <c>AppenderCollection</c> class
		/// that contains elements copied from the specified <see cref="IAppender"/> array.
		/// </summary>
		/// <param name="a">The <see cref="IAppender"/> array whose elements are copied to the new list.</param>
		public AppenderCollection(IAppender[] a)
		{
			m_array = new IAppender[a.Length];
			AddRange(a);
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_count = 0;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="70" sc="3" el="156" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="74e3f5c8e4a2c65dccad209b21cfd8c8"><![CDATA[private int m_count = 0;
		private int m_version = 0;

		#endregion
	
		#region Static Wrappers

		/// <summary>
		/// Creates a read-only wrapper for a <c>AppenderCollection</c> instance.
		/// </summary>
		/// <param name="list">list to create a readonly wrapper arround</param>
		/// <returns>
		/// An <c>AppenderCollection</c> wrapper that is read-only.
		/// </returns>
		public static AppenderCollection ReadOnly(AppenderCollection list)
		{
			if(list==null) throw new ArgumentNullException("list");

			return new ReadOnlyAppenderCollection(list);
		}

		#endregion

		#region Static Fields

		/// <summary>
		/// An empty readonly static AppenderCollection
		/// </summary>
		public static readonly AppenderCollection EmptyCollection = ReadOnly(new AppenderCollection(0));

		#endregion

		#region Constructors

		/// <summary>
		/// Initializes a new instance of the <c>AppenderCollection</c> class
		/// that is empty and has the default initial capacity.
		/// </summary>
		public AppenderCollection()
		{
			m_array = new IAppender[DEFAULT_CAPACITY];
		}
		
		/// <summary>
		/// Initializes a new instance of the <c>AppenderCollection</c> class
		/// that has the specified initial capacity.
		/// </summary>
		/// <param name="capacity">
		/// The number of elements that the new <c>AppenderCollection</c> is initially capable of storing.
		/// </param>
		public AppenderCollection(int capacity)
		{
			m_array = new IAppender[capacity];
		}

		/// <summary>
		/// Initializes a new instance of the <c>AppenderCollection</c> class
		/// that contains elements copied from the specified <c>AppenderCollection</c>.
		/// </summary>
		/// <param name="c">The <c>AppenderCollection</c> whose elements are copied to the new collection.</param>
		public AppenderCollection(AppenderCollection c)
		{
			m_array = new IAppender[c.Count];
			AddRange(c);
		}

		/// <summary>
		/// Initializes a new instance of the <c>AppenderCollection</c> class
		/// that contains elements copied from the specified <see cref="IAppender"/> array.
		/// </summary>
		/// <param name="a">The <see cref="IAppender"/> array whose elements are copied to the new list.</param>
		public AppenderCollection(IAppender[] a)
		{
			m_array = new IAppender[a.Length];
			AddRange(a);
		}
		
		/// <summary>
		/// Initializes a new instance of the <c>AppenderCollection</c> class
		/// that contains elements copied from the specified <see cref="IAppender"/> collection.
		/// </summary>
		/// <param name="col">The <see cref="IAppender"/> collection whose elements are copied to the new list.</param>
		public AppenderCollection(ICollection col)
		{
			m_array = new IAppender[col.Count];
			AddRange(col);
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_count = 0;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="70" sc="3" el="179" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="81adc862223e78d4484b27aab57dbd98"><![CDATA[private int m_count = 0;
		private int m_version = 0;

		#endregion
	
		#region Static Wrappers

		/// <summary>
		/// Creates a read-only wrapper for a <c>AppenderCollection</c> instance.
		/// </summary>
		/// <param name="list">list to create a readonly wrapper arround</param>
		/// <returns>
		/// An <c>AppenderCollection</c> wrapper that is read-only.
		/// </returns>
		public static AppenderCollection ReadOnly(AppenderCollection list)
		{
			if(list==null) throw new ArgumentNullException("list");

			return new ReadOnlyAppenderCollection(list);
		}

		#endregion

		#region Static Fields

		/// <summary>
		/// An empty readonly static AppenderCollection
		/// </summary>
		public static readonly AppenderCollection EmptyCollection = ReadOnly(new AppenderCollection(0));

		#endregion

		#region Constructors

		/// <summary>
		/// Initializes a new instance of the <c>AppenderCollection</c> class
		/// that is empty and has the default initial capacity.
		/// </summary>
		public AppenderCollection()
		{
			m_array = new IAppender[DEFAULT_CAPACITY];
		}
		
		/// <summary>
		/// Initializes a new instance of the <c>AppenderCollection</c> class
		/// that has the specified initial capacity.
		/// </summary>
		/// <param name="capacity">
		/// The number of elements that the new <c>AppenderCollection</c> is initially capable of storing.
		/// </param>
		public AppenderCollection(int capacity)
		{
			m_array = new IAppender[capacity];
		}

		/// <summary>
		/// Initializes a new instance of the <c>AppenderCollection</c> class
		/// that contains elements copied from the specified <c>AppenderCollection</c>.
		/// </summary>
		/// <param name="c">The <c>AppenderCollection</c> whose elements are copied to the new collection.</param>
		public AppenderCollection(AppenderCollection c)
		{
			m_array = new IAppender[c.Count];
			AddRange(c);
		}

		/// <summary>
		/// Initializes a new instance of the <c>AppenderCollection</c> class
		/// that contains elements copied from the specified <see cref="IAppender"/> array.
		/// </summary>
		/// <param name="a">The <see cref="IAppender"/> array whose elements are copied to the new list.</param>
		public AppenderCollection(IAppender[] a)
		{
			m_array = new IAppender[a.Length];
			AddRange(a);
		}
		
		/// <summary>
		/// Initializes a new instance of the <c>AppenderCollection</c> class
		/// that contains elements copied from the specified <see cref="IAppender"/> collection.
		/// </summary>
		/// <param name="col">The <see cref="IAppender"/> collection whose elements are copied to the new list.</param>
		public AppenderCollection(ICollection col)
		{
			m_array = new IAppender[col.Count];
			AddRange(col);
		}

		/// <summary>
		/// Type visible only to our subclasses
		/// Used to access protected constructor
		/// </summary>
		/// <exclude/>
		internal protected enum Tag 
		{
			/// <summary>
			/// A value
			/// </summary>
			Default
		}

		/// <summary>
		/// Allow subclasses to avoid our default constructors
		/// </summary>
		/// <param name="tag"></param>
		/// <exclude/>
		internal protected AppenderCollection(Tag tag)
		{
			m_array = null;
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static AppenderCollection()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="98" sc="3" el="98" ec="99">log4net\Appender\AppenderCollection.cs</location>
            <body hash="c636d7e212224ba49398ee5628ef745a"><![CDATA[public static readonly AppenderCollection EmptyCollection = ReadOnly(new AppenderCollection(0))]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Add">
          <declaration><![CDATA[public virtual int Add(IAppender item)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="270" sc="3" el="280" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="f295516af989168beb5ba8e0314bc4f2"><![CDATA[{
			if (m_count == m_array.Length)
			{
				EnsureCapacity(m_count + 1);
			}

			m_array[m_count] = item;
			m_version++;

			return m_count++;
		}]]></body>
          </codeblock>
        </method>
        <method name="AddRange">
          <declaration><![CDATA[public virtual int AddRange(AppenderCollection x)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="493" sc="3" el="504" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="0d8472a90bea124229797545dba34bc9"><![CDATA[{
			if (m_count + x.Count >= m_array.Length)
			{
				EnsureCapacity(m_count + x.Count);
			}
			
			Array.Copy(x.m_array, 0, m_array, m_count, x.Count);
			m_count += x.Count;
			m_version++;

			return m_count;
		}]]></body>
          </codeblock>
        </method>
        <method name="AddRange">
          <declaration><![CDATA[public virtual int AddRange(IAppender[] x)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="512" sc="3" el="523" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="afd08b017faf3b66473566896850f9c5"><![CDATA[{
			if (m_count + x.Length >= m_array.Length)
			{
				EnsureCapacity(m_count + x.Length);
			}

			Array.Copy(x, 0, m_array, m_count, x.Length);
			m_count += x.Length;
			m_version++;

			return m_count;
		}]]></body>
          </codeblock>
        </method>
        <method name="AddRange">
          <declaration><![CDATA[public virtual int AddRange(ICollection col)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="531" sc="3" el="543" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="32de290055b19a1d003db6950942edde"><![CDATA[{
			if (m_count + col.Count >= m_array.Length)
			{
				EnsureCapacity(m_count + col.Count);
			}

			foreach(object item in col)
			{
				Add((IAppender)item);
			}

			return m_count;
		}]]></body>
          </codeblock>
        </method>
        <method name="Clear">
          <declaration><![CDATA[public virtual void Clear()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="286" sc="3" el="290" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="78d7241dcc764554445abfe53c021f79"><![CDATA[{
			++m_version;
			m_array = new IAppender[DEFAULT_CAPACITY];
			m_count = 0;
		}]]></body>
          </codeblock>
        </method>
        <method name="Clone">
          <declaration><![CDATA[public virtual object Clone()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="297" sc="3" el="304" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="0cc70c9ad9259012df86b087262e9418"><![CDATA[{
			AppenderCollection newCol = new AppenderCollection(m_count);
			Array.Copy(m_array, 0, newCol.m_array, 0, m_count);
			newCol.m_count = m_count;
			newCol.m_version = m_version;

			return newCol;
		}]]></body>
          </codeblock>
        </method>
        <method name="Contains">
          <declaration><![CDATA[public virtual bool Contains(IAppender item)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="312" sc="3" el="321" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="3cb94335e2e358ee489dc1026763b704"><![CDATA[{
			for (int i=0; i != m_count; ++i)
			{
				if (m_array[i].Equals(item))
				{
					return true;
				}
			}
			return false;
		}]]></body>
          </codeblock>
        </method>
        <method name="CopyTo">
          <declaration><![CDATA[public virtual void CopyTo(IAppender[] array)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="199" sc="3" el="201" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="10b59a8638112a8dbe9bf9a101801af7"><![CDATA[{
			this.CopyTo(array, 0);
		}]]></body>
          </codeblock>
        </method>
        <method name="CopyTo">
          <declaration><![CDATA[public virtual void CopyTo(IAppender[] array, int start)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="210" sc="3" el="217" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="356909617fc98c0707a2955deb7b7513"><![CDATA[{
			if (m_count > array.GetUpperBound(0) + 1 - start)
			{
				throw new System.ArgumentException("Destination array was not long enough.");
			}
			
			Array.Copy(m_array, 0, array, start, m_count); 
		}]]></body>
          </codeblock>
        </method>
        <method name="EnsureCapacity">
          <declaration><![CDATA[private void EnsureCapacity(int min)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="596" sc="3" el="604" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="36181dd4bfc53e22bb4ca4f382b24b84"><![CDATA[{
			int newCapacity = ((m_array.Length == 0) ? DEFAULT_CAPACITY : m_array.Length * 2);
			if (newCapacity < min)
			{
				newCapacity = min;
			}

			this.Capacity = newCapacity;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetEnumerator">
          <declaration><![CDATA[public virtual AppenderCollection.IAppenderCollectionEnumerator GetEnumerator()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="447" sc="3" el="449" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="ebbb622c744110f8d1bac0707e083576"><![CDATA[{
			return new Enumerator(this);
		}]]></body>
          </codeblock>
        </method>
        <method name="IndexOf">
          <declaration><![CDATA[public virtual int IndexOf(IAppender item)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="333" sc="3" el="342" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="4f9aff8712a844ff66b969172807a0f6"><![CDATA[{
			for (int i=0; i != m_count; ++i)
			{
				if (m_array[i].Equals(item))
				{
					return i;
				}
			}
			return -1;
		}]]></body>
          </codeblock>
        </method>
        <method name="Insert">
          <declaration><![CDATA[public virtual void Insert(int index, IAppender item)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="355" sc="3" el="371" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="096f7827a2ecf8600dd315c69d823234"><![CDATA[{
			ValidateIndex(index, true); // throws
			
			if (m_count == m_array.Length)
			{
				EnsureCapacity(m_count + 1);
			}

			if (index < m_count)
			{
				Array.Copy(m_array, index, m_array, index + 1, m_count - index);
			}

			m_array[index] = item;
			m_count++;
			m_version++;
		}]]></body>
          </codeblock>
        </method>
        <method name="ReadOnly">
          <declaration><![CDATA[public static AppenderCollection ReadOnly(AppenderCollection list)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="85" sc="3" el="89" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="33e5b5303397ad90af590c844da9f173"><![CDATA[{
			if(list==null) throw new ArgumentNullException("list");

			return new ReadOnlyAppenderCollection(list);
		}]]></body>
          </codeblock>
        </method>
        <method name="Remove">
          <declaration><![CDATA[public virtual void Remove(IAppender item)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="381" sc="3" el="390" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="de949f961937e30af1d8adb206493d69"><![CDATA[{		   
			int i = IndexOf(item);
			if (i < 0)
			{
				throw new System.ArgumentException("Cannot remove the specified item because it was not found in the specified Collection.");
			}
			
			++m_version;
			RemoveAt(i);
		}]]></body>
          </codeblock>
        </method>
        <method name="RemoveAt">
          <declaration><![CDATA[public virtual void RemoveAt(int index)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="402" sc="3" el="418" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="04018153b623322c6d7e52a86db80e49"><![CDATA[{
			ValidateIndex(index); // throws
			
			m_count--;

			if (index < m_count)
			{
				Array.Copy(m_array, index + 1, m_array, index, m_count - index);
			}
			
			// We can't set the deleted entry equal to null, because it might be a value type.
			// Instead, we'll create an empty single-element array of the right type and copy it 
			// over the entry we want to erase.
			IAppender[] temp = new IAppender[1];
			Array.Copy(temp, 0, m_array, m_count, 1);
			m_version++;
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.ICollection.CopyTo">
          <declaration><![CDATA[void ICollection.CopyTo(Array array, int start)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="611" sc="3" el="616" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="7ba15840c946c3b5464fb39c9c82cdac"><![CDATA[{
			if (m_count > 0)
			{
				Array.Copy(m_array, 0, array, start, m_count);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IEnumerable.GetEnumerator">
          <declaration><![CDATA[IEnumerator IEnumerable.GetEnumerator()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="663" sc="3" el="665" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="7d02d007029b1701aa133378962cdce0"><![CDATA[{
			return (IEnumerator)(this.GetEnumerator());
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IList.Add">
          <declaration><![CDATA[int IList.Add(object x)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="629" sc="3" el="631" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="0df5666325423daec617b5be1ba69cd7"><![CDATA[{
			return this.Add((IAppender)x);
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IList.Contains">
          <declaration><![CDATA[bool IList.Contains(object x)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="634" sc="3" el="636" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="9a0d18ed8ad7315e96a6b860507b6230"><![CDATA[{
			return this.Contains((IAppender)x);
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IList.IndexOf">
          <declaration><![CDATA[int IList.IndexOf(object x)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="639" sc="3" el="641" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="f17f7900ac5de3c609b871237c8069f8"><![CDATA[{
			return this.IndexOf((IAppender)x);
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IList.Insert">
          <declaration><![CDATA[void IList.Insert(int pos, object x)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="644" sc="3" el="646" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="543ad576ed3741c84df703f0ec998318"><![CDATA[{
			this.Insert(pos, (IAppender)x);
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IList.Remove">
          <declaration><![CDATA[void IList.Remove(object x)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="649" sc="3" el="651" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="d23791216c2c1e3d8578ab16a647a9c3"><![CDATA[{
			this.Remove((IAppender)x);
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IList.RemoveAt">
          <declaration><![CDATA[void IList.RemoveAt(int pos)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="654" sc="3" el="656" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="e53002e980b10fa2d00afbb5c90a0118"><![CDATA[{
			this.RemoveAt(pos);
		}]]></body>
          </codeblock>
        </method>
        <method name="ToArray">
          <declaration><![CDATA[public virtual IAppender[] ToArray()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="558" sc="3" el="565" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="0e0bf4516254e5ec5e0aa4294fa3499d"><![CDATA[{
			IAppender[] resultArray = new IAppender[m_count];
			if (m_count > 0)
			{
				Array.Copy(m_array, 0, resultArray, 0, m_count);
			}
			return resultArray;
		}]]></body>
          </codeblock>
        </method>
        <method name="TrimToSize">
          <declaration><![CDATA[public virtual void TrimToSize()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="549" sc="3" el="551" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="b5df69cc284a1eeb88684b3bf89b1d2d"><![CDATA[{
			this.Capacity = m_count;
		}]]></body>
          </codeblock>
        </method>
        <method name="ValidateIndex">
          <declaration><![CDATA[private void ValidateIndex(int i)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="577" sc="3" el="579" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="7ba51ed3f3d914d29194aeca0387acc8"><![CDATA[{
			ValidateIndex(i, false);
		}]]></body>
          </codeblock>
        </method>
        <method name="ValidateIndex">
          <declaration><![CDATA[private void ValidateIndex(int i, bool allowEqualEnd)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="587" sc="3" el="593" ec="4">log4net\Appender\AppenderCollection.cs</location>
            <body hash="0dd0b75cfb3e4e5eb58308feb8976830"><![CDATA[{
			int max = (allowEqualEnd) ? (m_count) : (m_count-1);
			if (i < 0 || i > max)
			{
				throw log4net.Util.SystemInfo.CreateArgumentOutOfRangeException("i", (object)i, "Index was out of range. Must be non-negative and less than the size of the collection. [" + (object)i + "] Specified argument was out of the range of valid values.");
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="DEFAULT_CAPACITY">
          <declaration><![CDATA[private const int DEFAULT_CAPACITY = 16;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="EmptyCollection">
          <declaration><![CDATA[public static readonly AppenderCollection EmptyCollection = AppenderCollection.ReadOnly(new AppenderCollection(0));]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_array">
          <declaration><![CDATA[private IAppender[] m_array;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_count">
          <declaration><![CDATA[private int m_count = 0;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_version">
          <declaration><![CDATA[private int m_version = 0;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Capacity">
          <declaration><![CDATA[public virtual int Capacity]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="461" sc="4" el="463" ec="5">log4net\Appender\AppenderCollection.cs</location>
            <body hash="78cd26a0d2ccca573376c8e22f67dc8a"><![CDATA[{ 
				return m_array.Length; 
			}]]></body>
          </codeblock>
          <codeblock>
            <location sl="465" sc="4" el="484" ec="5">log4net\Appender\AppenderCollection.cs</location>
            <body hash="0c28831709912c68c875c029841f40dd"><![CDATA[{
				if (value < m_count)
				{
					value = m_count;
				}

				if (value != m_array.Length)
				{
					if (value > 0)
					{
						IAppender[] temp = new IAppender[value];
						Array.Copy(m_array, 0, temp, 0, m_count);
						m_array = temp;
					}
					else
					{
						m_array = new IAppender[DEFAULT_CAPACITY];
					}
				}
			}]]></body>
          </codeblock>
        </property>
        <property name="Count">
          <declaration><![CDATA[public virtual int Count]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IsFixedSize">
          <declaration><![CDATA[public virtual bool IsFixedSize]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IsReadOnly">
          <declaration><![CDATA[public virtual bool IsReadOnly]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IsSynchronized">
          <declaration><![CDATA[public virtual bool IsSynchronized]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Item">
          <declaration><![CDATA[public virtual IAppender this[int index]]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="252" sc="4" el="255" ec="5">log4net\Appender\AppenderCollection.cs</location>
            <body hash="8dd2c766f54a28c4d63c86d0a7480385"><![CDATA[{
				ValidateIndex(index); // throws
				return m_array[index]; 
			}]]></body>
          </codeblock>
          <codeblock>
            <location sl="257" sc="4" el="261" ec="5">log4net\Appender\AppenderCollection.cs</location>
            <body hash="102e9f11d0fb63e58b9453e9181a9a4c"><![CDATA[{
				ValidateIndex(index); // throws
				++m_version; 
				m_array[index] = value; 
			}]]></body>
          </codeblock>
        </property>
        <property name="SyncRoot">
          <declaration><![CDATA[public virtual object SyncRoot]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="System.Collections.IList.Item">
          <declaration><![CDATA[object IList.this[int i]]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="AppenderSkeleton">
      <declaration><![CDATA[public abstract class AppenderSkeleton : IAppender, IBulkAppender, IOptionHandler, IFlushable]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private bool m_closed = false;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="57" sc="3" el="878" ec="54">log4net\Appender\AppenderSkeleton.cs</location>
            <body hash="ab60609340d22210611ce9e989428fc2"><![CDATA[protected AppenderSkeleton()
		{
			m_errorHandler = new OnlyOnceErrorHandler(this.GetType().Name);
		}

		#endregion Protected Instance Constructors

		#region Finalizer

		/// <summary>
		/// Finalizes this appender by calling the implementation's 
		/// <see cref="Close"/> method.
		/// </summary>
		/// <remarks>
		/// <para>
		/// If this appender has not been closed then the <c>Finalize</c> method
		/// will call <see cref="Close"/>.
		/// </para>
		/// </remarks>
		~AppenderSkeleton() 
		{
			// An appender might be closed then garbage collected. 
			// There is no point in closing twice.
			if (!m_closed) 
			{
				LogLog.Debug(declaringType, "Finalizing appender named ["+m_name+"].");
				Close();
			}
		}

		#endregion Finalizer

		#region Public Instance Properties

		/// <summary>
		/// Gets or sets the threshold <see cref="Level"/> of this appender.
		/// </summary>
		/// <value>
		/// The threshold <see cref="Level"/> of the appender. 
		/// </value>
		/// <remarks>
		/// <para>
		/// All log events with lower level than the threshold level are ignored 
		/// by the appender.
		/// </para>
		/// <para>
		/// In configuration files this option is specified by setting the
		/// value of the <see cref="Threshold"/> option to a level
		/// string, such as "DEBUG", "INFO" and so on.
		/// </para>
		/// </remarks>
		public Level Threshold 
		{
			get { return m_threshold; }
			set { m_threshold = value; }
		}

		/// <summary>
		/// Gets or sets the <see cref="IErrorHandler"/> for this appender.
		/// </summary>
		/// <value>The <see cref="IErrorHandler"/> of the appender</value>
		/// <remarks>
		/// <para>
		/// The <see cref="AppenderSkeleton"/> provides a default 
		/// implementation for the <see cref="ErrorHandler"/> property. 
		/// </para>
		/// </remarks>
		virtual public IErrorHandler ErrorHandler 
		{
			get { return this.m_errorHandler; }
			set 
			{
				lock(this) 
				{
					if (value == null) 
					{
						// We do not throw exception here since the cause is probably a
						// bad config file.
						LogLog.Warn(declaringType, "You have tried to set a null error-handler.");
					} 
					else 
					{
						m_errorHandler = value;
					}
				}
			}
		}

		/// <summary>
		/// The filter chain.
		/// </summary>
		/// <value>The head of the filter chain filter chain.</value>
		/// <remarks>
		/// <para>
		/// Returns the head Filter. The Filters are organized in a linked list
		/// and so all Filters on this Appender are available through the result.
		/// </para>
		/// </remarks>
		virtual public IFilter FilterHead
		{
			get { return m_headFilter; }
		}

		/// <summary>
		/// Gets or sets the <see cref="ILayout"/> for this appender.
		/// </summary>
		/// <value>The layout of the appender.</value>
		/// <remarks>
		/// <para>
		/// See <see cref="RequiresLayout"/> for more information.
		/// </para>
		/// </remarks>
		/// <seealso cref="RequiresLayout"/>
		virtual public ILayout Layout 
		{
			get { return m_layout; }
			set { m_layout = value; }
		}

		#endregion

		#region Implementation of IOptionHandler

		/// <summary>
		/// Initialize the appender based on the options set
		/// </summary>
		/// <remarks>
		/// <para>
		/// This is part of the <see cref="IOptionHandler"/> delayed object
		/// activation scheme. The <see cref="ActivateOptions"/> method must 
		/// be called on this object after the configuration properties have
		/// been set. Until <see cref="ActivateOptions"/> is called this
		/// object is in an undefined state and must not be used. 
		/// </para>
		/// <para>
		/// If any of the configuration properties are modified then 
		/// <see cref="ActivateOptions"/> must be called again.
		/// </para>
		/// </remarks>
		virtual public void ActivateOptions() 
		{
		}

		#endregion Implementation of IOptionHandler

		#region Implementation of IAppender

		/// <summary>
		/// Gets or sets the name of this appender.
		/// </summary>
		/// <value>The name of the appender.</value>
		/// <remarks>
		/// <para>
		/// The name uniquely identifies the appender.
		/// </para>
		/// </remarks>
		public string Name 
		{
			get { return m_name; }
			set { m_name = value; }
		}

		/// <summary>
		/// Closes the appender and release resources.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Release any resources allocated within the appender such as file handles, 
		/// network connections, etc.
		/// </para>
		/// <para>
		/// It is a programming error to append to a closed appender.
		/// </para>
		/// <para>
		/// This method cannot be overridden by subclasses. This method 
		/// delegates the closing of the appender to the <see cref="OnClose"/>
		/// method which must be overridden in the subclass.
		/// </para>
		/// </remarks>
		public void Close()
		{
			// This lock prevents the appender being closed while it is still appending
			lock(this)
			{
				if (!m_closed)
				{
					OnClose();
					m_closed = true;
				}
			}
		}

		/// <summary>
		/// Performs threshold checks and invokes filters before 
		/// delegating actual logging to the subclasses specific 
		/// <see cref="M:Append(LoggingEvent)"/> method.
		/// </summary>
		/// <param name="loggingEvent">The event to log.</param>
		/// <remarks>
		/// <para>
		/// This method cannot be overridden by derived classes. A
		/// derived class should override the <see cref="M:Append(LoggingEvent)"/> method
		/// which is called by this method.
		/// </para>
		/// <para>
		/// The implementation of this method is as follows:
		/// </para>
		/// <para>
		/// <list type="bullet">
		///		<item>
		///			<description>
		///			Checks that the severity of the <paramref name="loggingEvent"/>
		///			is greater than or equal to the <see cref="Threshold"/> of this
		///			appender.</description>
		///		</item>
		///		<item>
		///			<description>
		///			Checks that the <see cref="IFilter"/> chain accepts the 
		///			<paramref name="loggingEvent"/>.
		///			</description>
		///		</item>
		///		<item>
		///			<description>
		///			Calls <see cref="M:PreAppendCheck()"/> and checks that 
		///			it returns <c>true</c>.</description>
		///		</item>
		/// </list>
		/// </para>
		/// <para>
		/// If all of the above steps succeed then the <paramref name="loggingEvent"/>
		/// will be passed to the abstract <see cref="M:Append(LoggingEvent)"/> method.
		/// </para>
		/// </remarks>
		public void DoAppend(LoggingEvent loggingEvent) 
		{
			// This lock is absolutely critical for correct formatting
			// of the message in a multi-threaded environment.  Without
			// this, the message may be broken up into elements from
			// multiple thread contexts (like get the wrong thread ID).

			lock(this)
			{
				if (m_closed)
				{
					ErrorHandler.Error("Attempted to append to closed appender named ["+m_name+"].");
					return;
				}

				// prevent re-entry
				if (m_recursiveGuard)
				{
					return;
				}

				try
				{
					m_recursiveGuard = true;

					if (FilterEvent(loggingEvent) && PreAppendCheck())
					{
						this.Append(loggingEvent);
					}
				}
				catch(Exception ex)
				{
					ErrorHandler.Error("Failed in DoAppend", ex);
				}
#if !MONO && !NET_2_0 && !NETSTANDARD1_3
				// on .NET 2.0 (and higher) and Mono (all profiles), 
				// exceptions that do not derive from System.Exception will be
				// wrapped in a RuntimeWrappedException by the runtime, and as
				// such will be catched by the catch clause above
				catch
				{
					// Catch handler for non System.Exception types
					ErrorHandler.Error("Failed in DoAppend (unknown exception)");
				}
#endif
				finally
				{
					m_recursiveGuard = false;
				}
			}
		}

		#endregion Implementation of IAppender

		#region Implementation of IBulkAppender

		/// <summary>
		/// Performs threshold checks and invokes filters before 
		/// delegating actual logging to the subclasses specific 
		/// <see cref="M:Append(LoggingEvent[])"/> method.
		/// </summary>
		/// <param name="loggingEvents">The array of events to log.</param>
		/// <remarks>
		/// <para>
		/// This method cannot be overridden by derived classes. A
		/// derived class should override the <see cref="M:Append(LoggingEvent[])"/> method
		/// which is called by this method.
		/// </para>
		/// <para>
		/// The implementation of this method is as follows:
		/// </para>
		/// <para>
		/// <list type="bullet">
		///		<item>
		///			<description>
		///			Checks that the severity of the <paramref name="loggingEvents"/>
		///			is greater than or equal to the <see cref="Threshold"/> of this
		///			appender.</description>
		///		</item>
		///		<item>
		///			<description>
		///			Checks that the <see cref="IFilter"/> chain accepts the 
		///			<paramref name="loggingEvents"/>.
		///			</description>
		///		</item>
		///		<item>
		///			<description>
		///			Calls <see cref="M:PreAppendCheck()"/> and checks that 
		///			it returns <c>true</c>.</description>
		///		</item>
		/// </list>
		/// </para>
		/// <para>
		/// If all of the above steps succeed then the <paramref name="loggingEvents"/>
		/// will be passed to the <see cref="M:Append(LoggingEvent[])"/> method.
		/// </para>
		/// </remarks>
		public void DoAppend(LoggingEvent[] loggingEvents) 
		{
			// This lock is absolutely critical for correct formatting
			// of the message in a multi-threaded environment.  Without
			// this, the message may be broken up into elements from
			// multiple thread contexts (like get the wrong thread ID).

			lock(this)
			{
				if (m_closed)
				{
					ErrorHandler.Error("Attempted to append to closed appender named ["+m_name+"].");
					return;
				}

				// prevent re-entry
				if (m_recursiveGuard)
				{
					return;
				}

				try
				{
					m_recursiveGuard = true;

					ArrayList filteredEvents = new ArrayList(loggingEvents.Length);

					foreach(LoggingEvent loggingEvent in loggingEvents)
					{
						if (FilterEvent(loggingEvent))
						{
							filteredEvents.Add(loggingEvent);
						}
					}

					if (filteredEvents.Count > 0 && PreAppendCheck())
					{
						this.Append((LoggingEvent[])filteredEvents.ToArray(typeof(LoggingEvent)));
					}
				}
				catch(Exception ex)
				{
					ErrorHandler.Error("Failed in Bulk DoAppend", ex);
				}
#if !MONO && !NET_2_0 && !NETSTANDARD1_3
				// on .NET 2.0 (and higher) and Mono (all profiles), 
				// exceptions that do not derive from System.Exception will be
				// wrapped in a RuntimeWrappedException by the runtime, and as
				// such will be catched by the catch clause above
				catch
				{
					// Catch handler for non System.Exception types
					ErrorHandler.Error("Failed in Bulk DoAppend (unknown exception)");
				}
#endif
				finally
				{
					m_recursiveGuard = false;
				}
			}
		}

		#endregion Implementation of IBulkAppender

		/// <summary>
		/// Test if the logging event should we output by this appender
		/// </summary>
		/// <param name="loggingEvent">the event to test</param>
		/// <returns><c>true</c> if the event should be output, <c>false</c> if the event should be ignored</returns>
		/// <remarks>
		/// <para>
		/// This method checks the logging event against the threshold level set
		/// on this appender and also against the filters specified on this
		/// appender.
		/// </para>
		/// <para>
		/// The implementation of this method is as follows:
		/// </para>
		/// <para>
		/// <list type="bullet">
		///		<item>
		///			<description>
		///			Checks that the severity of the <paramref name="loggingEvent"/>
		///			is greater than or equal to the <see cref="Threshold"/> of this
		///			appender.</description>
		///		</item>
		///		<item>
		///			<description>
		///			Checks that the <see cref="IFilter"/> chain accepts the 
		///			<paramref name="loggingEvent"/>.
		///			</description>
		///		</item>
		/// </list>
		/// </para>
		/// </remarks>
		virtual protected bool FilterEvent(LoggingEvent loggingEvent)
		{
			if (!IsAsSevereAsThreshold(loggingEvent.Level)) 
			{
				return false;
			}

			IFilter f = this.FilterHead;

			while(f != null) 
			{
				switch(f.Decide(loggingEvent)) 
				{
					case FilterDecision.Deny: 
						return false;	// Return without appending

					case FilterDecision.Accept:
						f = null;		// Break out of the loop
						break;

					case FilterDecision.Neutral:
						f = f.Next;		// Move to next filter
						break;
				}
			}

			return true;
		}

		#region Public Instance Methods

		/// <summary>
		/// Adds a filter to the end of the filter chain.
		/// </summary>
		/// <param name="filter">the filter to add to this appender</param>
		/// <remarks>
		/// <para>
		/// The Filters are organized in a linked list.
		/// </para>
		/// <para>
		/// Setting this property causes the new filter to be pushed onto the 
		/// back of the filter chain.
		/// </para>
		/// </remarks>
		virtual public void AddFilter(IFilter filter)
		{
			if (filter == null)
			{
				throw new ArgumentNullException("filter param must not be null");
			}

			if (m_headFilter == null) 
			{
				m_headFilter = m_tailFilter = filter;
			} 
			else 
			{
				m_tailFilter.Next = filter;
				m_tailFilter = filter;	
			}
		}

		/// <summary>
		/// Clears the filter list for this appender.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Clears the filter list for this appender.
		/// </para>
		/// </remarks>
		virtual public void ClearFilters()
		{
			m_headFilter = m_tailFilter = null;
		}

		#endregion Public Instance Methods

		#region Protected Instance Methods

		/// <summary>
		/// Checks if the message level is below this appender's threshold.
		/// </summary>
		/// <param name="level"><see cref="Level"/> to test against.</param>
		/// <remarks>
		/// <para>
		/// If there is no threshold set, then the return value is always <c>true</c>.
		/// </para>
		/// </remarks>
		/// <returns>
		/// <c>true</c> if the <paramref name="level"/> meets the <see cref="Threshold"/> 
		/// requirements of this appender.
		/// </returns>
		virtual protected bool IsAsSevereAsThreshold(Level level) 
		{
			return ((m_threshold == null) || level >= m_threshold);
		}

		/// <summary>
		/// Is called when the appender is closed. Derived classes should override 
		/// this method if resources need to be released.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Releases any resources allocated within the appender such as file handles, 
		/// network connections, etc.
		/// </para>
		/// <para>
		/// It is a programming error to append to a closed appender.
		/// </para>
		/// </remarks>
		virtual protected void OnClose() 
		{
			// Do nothing by default
		}

		/// <summary>
		/// Subclasses of <see cref="AppenderSkeleton"/> should implement this method 
		/// to perform actual logging.
		/// </summary>
		/// <param name="loggingEvent">The event to append.</param>
		/// <remarks>
		/// <para>
		/// A subclass must implement this method to perform
		/// logging of the <paramref name="loggingEvent"/>.
		/// </para>
		/// <para>This method will be called by <see cref="M:DoAppend(LoggingEvent)"/>
		/// if all the conditions listed for that method are met.
		/// </para>
		/// <para>
		/// To restrict the logging of events in the appender
		/// override the <see cref="M:PreAppendCheck()"/> method.
		/// </para>
		/// </remarks>
		abstract protected void Append(LoggingEvent loggingEvent);

		/// <summary>
		/// Append a bulk array of logging events.
		/// </summary>
		/// <param name="loggingEvents">the array of logging events</param>
		/// <remarks>
		/// <para>
		/// This base class implementation calls the <see cref="M:Append(LoggingEvent)"/>
		/// method for each element in the bulk array.
		/// </para>
		/// <para>
		/// A sub class that can better process a bulk array of events should
		/// override this method in addition to <see cref="M:Append(LoggingEvent)"/>.
		/// </para>
		/// </remarks>
		virtual protected void Append(LoggingEvent[] loggingEvents)
		{
			foreach(LoggingEvent loggingEvent in loggingEvents)
			{
				Append(loggingEvent);
			}
		}

		/// <summary>
		/// Called before <see cref="M:Append(LoggingEvent)"/> as a precondition.
		/// </summary>
		/// <remarks>
		/// <para>
		/// This method is called by <see cref="M:DoAppend(LoggingEvent)"/>
		/// before the call to the abstract <see cref="M:Append(LoggingEvent)"/> method.
		/// </para>
		/// <para>
		/// This method can be overridden in a subclass to extend the checks 
		/// made before the event is passed to the <see cref="M:Append(LoggingEvent)"/> method.
		/// </para>
		/// <para>
		/// A subclass should ensure that they delegate this call to
		/// this base class if it is overridden.
		/// </para>
		/// </remarks>
		/// <returns><c>true</c> if the call to <see cref="M:Append(LoggingEvent)"/> should proceed.</returns>
		virtual protected bool PreAppendCheck()
		{
			if ((m_layout == null) && RequiresLayout)
			{
				ErrorHandler.Error("AppenderSkeleton: No layout set for the appender named ["+m_name+"].");
				return false;
			}

			return true;
		}

		/// <summary>
		/// Renders the <see cref="LoggingEvent"/> to a string.
		/// </summary>
		/// <param name="loggingEvent">The event to render.</param>
		/// <returns>The event rendered as a string.</returns>
		/// <remarks>
		/// <para>
		/// Helper method to render a <see cref="LoggingEvent"/> to 
		/// a string. This appender must have a <see cref="Layout"/>
		/// set to render the <paramref name="loggingEvent"/> to 
		/// a string.
		/// </para>
		/// <para>If there is exception data in the logging event and 
		/// the layout does not process the exception, this method 
		/// will append the exception text to the rendered string.
		/// </para>
		/// <para>
		/// Where possible use the alternative version of this method
		/// <see cref="M:RenderLoggingEvent(TextWriter,LoggingEvent)"/>.
		/// That method streams the rendering onto an existing Writer
		/// which can give better performance if the caller already has
		/// a <see cref="TextWriter"/> open and ready for writing.
		/// </para>
		/// </remarks>
		protected string RenderLoggingEvent(LoggingEvent loggingEvent)
		{
			// Create the render writer on first use
			if (m_renderWriter == null)
			{
				m_renderWriter = new ReusableStringWriter(System.Globalization.CultureInfo.InvariantCulture);
			}

            lock (m_renderWriter)
            {
                // Reset the writer so we can reuse it
                m_renderWriter.Reset(c_renderBufferMaxCapacity, c_renderBufferSize);

                RenderLoggingEvent(m_renderWriter, loggingEvent);
                return m_renderWriter.ToString();
            }
		}

		/// <summary>
		/// Renders the <see cref="LoggingEvent"/> to a string.
		/// </summary>
		/// <param name="loggingEvent">The event to render.</param>
		/// <param name="writer">The TextWriter to write the formatted event to</param>
		/// <remarks>
		/// <para>
		/// Helper method to render a <see cref="LoggingEvent"/> to 
		/// a string. This appender must have a <see cref="Layout"/>
		/// set to render the <paramref name="loggingEvent"/> to 
		/// a string.
		/// </para>
		/// <para>If there is exception data in the logging event and 
		/// the layout does not process the exception, this method 
		/// will append the exception text to the rendered string.
		/// </para>
		/// <para>
		/// Use this method in preference to <see cref="M:RenderLoggingEvent(LoggingEvent)"/>
		/// where possible. If, however, the caller needs to render the event
		/// to a string then <see cref="M:RenderLoggingEvent(LoggingEvent)"/> does
		/// provide an efficient mechanism for doing so.
		/// </para>
		/// </remarks>
		protected void RenderLoggingEvent(TextWriter writer, LoggingEvent loggingEvent)
		{
			if (m_layout == null) 
			{
				throw new InvalidOperationException("A layout must be set");
			}

			if (m_layout.IgnoresException) 
			{
				string exceptionStr = loggingEvent.GetExceptionString();
				if (exceptionStr != null && exceptionStr.Length > 0) 
				{
					// render the event and the exception
					m_layout.Format(writer, loggingEvent);
					writer.WriteLine(exceptionStr);
				}
				else 
				{
					// there is no exception to render
					m_layout.Format(writer, loggingEvent);
				}
			}
			else 
			{
				// The layout will render the exception
				m_layout.Format(writer, loggingEvent);
			}
		}

		/// <summary>
		/// Tests if this appender requires a <see cref="Layout"/> to be set.
		/// </summary>
		/// <remarks>
		/// <para>
		/// In the rather exceptional case, where the appender 
		/// implementation admits a layout but can also work without it, 
		/// then the appender should return <c>true</c>.
		/// </para>
		/// <para>
		/// This default implementation always returns <c>false</c>.
		/// </para>
		/// </remarks>
		/// <returns>
		/// <c>true</c> if the appender requires a layout object, otherwise <c>false</c>.
		/// </returns>
		virtual protected bool RequiresLayout
		{
			get { return false; }
		}

		#endregion

		/// <summary>
        	/// Flushes any buffered log data.
        	/// </summary>
		/// <remarks>
		/// This implementation doesn't flush anything and always returns true
		/// </remarks>
        	/// <returns><c>True</c> if all logging events were flushed successfully, else <c>false</c>.</returns>
        	public virtual bool Flush(int millisecondsTimeout)
        	{
		    return true;
        	}

		#region Private Instance Fields

		/// <summary>
		/// The layout of this appender.
		/// </summary>
		/// <remarks>
		/// See <see cref="Layout"/> for more information.
		/// </remarks>
		private ILayout m_layout;

		/// <summary>
		/// The name of this appender.
		/// </summary>
		/// <remarks>
		/// See <see cref="Name"/> for more information.
		/// </remarks>
		private string m_name;

		/// <summary>
		/// The level threshold of this appender.
		/// </summary>
		/// <remarks>
		/// <para>
		/// There is no level threshold filtering by default.
		/// </para>
		/// <para>
		/// See <see cref="Threshold"/> for more information.
		/// </para>
		/// </remarks>
		private Level m_threshold;

		/// <summary>
		/// It is assumed and enforced that errorHandler is never null.
		/// </summary>
		/// <remarks>
		/// <para>
		/// It is assumed and enforced that errorHandler is never null.
		/// </para>
		/// <para>
		/// See <see cref="ErrorHandler"/> for more information.
		/// </para>
		/// </remarks>
		private IErrorHandler m_errorHandler;

		/// <summary>
		/// The first filter in the filter chain.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Set to <c>null</c> initially.
		/// </para>
		/// <para>
		/// See <see cref="IFilter"/> for more information.
		/// </para>
		/// </remarks>
		private IFilter m_headFilter;

		/// <summary>
		/// The last filter in the filter chain.
		/// </summary>
		/// <remarks>
		/// See <see cref="IFilter"/> for more information.
		/// </remarks>
		private IFilter m_tailFilter;

		/// <summary>
		/// Flag indicating if this appender is closed.
		/// </summary>
		/// <remarks>
		/// See <see cref="Close"/> for more information.
		/// </remarks>
		private bool m_closed = false;

		/// <summary>
		/// The guard prevents an appender from repeatedly calling its own DoAppend method
		/// </summary>
		private bool m_recursiveGuard = false;

		/// <summary>
		/// StringWriter used to render events
		/// </summary>
		private ReusableStringWriter m_renderWriter = null;]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static AppenderSkeleton()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="905" sc="6" el="905" ec="76">log4net\Appender\AppenderSkeleton.cs</location>
            <body hash="b59e54a9ed16a627a342e7a01c3c902a"><![CDATA[private readonly static Type declaringType = typeof(AppenderSkeleton)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public virtual void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="197" sc="3" el="198" ec="4">log4net\Appender\AppenderSkeleton.cs</location>
            <body hash="d2c65ffc45d1c7103cabbde916faf7e7"><![CDATA[{
		}]]></body>
          </codeblock>
        </method>
        <method name="AddFilter">
          <declaration><![CDATA[public virtual void AddFilter(IFilter filter)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="527" sc="3" el="542" ec="4">log4net\Appender\AppenderSkeleton.cs</location>
            <body hash="3eebda386dd3f1884e837e130c0fb348"><![CDATA[{
			if (filter == null)
			{
				throw new ArgumentNullException("filter param must not be null");
			}

			if (m_headFilter == null) 
			{
				m_headFilter = m_tailFilter = filter;
			} 
			else 
			{
				m_tailFilter.Next = filter;
				m_tailFilter = filter;	
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Append">
          <declaration><![CDATA[protected abstract void Append(LoggingEvent loggingEvent);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Append">
          <declaration><![CDATA[protected virtual void Append(LoggingEvent[] loggingEvents)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="632" sc="3" el="637" ec="4">log4net\Appender\AppenderSkeleton.cs</location>
            <body hash="01d822b876b010675abb5da0875ed694"><![CDATA[{
			foreach(LoggingEvent loggingEvent in loggingEvents)
			{
				Append(loggingEvent);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ClearFilters">
          <declaration><![CDATA[public virtual void ClearFilters()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="553" sc="3" el="555" ec="4">log4net\Appender\AppenderSkeleton.cs</location>
            <body hash="87b1a39f9b6ac20f095144acf6baed35"><![CDATA[{
			m_headFilter = m_tailFilter = null;
		}]]></body>
          </codeblock>
        </method>
        <method name="Close">
          <declaration><![CDATA[public void Close()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="237" sc="3" el="247" ec="4">log4net\Appender\AppenderSkeleton.cs</location>
            <body hash="5f08658daf5864cfba6c99fe24b3232d"><![CDATA[{
			// This lock prevents the appender being closed while it is still appending
			lock(this)
			{
				if (!m_closed)
				{
					OnClose();
					m_closed = true;
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="DoAppend">
          <declaration><![CDATA[public void DoAppend(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="291" sc="3" el="340" ec="4">log4net\Appender\AppenderSkeleton.cs</location>
            <body hash="07716c649f43df84116a22b3dfea7f57"><![CDATA[{
			// This lock is absolutely critical for correct formatting
			// of the message in a multi-threaded environment.  Without
			// this, the message may be broken up into elements from
			// multiple thread contexts (like get the wrong thread ID).

			lock(this)
			{
				if (m_closed)
				{
					ErrorHandler.Error("Attempted to append to closed appender named ["+m_name+"].");
					return;
				}

				// prevent re-entry
				if (m_recursiveGuard)
				{
					return;
				}

				try
				{
					m_recursiveGuard = true;

					if (FilterEvent(loggingEvent) && PreAppendCheck())
					{
						this.Append(loggingEvent);
					}
				}
				catch(Exception ex)
				{
					ErrorHandler.Error("Failed in DoAppend", ex);
				}
#if !MONO && !NET_2_0 && !NETSTANDARD1_3
				// on .NET 2.0 (and higher) and Mono (all profiles), 
				// exceptions that do not derive from System.Exception will be
				// wrapped in a RuntimeWrappedException by the runtime, and as
				// such will be catched by the catch clause above
				catch
				{
					// Catch handler for non System.Exception types
					ErrorHandler.Error("Failed in DoAppend (unknown exception)");
				}
#endif
				finally
				{
					m_recursiveGuard = false;
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="DoAppend">
          <declaration><![CDATA[public void DoAppend(LoggingEvent[] loggingEvents)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="388" sc="3" el="447" ec="4">log4net\Appender\AppenderSkeleton.cs</location>
            <body hash="20a1e4c50e69cdbdbc2269c5288c5711"><![CDATA[{
			// This lock is absolutely critical for correct formatting
			// of the message in a multi-threaded environment.  Without
			// this, the message may be broken up into elements from
			// multiple thread contexts (like get the wrong thread ID).

			lock(this)
			{
				if (m_closed)
				{
					ErrorHandler.Error("Attempted to append to closed appender named ["+m_name+"].");
					return;
				}

				// prevent re-entry
				if (m_recursiveGuard)
				{
					return;
				}

				try
				{
					m_recursiveGuard = true;

					ArrayList filteredEvents = new ArrayList(loggingEvents.Length);

					foreach(LoggingEvent loggingEvent in loggingEvents)
					{
						if (FilterEvent(loggingEvent))
						{
							filteredEvents.Add(loggingEvent);
						}
					}

					if (filteredEvents.Count > 0 && PreAppendCheck())
					{
						this.Append((LoggingEvent[])filteredEvents.ToArray(typeof(LoggingEvent)));
					}
				}
				catch(Exception ex)
				{
					ErrorHandler.Error("Failed in Bulk DoAppend", ex);
				}
#if !MONO && !NET_2_0 && !NETSTANDARD1_3
				// on .NET 2.0 (and higher) and Mono (all profiles), 
				// exceptions that do not derive from System.Exception will be
				// wrapped in a RuntimeWrappedException by the runtime, and as
				// such will be catched by the catch clause above
				catch
				{
					// Catch handler for non System.Exception types
					ErrorHandler.Error("Failed in Bulk DoAppend (unknown exception)");
				}
#endif
				finally
				{
					m_recursiveGuard = false;
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="FilterEvent">
          <declaration><![CDATA[protected virtual bool FilterEvent(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="483" sc="3" el="509" ec="4">log4net\Appender\AppenderSkeleton.cs</location>
            <body hash="ec694c7a74815236cb41afd2a4d82333"><![CDATA[{
			if (!IsAsSevereAsThreshold(loggingEvent.Level)) 
			{
				return false;
			}

			IFilter f = this.FilterHead;

			while(f != null) 
			{
				switch(f.Decide(loggingEvent)) 
				{
					case FilterDecision.Deny: 
						return false;	// Return without appending

					case FilterDecision.Accept:
						f = null;		// Break out of the loop
						break;

					case FilterDecision.Neutral:
						f = f.Next;		// Move to next filter
						break;
				}
			}

			return true;
		}]]></body>
          </codeblock>
        </method>
        <method name="Finalize">
          <declaration><![CDATA[protected override void Finalize()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="77" sc="3" el="85" ec="4">log4net\Appender\AppenderSkeleton.cs</location>
            <body hash="0bbc1e1872ceb35e6580704eb0d72ab9"><![CDATA[{
			// An appender might be closed then garbage collected. 
			// There is no point in closing twice.
			if (!m_closed) 
			{
				LogLog.Debug(declaringType, "Finalizing appender named ["+m_name+"].");
				Close();
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Flush">
          <declaration><![CDATA[public virtual bool Flush(int millisecondsTimeout)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="793" sc="10" el="795" ec="11">log4net\Appender\AppenderSkeleton.cs</location>
            <body hash="b4a0b01ff397b8b9e9d4e9a26e23f079"><![CDATA[{
		    return true;
        	}]]></body>
          </codeblock>
        </method>
        <method name="IsAsSevereAsThreshold">
          <declaration><![CDATA[protected virtual bool IsAsSevereAsThreshold(Level level)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="575" sc="3" el="577" ec="4">log4net\Appender\AppenderSkeleton.cs</location>
            <body hash="4fe0bb535a0416ad3c1173d8f2cafa8c"><![CDATA[{
			return ((m_threshold == null) || level >= m_threshold);
		}]]></body>
          </codeblock>
        </method>
        <method name="OnClose">
          <declaration><![CDATA[protected virtual void OnClose()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="593" sc="3" el="595" ec="4">log4net\Appender\AppenderSkeleton.cs</location>
            <body hash="d6160498b5a5c504c24534cef80661a6"><![CDATA[{
			// Do nothing by default
		}]]></body>
          </codeblock>
        </method>
        <method name="PreAppendCheck">
          <declaration><![CDATA[protected virtual bool PreAppendCheck()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="658" sc="3" el="666" ec="4">log4net\Appender\AppenderSkeleton.cs</location>
            <body hash="eb935e5354066002e2ba9daa61f9635e"><![CDATA[{
			if ((m_layout == null) && RequiresLayout)
			{
				ErrorHandler.Error("AppenderSkeleton: No layout set for the appender named ["+m_name+"].");
				return false;
			}

			return true;
		}]]></body>
          </codeblock>
        </method>
        <method name="RenderLoggingEvent">
          <declaration><![CDATA[protected string RenderLoggingEvent(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="693" sc="3" el="708" ec="4">log4net\Appender\AppenderSkeleton.cs</location>
            <body hash="0a79bc58f949eecc375f0a98b65f4c31"><![CDATA[{
			// Create the render writer on first use
			if (m_renderWriter == null)
			{
				m_renderWriter = new ReusableStringWriter(System.Globalization.CultureInfo.InvariantCulture);
			}

            lock (m_renderWriter)
            {
                // Reset the writer so we can reuse it
                m_renderWriter.Reset(c_renderBufferMaxCapacity, c_renderBufferSize);

                RenderLoggingEvent(m_renderWriter, loggingEvent);
                return m_renderWriter.ToString();
            }
		}]]></body>
          </codeblock>
        </method>
        <method name="RenderLoggingEvent">
          <declaration><![CDATA[protected void RenderLoggingEvent(TextWriter writer, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="734" sc="3" el="760" ec="4">log4net\Appender\AppenderSkeleton.cs</location>
            <body hash="3c02ac741e002dc63e678700d3ef1a51"><![CDATA[{
			if (m_layout == null) 
			{
				throw new InvalidOperationException("A layout must be set");
			}

			if (m_layout.IgnoresException) 
			{
				string exceptionStr = loggingEvent.GetExceptionString();
				if (exceptionStr != null && exceptionStr.Length > 0) 
				{
					// render the event and the exception
					m_layout.Format(writer, loggingEvent);
					writer.WriteLine(exceptionStr);
				}
				else 
				{
					// there is no exception to render
					m_layout.Format(writer, loggingEvent);
				}
			}
			else 
			{
				// The layout will render the exception
				m_layout.Format(writer, loggingEvent);
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="c_renderBufferMaxCapacity">
          <declaration><![CDATA[private const int c_renderBufferMaxCapacity = 1024;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="c_renderBufferSize">
          <declaration><![CDATA[private const int c_renderBufferSize = 256;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(AppenderSkeleton);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_closed">
          <declaration><![CDATA[private bool m_closed = false;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_errorHandler">
          <declaration><![CDATA[private IErrorHandler m_errorHandler;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_headFilter">
          <declaration><![CDATA[private IFilter m_headFilter;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_layout">
          <declaration><![CDATA[private ILayout m_layout;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_name">
          <declaration><![CDATA[private string m_name;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_recursiveGuard">
          <declaration><![CDATA[private bool m_recursiveGuard = false;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_renderWriter">
          <declaration><![CDATA[private ReusableStringWriter m_renderWriter = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_tailFilter">
          <declaration><![CDATA[private IFilter m_tailFilter;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_threshold">
          <declaration><![CDATA[private Level m_threshold;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="ErrorHandler">
          <declaration><![CDATA[public virtual IErrorHandler ErrorHandler]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="128" sc="4" el="142" ec="5">log4net\Appender\AppenderSkeleton.cs</location>
            <body hash="b1d86febc384cc410eaee7cd4939a5ef"><![CDATA[{
				lock(this) 
				{
					if (value == null) 
					{
						// We do not throw exception here since the cause is probably a
						// bad config file.
						LogLog.Warn(declaringType, "You have tried to set a null error-handler.");
					} 
					else 
					{
						m_errorHandler = value;
					}
				}
			}]]></body>
          </codeblock>
        </property>
        <property name="FilterHead">
          <declaration><![CDATA[public virtual IFilter FilterHead]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Layout">
          <declaration><![CDATA[public virtual ILayout Layout]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Name">
          <declaration><![CDATA[public string Name]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="RequiresLayout">
          <declaration><![CDATA[protected virtual bool RequiresLayout]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Threshold">
          <declaration><![CDATA[public Level Threshold]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="AspNetTraceAppender">
      <declaration><![CDATA[public class AspNetTraceAppender : AppenderSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private PatternLayout m_category = new PatternLayout("%logger");]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="68" sc="3" el="149" ec="70">log4net\Appender\AspNetTraceAppender.cs</location>
            <body hash="e90c3e51e38a82e09da619305c5d034a"><![CDATA[public AspNetTraceAppender() 
		{
		}

		#endregion // Public Instances Constructors

		#region Override implementation of AppenderSkeleton

		/// <summary>
		/// Write the logging event to the ASP.NET trace
		/// </summary>
		/// <param name="loggingEvent">the event to log</param>
		/// <remarks>
		/// <para>
		/// Write the logging event to the ASP.NET trace
		/// <c>HttpContext.Current.Trace</c> 
		/// (<see cref="TraceContext"/>).
		/// </para>
		/// </remarks>
		override protected void Append(LoggingEvent loggingEvent) 
		{
			// check if log4net is running in the context of an ASP.NET application
			if (HttpContext.Current != null) 
			{
				// check if tracing is enabled for the current context
				if (HttpContext.Current.Trace.IsEnabled) 
				{
					if (loggingEvent.Level >= Level.Warn) 
					{
                        HttpContext.Current.Trace.Warn(m_category.Format(loggingEvent), RenderLoggingEvent(loggingEvent));
					}
					else 
					{
                        HttpContext.Current.Trace.Write(m_category.Format(loggingEvent), RenderLoggingEvent(loggingEvent));
					}
				}
			}
		}

		/// <summary>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </summary>
		/// <value><c>true</c></value>
		/// <remarks>
		/// <para>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </para>
		/// </remarks>
		override protected bool RequiresLayout
		{
			get { return true; }
		}

		#endregion // Override implementation of AppenderSkeleton

        #region Public Instance Properties

        /// <summary>
        /// The category parameter sent to the Trace method.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Defaults to %logger which will use the logger name of the current 
        /// <see cref="LoggingEvent"/> as the category parameter.
        /// </para>
        /// <para>
        /// </para> 
        /// </remarks>
        public PatternLayout Category
        {
            get { return m_category; }
            set { m_category = value; }
        }

	    #endregion

	    #region Private Instance Fields

	    /// <summary>
	    /// Defaults to %logger
	    /// </summary>
	    private PatternLayout m_category = new PatternLayout("%logger");]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Append">
          <declaration><![CDATA[protected override void Append(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="88" sc="3" el="105" ec="4">log4net\Appender\AspNetTraceAppender.cs</location>
            <body hash="eeea11f98b24420590d30e2b16afccf2"><![CDATA[{
			// check if log4net is running in the context of an ASP.NET application
			if (HttpContext.Current != null) 
			{
				// check if tracing is enabled for the current context
				if (HttpContext.Current.Trace.IsEnabled) 
				{
					if (loggingEvent.Level >= Level.Warn) 
					{
                        HttpContext.Current.Trace.Warn(m_category.Format(loggingEvent), RenderLoggingEvent(loggingEvent));
					}
					else 
					{
                        HttpContext.Current.Trace.Write(m_category.Format(loggingEvent), RenderLoggingEvent(loggingEvent));
					}
				}
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_category">
          <declaration><![CDATA[private PatternLayout m_category = new PatternLayout("%logger");]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Category">
          <declaration><![CDATA[public PatternLayout Category]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="RequiresLayout">
          <declaration><![CDATA[protected override bool RequiresLayout]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="BufferingAppenderSkeleton">
      <declaration><![CDATA[public abstract class BufferingAppenderSkeleton : AppenderSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[protected BufferingAppenderSkeleton() : this(true)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="83" sc="43" el="85" ec="4">log4net\Appender\BufferingAppenderSkeleton.cs</location>
            <body hash="ad9a2695bedd9f280118b498e8480ed0"><![CDATA[this(true)
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_bufferSize = 512;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="102" sc="64" el="649" ec="46">log4net\Appender\BufferingAppenderSkeleton.cs</location>
            <body hash="16c532bf1a5d1611f2482a9f3cf1cbe6"><![CDATA[base()
		{
			m_eventMustBeFixed = eventMustBeFixed;
		}

		#endregion Protected Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Gets or sets a value that indicates whether the appender is lossy.
		/// </summary>
		/// <value>
		/// <c>true</c> if the appender is lossy, otherwise <c>false</c>. The default is <c>false</c>.
		/// </value>
		/// <remarks>
		/// <para>
		/// This appender uses a buffer to store logging events before 
		/// delivering them. A triggering event causes the whole buffer
		/// to be send to the remote sink. If the buffer overruns before
		/// a triggering event then logging events could be lost. Set
		/// <see cref="Lossy"/> to <c>false</c> to prevent logging events 
		/// from being lost.
		/// </para>
		/// <para>If <see cref="Lossy"/> is set to <c>true</c> then an
		/// <see cref="Evaluator"/> must be specified.</para>
		/// </remarks>
		public bool Lossy
		{
			get { return m_lossy; }
			set { m_lossy = value; }
		}

		/// <summary>
		/// Gets or sets the size of the cyclic buffer used to hold the 
		/// logging events.
		/// </summary>
		/// <value>
		/// The size of the cyclic buffer used to hold the logging events.
		/// </value>
		/// <remarks>
		/// <para>
		/// The <see cref="BufferSize"/> option takes a positive integer
		/// representing the maximum number of logging events to collect in 
		/// a cyclic buffer. When the <see cref="BufferSize"/> is reached,
		/// oldest events are deleted as new events are added to the
		/// buffer. By default the size of the cyclic buffer is 512 events.
		/// </para>
		/// <para>
		/// If the <see cref="BufferSize"/> is set to a value less than
		/// or equal to 1 then no buffering will occur. The logging event
		/// will be delivered synchronously (depending on the <see cref="Lossy"/>
		/// and <see cref="Evaluator"/> properties). Otherwise the event will
		/// be buffered.
		/// </para>
		/// </remarks>
		public int BufferSize
		{
			get { return m_bufferSize; }
			set { m_bufferSize = value; }
		}

		/// <summary>
		/// Gets or sets the <see cref="ITriggeringEventEvaluator"/> that causes the 
		/// buffer to be sent immediately.
		/// </summary>
		/// <value>
		/// The <see cref="ITriggeringEventEvaluator"/> that causes the buffer to be
		/// sent immediately.
		/// </value>
		/// <remarks>
		/// <para>
		/// The evaluator will be called for each event that is appended to this 
		/// appender. If the evaluator triggers then the current buffer will 
		/// immediately be sent (see <see cref="M:SendBuffer(LoggingEvent[])"/>).
		/// </para>
		/// <para>If <see cref="Lossy"/> is set to <c>true</c> then an
		/// <see cref="Evaluator"/> must be specified.</para>
		/// </remarks>
		public ITriggeringEventEvaluator Evaluator
		{
			get { return m_evaluator; }
			set	{ m_evaluator = value; }
		}

		/// <summary>
		/// Gets or sets the value of the <see cref="ITriggeringEventEvaluator"/> to use.
		/// </summary>
		/// <value>
		/// The value of the <see cref="ITriggeringEventEvaluator"/> to use.
		/// </value>
		/// <remarks>
		/// <para>
		/// The evaluator will be called for each event that is discarded from this 
		/// appender. If the evaluator triggers then the current buffer will immediately 
		/// be sent (see <see cref="M:SendBuffer(LoggingEvent[])"/>).
		/// </para>
		/// </remarks>
		public ITriggeringEventEvaluator LossyEvaluator
		{
			get { return m_lossyEvaluator; }
			set	{ m_lossyEvaluator = value; }
		}

		/// <summary>
		/// Gets or sets a value indicating if only part of the logging event data
		/// should be fixed.
		/// </summary>
		/// <value>
		/// <c>true</c> if the appender should only fix part of the logging event 
		/// data, otherwise <c>false</c>. The default is <c>false</c>.
		/// </value>
		/// <remarks>
		/// <para>
		/// Setting this property to <c>true</c> will cause only part of the
		/// event data to be fixed and serialized. This will improve performance.
		/// </para>
		/// <para>
		/// See <see cref="M:LoggingEvent.FixVolatileData(FixFlags)"/> for more information.
		/// </para>
		/// </remarks>
		[Obsolete("Use Fix property")]
		virtual public bool OnlyFixPartialEventData
		{
			get { return (Fix == FixFlags.Partial); }
			set 
			{ 
				if (value)
				{
					Fix = FixFlags.Partial;
				}
				else
				{
					Fix = FixFlags.All;
				}
			}
		}

		/// <summary>
		/// Gets or sets a the fields that will be fixed in the event
		/// </summary>
		/// <value>
		/// The event fields that will be fixed before the event is buffered
		/// </value>
		/// <remarks>
		/// <para>
		/// The logging event needs to have certain thread specific values 
		/// captured before it can be buffered. See <see cref="LoggingEvent.Fix"/>
		/// for details.
		/// </para>
		/// </remarks>
		/// <seealso cref="LoggingEvent.Fix"/>
		virtual public FixFlags Fix
		{
			get { return m_fixFlags; }
			set { m_fixFlags = value; }
		}

		#endregion Public Instance Properties

		#region Public Methods

        /// <summary>
        /// Flushes any buffered log data.
        /// </summary>
        /// <param name="millisecondsTimeout">The maximum time to wait for logging events to be flushed.</param>
        /// <returns><c>True</c> if all logging events were flushed successfully, else <c>false</c>.</returns>
        public override bool Flush(int millisecondsTimeout)
        {
            Flush();
            return true;
        }

		/// <summary>
		/// Flush the currently buffered events
		/// </summary>
		/// <remarks>
		/// <para>
		/// Flushes any events that have been buffered.
		/// </para>
		/// <para>
		/// If the appender is buffering in <see cref="Lossy"/> mode then the contents
		/// of the buffer will NOT be flushed to the appender.
		/// </para>
		/// </remarks>
		public virtual void Flush()
		{
			Flush(false);
		}

		/// <summary>
		/// Flush the currently buffered events
		/// </summary>
		/// <param name="flushLossyBuffer">set to <c>true</c> to flush the buffer of lossy events</param>
		/// <remarks>
		/// <para>
		/// Flushes events that have been buffered. If <paramref name="flushLossyBuffer" /> is
		/// <c>false</c> then events will only be flushed if this buffer is non-lossy mode.
		/// </para>
		/// <para>
		/// If the appender is buffering in <see cref="Lossy"/> mode then the contents
		/// of the buffer will only be flushed if <paramref name="flushLossyBuffer" /> is <c>true</c>.
		/// In this case the contents of the buffer will be tested against the 
		/// <see cref="LossyEvaluator"/> and if triggering will be output. All other buffered
		/// events will be discarded.
		/// </para>
		/// <para>
		/// If <paramref name="flushLossyBuffer" /> is <c>true</c> then the buffer will always
		/// be emptied by calling this method.
		/// </para>
		/// </remarks>
		public virtual void Flush(bool flushLossyBuffer)
		{
			// This method will be called outside of the AppenderSkeleton DoAppend() method
			// therefore it needs to be protected by its own lock. This will block any
			// Appends while the buffer is flushed.
			lock(this)
			{
				if (m_cb != null && m_cb.Length > 0)
				{
					if (m_lossy)
					{
						// If we are allowed to eagerly flush from the lossy buffer
						if (flushLossyBuffer)
						{
							if (m_lossyEvaluator != null)
							{
								// Test the contents of the buffer against the lossy evaluator
								LoggingEvent[] bufferedEvents = m_cb.PopAll();
								ArrayList filteredEvents = new ArrayList(bufferedEvents.Length);

								foreach(LoggingEvent loggingEvent in bufferedEvents)
								{
									if (m_lossyEvaluator.IsTriggeringEvent(loggingEvent))
									{
										filteredEvents.Add(loggingEvent);
									}
								}

								// Send the events that meet the lossy evaluator criteria
								if (filteredEvents.Count > 0)
								{
									SendBuffer((LoggingEvent[])filteredEvents.ToArray(typeof(LoggingEvent)));
								}
							}
							else
							{
								// No lossy evaluator, all buffered events are discarded
								m_cb.Clear();
							}
						}
					}
					else
					{
						// Not lossy, send whole buffer
						SendFromBuffer(null, m_cb);
					}
				}
			}
		}

		#endregion Public Methods

		#region Implementation of IOptionHandler

		/// <summary>
		/// Initialize the appender based on the options set
		/// </summary>
		/// <remarks>
		/// <para>
		/// This is part of the <see cref="IOptionHandler"/> delayed object
		/// activation scheme. The <see cref="ActivateOptions"/> method must 
		/// be called on this object after the configuration properties have
		/// been set. Until <see cref="ActivateOptions"/> is called this
		/// object is in an undefined state and must not be used. 
		/// </para>
		/// <para>
		/// If any of the configuration properties are modified then 
		/// <see cref="ActivateOptions"/> must be called again.
		/// </para>
		/// </remarks>
		override public void ActivateOptions() 
		{
			base.ActivateOptions();

			// If the appender is in Lossy mode then we will
			// only send the buffer when the Evaluator triggers
			// therefore check we have an evaluator.
			if (m_lossy && m_evaluator == null)
			{
				ErrorHandler.Error("Appender ["+Name+"] is Lossy but has no Evaluator. The buffer will never be sent!"); 
			}

			if (m_bufferSize > 1)
			{
				m_cb = new CyclicBuffer(m_bufferSize);
			}
			else
			{
				m_cb = null;
			}
		}

		#endregion Implementation of IOptionHandler

		#region Override implementation of AppenderSkeleton

		/// <summary>
		/// Close this appender instance.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Close this appender instance. If this appender is marked
		/// as not <see cref="Lossy"/> then the remaining events in 
		/// the buffer must be sent when the appender is closed.
		/// </para>
		/// </remarks>
		override protected void OnClose() 
		{
			// Flush the buffer on close
			Flush(true);
		}

		/// <summary>
		/// This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent)"/> method. 
		/// </summary>
		/// <param name="loggingEvent">the event to log</param>
		/// <remarks>
		/// <para>
		/// Stores the <paramref name="loggingEvent"/> in the cyclic buffer.
		/// </para>
		/// <para>
		/// The buffer will be sent (i.e. passed to the <see cref="SendBuffer"/> 
		/// method) if one of the following conditions is met:
		/// </para>
		/// <list type="bullet">
		///		<item>
		///			<description>The cyclic buffer is full and this appender is
		///			marked as not lossy (see <see cref="Lossy"/>)</description>
		///		</item>
		///		<item>
		///			<description>An <see cref="Evaluator"/> is set and
		///			it is triggered for the <paramref name="loggingEvent"/>
		///			specified.</description>
		///		</item>
		/// </list>
		/// <para>
		/// Before the event is stored in the buffer it is fixed
		/// (see <see cref="M:LoggingEvent.FixVolatileData(FixFlags)"/>) to ensure that
		/// any data referenced by the event will be valid when the buffer
		/// is processed.
		/// </para>
		/// </remarks>
		override protected void Append(LoggingEvent loggingEvent) 
		{
			// If the buffer size is set to 1 or less then the buffer will be
			// sent immediately because there is not enough space in the buffer
			// to buffer up more than 1 event. Therefore as a special case
			// we don't use the buffer at all.
			if (m_cb == null || m_bufferSize <= 1)
			{
				// Only send the event if we are in non lossy mode or the event is a triggering event
				if ((!m_lossy) || 
					(m_evaluator != null && m_evaluator.IsTriggeringEvent(loggingEvent)) || 
					(m_lossyEvaluator != null && m_lossyEvaluator.IsTriggeringEvent(loggingEvent)))
				{
					if (m_eventMustBeFixed)
					{
						// Derive class expects fixed events
						loggingEvent.Fix = this.Fix;
					}

					// Not buffering events, send immediately
					SendBuffer(new LoggingEvent[] { loggingEvent } );
				}
			}
			else
			{
				// Because we are caching the LoggingEvent beyond the
				// lifetime of the Append() method we must fix any
				// volatile data in the event.
				loggingEvent.Fix = this.Fix;

				// Add to the buffer, returns the event discarded from the buffer if there is no space remaining after the append
				LoggingEvent discardedLoggingEvent = m_cb.Append(loggingEvent);

				if (discardedLoggingEvent != null)
				{
					// Buffer is full and has had to discard an event
					if (!m_lossy)
					{
						// Not lossy, must send all events
						SendFromBuffer(discardedLoggingEvent, m_cb);
					}
					else
					{
						// Check if the discarded event should not be logged
						if (m_lossyEvaluator == null || !m_lossyEvaluator.IsTriggeringEvent(discardedLoggingEvent))
						{
							// Clear the discarded event as we should not forward it
							discardedLoggingEvent = null;
						}

						// Check if the event should trigger the whole buffer to be sent
						if (m_evaluator != null && m_evaluator.IsTriggeringEvent(loggingEvent))
						{
							SendFromBuffer(discardedLoggingEvent, m_cb);
						}
						else if (discardedLoggingEvent != null)
						{
							// Just send the discarded event
							SendBuffer(new LoggingEvent[] { discardedLoggingEvent } );
						}
					}
				}
				else
				{
					// Buffer is not yet full

					// Check if the event should trigger the whole buffer to be sent
					if (m_evaluator != null && m_evaluator.IsTriggeringEvent(loggingEvent))
					{
						SendFromBuffer(null, m_cb);
					}
				}
			}
		}

		#endregion Override implementation of AppenderSkeleton

		#region Protected Instance Methods

		/// <summary>
		/// Sends the contents of the buffer.
		/// </summary>
		/// <param name="firstLoggingEvent">The first logging event.</param>
		/// <param name="buffer">The buffer containing the events that need to be send.</param>
		/// <remarks>
		/// <para>
		/// The subclass must override <see cref="M:SendBuffer(LoggingEvent[])"/>.
		/// </para>
		/// </remarks>
		virtual protected void SendFromBuffer(LoggingEvent firstLoggingEvent, CyclicBuffer buffer)
		{
			LoggingEvent[] bufferEvents = buffer.PopAll();

			if (firstLoggingEvent == null)
			{
				SendBuffer(bufferEvents);
			}
			else if (bufferEvents.Length == 0)
			{
				SendBuffer(new LoggingEvent[] { firstLoggingEvent } );
			}
			else
			{
				// Create new array with the firstLoggingEvent at the head
				LoggingEvent[] events = new LoggingEvent[bufferEvents.Length + 1];
				Array.Copy(bufferEvents, 0, events, 1, bufferEvents.Length);
				events[0] = firstLoggingEvent;

				SendBuffer(events);
			}
		}

		#endregion Protected Instance Methods

		/// <summary>
		/// Sends the events.
		/// </summary>
		/// <param name="events">The events that need to be send.</param>
		/// <remarks>
		/// <para>
		/// The subclass must override this method to process the buffered events.
		/// </para>
		/// </remarks>
		abstract protected void SendBuffer(LoggingEvent[] events);

		#region Private Static Fields

		/// <summary>
		/// The default buffer size.
		/// </summary>
		/// <remarks>
		/// The default size of the cyclic buffer used to store events.
		/// This is set to 512 by default.
		/// </remarks>
		private const int DEFAULT_BUFFER_SIZE = 512;

		#endregion Private Static Fields

		#region Private Instance Fields

		/// <summary>
		/// The size of the cyclic buffer used to hold the logging events.
		/// </summary>
		/// <remarks>
		/// Set to <see cref="DEFAULT_BUFFER_SIZE"/> by default.
		/// </remarks>
		private int m_bufferSize = DEFAULT_BUFFER_SIZE;

		/// <summary>
		/// The cyclic buffer used to store the logging events.
		/// </summary>
		private CyclicBuffer m_cb;

		/// <summary>
		/// The triggering event evaluator that causes the buffer to be sent immediately.
		/// </summary>
		/// <remarks>
		/// The object that is used to determine if an event causes the entire
		/// buffer to be sent immediately. This field can be <c>null</c>, which 
		/// indicates that event triggering is not to be done. The evaluator
		/// can be set using the <see cref="Evaluator"/> property. If this appender
		/// has the <see cref="m_lossy"/> (<see cref="Lossy"/> property) set to 
		/// <c>true</c> then an <see cref="Evaluator"/> must be set.
		/// </remarks>
		private ITriggeringEventEvaluator m_evaluator;

		/// <summary>
		/// Indicates if the appender should overwrite events in the cyclic buffer 
		/// when it becomes full, or if the buffer should be flushed when the 
		/// buffer is full.
		/// </summary>
		/// <remarks>
		/// If this field is set to <c>true</c> then an <see cref="Evaluator"/> must 
		/// be set.
		/// </remarks>
		private bool m_lossy = false;

		/// <summary>
		/// The triggering event evaluator filters discarded events.
		/// </summary>
		/// <remarks>
		/// The object that is used to determine if an event that is discarded should
		/// really be discarded or if it should be sent to the appenders. 
		/// This field can be <c>null</c>, which indicates that all discarded events will
		/// be discarded. 
		/// </remarks>
		private ITriggeringEventEvaluator m_lossyEvaluator;

		/// <summary>
		/// Value indicating which fields in the event should be fixed
		/// </summary>
		/// <remarks>
		/// By default all fields are fixed
		/// </remarks>
		private FixFlags m_fixFlags = FixFlags.All;]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public override void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="384" sc="3" el="403" ec="4">log4net\Appender\BufferingAppenderSkeleton.cs</location>
            <body hash="7b04cc5ebad99b6264832d534c183e36"><![CDATA[{
			base.ActivateOptions();

			// If the appender is in Lossy mode then we will
			// only send the buffer when the Evaluator triggers
			// therefore check we have an evaluator.
			if (m_lossy && m_evaluator == null)
			{
				ErrorHandler.Error("Appender ["+Name+"] is Lossy but has no Evaluator. The buffer will never be sent!"); 
			}

			if (m_bufferSize > 1)
			{
				m_cb = new CyclicBuffer(m_bufferSize);
			}
			else
			{
				m_cb = null;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Append">
          <declaration><![CDATA[protected override void Append(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="456" sc="3" el="528" ec="4">log4net\Appender\BufferingAppenderSkeleton.cs</location>
            <body hash="97e1d1b3ebba7134677a0e3175b4244f"><![CDATA[{
			// If the buffer size is set to 1 or less then the buffer will be
			// sent immediately because there is not enough space in the buffer
			// to buffer up more than 1 event. Therefore as a special case
			// we don't use the buffer at all.
			if (m_cb == null || m_bufferSize <= 1)
			{
				// Only send the event if we are in non lossy mode or the event is a triggering event
				if ((!m_lossy) || 
					(m_evaluator != null && m_evaluator.IsTriggeringEvent(loggingEvent)) || 
					(m_lossyEvaluator != null && m_lossyEvaluator.IsTriggeringEvent(loggingEvent)))
				{
					if (m_eventMustBeFixed)
					{
						// Derive class expects fixed events
						loggingEvent.Fix = this.Fix;
					}

					// Not buffering events, send immediately
					SendBuffer(new LoggingEvent[] { loggingEvent } );
				}
			}
			else
			{
				// Because we are caching the LoggingEvent beyond the
				// lifetime of the Append() method we must fix any
				// volatile data in the event.
				loggingEvent.Fix = this.Fix;

				// Add to the buffer, returns the event discarded from the buffer if there is no space remaining after the append
				LoggingEvent discardedLoggingEvent = m_cb.Append(loggingEvent);

				if (discardedLoggingEvent != null)
				{
					// Buffer is full and has had to discard an event
					if (!m_lossy)
					{
						// Not lossy, must send all events
						SendFromBuffer(discardedLoggingEvent, m_cb);
					}
					else
					{
						// Check if the discarded event should not be logged
						if (m_lossyEvaluator == null || !m_lossyEvaluator.IsTriggeringEvent(discardedLoggingEvent))
						{
							// Clear the discarded event as we should not forward it
							discardedLoggingEvent = null;
						}

						// Check if the event should trigger the whole buffer to be sent
						if (m_evaluator != null && m_evaluator.IsTriggeringEvent(loggingEvent))
						{
							SendFromBuffer(discardedLoggingEvent, m_cb);
						}
						else if (discardedLoggingEvent != null)
						{
							// Just send the discarded event
							SendBuffer(new LoggingEvent[] { discardedLoggingEvent } );
						}
					}
				}
				else
				{
					// Buffer is not yet full

					// Check if the event should trigger the whole buffer to be sent
					if (m_evaluator != null && m_evaluator.IsTriggeringEvent(loggingEvent))
					{
						SendFromBuffer(null, m_cb);
					}
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Flush">
          <declaration><![CDATA[public override bool Flush(int millisecondsTimeout)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="270" sc="9" el="273" ec="10">log4net\Appender\BufferingAppenderSkeleton.cs</location>
            <body hash="540ccea7cc4fc74672b630b3f811ecb2"><![CDATA[{
            Flush();
            return true;
        }]]></body>
          </codeblock>
        </method>
        <method name="Flush">
          <declaration><![CDATA[public virtual void Flush()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="288" sc="3" el="290" ec="4">log4net\Appender\BufferingAppenderSkeleton.cs</location>
            <body hash="3df124d529650eff1ed33d7238f6819c"><![CDATA[{
			Flush(false);
		}]]></body>
          </codeblock>
        </method>
        <method name="Flush">
          <declaration><![CDATA[public virtual void Flush(bool flushLossyBuffer)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="314" sc="3" el="361" ec="4">log4net\Appender\BufferingAppenderSkeleton.cs</location>
            <body hash="6554b3a21518f219af6b695ff5bf66fa"><![CDATA[{
			// This method will be called outside of the AppenderSkeleton DoAppend() method
			// therefore it needs to be protected by its own lock. This will block any
			// Appends while the buffer is flushed.
			lock(this)
			{
				if (m_cb != null && m_cb.Length > 0)
				{
					if (m_lossy)
					{
						// If we are allowed to eagerly flush from the lossy buffer
						if (flushLossyBuffer)
						{
							if (m_lossyEvaluator != null)
							{
								// Test the contents of the buffer against the lossy evaluator
								LoggingEvent[] bufferedEvents = m_cb.PopAll();
								ArrayList filteredEvents = new ArrayList(bufferedEvents.Length);

								foreach(LoggingEvent loggingEvent in bufferedEvents)
								{
									if (m_lossyEvaluator.IsTriggeringEvent(loggingEvent))
									{
										filteredEvents.Add(loggingEvent);
									}
								}

								// Send the events that meet the lossy evaluator criteria
								if (filteredEvents.Count > 0)
								{
									SendBuffer((LoggingEvent[])filteredEvents.ToArray(typeof(LoggingEvent)));
								}
							}
							else
							{
								// No lossy evaluator, all buffered events are discarded
								m_cb.Clear();
							}
						}
					}
					else
					{
						// Not lossy, send whole buffer
						SendFromBuffer(null, m_cb);
					}
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="OnClose">
          <declaration><![CDATA[protected override void OnClose()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="420" sc="3" el="423" ec="4">log4net\Appender\BufferingAppenderSkeleton.cs</location>
            <body hash="ba85526c702612db0d1d626bae24d071"><![CDATA[{
			// Flush the buffer on close
			Flush(true);
		}]]></body>
          </codeblock>
        </method>
        <method name="SendBuffer">
          <declaration><![CDATA[protected abstract void SendBuffer(LoggingEvent[] events);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="SendFromBuffer">
          <declaration><![CDATA[protected virtual void SendFromBuffer(LoggingEvent firstLoggingEvent, CyclicBuffer buffer)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="545" sc="3" el="565" ec="4">log4net\Appender\BufferingAppenderSkeleton.cs</location>
            <body hash="fb07dc6bce0e0f4144d550a14e4f6696"><![CDATA[{
			LoggingEvent[] bufferEvents = buffer.PopAll();

			if (firstLoggingEvent == null)
			{
				SendBuffer(bufferEvents);
			}
			else if (bufferEvents.Length == 0)
			{
				SendBuffer(new LoggingEvent[] { firstLoggingEvent } );
			}
			else
			{
				// Create new array with the firstLoggingEvent at the head
				LoggingEvent[] events = new LoggingEvent[bufferEvents.Length + 1];
				Array.Copy(bufferEvents, 0, events, 1, bufferEvents.Length);
				events[0] = firstLoggingEvent;

				SendBuffer(events);
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="DEFAULT_BUFFER_SIZE">
          <declaration><![CDATA[private const int DEFAULT_BUFFER_SIZE = 512;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_bufferSize">
          <declaration><![CDATA[private int m_bufferSize = 512;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_cb">
          <declaration><![CDATA[private CyclicBuffer m_cb;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_evaluator">
          <declaration><![CDATA[private ITriggeringEventEvaluator m_evaluator;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_eventMustBeFixed">
          <declaration><![CDATA[private readonly bool m_eventMustBeFixed;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_fixFlags">
          <declaration><![CDATA[private FixFlags m_fixFlags = FixFlags.All;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_lossy">
          <declaration><![CDATA[private bool m_lossy = false;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_lossyEvaluator">
          <declaration><![CDATA[private ITriggeringEventEvaluator m_lossyEvaluator;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="BufferSize">
          <declaration><![CDATA[public int BufferSize]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Evaluator">
          <declaration><![CDATA[public ITriggeringEventEvaluator Evaluator]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Fix">
          <declaration><![CDATA[public virtual FixFlags Fix]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Lossy">
          <declaration><![CDATA[public bool Lossy]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="LossyEvaluator">
          <declaration><![CDATA[public ITriggeringEventEvaluator LossyEvaluator]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="OnlyFixPartialEventData">
          <deprecation>Use Fix property</deprecation>
          <declaration><![CDATA[public virtual bool OnlyFixPartialEventData]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="228" sc="4" el="237" ec="5">log4net\Appender\BufferingAppenderSkeleton.cs</location>
            <body hash="211e7672d86a93d521a7ef57f2633c91"><![CDATA[{ 
				if (value)
				{
					Fix = FixFlags.Partial;
				}
				else
				{
					Fix = FixFlags.All;
				}
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="BufferingForwardingAppender">
      <declaration><![CDATA[public class BufferingForwardingAppender : BufferingAppenderSkeleton, IAppenderAttachable]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public BufferingForwardingAppender()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="57" sc="3" el="59" ec="4">log4net\Appender\BufferingForwardingAppender.cs</location>
            <body hash="05bc59b9b9055be351cc991869980a2c"><![CDATA[public BufferingForwardingAppender()
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AddAppender">
          <declaration><![CDATA[public virtual void AddAppender(IAppender newAppender)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="130" sc="3" el="143" ec="4">log4net\Appender\BufferingForwardingAppender.cs</location>
            <body hash="d9b05b0e3ecda7e2f58c4489022ccbad"><![CDATA[{
			if (newAppender == null)
			{
				throw new ArgumentNullException("newAppender");
			}
			lock(this)
			{
				if (m_appenderAttachedImpl == null) 
				{
					m_appenderAttachedImpl = new log4net.Util.AppenderAttachedImpl();
				}
				m_appenderAttachedImpl.AddAppender(newAppender);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="GetAppender">
          <declaration><![CDATA[public virtual IAppender GetAppender(string name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="187" sc="3" el="197" ec="4">log4net\Appender\BufferingForwardingAppender.cs</location>
            <body hash="7f10ebf16dd6e3f4bb18193aa5983b12"><![CDATA[{
			lock(this)
			{
				if (m_appenderAttachedImpl == null || name == null)
				{
					return null;
				}

				return m_appenderAttachedImpl.GetAppender(name);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="OnClose">
          <declaration><![CDATA[protected override void OnClose()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="78" sc="3" el="90" ec="4">log4net\Appender\BufferingForwardingAppender.cs</location>
            <body hash="ca22e063a8230106e962235a3a086633"><![CDATA[{
			// Remove all the attached appenders
			lock(this)
			{
				// Delegate to base, which will flush buffers
				base.OnClose();

				if (m_appenderAttachedImpl != null)
				{
					m_appenderAttachedImpl.RemoveAllAppenders();
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="RemoveAllAppenders">
          <declaration><![CDATA[public virtual void RemoveAllAppenders()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="208" sc="3" el="217" ec="4">log4net\Appender\BufferingForwardingAppender.cs</location>
            <body hash="1940b92492970443d3573bab4baedf20"><![CDATA[{
			lock(this)
			{
				if (m_appenderAttachedImpl != null) 
				{
					m_appenderAttachedImpl.RemoveAllAppenders();
					m_appenderAttachedImpl = null;
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="RemoveAppender">
          <declaration><![CDATA[public virtual IAppender RemoveAppender(IAppender appender)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="230" sc="3" el="239" ec="4">log4net\Appender\BufferingForwardingAppender.cs</location>
            <body hash="f3152342c0d7431a05655ba05b21c843"><![CDATA[{
			lock(this)
			{
				if (appender != null && m_appenderAttachedImpl != null) 
				{
					return m_appenderAttachedImpl.RemoveAppender(appender);
				}
			}
			return null;
		}]]></body>
          </codeblock>
        </method>
        <method name="RemoveAppender">
          <declaration><![CDATA[public virtual IAppender RemoveAppender(string name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="252" sc="3" el="261" ec="4">log4net\Appender\BufferingForwardingAppender.cs</location>
            <body hash="1b61b04c5739b7cba116b8314c597356"><![CDATA[{
			lock(this)
			{
				if (name != null && m_appenderAttachedImpl != null)
				{
					return m_appenderAttachedImpl.RemoveAppender(name);
				}
			}
			return null;
		}]]></body>
          </codeblock>
        </method>
        <method name="SendBuffer">
          <declaration><![CDATA[protected override void SendBuffer(LoggingEvent[] events)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="106" sc="3" el="112" ec="4">log4net\Appender\BufferingForwardingAppender.cs</location>
            <body hash="3bbdbe9ce4f9826d0c4d1d1e8ab1fb95"><![CDATA[{
			// Pass the logging event on to the attached appenders
			if (m_appenderAttachedImpl != null)
			{
				m_appenderAttachedImpl.AppendLoopOnAppenders(events);
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_appenderAttachedImpl">
          <declaration><![CDATA[private AppenderAttachedImpl m_appenderAttachedImpl;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Appenders">
          <declaration><![CDATA[public virtual AppenderCollection Appenders]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="159" sc="4" el="171" ec="5">log4net\Appender\BufferingForwardingAppender.cs</location>
            <body hash="227e454749b13f96dad67c304be66991"><![CDATA[{
				lock(this)
				{
					if (m_appenderAttachedImpl == null)
					{
						return AppenderCollection.EmptyCollection;
					}
					else 
					{
						return m_appenderAttachedImpl.Appenders;
					}
				}
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ColoredConsoleAppender">
      <declaration><![CDATA[public class ColoredConsoleAppender : AppenderSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private bool m_writeToErrorStream = false;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="164" sc="3" el="525" ec="63">log4net\Appender\ColoredConsoleAppender.cs</location>
            <body hash="ccc18c57d52ef3a9deeff8b95fa41b21"><![CDATA[public ColoredConsoleAppender() 
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="ColoredConsoleAppender" /> class
		/// with the specified layout.
		/// </summary>
		/// <param name="layout">the layout to use for this appender</param>
		/// <remarks>
		/// The instance of the <see cref="ColoredConsoleAppender" /> class is set up to write 
		/// to the standard output stream.
		/// </remarks>
		[Obsolete("Instead use the default constructor and set the Layout property")]
		public ColoredConsoleAppender(ILayout layout) : this(layout, false)
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="ColoredConsoleAppender" /> class
		/// with the specified layout.
		/// </summary>
		/// <param name="layout">the layout to use for this appender</param>
		/// <param name="writeToErrorStream">flag set to <c>true</c> to write to the console error stream</param>
		/// <remarks>
		/// When <paramref name="writeToErrorStream" /> is set to <c>true</c>, output is written to
		/// the standard error output stream.  Otherwise, output is written to the standard
		/// output stream.
		/// </remarks>
		[Obsolete("Instead use the default constructor and set the Layout & Target properties")]
		public ColoredConsoleAppender(ILayout layout, bool writeToErrorStream) 
		{
			Layout = layout;
			m_writeToErrorStream = writeToErrorStream;
		}

		#endregion // Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Target is the value of the console output stream.
		/// This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
		/// </summary>
		/// <value>
		/// Target is the value of the console output stream.
		/// This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
		/// </value>
		/// <remarks>
		/// <para>
		/// Target is the value of the console output stream.
		/// This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
		/// </para>
		/// </remarks>
		virtual public string Target
		{
			get { return m_writeToErrorStream ? ConsoleError : ConsoleOut; }
			set
			{
				string v = value.Trim();
				
				if (string.Compare(ConsoleError, v, true, CultureInfo.InvariantCulture) == 0) 
				{
					m_writeToErrorStream = true;
				} 
				else 
				{
					m_writeToErrorStream = false;
				}
			}
		}

		/// <summary>
		/// Add a mapping of level to color - done by the config file
		/// </summary>
		/// <param name="mapping">The mapping to add</param>
		/// <remarks>
		/// <para>
		/// Add a <see cref="LevelColors"/> mapping to this appender.
		/// Each mapping defines the foreground and background colors
		/// for a level.
		/// </para>
		/// </remarks>
		public void AddMapping(LevelColors mapping)
		{
			m_levelMapping.Add(mapping);
		}

		#endregion // Public Instance Properties

		#region Override implementation of AppenderSkeleton

		/// <summary>
		/// This method is called by the <see cref="M:AppenderSkeleton.DoAppend(log4net.Core.LoggingEvent)"/> method.
		/// </summary>
		/// <param name="loggingEvent">The event to log.</param>
		/// <remarks>
		/// <para>
		/// Writes the event to the console.
		/// </para>
		/// <para>
		/// The format of the output will depend on the appender's layout.
		/// </para>
		/// </remarks>
#if NET_4_0 || MONO_4_0
        [System.Security.SecuritySafeCritical]
#endif
        [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, UnmanagedCode = true)]
        override protected void Append(log4net.Core.LoggingEvent loggingEvent) 
		{
			if (m_consoleOutputWriter != null)
			{
				IntPtr consoleHandle = IntPtr.Zero;
				if (m_writeToErrorStream)
				{
					// Write to the error stream
					consoleHandle = GetStdHandle(STD_ERROR_HANDLE);
				}
				else
				{
					// Write to the output stream
					consoleHandle = GetStdHandle(STD_OUTPUT_HANDLE);
				}

				// Default to white on black
				ushort colorInfo = (ushort)Colors.White;

				// see if there is a specified lookup
				LevelColors levelColors = m_levelMapping.Lookup(loggingEvent.Level) as LevelColors;
				if (levelColors != null)
				{
					colorInfo = levelColors.CombinedColor;
				}

				// Render the event to a string
				string strLoggingMessage = RenderLoggingEvent(loggingEvent);

				// get the current console color - to restore later
				CONSOLE_SCREEN_BUFFER_INFO bufferInfo;
				GetConsoleScreenBufferInfo(consoleHandle, out bufferInfo);

				// set the console colors
				SetConsoleTextAttribute(consoleHandle, colorInfo);

				// Using WriteConsoleW seems to be unreliable.
				// If a large buffer is written, say 15,000 chars
				// Followed by a larger buffer, say 20,000 chars
				// then WriteConsoleW will fail, last error 8
				// 'Not enough storage is available to process this command.'
				// 
				// Although the documentation states that the buffer must
				// be less that 64KB (i.e. 32,000 WCHARs) the longest string
				// that I can write out a the first call to WriteConsoleW
				// is only 30,704 chars.
				//
				// Unlike the WriteFile API the WriteConsoleW method does not 
				// seem to be able to partially write out from the input buffer.
				// It does have a lpNumberOfCharsWritten parameter, but this is
				// either the length of the input buffer if any output was written,
				// or 0 when an error occurs.
				//
				// All results above were observed on Windows XP SP1 running
				// .NET runtime 1.1 SP1.
				//
				// Old call to WriteConsoleW:
				//
				// WriteConsoleW(
				//     consoleHandle,
				//     strLoggingMessage,
				//     (UInt32)strLoggingMessage.Length,
				//     out (UInt32)ignoreWrittenCount,
				//     IntPtr.Zero);
				//
				// Instead of calling WriteConsoleW we use WriteFile which 
				// handles large buffers correctly. Because WriteFile does not
				// handle the codepage conversion as WriteConsoleW does we 
				// need to use a System.IO.StreamWriter with the appropriate
				// Encoding. The WriteFile calls are wrapped up in the
				// System.IO.__ConsoleStream internal class obtained through
				// the System.Console.OpenStandardOutput method.
				//
				// See the ActivateOptions method below for the code that
				// retrieves and wraps the stream.


				// The windows console uses ScrollConsoleScreenBuffer internally to
				// scroll the console buffer when the display buffer of the console
				// has been used up. ScrollConsoleScreenBuffer fills the area uncovered
				// by moving the current content with the background color 
				// currently specified on the console. This means that it fills the
				// whole line in front of the cursor position with the current 
				// background color.
				// This causes an issue when writing out text with a non default
				// background color. For example; We write a message with a Blue
				// background color and the scrollable area of the console is full.
				// When we write the newline at the end of the message the console
				// needs to scroll the buffer to make space available for the new line.
				// The ScrollConsoleScreenBuffer internals will fill the newly created
				// space with the current background color: Blue.
				// We then change the console color back to default (White text on a
				// Black background). We write some text to the console, the text is
				// written correctly in White with a Black background, however the
				// remainder of the line still has a Blue background.
				// 
				// This causes a disjointed appearance to the output where the background
				// colors change.
				//
				// This can be remedied by restoring the console colors before causing
				// the buffer to scroll, i.e. before writing the last newline. This does
				// assume that the rendered message will end with a newline.
				//
				// Therefore we identify a trailing newline in the message and don't
				// write this to the output, then we restore the console color and write
				// a newline. Note that we must AutoFlush before we restore the console
				// color otherwise we will have no effect.
				//
				// There will still be a slight artefact for the last line of the message
				// will have the background extended to the end of the line, however this
				// is unlikely to cause any user issues.
				//
				// Note that none of the above is visible while the console buffer is scrollable
				// within the console window viewport, the effects only arise when the actual
				// buffer is full and needs to be scrolled.

				char[] messageCharArray = strLoggingMessage.ToCharArray();
				int arrayLength = messageCharArray.Length;
				bool appendNewline = false;

				// Trim off last newline, if it exists
				if (arrayLength > 1 && messageCharArray[arrayLength-2] == '\r' && messageCharArray[arrayLength-1] == '\n')
				{
					arrayLength -= 2;
					appendNewline = true;
				}

				// Write to the output stream
				m_consoleOutputWriter.Write(messageCharArray, 0, arrayLength);

				// Restore the console back to its previous color scheme
				SetConsoleTextAttribute(consoleHandle, bufferInfo.wAttributes);

				if (appendNewline)
				{
					// Write the newline, after changing the color scheme
					m_consoleOutputWriter.Write(s_windowsNewline, 0, 2);
				}
			}
		}

		private static readonly char[] s_windowsNewline = {'\r', '\n'};

		/// <summary>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </summary>
		/// <value><c>true</c></value>
		/// <remarks>
		/// <para>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </para>
		/// </remarks>
		override protected bool RequiresLayout
		{
			get { return true; }
		}

		/// <summary>
		/// Initialize the options for this appender
		/// </summary>
		/// <remarks>
		/// <para>
		/// Initialize the level to color mappings set on this appender.
		/// </para>
		/// </remarks>
#if NET_4_0 || MONO_4_0
        [System.Security.SecuritySafeCritical]
#endif
        [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, UnmanagedCode=true)]
        public override void ActivateOptions()
		{
			base.ActivateOptions();
			m_levelMapping.ActivateOptions();

			System.IO.Stream consoleOutputStream = null;

			// Use the Console methods to open a Stream over the console std handle
			if (m_writeToErrorStream)
			{
				// Write to the error stream
				consoleOutputStream = Console.OpenStandardError();
			}
			else
			{
				// Write to the output stream
				consoleOutputStream = Console.OpenStandardOutput();
			}

			// Lookup the codepage encoding for the console
			System.Text.Encoding consoleEncoding = System.Text.Encoding.GetEncoding(GetConsoleOutputCP());

			// Create a writer around the console stream
			m_consoleOutputWriter = new System.IO.StreamWriter(consoleOutputStream, consoleEncoding, 0x100);

			m_consoleOutputWriter.AutoFlush = true;

			// SuppressFinalize on m_consoleOutputWriter because all it will do is flush
			// and close the file handle. Because we have set AutoFlush the additional flush
			// is not required. The console file handle should not be closed, so we don't call
			// Dispose, Close or the finalizer.
			GC.SuppressFinalize(m_consoleOutputWriter);
		}

		#endregion // Override implementation of AppenderSkeleton

		#region Public Static Fields

		/// <summary>
		/// The <see cref="ColoredConsoleAppender.Target"/> to use when writing to the Console 
		/// standard output stream.
		/// </summary>
		/// <remarks>
		/// <para>
		/// The <see cref="ColoredConsoleAppender.Target"/> to use when writing to the Console 
		/// standard output stream.
		/// </para>
		/// </remarks>
		public const string ConsoleOut = "Console.Out";

		/// <summary>
		/// The <see cref="ColoredConsoleAppender.Target"/> to use when writing to the Console 
		/// standard error output stream.
		/// </summary>
		/// <remarks>
		/// <para>
		/// The <see cref="ColoredConsoleAppender.Target"/> to use when writing to the Console 
		/// standard error output stream.
		/// </para>
		/// </remarks>
		public const string ConsoleError = "Console.Error";

		#endregion // Public Static Fields

		#region Private Instances Fields

		/// <summary>
		/// Flag to write output to the error stream rather than the standard output stream
		/// </summary>
		private bool m_writeToErrorStream = false;

		/// <summary>
		/// Mapping from level object to color value
		/// </summary>
		private LevelMapping m_levelMapping = new LevelMapping();

		/// <summary>
		/// The console output stream writer to write to
		/// </summary>
		/// <remarks>
		/// <para>
		/// This writer is not thread safe.
		/// </para>
		/// </remarks>
		private System.IO.StreamWriter m_consoleOutputWriter = null;]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <deprecation>Instead use the default constructor and set the Layout property</deprecation>
          <declaration><![CDATA[public ColoredConsoleAppender(ILayout layout) : this(layout, false)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="178" sc="51" el="180" ec="4">log4net\Appender\ColoredConsoleAppender.cs</location>
            <body hash="d909f0ac740fa7ee2d057318938d804f"><![CDATA[this(layout, false)
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <deprecation>Instead use the default constructor and set the Layout &amp; Target properties</deprecation>
          <declaration><![CDATA[private bool m_writeToErrorStream = false;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="194" sc="3" el="525" ec="63">log4net\Appender\ColoredConsoleAppender.cs</location>
            <body hash="63e83f30391d4a4992fa18bd409c802c"><![CDATA[public ColoredConsoleAppender(ILayout layout, bool writeToErrorStream) 
		{
			Layout = layout;
			m_writeToErrorStream = writeToErrorStream;
		}

		#endregion // Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Target is the value of the console output stream.
		/// This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
		/// </summary>
		/// <value>
		/// Target is the value of the console output stream.
		/// This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
		/// </value>
		/// <remarks>
		/// <para>
		/// Target is the value of the console output stream.
		/// This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
		/// </para>
		/// </remarks>
		virtual public string Target
		{
			get { return m_writeToErrorStream ? ConsoleError : ConsoleOut; }
			set
			{
				string v = value.Trim();
				
				if (string.Compare(ConsoleError, v, true, CultureInfo.InvariantCulture) == 0) 
				{
					m_writeToErrorStream = true;
				} 
				else 
				{
					m_writeToErrorStream = false;
				}
			}
		}

		/// <summary>
		/// Add a mapping of level to color - done by the config file
		/// </summary>
		/// <param name="mapping">The mapping to add</param>
		/// <remarks>
		/// <para>
		/// Add a <see cref="LevelColors"/> mapping to this appender.
		/// Each mapping defines the foreground and background colors
		/// for a level.
		/// </para>
		/// </remarks>
		public void AddMapping(LevelColors mapping)
		{
			m_levelMapping.Add(mapping);
		}

		#endregion // Public Instance Properties

		#region Override implementation of AppenderSkeleton

		/// <summary>
		/// This method is called by the <see cref="M:AppenderSkeleton.DoAppend(log4net.Core.LoggingEvent)"/> method.
		/// </summary>
		/// <param name="loggingEvent">The event to log.</param>
		/// <remarks>
		/// <para>
		/// Writes the event to the console.
		/// </para>
		/// <para>
		/// The format of the output will depend on the appender's layout.
		/// </para>
		/// </remarks>
#if NET_4_0 || MONO_4_0
        [System.Security.SecuritySafeCritical]
#endif
        [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, UnmanagedCode = true)]
        override protected void Append(log4net.Core.LoggingEvent loggingEvent) 
		{
			if (m_consoleOutputWriter != null)
			{
				IntPtr consoleHandle = IntPtr.Zero;
				if (m_writeToErrorStream)
				{
					// Write to the error stream
					consoleHandle = GetStdHandle(STD_ERROR_HANDLE);
				}
				else
				{
					// Write to the output stream
					consoleHandle = GetStdHandle(STD_OUTPUT_HANDLE);
				}

				// Default to white on black
				ushort colorInfo = (ushort)Colors.White;

				// see if there is a specified lookup
				LevelColors levelColors = m_levelMapping.Lookup(loggingEvent.Level) as LevelColors;
				if (levelColors != null)
				{
					colorInfo = levelColors.CombinedColor;
				}

				// Render the event to a string
				string strLoggingMessage = RenderLoggingEvent(loggingEvent);

				// get the current console color - to restore later
				CONSOLE_SCREEN_BUFFER_INFO bufferInfo;
				GetConsoleScreenBufferInfo(consoleHandle, out bufferInfo);

				// set the console colors
				SetConsoleTextAttribute(consoleHandle, colorInfo);

				// Using WriteConsoleW seems to be unreliable.
				// If a large buffer is written, say 15,000 chars
				// Followed by a larger buffer, say 20,000 chars
				// then WriteConsoleW will fail, last error 8
				// 'Not enough storage is available to process this command.'
				// 
				// Although the documentation states that the buffer must
				// be less that 64KB (i.e. 32,000 WCHARs) the longest string
				// that I can write out a the first call to WriteConsoleW
				// is only 30,704 chars.
				//
				// Unlike the WriteFile API the WriteConsoleW method does not 
				// seem to be able to partially write out from the input buffer.
				// It does have a lpNumberOfCharsWritten parameter, but this is
				// either the length of the input buffer if any output was written,
				// or 0 when an error occurs.
				//
				// All results above were observed on Windows XP SP1 running
				// .NET runtime 1.1 SP1.
				//
				// Old call to WriteConsoleW:
				//
				// WriteConsoleW(
				//     consoleHandle,
				//     strLoggingMessage,
				//     (UInt32)strLoggingMessage.Length,
				//     out (UInt32)ignoreWrittenCount,
				//     IntPtr.Zero);
				//
				// Instead of calling WriteConsoleW we use WriteFile which 
				// handles large buffers correctly. Because WriteFile does not
				// handle the codepage conversion as WriteConsoleW does we 
				// need to use a System.IO.StreamWriter with the appropriate
				// Encoding. The WriteFile calls are wrapped up in the
				// System.IO.__ConsoleStream internal class obtained through
				// the System.Console.OpenStandardOutput method.
				//
				// See the ActivateOptions method below for the code that
				// retrieves and wraps the stream.


				// The windows console uses ScrollConsoleScreenBuffer internally to
				// scroll the console buffer when the display buffer of the console
				// has been used up. ScrollConsoleScreenBuffer fills the area uncovered
				// by moving the current content with the background color 
				// currently specified on the console. This means that it fills the
				// whole line in front of the cursor position with the current 
				// background color.
				// This causes an issue when writing out text with a non default
				// background color. For example; We write a message with a Blue
				// background color and the scrollable area of the console is full.
				// When we write the newline at the end of the message the console
				// needs to scroll the buffer to make space available for the new line.
				// The ScrollConsoleScreenBuffer internals will fill the newly created
				// space with the current background color: Blue.
				// We then change the console color back to default (White text on a
				// Black background). We write some text to the console, the text is
				// written correctly in White with a Black background, however the
				// remainder of the line still has a Blue background.
				// 
				// This causes a disjointed appearance to the output where the background
				// colors change.
				//
				// This can be remedied by restoring the console colors before causing
				// the buffer to scroll, i.e. before writing the last newline. This does
				// assume that the rendered message will end with a newline.
				//
				// Therefore we identify a trailing newline in the message and don't
				// write this to the output, then we restore the console color and write
				// a newline. Note that we must AutoFlush before we restore the console
				// color otherwise we will have no effect.
				//
				// There will still be a slight artefact for the last line of the message
				// will have the background extended to the end of the line, however this
				// is unlikely to cause any user issues.
				//
				// Note that none of the above is visible while the console buffer is scrollable
				// within the console window viewport, the effects only arise when the actual
				// buffer is full and needs to be scrolled.

				char[] messageCharArray = strLoggingMessage.ToCharArray();
				int arrayLength = messageCharArray.Length;
				bool appendNewline = false;

				// Trim off last newline, if it exists
				if (arrayLength > 1 && messageCharArray[arrayLength-2] == '\r' && messageCharArray[arrayLength-1] == '\n')
				{
					arrayLength -= 2;
					appendNewline = true;
				}

				// Write to the output stream
				m_consoleOutputWriter.Write(messageCharArray, 0, arrayLength);

				// Restore the console back to its previous color scheme
				SetConsoleTextAttribute(consoleHandle, bufferInfo.wAttributes);

				if (appendNewline)
				{
					// Write the newline, after changing the color scheme
					m_consoleOutputWriter.Write(s_windowsNewline, 0, 2);
				}
			}
		}

		private static readonly char[] s_windowsNewline = {'\r', '\n'};

		/// <summary>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </summary>
		/// <value><c>true</c></value>
		/// <remarks>
		/// <para>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </para>
		/// </remarks>
		override protected bool RequiresLayout
		{
			get { return true; }
		}

		/// <summary>
		/// Initialize the options for this appender
		/// </summary>
		/// <remarks>
		/// <para>
		/// Initialize the level to color mappings set on this appender.
		/// </para>
		/// </remarks>
#if NET_4_0 || MONO_4_0
        [System.Security.SecuritySafeCritical]
#endif
        [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, UnmanagedCode=true)]
        public override void ActivateOptions()
		{
			base.ActivateOptions();
			m_levelMapping.ActivateOptions();

			System.IO.Stream consoleOutputStream = null;

			// Use the Console methods to open a Stream over the console std handle
			if (m_writeToErrorStream)
			{
				// Write to the error stream
				consoleOutputStream = Console.OpenStandardError();
			}
			else
			{
				// Write to the output stream
				consoleOutputStream = Console.OpenStandardOutput();
			}

			// Lookup the codepage encoding for the console
			System.Text.Encoding consoleEncoding = System.Text.Encoding.GetEncoding(GetConsoleOutputCP());

			// Create a writer around the console stream
			m_consoleOutputWriter = new System.IO.StreamWriter(consoleOutputStream, consoleEncoding, 0x100);

			m_consoleOutputWriter.AutoFlush = true;

			// SuppressFinalize on m_consoleOutputWriter because all it will do is flush
			// and close the file handle. Because we have set AutoFlush the additional flush
			// is not required. The console file handle should not be closed, so we don't call
			// Dispose, Close or the finalizer.
			GC.SuppressFinalize(m_consoleOutputWriter);
		}

		#endregion // Override implementation of AppenderSkeleton

		#region Public Static Fields

		/// <summary>
		/// The <see cref="ColoredConsoleAppender.Target"/> to use when writing to the Console 
		/// standard output stream.
		/// </summary>
		/// <remarks>
		/// <para>
		/// The <see cref="ColoredConsoleAppender.Target"/> to use when writing to the Console 
		/// standard output stream.
		/// </para>
		/// </remarks>
		public const string ConsoleOut = "Console.Out";

		/// <summary>
		/// The <see cref="ColoredConsoleAppender.Target"/> to use when writing to the Console 
		/// standard error output stream.
		/// </summary>
		/// <remarks>
		/// <para>
		/// The <see cref="ColoredConsoleAppender.Target"/> to use when writing to the Console 
		/// standard error output stream.
		/// </para>
		/// </remarks>
		public const string ConsoleError = "Console.Error";

		#endregion // Public Static Fields

		#region Private Instances Fields

		/// <summary>
		/// Flag to write output to the error stream rather than the standard output stream
		/// </summary>
		private bool m_writeToErrorStream = false;

		/// <summary>
		/// Mapping from level object to color value
		/// </summary>
		private LevelMapping m_levelMapping = new LevelMapping();

		/// <summary>
		/// The console output stream writer to write to
		/// </summary>
		/// <remarks>
		/// <para>
		/// This writer is not thread safe.
		/// </para>
		/// </remarks>
		private System.IO.StreamWriter m_consoleOutputWriter = null;]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static ColoredConsoleAppender()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="413" sc="3" el="413" ec="66">log4net\Appender\ColoredConsoleAppender.cs</location>
            <body hash="fd27863ce6bd7c30b1e919d4f85733ab"><![CDATA[private static readonly char[] s_windowsNewline = {'\r', '\n'}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public override void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="442" sc="3" el="473" ec="4">log4net\Appender\ColoredConsoleAppender.cs</location>
            <body hash="96deb9e0c4c6a1e03ddac336895ba91f"><![CDATA[{
			base.ActivateOptions();
			m_levelMapping.ActivateOptions();

			System.IO.Stream consoleOutputStream = null;

			// Use the Console methods to open a Stream over the console std handle
			if (m_writeToErrorStream)
			{
				// Write to the error stream
				consoleOutputStream = Console.OpenStandardError();
			}
			else
			{
				// Write to the output stream
				consoleOutputStream = Console.OpenStandardOutput();
			}

			// Lookup the codepage encoding for the console
			System.Text.Encoding consoleEncoding = System.Text.Encoding.GetEncoding(GetConsoleOutputCP());

			// Create a writer around the console stream
			m_consoleOutputWriter = new System.IO.StreamWriter(consoleOutputStream, consoleEncoding, 0x100);

			m_consoleOutputWriter.AutoFlush = true;

			// SuppressFinalize on m_consoleOutputWriter because all it will do is flush
			// and close the file handle. Because we have set AutoFlush the additional flush
			// is not required. The console file handle should not be closed, so we don't call
			// Dispose, Close or the finalizer.
			GC.SuppressFinalize(m_consoleOutputWriter);
		}]]></body>
          </codeblock>
        </method>
        <method name="AddMapping">
          <declaration><![CDATA[public void AddMapping(ColoredConsoleAppender.LevelColors mapping)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="248" sc="3" el="250" ec="4">log4net\Appender\ColoredConsoleAppender.cs</location>
            <body hash="9683e4fc6ec5e4d8a9d684ec86bdb867"><![CDATA[{
			m_levelMapping.Add(mapping);
		}]]></body>
          </codeblock>
        </method>
        <method name="Append">
          <declaration><![CDATA[protected override void Append(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="273" sc="3" el="411" ec="4">log4net\Appender\ColoredConsoleAppender.cs</location>
            <body hash="8dd3fb4633c0e9df954959ed7506bdff"><![CDATA[{
			if (m_consoleOutputWriter != null)
			{
				IntPtr consoleHandle = IntPtr.Zero;
				if (m_writeToErrorStream)
				{
					// Write to the error stream
					consoleHandle = GetStdHandle(STD_ERROR_HANDLE);
				}
				else
				{
					// Write to the output stream
					consoleHandle = GetStdHandle(STD_OUTPUT_HANDLE);
				}

				// Default to white on black
				ushort colorInfo = (ushort)Colors.White;

				// see if there is a specified lookup
				LevelColors levelColors = m_levelMapping.Lookup(loggingEvent.Level) as LevelColors;
				if (levelColors != null)
				{
					colorInfo = levelColors.CombinedColor;
				}

				// Render the event to a string
				string strLoggingMessage = RenderLoggingEvent(loggingEvent);

				// get the current console color - to restore later
				CONSOLE_SCREEN_BUFFER_INFO bufferInfo;
				GetConsoleScreenBufferInfo(consoleHandle, out bufferInfo);

				// set the console colors
				SetConsoleTextAttribute(consoleHandle, colorInfo);

				// Using WriteConsoleW seems to be unreliable.
				// If a large buffer is written, say 15,000 chars
				// Followed by a larger buffer, say 20,000 chars
				// then WriteConsoleW will fail, last error 8
				// 'Not enough storage is available to process this command.'
				// 
				// Although the documentation states that the buffer must
				// be less that 64KB (i.e. 32,000 WCHARs) the longest string
				// that I can write out a the first call to WriteConsoleW
				// is only 30,704 chars.
				//
				// Unlike the WriteFile API the WriteConsoleW method does not 
				// seem to be able to partially write out from the input buffer.
				// It does have a lpNumberOfCharsWritten parameter, but this is
				// either the length of the input buffer if any output was written,
				// or 0 when an error occurs.
				//
				// All results above were observed on Windows XP SP1 running
				// .NET runtime 1.1 SP1.
				//
				// Old call to WriteConsoleW:
				//
				// WriteConsoleW(
				//     consoleHandle,
				//     strLoggingMessage,
				//     (UInt32)strLoggingMessage.Length,
				//     out (UInt32)ignoreWrittenCount,
				//     IntPtr.Zero);
				//
				// Instead of calling WriteConsoleW we use WriteFile which 
				// handles large buffers correctly. Because WriteFile does not
				// handle the codepage conversion as WriteConsoleW does we 
				// need to use a System.IO.StreamWriter with the appropriate
				// Encoding. The WriteFile calls are wrapped up in the
				// System.IO.__ConsoleStream internal class obtained through
				// the System.Console.OpenStandardOutput method.
				//
				// See the ActivateOptions method below for the code that
				// retrieves and wraps the stream.


				// The windows console uses ScrollConsoleScreenBuffer internally to
				// scroll the console buffer when the display buffer of the console
				// has been used up. ScrollConsoleScreenBuffer fills the area uncovered
				// by moving the current content with the background color 
				// currently specified on the console. This means that it fills the
				// whole line in front of the cursor position with the current 
				// background color.
				// This causes an issue when writing out text with a non default
				// background color. For example; We write a message with a Blue
				// background color and the scrollable area of the console is full.
				// When we write the newline at the end of the message the console
				// needs to scroll the buffer to make space available for the new line.
				// The ScrollConsoleScreenBuffer internals will fill the newly created
				// space with the current background color: Blue.
				// We then change the console color back to default (White text on a
				// Black background). We write some text to the console, the text is
				// written correctly in White with a Black background, however the
				// remainder of the line still has a Blue background.
				// 
				// This causes a disjointed appearance to the output where the background
				// colors change.
				//
				// This can be remedied by restoring the console colors before causing
				// the buffer to scroll, i.e. before writing the last newline. This does
				// assume that the rendered message will end with a newline.
				//
				// Therefore we identify a trailing newline in the message and don't
				// write this to the output, then we restore the console color and write
				// a newline. Note that we must AutoFlush before we restore the console
				// color otherwise we will have no effect.
				//
				// There will still be a slight artefact for the last line of the message
				// will have the background extended to the end of the line, however this
				// is unlikely to cause any user issues.
				//
				// Note that none of the above is visible while the console buffer is scrollable
				// within the console window viewport, the effects only arise when the actual
				// buffer is full and needs to be scrolled.

				char[] messageCharArray = strLoggingMessage.ToCharArray();
				int arrayLength = messageCharArray.Length;
				bool appendNewline = false;

				// Trim off last newline, if it exists
				if (arrayLength > 1 && messageCharArray[arrayLength-2] == '\r' && messageCharArray[arrayLength-1] == '\n')
				{
					arrayLength -= 2;
					appendNewline = true;
				}

				// Write to the output stream
				m_consoleOutputWriter.Write(messageCharArray, 0, arrayLength);

				// Restore the console back to its previous color scheme
				SetConsoleTextAttribute(consoleHandle, bufferInfo.wAttributes);

				if (appendNewline)
				{
					// Write the newline, after changing the color scheme
					m_consoleOutputWriter.Write(s_windowsNewline, 0, 2);
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="GetConsoleOutputCP">
          <declaration><![CDATA[private static extern int GetConsoleOutputCP();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetConsoleScreenBufferInfo">
          <declaration><![CDATA[private static extern bool GetConsoleScreenBufferInfo(IntPtr consoleHandle, out ColoredConsoleAppender.CONSOLE_SCREEN_BUFFER_INFO bufferInfo);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetStdHandle">
          <declaration><![CDATA[private static extern IntPtr GetStdHandle(uint type);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="SetConsoleTextAttribute">
          <declaration><![CDATA[private static extern bool SetConsoleTextAttribute(IntPtr consoleHandle, ushort attributes);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="ConsoleError">
          <declaration><![CDATA[public const string ConsoleError = "Console.Error";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ConsoleOut">
          <declaration><![CDATA[public const string ConsoleOut = "Console.Out";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_consoleOutputWriter">
          <declaration><![CDATA[private StreamWriter m_consoleOutputWriter = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_levelMapping">
          <declaration><![CDATA[private LevelMapping m_levelMapping = new LevelMapping();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_writeToErrorStream">
          <declaration><![CDATA[private bool m_writeToErrorStream = false;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="s_windowsNewline">
          <declaration><![CDATA[private static readonly char[] s_windowsNewline = new char[]]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="STD_ERROR_HANDLE">
          <declaration><![CDATA[private const uint STD_ERROR_HANDLE = 4294967284u;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="STD_OUTPUT_HANDLE">
          <declaration><![CDATA[private const uint STD_OUTPUT_HANDLE = 4294967285u;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="RequiresLayout">
          <declaration><![CDATA[protected override bool RequiresLayout]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Target">
          <declaration><![CDATA[public virtual string Target]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="222" sc="4" el="233" ec="5">log4net\Appender\ColoredConsoleAppender.cs</location>
            <body hash="479c1c0bf3fc120ecfd4130ca16c9885"><![CDATA[{
				string v = value.Trim();
				
				if (string.Compare(ConsoleError, v, true, CultureInfo.InvariantCulture) == 0) 
				{
					m_writeToErrorStream = true;
				} 
				else 
				{
					m_writeToErrorStream = false;
				}
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ConsoleAppender">
      <declaration><![CDATA[public class ConsoleAppender : AppenderSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private bool m_writeToErrorStream = false;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="64" sc="3" el="217" ec="45">log4net\Appender\ConsoleAppender.cs</location>
            <body hash="fc1091a122244d6b61eefd2d1fb2cec7"><![CDATA[public ConsoleAppender() 
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="ConsoleAppender" /> class
		/// with the specified layout.
		/// </summary>
		/// <param name="layout">the layout to use for this appender</param>
		/// <remarks>
		/// The instance of the <see cref="ConsoleAppender" /> class is set up to write 
		/// to the standard output stream.
		/// </remarks>
		[Obsolete("Instead use the default constructor and set the Layout property")]
		public ConsoleAppender(ILayout layout) : this(layout, false)
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="ConsoleAppender" /> class
		/// with the specified layout.
		/// </summary>
		/// <param name="layout">the layout to use for this appender</param>
		/// <param name="writeToErrorStream">flag set to <c>true</c> to write to the console error stream</param>
		/// <remarks>
		/// When <paramref name="writeToErrorStream" /> is set to <c>true</c>, output is written to
		/// the standard error output stream.  Otherwise, output is written to the standard
		/// output stream.
		/// </remarks>
		[Obsolete("Instead use the default constructor and set the Layout & Target properties")]
		public ConsoleAppender(ILayout layout, bool writeToErrorStream) 
		{
			Layout = layout;
			m_writeToErrorStream = writeToErrorStream;
		}

		#endregion Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Target is the value of the console output stream.
		/// This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
		/// </summary>
		/// <value>
		/// Target is the value of the console output stream.
		/// This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
		/// </value>
		/// <remarks>
		/// <para>
		/// Target is the value of the console output stream.
		/// This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
		/// </para>
		/// </remarks>
		virtual public string Target
		{
			get { return m_writeToErrorStream ? ConsoleError : ConsoleOut; }
			set
			{
				string v = value.Trim();

				if (SystemInfo.EqualsIgnoringCase(ConsoleError, v))
				{
					m_writeToErrorStream = true;
				} 
				else 
				{
					m_writeToErrorStream = false;
				}
			}
		}

		#endregion Public Instance Properties

		#region Override implementation of AppenderSkeleton

		/// <summary>
		/// This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent)"/> method.
		/// </summary>
		/// <param name="loggingEvent">The event to log.</param>
		/// <remarks>
		/// <para>
		/// Writes the event to the console.
		/// </para>
		/// <para>
		/// The format of the output will depend on the appender's layout.
		/// </para>
		/// </remarks>
		override protected void Append(LoggingEvent loggingEvent) 
		{
#if NETCF_1_0
			// Write to the output stream
			Console.Write(RenderLoggingEvent(loggingEvent));
#else
			if (m_writeToErrorStream)
			{
				// Write to the error stream
				Console.Error.Write(RenderLoggingEvent(loggingEvent));
			}
			else
			{
				// Write to the output stream
				Console.Write(RenderLoggingEvent(loggingEvent));
			}
#endif
		}

		/// <summary>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </summary>
		/// <value><c>true</c></value>
		/// <remarks>
		/// <para>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </para>
		/// </remarks>
		override protected bool RequiresLayout
		{
			get { return true; }
		}

		#endregion Override implementation of AppenderSkeleton

		#region Public Static Fields

		/// <summary>
		/// The <see cref="ConsoleAppender.Target"/> to use when writing to the Console 
		/// standard output stream.
		/// </summary>
		/// <remarks>
		/// <para>
		/// The <see cref="ConsoleAppender.Target"/> to use when writing to the Console 
		/// standard output stream.
		/// </para>
		/// </remarks>
		public const string ConsoleOut = "Console.Out";

		/// <summary>
		/// The <see cref="ConsoleAppender.Target"/> to use when writing to the Console 
		/// standard error output stream.
		/// </summary>
		/// <remarks>
		/// <para>
		/// The <see cref="ConsoleAppender.Target"/> to use when writing to the Console 
		/// standard error output stream.
		/// </para>
		/// </remarks>
		public const string ConsoleError = "Console.Error";

		#endregion Public Static Fields

		#region Private Instances Fields

		private bool m_writeToErrorStream = false;]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <deprecation>Instead use the default constructor and set the Layout property</deprecation>
          <declaration><![CDATA[public ConsoleAppender(ILayout layout) : this(layout, false)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="78" sc="44" el="80" ec="4">log4net\Appender\ConsoleAppender.cs</location>
            <body hash="d909f0ac740fa7ee2d057318938d804f"><![CDATA[this(layout, false)
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <deprecation>Instead use the default constructor and set the Layout &amp; Target properties</deprecation>
          <declaration><![CDATA[private bool m_writeToErrorStream = false;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="94" sc="3" el="217" ec="45">log4net\Appender\ConsoleAppender.cs</location>
            <body hash="5ababe64d333d50fc05d09762c370271"><![CDATA[public ConsoleAppender(ILayout layout, bool writeToErrorStream) 
		{
			Layout = layout;
			m_writeToErrorStream = writeToErrorStream;
		}

		#endregion Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Target is the value of the console output stream.
		/// This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
		/// </summary>
		/// <value>
		/// Target is the value of the console output stream.
		/// This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
		/// </value>
		/// <remarks>
		/// <para>
		/// Target is the value of the console output stream.
		/// This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
		/// </para>
		/// </remarks>
		virtual public string Target
		{
			get { return m_writeToErrorStream ? ConsoleError : ConsoleOut; }
			set
			{
				string v = value.Trim();

				if (SystemInfo.EqualsIgnoringCase(ConsoleError, v))
				{
					m_writeToErrorStream = true;
				} 
				else 
				{
					m_writeToErrorStream = false;
				}
			}
		}

		#endregion Public Instance Properties

		#region Override implementation of AppenderSkeleton

		/// <summary>
		/// This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent)"/> method.
		/// </summary>
		/// <param name="loggingEvent">The event to log.</param>
		/// <remarks>
		/// <para>
		/// Writes the event to the console.
		/// </para>
		/// <para>
		/// The format of the output will depend on the appender's layout.
		/// </para>
		/// </remarks>
		override protected void Append(LoggingEvent loggingEvent) 
		{
#if NETCF_1_0
			// Write to the output stream
			Console.Write(RenderLoggingEvent(loggingEvent));
#else
			if (m_writeToErrorStream)
			{
				// Write to the error stream
				Console.Error.Write(RenderLoggingEvent(loggingEvent));
			}
			else
			{
				// Write to the output stream
				Console.Write(RenderLoggingEvent(loggingEvent));
			}
#endif
		}

		/// <summary>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </summary>
		/// <value><c>true</c></value>
		/// <remarks>
		/// <para>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </para>
		/// </remarks>
		override protected bool RequiresLayout
		{
			get { return true; }
		}

		#endregion Override implementation of AppenderSkeleton

		#region Public Static Fields

		/// <summary>
		/// The <see cref="ConsoleAppender.Target"/> to use when writing to the Console 
		/// standard output stream.
		/// </summary>
		/// <remarks>
		/// <para>
		/// The <see cref="ConsoleAppender.Target"/> to use when writing to the Console 
		/// standard output stream.
		/// </para>
		/// </remarks>
		public const string ConsoleOut = "Console.Out";

		/// <summary>
		/// The <see cref="ConsoleAppender.Target"/> to use when writing to the Console 
		/// standard error output stream.
		/// </summary>
		/// <remarks>
		/// <para>
		/// The <see cref="ConsoleAppender.Target"/> to use when writing to the Console 
		/// standard error output stream.
		/// </para>
		/// </remarks>
		public const string ConsoleError = "Console.Error";

		#endregion Public Static Fields

		#region Private Instances Fields

		private bool m_writeToErrorStream = false;]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Append">
          <declaration><![CDATA[protected override void Append(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="153" sc="3" el="169" ec="4">log4net\Appender\ConsoleAppender.cs</location>
            <body hash="d8670b24f23523e9e6eca7ed1d7c5bdc"><![CDATA[{
#if NETCF_1_0
			// Write to the output stream
			Console.Write(RenderLoggingEvent(loggingEvent));
#else
			if (m_writeToErrorStream)
			{
				// Write to the error stream
				Console.Error.Write(RenderLoggingEvent(loggingEvent));
			}
			else
			{
				// Write to the output stream
				Console.Write(RenderLoggingEvent(loggingEvent));
			}
#endif
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="ConsoleError">
          <declaration><![CDATA[public const string ConsoleError = "Console.Error";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ConsoleOut">
          <declaration><![CDATA[public const string ConsoleOut = "Console.Out";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_writeToErrorStream">
          <declaration><![CDATA[private bool m_writeToErrorStream = false;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="RequiresLayout">
          <declaration><![CDATA[protected override bool RequiresLayout]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Target">
          <declaration><![CDATA[public virtual string Target]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="122" sc="4" el="133" ec="5">log4net\Appender\ConsoleAppender.cs</location>
            <body hash="988aece71481074ecff4654ae03f8873"><![CDATA[{
				string v = value.Trim();

				if (SystemInfo.EqualsIgnoringCase(ConsoleError, v))
				{
					m_writeToErrorStream = true;
				} 
				else 
				{
					m_writeToErrorStream = false;
				}
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="DebugAppender">
      <declaration><![CDATA[public class DebugAppender : AppenderSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private bool m_immediateFlush = true;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="55" sc="3" el="186" ec="40">log4net\Appender\DebugAppender.cs</location>
            <body hash="45d8aebad22920de3f28809d326dec99"><![CDATA[public DebugAppender()
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="DebugAppender" /> 
		/// with a specified layout.
		/// </summary>
		/// <param name="layout">The layout to use with this appender.</param>
		/// <remarks>
		/// <para>
		/// Obsolete constructor.
		/// </para>
		/// </remarks>
		[System.Obsolete("Instead use the default constructor and set the Layout property")]
		public DebugAppender(ILayout layout)
		{
			Layout = layout;
		}

		#endregion Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Gets or sets a value that indicates whether the appender will 
		/// flush at the end of each write.
		/// </summary>
		/// <remarks>
		/// <para>The default behavior is to flush at the end of each 
		/// write. If the option is set to<c>false</c>, then the underlying 
		/// stream can defer writing to physical medium to a later time. 
		/// </para>
		/// <para>
		/// Avoiding the flush operation at the end of each append results 
		/// in a performance gain of 10 to 20 percent. However, there is safety
		/// trade-off involved in skipping flushing. Indeed, when flushing is
		/// skipped, then it is likely that the last few log events will not
		/// be recorded on disk when the application exits. This is a high
		/// price to pay even for a 20% performance gain.
		/// </para>
		/// </remarks>
		public bool ImmediateFlush
		{
			get { return m_immediateFlush; }
			set { m_immediateFlush = value; }
		}

		#endregion Public Instance Properties

#if !NETSTANDARD1_3
            /// <summary>
            /// Flushes any buffered log data.
            /// </summary>
            /// <param name="millisecondsTimeout">The maximum time to wait for logging events to be flushed.</param>
            /// <returns><c>True</c> if all logging events were flushed successfully, else <c>false</c>.</returns>
            public override bool Flush(int millisecondsTimeout)
            {
                // Nothing to do if ImmediateFlush is true
                if (m_immediateFlush) return true;

                // System.Diagnostics.Debug is thread-safe, so no need for lock(this).
                System.Diagnostics.Debug.Flush();

                return true;
            }
#endif

		#region Override implementation of AppenderSkeleton

		/// <summary>
		/// Writes the logging event to the <see cref="System.Diagnostics.Debug"/> system.
		/// </summary>
		/// <param name="loggingEvent">The event to log.</param>
		/// <remarks>
		/// <para>
		/// Writes the logging event to the <see cref="System.Diagnostics.Debug"/> system.
		/// If <see cref="ImmediateFlush"/> is <c>true</c> then the <see cref="System.Diagnostics.Debug.Flush"/>
		/// is called.
		/// </para>
		/// </remarks>
		override protected void Append(LoggingEvent loggingEvent) 
		{
			//
			// Write the string to the Debug system
			//
			System.Diagnostics.Debug.Write(RenderLoggingEvent(loggingEvent), loggingEvent.LoggerName);
#if !NETSTANDARD1_3
			//
			// Flush the Debug system if needed
			//
			if (m_immediateFlush) 
			{
				System.Diagnostics.Debug.Flush();
			} 
#endif
		}

		/// <summary>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </summary>
		/// <value><c>true</c></value>
		/// <remarks>
		/// <para>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </para>
		/// </remarks>
		override protected bool RequiresLayout
		{
			get { return true; }
		}

		#endregion Override implementation of AppenderSkeleton

		#region Private Instance Fields

		/// <summary>
		/// Immediate flush means that the underlying writer or output stream
		/// will be flushed at the end of each append operation.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Immediate flush is slower but ensures that each append request is 
		/// actually written. If <see cref="ImmediateFlush"/> is set to
		/// <c>false</c>, then there is a good chance that the last few
		/// logs events are not actually written to persistent media if and
		/// when the application crashes.
		/// </para>
		/// <para>
		/// The default value is <c>true</c>.</para>
		/// </remarks>
		private bool m_immediateFlush = true;]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <deprecation>Instead use the default constructor and set the Layout property</deprecation>
          <declaration><![CDATA[private bool m_immediateFlush = true;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="70" sc="3" el="186" ec="40">log4net\Appender\DebugAppender.cs</location>
            <body hash="803ebb0012d10ee1b73ca4a3329dfb46"><![CDATA[public DebugAppender(ILayout layout)
		{
			Layout = layout;
		}

		#endregion Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Gets or sets a value that indicates whether the appender will 
		/// flush at the end of each write.
		/// </summary>
		/// <remarks>
		/// <para>The default behavior is to flush at the end of each 
		/// write. If the option is set to<c>false</c>, then the underlying 
		/// stream can defer writing to physical medium to a later time. 
		/// </para>
		/// <para>
		/// Avoiding the flush operation at the end of each append results 
		/// in a performance gain of 10 to 20 percent. However, there is safety
		/// trade-off involved in skipping flushing. Indeed, when flushing is
		/// skipped, then it is likely that the last few log events will not
		/// be recorded on disk when the application exits. This is a high
		/// price to pay even for a 20% performance gain.
		/// </para>
		/// </remarks>
		public bool ImmediateFlush
		{
			get { return m_immediateFlush; }
			set { m_immediateFlush = value; }
		}

		#endregion Public Instance Properties

#if !NETSTANDARD1_3
            /// <summary>
            /// Flushes any buffered log data.
            /// </summary>
            /// <param name="millisecondsTimeout">The maximum time to wait for logging events to be flushed.</param>
            /// <returns><c>True</c> if all logging events were flushed successfully, else <c>false</c>.</returns>
            public override bool Flush(int millisecondsTimeout)
            {
                // Nothing to do if ImmediateFlush is true
                if (m_immediateFlush) return true;

                // System.Diagnostics.Debug is thread-safe, so no need for lock(this).
                System.Diagnostics.Debug.Flush();

                return true;
            }
#endif

		#region Override implementation of AppenderSkeleton

		/// <summary>
		/// Writes the logging event to the <see cref="System.Diagnostics.Debug"/> system.
		/// </summary>
		/// <param name="loggingEvent">The event to log.</param>
		/// <remarks>
		/// <para>
		/// Writes the logging event to the <see cref="System.Diagnostics.Debug"/> system.
		/// If <see cref="ImmediateFlush"/> is <c>true</c> then the <see cref="System.Diagnostics.Debug.Flush"/>
		/// is called.
		/// </para>
		/// </remarks>
		override protected void Append(LoggingEvent loggingEvent) 
		{
			//
			// Write the string to the Debug system
			//
			System.Diagnostics.Debug.Write(RenderLoggingEvent(loggingEvent), loggingEvent.LoggerName);
#if !NETSTANDARD1_3
			//
			// Flush the Debug system if needed
			//
			if (m_immediateFlush) 
			{
				System.Diagnostics.Debug.Flush();
			} 
#endif
		}

		/// <summary>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </summary>
		/// <value><c>true</c></value>
		/// <remarks>
		/// <para>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </para>
		/// </remarks>
		override protected bool RequiresLayout
		{
			get { return true; }
		}

		#endregion Override implementation of AppenderSkeleton

		#region Private Instance Fields

		/// <summary>
		/// Immediate flush means that the underlying writer or output stream
		/// will be flushed at the end of each append operation.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Immediate flush is slower but ensures that each append request is 
		/// actually written. If <see cref="ImmediateFlush"/> is set to
		/// <c>false</c>, then there is a good chance that the last few
		/// logs events are not actually written to persistent media if and
		/// when the application crashes.
		/// </para>
		/// <para>
		/// The default value is <c>true</c>.</para>
		/// </remarks>
		private bool m_immediateFlush = true;]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Append">
          <declaration><![CDATA[protected override void Append(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="137" sc="3" el="151" ec="4">log4net\Appender\DebugAppender.cs</location>
            <body hash="f521990d7e041874be8888dfd5d08335"><![CDATA[{
			//
			// Write the string to the Debug system
			//
			System.Diagnostics.Debug.Write(RenderLoggingEvent(loggingEvent), loggingEvent.LoggerName);
#if !NETSTANDARD1_3
			//
			// Flush the Debug system if needed
			//
			if (m_immediateFlush) 
			{
				System.Diagnostics.Debug.Flush();
			} 
#endif
		}]]></body>
          </codeblock>
        </method>
        <method name="Flush">
          <declaration><![CDATA[public override bool Flush(int millisecondsTimeout)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="112" sc="13" el="120" ec="14">log4net\Appender\DebugAppender.cs</location>
            <body hash="b8033acc5cb10be7b3b7a7a939728ba4"><![CDATA[{
                // Nothing to do if ImmediateFlush is true
                if (m_immediateFlush) return true;

                // System.Diagnostics.Debug is thread-safe, so no need for lock(this).
                System.Diagnostics.Debug.Flush();

                return true;
            }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_immediateFlush">
          <declaration><![CDATA[private bool m_immediateFlush = true;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="ImmediateFlush">
          <declaration><![CDATA[public bool ImmediateFlush]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="RequiresLayout">
          <declaration><![CDATA[protected override bool RequiresLayout]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="EventLogAppender">
      <declaration><![CDATA[public class EventLogAppender : AppenderSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private LevelMapping m_levelMapping = new LevelMapping();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="99" sc="3" el="569" ec="38">log4net\Appender\EventLogAppender.cs</location>
            <body hash="04c8abb2024ebbca04d61c648336485a"><![CDATA[public EventLogAppender()
		{
			m_applicationName	= System.Threading.Thread.GetDomain().FriendlyName;
			m_logName			= "Application";	// Defaults to application log
			m_machineName		= ".";	// Only log on the local machine
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="EventLogAppender" /> class
		/// with the specified <see cref="ILayout" />.
		/// </summary>
		/// <param name="layout">The <see cref="ILayout" /> to use with this appender.</param>
		/// <remarks>
		/// <para>
		/// Obsolete constructor.
		/// </para>
		/// </remarks>
		[Obsolete("Instead use the default constructor and set the Layout property")]
		public EventLogAppender(ILayout layout) : this()
		{
			Layout = layout;
		}

		#endregion // Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// The name of the log where messages will be stored.
		/// </summary>
		/// <value>
		/// The string name of the log where messages will be stored.
		/// </value>
		/// <remarks>
		/// <para>This is the name of the log as it appears in the Event Viewer
		/// tree. The default value is to log into the <c>Application</c>
		/// log, this is where most applications write their events. However
		/// if you need a separate log for your application (or applications)
		/// then you should set the <see cref="LogName"/> appropriately.</para>
		/// <para>This should not be used to distinguish your event log messages
		/// from those of other applications, the <see cref="ApplicationName"/>
		/// property should be used to distinguish events. This property should be 
		/// used to group together events into a single log.
		/// </para>
		/// </remarks>
		public string LogName
		{
			get { return m_logName; }
			set { m_logName = value; }
		}

		/// <summary>
		/// Property used to set the Application name.  This appears in the
		/// event logs when logging.
		/// </summary>
		/// <value>
		/// The string used to distinguish events from different sources.
		/// </value>
		/// <remarks>
		/// Sets the event log source property.
		/// </remarks>
		public string ApplicationName
		{
			get { return m_applicationName; }
			set { m_applicationName = value; }
		}

		/// <summary>
		/// This property is used to return the name of the computer to use
		/// when accessing the event logs.  Currently, this is the current
		/// computer, denoted by a dot "."
		/// </summary>
		/// <value>
		/// The string name of the machine holding the event log that 
		/// will be logged into.
		/// </value>
		/// <remarks>
		/// This property cannot be changed. It is currently set to '.'
		/// i.e. the local machine. This may be changed in future.
		/// </remarks>
		public string MachineName
		{
			get { return m_machineName; }
			set { /* Currently we do not allow the machine name to be changed */; }
		}

		/// <summary>
		/// Add a mapping of level to <see cref="EventLogEntryType"/> - done by the config file
		/// </summary>
		/// <param name="mapping">The mapping to add</param>
		/// <remarks>
		/// <para>
		/// Add a <see cref="Level2EventLogEntryType"/> mapping to this appender.
		/// Each mapping defines the event log entry type for a level.
		/// </para>
		/// </remarks>
		public void AddMapping(Level2EventLogEntryType mapping)
		{
			m_levelMapping.Add(mapping);
		}

		/// <summary>
		/// Gets or sets the <see cref="SecurityContext"/> used to write to the EventLog.
		/// </summary>
		/// <value>
		/// The <see cref="SecurityContext"/> used to write to the EventLog.
		/// </value>
		/// <remarks>
		/// <para>
		/// The system security context used to write to the EventLog.
		/// </para>
		/// <para>
		/// Unless a <see cref="SecurityContext"/> specified here for this appender
		/// the <see cref="SecurityContextProvider.DefaultProvider"/> is queried for the
		/// security context to use. The default behavior is to use the security context
		/// of the current thread.
		/// </para>
		/// </remarks>
		public SecurityContext SecurityContext 
		{
			get { return m_securityContext; }
			set { m_securityContext = value; }
		}

        /// <summary>
        /// Gets or sets the <c>EventId</c> to use unless one is explicitly specified via the <c>LoggingEvent</c>'s properties.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The <c>EventID</c> of the event log entry will normally be
	    /// set using the <c>EventID</c> property (<see cref="LoggingEvent.Properties"/>)
	    /// on the <see cref="LoggingEvent"/>.
        /// This property provides the fallback value which defaults to 0.
        /// </para>
        /// </remarks>
        public int EventId {
            get { return m_eventId; }
            set { m_eventId = value; }
        }


        /// <summary>
        /// Gets or sets the <c>Category</c> to use unless one is explicitly specified via the <c>LoggingEvent</c>'s properties.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The <c>Category</c> of the event log entry will normally be
	    /// set using the <c>Category</c> property (<see cref="LoggingEvent.Properties"/>)
	    /// on the <see cref="LoggingEvent"/>.
        /// This property provides the fallback value which defaults to 0.
        /// </para>
        /// </remarks>
        public short Category
        {
            get { return m_category; }
            set { m_category = value; }
        }
        #endregion // Public Instance Properties

		#region Implementation of IOptionHandler

		/// <summary>
		/// Initialize the appender based on the options set
		/// </summary>
		/// <remarks>
		/// <para>
		/// This is part of the <see cref="IOptionHandler"/> delayed object
		/// activation scheme. The <see cref="ActivateOptions"/> method must 
		/// be called on this object after the configuration properties have
		/// been set. Until <see cref="ActivateOptions"/> is called this
		/// object is in an undefined state and must not be used. 
		/// </para>
		/// <para>
		/// If any of the configuration properties are modified then 
		/// <see cref="ActivateOptions"/> must be called again.
		/// </para>
		/// </remarks>
		override public void ActivateOptions() 
		{
            try
            {
                base.ActivateOptions();

                if (m_securityContext == null)
                {
                    m_securityContext = SecurityContextProvider.DefaultProvider.CreateSecurityContext(this);
                }

                bool sourceAlreadyExists = false;
                string currentLogName = null;

                using (SecurityContext.Impersonate(this))
                {
                    sourceAlreadyExists = EventLog.SourceExists(m_applicationName);
                    if (sourceAlreadyExists) {
                        currentLogName = EventLog.LogNameFromSourceName(m_applicationName, m_machineName);
                    }
                }

                if (sourceAlreadyExists && currentLogName != m_logName)
                {
                    LogLog.Debug(declaringType, "Changing event source [" + m_applicationName + "] from log [" + currentLogName + "] to log [" + m_logName + "]");
                }
                else if (!sourceAlreadyExists)
                {
                    LogLog.Debug(declaringType, "Creating event source Source [" + m_applicationName + "] in log " + m_logName + "]");
                }

                string registeredLogName = null;

                using (SecurityContext.Impersonate(this))
                {
                    if (sourceAlreadyExists && currentLogName != m_logName)
                    {
                        //
                        // Re-register this to the current application if the user has changed
                        // the application / logfile association
                        //
                        EventLog.DeleteEventSource(m_applicationName, m_machineName);
                        CreateEventSource(m_applicationName, m_logName, m_machineName);

                        registeredLogName = EventLog.LogNameFromSourceName(m_applicationName, m_machineName);
                    }
                    else if (!sourceAlreadyExists)
                    {
                        CreateEventSource(m_applicationName, m_logName, m_machineName);

                        registeredLogName = EventLog.LogNameFromSourceName(m_applicationName, m_machineName);
                    }
                }

                m_levelMapping.ActivateOptions();

                LogLog.Debug(declaringType, "Source [" + m_applicationName + "] is registered to log [" + registeredLogName + "]");
            }
            catch (System.Security.SecurityException ex)
            {
                ErrorHandler.Error("Caught a SecurityException trying to access the EventLog.  Most likely the event source "
                    + m_applicationName
                    + " doesn't exist and must be created by a local administrator.  Will disable EventLogAppender."
                    + "  See http://logging.apache.org/log4net/release/faq.html#trouble-EventLog",
                    ex);
                Threshold = Level.Off;
            }
		}

		#endregion // Implementation of IOptionHandler

		/// <summary>
		/// Create an event log source
		/// </summary>
		/// <remarks>
		/// Uses different API calls under NET_2_0
		/// </remarks>
		private static void CreateEventSource(string source, string logName, string machineName)
		{
#if NET_2_0
			EventSourceCreationData eventSourceCreationData = new EventSourceCreationData(source, logName);
			eventSourceCreationData.MachineName = machineName;
			EventLog.CreateEventSource(eventSourceCreationData);
#else
			EventLog.CreateEventSource(source, logName, machineName);
#endif
		}
 
		#region Override implementation of AppenderSkeleton

		/// <summary>
		/// This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent)"/>
		/// method. 
		/// </summary>
		/// <param name="loggingEvent">the event to log</param>
		/// <remarks>
		/// <para>Writes the event to the system event log using the 
		/// <see cref="ApplicationName"/>.</para>
		/// 
		/// <para>If the event has an <c>EventID</c> property (see <see cref="LoggingEvent.Properties"/>)
		/// set then this integer will be used as the event log event id.</para>
		/// 
		/// <para>
		/// There is a limit of 32K characters for an event log message
		/// </para>
		/// </remarks>
		override protected void Append(LoggingEvent loggingEvent) 
		{
			//
			// Write the resulting string to the event log system
			//
			int eventID = m_eventId;

			// Look for the EventID property
			object eventIDPropertyObj = loggingEvent.LookupProperty("EventID");
			if (eventIDPropertyObj != null)
			{
				if (eventIDPropertyObj is int)
				{
					eventID = (int)eventIDPropertyObj;
				}
				else
				{
					string eventIDPropertyString = eventIDPropertyObj as string;
                    if (eventIDPropertyString == null)
                    {
                        eventIDPropertyString = eventIDPropertyObj.ToString();
                    }
					if (eventIDPropertyString != null && eventIDPropertyString.Length > 0)
					{
						// Read the string property into a number
						int intVal;
						if (SystemInfo.TryParse(eventIDPropertyString, out intVal))
						{
							eventID = intVal;
						}
						else
						{
							ErrorHandler.Error("Unable to parse event ID property [" + eventIDPropertyString + "].");
						}
					}
				}
			}

            short category = m_category;
            // Look for the Category property
            object categoryPropertyObj = loggingEvent.LookupProperty("Category");
            if (categoryPropertyObj != null)
            {
                if (categoryPropertyObj is short)
                {
                    category = (short) categoryPropertyObj;
                }
                else
                {
                    string categoryPropertyString = categoryPropertyObj as string;
                    if (categoryPropertyString == null)
                    {
                        categoryPropertyString = categoryPropertyObj.ToString();
                    }
                    if (categoryPropertyString != null && categoryPropertyString.Length > 0)
                    {
                        // Read the string property into a number
                        short shortVal;
                        if (SystemInfo.TryParse(categoryPropertyString, out shortVal))
                        {
                            category = shortVal;
                        }
                        else
                        {
                            ErrorHandler.Error("Unable to parse event category property [" + categoryPropertyString + "].");
                        }
                    }
                }
            }

			// Write to the event log
			try
			{
				string eventTxt = RenderLoggingEvent(loggingEvent);

				// There is a limit of about 32K characters for an event log message
				if (eventTxt.Length > MAX_EVENTLOG_MESSAGE_SIZE)
				{
					eventTxt = eventTxt.Substring(0, MAX_EVENTLOG_MESSAGE_SIZE);
				}

				EventLogEntryType entryType = GetEntryType(loggingEvent.Level);

				using(SecurityContext.Impersonate(this))
				{
					EventLog.WriteEntry(m_applicationName, eventTxt, entryType, eventID, category);
				}
			}
			catch(Exception ex)
			{
				ErrorHandler.Error("Unable to write to event log [" + m_logName + "] using source [" + m_applicationName + "]", ex);
			}
		} 

		/// <summary>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </summary>
		/// <value><c>true</c></value>
		/// <remarks>
		/// <para>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </para>
		/// </remarks>
		override protected bool RequiresLayout
		{
			get { return true; }
		}

		#endregion // Override implementation of AppenderSkeleton

		#region Protected Instance Methods

		/// <summary>
		/// Get the equivalent <see cref="EventLogEntryType"/> for a <see cref="Level"/> <paramref name="level"/>
		/// </summary>
		/// <param name="level">the Level to convert to an EventLogEntryType</param>
		/// <returns>The equivalent <see cref="EventLogEntryType"/> for a <see cref="Level"/> <paramref name="level"/></returns>
		/// <remarks>
		/// Because there are fewer applicable <see cref="EventLogEntryType"/>
		/// values to use in logging levels than there are in the 
		/// <see cref="Level"/> this is a one way mapping. There is
		/// a loss of information during the conversion.
		/// </remarks>
		virtual protected EventLogEntryType GetEntryType(Level level)
		{
			// see if there is a specified lookup.
			Level2EventLogEntryType entryType = m_levelMapping.Lookup(level) as Level2EventLogEntryType;
			if (entryType != null)
			{
				return entryType.EventLogEntryType;
			}

			// Use default behavior

			if (level >= Level.Error) 
			{
				return EventLogEntryType.Error;
			}
			else if (level == Level.Warn) 
			{
				return EventLogEntryType.Warning;
			} 

			// Default setting
			return EventLogEntryType.Information;
		}

		#endregion // Protected Instance Methods

		#region Private Instance Fields

		/// <summary>
		/// The log name is the section in the event logs where the messages
		/// are stored.
		/// </summary>
		private string m_logName;

		/// <summary>
		/// Name of the application to use when logging.  This appears in the
		/// application column of the event log named by <see cref="m_logName"/>.
		/// </summary>
		private string m_applicationName;

		/// <summary>
		/// The name of the machine which holds the event log. This is
		/// currently only allowed to be '.' i.e. the current machine.
		/// </summary>
		private string m_machineName;

		/// <summary>
		/// Mapping from level object to EventLogEntryType
		/// </summary>
		private LevelMapping m_levelMapping = new LevelMapping();

		/// <summary>
		/// The security context to use for privileged calls
		/// </summary>
		private SecurityContext m_securityContext;

        /// <summary>
        /// The event ID to use unless one is explicitly specified via the <c>LoggingEvent</c>'s properties.
        /// </summary>
        private int m_eventId = 0;

        /// <summary>
        /// The event category to use unless one is explicitly specified via the <c>LoggingEvent</c>'s properties.
        /// </summary>
        private short m_category = 0;]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <deprecation>Instead use the default constructor and set the Layout property</deprecation>
          <declaration><![CDATA[public EventLogAppender(ILayout layout) : this()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="117" sc="45" el="120" ec="4">log4net\Appender\EventLogAppender.cs</location>
            <body hash="571d916e687b04170f7e6366fb614dea"><![CDATA[this()
		{
			Layout = layout;
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static EventLogAppender()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="615" sc="6" el="671" ec="87">log4net\Appender\EventLogAppender.cs</location>
            <body hash="e1328f387e717ea04713d903c912286f"><![CDATA[private readonly static Type declaringType = typeof(EventLogAppender);

		/// <summary>
		/// The maximum size supported by default.
		/// </summary>
		/// <remarks>
		/// http://msdn.microsoft.com/en-us/library/xzwc042w(v=vs.100).aspx
		/// The 32766 documented max size is two bytes shy of 32K (I'm assuming 32766 
		/// may leave space for a two byte null terminator of #0#0). The 32766 max 
		/// length is what the .NET 4.0 source code checks for, but this is WRONG! 
		/// Strings with a length > 31839 on Windows Vista or higher can CORRUPT 
		/// the event log! See: System.Diagnostics.EventLogInternal.InternalWriteEvent() 
		/// for the use of the 32766 max size.
		/// </remarks>
		private readonly static int MAX_EVENTLOG_MESSAGE_SIZE_DEFAULT = 32766;

		/// <summary>
		/// The maximum size supported by a windows operating system that is vista
		/// or newer.
		/// </summary>
		/// <remarks>
		/// See ReportEvent API:
		///		http://msdn.microsoft.com/en-us/library/aa363679(VS.85).aspx
		/// ReportEvent's lpStrings parameter:
		/// "A pointer to a buffer containing an array of 
		/// null-terminated strings that are merged into the message before Event Viewer 
		/// displays the string to the user. This parameter must be a valid pointer 
		/// (or NULL), even if wNumStrings is zero. Each string is limited to 31,839 characters."
		/// 
		/// Going beyond the size of 31839 will (at some point) corrupt the event log on Windows
		/// Vista or higher! It may succeed for a while...but you will eventually run into the
		/// error: "System.ComponentModel.Win32Exception : A device attached to the system is
		/// not functioning", and the event log will then be corrupt (I was able to corrupt 
		/// an event log using a length of 31877 on Windows 7).
		/// 
		/// The max size for Windows Vista or higher is documented here:
		///		http://msdn.microsoft.com/en-us/library/xzwc042w(v=vs.100).aspx.
		/// Going over this size may succeed a few times but the buffer will overrun and 
		/// eventually corrupt the log (based on testing).
		/// 
		/// The maxEventMsgSize size is based on the max buffer size of the lpStrings parameter of the ReportEvent API.
		/// The documented max size for EventLog.WriteEntry for Windows Vista and higher is 31839, but I'm leaving room for a
		/// terminator of #0#0, as we cannot see the source of ReportEvent (though we could use an API monitor to examine the
		/// buffer, given enough time).
		/// </remarks>
		private readonly static int MAX_EVENTLOG_MESSAGE_SIZE_VISTA_OR_NEWER = 31839 - 2;

		/// <summary>
		/// The maximum size that the operating system supports for
		/// a event log message.
		/// </summary>
		/// <remarks>
		/// Used to determine the maximum string length that can be written
		/// to the operating system event log and eventually truncate a string
		/// that exceeds the limits.
		/// </remarks>
		private readonly static int MAX_EVENTLOG_MESSAGE_SIZE = GetMaxEventLogMessageSize();]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public override void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="277" sc="3" el="343" ec="4">log4net\Appender\EventLogAppender.cs</location>
            <body hash="39b4aea337f0a0c232cefa6906237aae"><![CDATA[{
            try
            {
                base.ActivateOptions();

                if (m_securityContext == null)
                {
                    m_securityContext = SecurityContextProvider.DefaultProvider.CreateSecurityContext(this);
                }

                bool sourceAlreadyExists = false;
                string currentLogName = null;

                using (SecurityContext.Impersonate(this))
                {
                    sourceAlreadyExists = EventLog.SourceExists(m_applicationName);
                    if (sourceAlreadyExists) {
                        currentLogName = EventLog.LogNameFromSourceName(m_applicationName, m_machineName);
                    }
                }

                if (sourceAlreadyExists && currentLogName != m_logName)
                {
                    LogLog.Debug(declaringType, "Changing event source [" + m_applicationName + "] from log [" + currentLogName + "] to log [" + m_logName + "]");
                }
                else if (!sourceAlreadyExists)
                {
                    LogLog.Debug(declaringType, "Creating event source Source [" + m_applicationName + "] in log " + m_logName + "]");
                }

                string registeredLogName = null;

                using (SecurityContext.Impersonate(this))
                {
                    if (sourceAlreadyExists && currentLogName != m_logName)
                    {
                        //
                        // Re-register this to the current application if the user has changed
                        // the application / logfile association
                        //
                        EventLog.DeleteEventSource(m_applicationName, m_machineName);
                        CreateEventSource(m_applicationName, m_logName, m_machineName);

                        registeredLogName = EventLog.LogNameFromSourceName(m_applicationName, m_machineName);
                    }
                    else if (!sourceAlreadyExists)
                    {
                        CreateEventSource(m_applicationName, m_logName, m_machineName);

                        registeredLogName = EventLog.LogNameFromSourceName(m_applicationName, m_machineName);
                    }
                }

                m_levelMapping.ActivateOptions();

                LogLog.Debug(declaringType, "Source [" + m_applicationName + "] is registered to log [" + registeredLogName + "]");
            }
            catch (System.Security.SecurityException ex)
            {
                ErrorHandler.Error("Caught a SecurityException trying to access the EventLog.  Most likely the event source "
                    + m_applicationName
                    + " doesn't exist and must be created by a local administrator.  Will disable EventLogAppender."
                    + "  See http://logging.apache.org/log4net/release/faq.html#trouble-EventLog",
                    ex);
                Threshold = Level.Off;
            }
		}]]></body>
          </codeblock>
        </method>
        <method name="AddMapping">
          <declaration><![CDATA[public void AddMapping(EventLogAppender.Level2EventLogEntryType mapping)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="196" sc="3" el="198" ec="4">log4net\Appender\EventLogAppender.cs</location>
            <body hash="9683e4fc6ec5e4d8a9d684ec86bdb867"><![CDATA[{
			m_levelMapping.Add(mapping);
		}]]></body>
          </codeblock>
        </method>
        <method name="Append">
          <declaration><![CDATA[protected override void Append(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="383" sc="3" el="474" ec="4">log4net\Appender\EventLogAppender.cs</location>
            <body hash="41844e8e9afe27c858711f6304be95d6"><![CDATA[{
			//
			// Write the resulting string to the event log system
			//
			int eventID = m_eventId;

			// Look for the EventID property
			object eventIDPropertyObj = loggingEvent.LookupProperty("EventID");
			if (eventIDPropertyObj != null)
			{
				if (eventIDPropertyObj is int)
				{
					eventID = (int)eventIDPropertyObj;
				}
				else
				{
					string eventIDPropertyString = eventIDPropertyObj as string;
                    if (eventIDPropertyString == null)
                    {
                        eventIDPropertyString = eventIDPropertyObj.ToString();
                    }
					if (eventIDPropertyString != null && eventIDPropertyString.Length > 0)
					{
						// Read the string property into a number
						int intVal;
						if (SystemInfo.TryParse(eventIDPropertyString, out intVal))
						{
							eventID = intVal;
						}
						else
						{
							ErrorHandler.Error("Unable to parse event ID property [" + eventIDPropertyString + "].");
						}
					}
				}
			}

            short category = m_category;
            // Look for the Category property
            object categoryPropertyObj = loggingEvent.LookupProperty("Category");
            if (categoryPropertyObj != null)
            {
                if (categoryPropertyObj is short)
                {
                    category = (short) categoryPropertyObj;
                }
                else
                {
                    string categoryPropertyString = categoryPropertyObj as string;
                    if (categoryPropertyString == null)
                    {
                        categoryPropertyString = categoryPropertyObj.ToString();
                    }
                    if (categoryPropertyString != null && categoryPropertyString.Length > 0)
                    {
                        // Read the string property into a number
                        short shortVal;
                        if (SystemInfo.TryParse(categoryPropertyString, out shortVal))
                        {
                            category = shortVal;
                        }
                        else
                        {
                            ErrorHandler.Error("Unable to parse event category property [" + categoryPropertyString + "].");
                        }
                    }
                }
            }

			// Write to the event log
			try
			{
				string eventTxt = RenderLoggingEvent(loggingEvent);

				// There is a limit of about 32K characters for an event log message
				if (eventTxt.Length > MAX_EVENTLOG_MESSAGE_SIZE)
				{
					eventTxt = eventTxt.Substring(0, MAX_EVENTLOG_MESSAGE_SIZE);
				}

				EventLogEntryType entryType = GetEntryType(loggingEvent.Level);

				using(SecurityContext.Impersonate(this))
				{
					EventLog.WriteEntry(m_applicationName, eventTxt, entryType, eventID, category);
				}
			}
			catch(Exception ex)
			{
				ErrorHandler.Error("Unable to write to event log [" + m_logName + "] using source [" + m_applicationName + "]", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="CreateEventSource">
          <declaration><![CDATA[private static void CreateEventSource(string source, string logName, string machineName)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="354" sc="3" el="362" ec="4">log4net\Appender\EventLogAppender.cs</location>
            <body hash="3ec212c86d8931191079c8a4c15e1080"><![CDATA[{
#if NET_2_0
			EventSourceCreationData eventSourceCreationData = new EventSourceCreationData(source, logName);
			eventSourceCreationData.MachineName = machineName;
			EventLog.CreateEventSource(eventSourceCreationData);
#else
			EventLog.CreateEventSource(source, logName, machineName);
#endif
		}]]></body>
          </codeblock>
        </method>
        <method name="GetEntryType">
          <declaration><![CDATA[protected virtual EventLogEntryType GetEntryType(Level level)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="506" sc="3" el="527" ec="4">log4net\Appender\EventLogAppender.cs</location>
            <body hash="fa446e0c7e778579a50bc0b7ab3eb147"><![CDATA[{
			// see if there is a specified lookup.
			Level2EventLogEntryType entryType = m_levelMapping.Lookup(level) as Level2EventLogEntryType;
			if (entryType != null)
			{
				return entryType.EventLogEntryType;
			}

			// Use default behavior

			if (level >= Level.Error) 
			{
				return EventLogEntryType.Error;
			}
			else if (level == Level.Warn) 
			{
				return EventLogEntryType.Warning;
			} 

			// Default setting
			return EventLogEntryType.Information;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetMaxEventLogMessageSize">
          <declaration><![CDATA[private static int GetMaxEventLogMessageSize()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="679" sc="3" el="683" ec="4">log4net\Appender\EventLogAppender.cs</location>
            <body hash="58a264846215d85e501511465381eb00"><![CDATA[{
			if (Environment.OSVersion.Platform == PlatformID.Win32NT && Environment.OSVersion.Version.Major >= 6)
				return MAX_EVENTLOG_MESSAGE_SIZE_VISTA_OR_NEWER;
			return MAX_EVENTLOG_MESSAGE_SIZE_DEFAULT;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(EventLogAppender);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_applicationName">
          <declaration><![CDATA[private string m_applicationName;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_category">
          <declaration><![CDATA[private short m_category = 0;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_eventId">
          <declaration><![CDATA[private int m_eventId = 0;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_levelMapping">
          <declaration><![CDATA[private LevelMapping m_levelMapping = new LevelMapping();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_logName">
          <declaration><![CDATA[private string m_logName;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_machineName">
          <declaration><![CDATA[private string m_machineName;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_securityContext">
          <declaration><![CDATA[private SecurityContext m_securityContext;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="MAX_EVENTLOG_MESSAGE_SIZE">
          <declaration><![CDATA[private static readonly int MAX_EVENTLOG_MESSAGE_SIZE = EventLogAppender.GetMaxEventLogMessageSize();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="MAX_EVENTLOG_MESSAGE_SIZE_DEFAULT">
          <declaration><![CDATA[private static readonly int MAX_EVENTLOG_MESSAGE_SIZE_DEFAULT = 32766;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="MAX_EVENTLOG_MESSAGE_SIZE_VISTA_OR_NEWER">
          <declaration><![CDATA[private static readonly int MAX_EVENTLOG_MESSAGE_SIZE_VISTA_OR_NEWER = 31837;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="ApplicationName">
          <declaration><![CDATA[public string ApplicationName]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Category">
          <declaration><![CDATA[public short Category]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="EventId">
          <declaration><![CDATA[public int EventId]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="LogName">
          <declaration><![CDATA[public string LogName]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="MachineName">
          <declaration><![CDATA[public string MachineName]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="RequiresLayout">
          <declaration><![CDATA[protected override bool RequiresLayout]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="SecurityContext">
          <declaration><![CDATA[public SecurityContext SecurityContext]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="FileAppender">
      <declaration><![CDATA[public class FileAppender : TextWriterAppender]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private bool m_appendToFile = true;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="891" sc="3" el="1485" ec="91">log4net\Appender\FileAppender.cs</location>
            <body hash="4c714c43814f91241efe1eb8f83657e1"><![CDATA[public FileAppender()
		{
		}

		/// <summary>
		/// Construct a new appender using the layout, file and append mode.
		/// </summary>
		/// <param name="layout">the layout to use with this appender</param>
		/// <param name="filename">the full path to the file to write to</param>
		/// <param name="append">flag to indicate if the file should be appended to</param>
		/// <remarks>
		/// <para>
		/// Obsolete constructor.
		/// </para>
		/// </remarks>
		[Obsolete("Instead use the default constructor and set the Layout, File & AppendToFile properties")]
		public FileAppender(ILayout layout, string filename, bool append)
		{
			Layout = layout;
			File = filename;
			AppendToFile = append;
			ActivateOptions();
		}

		/// <summary>
		/// Construct a new appender using the layout and file specified.
		/// The file will be appended to.
		/// </summary>
		/// <param name="layout">the layout to use with this appender</param>
		/// <param name="filename">the full path to the file to write to</param>
		/// <remarks>
		/// <para>
		/// Obsolete constructor.
		/// </para>
		/// </remarks>
		[Obsolete("Instead use the default constructor and set the Layout & File properties")]
		public FileAppender(ILayout layout, string filename)
			: this(layout, filename, true)
		{
		}

		#endregion Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Gets or sets the path to the file that logging will be written to.
		/// </summary>
		/// <value>
		/// The path to the file that logging will be written to.
		/// </value>
		/// <remarks>
		/// <para>
		/// If the path is relative it is taken as relative from 
		/// the application base directory.
		/// </para>
		/// </remarks>
		virtual public string File
		{
			get { return m_fileName; }
			set { m_fileName = value; }
		}

		/// <summary>
		/// Gets or sets a flag that indicates whether the file should be
		/// appended to or overwritten.
		/// </summary>
		/// <value>
		/// Indicates whether the file should be appended to or overwritten.
		/// </value>
		/// <remarks>
		/// <para>
		/// If the value is set to false then the file will be overwritten, if 
		/// it is set to true then the file will be appended to.
		/// </para>
		/// The default value is true.
		/// </remarks>
		public bool AppendToFile
		{
			get { return m_appendToFile; }
			set { m_appendToFile = value; }
		}

		/// <summary>
		/// Gets or sets <see cref="Encoding"/> used to write to the file.
		/// </summary>
		/// <value>
		/// The <see cref="Encoding"/> used to write to the file.
		/// </value>
		/// <remarks>
		/// <para>
		/// The default encoding set is <see cref="System.Text.Encoding.Default"/>
		/// which is the encoding for the system's current ANSI code page.
		/// </para>
		/// </remarks>
		public Encoding Encoding
		{
			get { return m_encoding; }
			set { m_encoding = value; }
		}

		/// <summary>
		/// Gets or sets the <see cref="SecurityContext"/> used to write to the file.
		/// </summary>
		/// <value>
		/// The <see cref="SecurityContext"/> used to write to the file.
		/// </value>
		/// <remarks>
		/// <para>
		/// Unless a <see cref="SecurityContext"/> specified here for this appender
		/// the <see cref="SecurityContextProvider.DefaultProvider"/> is queried for the
		/// security context to use. The default behavior is to use the security context
		/// of the current thread.
		/// </para>
		/// </remarks>
		public SecurityContext SecurityContext
		{
			get { return m_securityContext; }
			set { m_securityContext = value; }
		}

#if NETCF
		/// <summary>
		/// Gets or sets the <see cref="FileAppender.LockingModel"/> used to handle locking of the file.
		/// </summary>
		/// <value>
		/// The <see cref="FileAppender.LockingModel"/> used to lock the file.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets or sets the <see cref="FileAppender.LockingModel"/> used to handle locking of the file.
		/// </para>
		/// <para>
        /// There are two built in locking models, <see cref="FileAppender.ExclusiveLock"/> and <see cref="FileAppender.MinimalLock"/>.
		/// The first locks the file from the start of logging to the end, the 
		/// second locks only for the minimal amount of time when logging each message
        /// and the last synchronizes processes using a named system wide Mutex.
		/// </para>
		/// <para>
		/// The default locking model is the <see cref="FileAppender.ExclusiveLock"/>.
		/// </para>
		/// </remarks>
#else
		/// <summary>
		/// Gets or sets the <see cref="FileAppender.LockingModel"/> used to handle locking of the file.
		/// </summary>
		/// <value>
		/// The <see cref="FileAppender.LockingModel"/> used to lock the file.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets or sets the <see cref="FileAppender.LockingModel"/> used to handle locking of the file.
		/// </para>
		/// <para>
		/// There are three built in locking models, <see cref="FileAppender.ExclusiveLock"/>, <see cref="FileAppender.MinimalLock"/> and <see cref="FileAppender.InterProcessLock"/> .
		/// The first locks the file from the start of logging to the end, the 
		/// second locks only for the minimal amount of time when logging each message
		/// and the last synchronizes processes using a named system wide Mutex.
		/// </para>
		/// <para>
		/// The default locking model is the <see cref="FileAppender.ExclusiveLock"/>.
		/// </para>
		/// </remarks>
#endif
		public FileAppender.LockingModelBase LockingModel
		{
			get { return m_lockingModel; }
			set { m_lockingModel = value; }
		}

		#endregion Public Instance Properties

		#region Override implementation of AppenderSkeleton

		/// <summary>
		/// Activate the options on the file appender. 
		/// </summary>
		/// <remarks>
		/// <para>
		/// This is part of the <see cref="IOptionHandler"/> delayed object
		/// activation scheme. The <see cref="ActivateOptions"/> method must 
		/// be called on this object after the configuration properties have
		/// been set. Until <see cref="ActivateOptions"/> is called this
		/// object is in an undefined state and must not be used. 
		/// </para>
		/// <para>
		/// If any of the configuration properties are modified then 
		/// <see cref="ActivateOptions"/> must be called again.
		/// </para>
		/// <para>
		/// This will cause the file to be opened.
		/// </para>
		/// </remarks>
		override public void ActivateOptions()
		{
			base.ActivateOptions();

			if (m_securityContext == null)
			{
				m_securityContext = SecurityContextProvider.DefaultProvider.CreateSecurityContext(this);
			}

			if (m_lockingModel == null)
			{
				m_lockingModel = new FileAppender.ExclusiveLock();
			}

			m_lockingModel.CurrentAppender = this;
			m_lockingModel.ActivateOptions();

			if (m_fileName != null)
			{
				using (SecurityContext.Impersonate(this))
				{
					m_fileName = ConvertToFullPath(m_fileName.Trim());
				}
				SafeOpenFile(m_fileName, m_appendToFile);
			}
			else
			{
				LogLog.Warn(declaringType, "FileAppender: File option not set for appender [" + Name + "].");
				LogLog.Warn(declaringType, "FileAppender: Are you using FileAppender instead of ConsoleAppender?");
			}
		}

		#endregion Override implementation of AppenderSkeleton

		#region Override implementation of TextWriterAppender

		/// <summary>
		/// Closes any previously opened file and calls the parent's <see cref="TextWriterAppender.Reset"/>.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Resets the filename and the file stream.
		/// </para>
		/// </remarks>
		override protected void Reset()
		{
			base.Reset();
			m_fileName = null;
		}

		/// <summary>
		/// Close this appender instance. The underlying stream or writer is also closed.
		/// </summary>
		override protected void OnClose()
		{
			base.OnClose();
			m_lockingModel.OnClose();
		}

		/// <summary>
		/// Called to initialize the file writer
		/// </summary>
		/// <remarks>
		/// <para>
		/// Will be called for each logged message until the file is
		/// successfully opened.
		/// </para>
		/// </remarks>
		override protected void PrepareWriter()
		{
			SafeOpenFile(m_fileName, m_appendToFile);
		}

		/// <summary>
		/// This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent)"/>
		/// method. 
		/// </summary>
		/// <param name="loggingEvent">The event to log.</param>
		/// <remarks>
		/// <para>
		/// Writes a log statement to the output stream if the output stream exists 
		/// and is writable.  
		/// </para>
		/// <para>
		/// The format of the output will depend on the appender's layout.
		/// </para>
		/// </remarks>
		override protected void Append(LoggingEvent loggingEvent)
		{
			if (m_stream.AcquireLock())
			{
				try
				{
					base.Append(loggingEvent);
				}
				finally
				{
					m_stream.ReleaseLock();
				}
			}
		}

		/// <summary>
		/// This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent[])"/>
		/// method. 
		/// </summary>
		/// <param name="loggingEvents">The array of events to log.</param>
		/// <remarks>
		/// <para>
		/// Acquires the output file locks once before writing all the events to
		/// the stream.
		/// </para>
		/// </remarks>
		override protected void Append(LoggingEvent[] loggingEvents)
		{
			if (m_stream.AcquireLock())
			{
				try
				{
					base.Append(loggingEvents);
				}
				finally
				{
					m_stream.ReleaseLock();
				}
			}
		}

		/// <summary>
		/// Writes a footer as produced by the embedded layout's <see cref="ILayout.Footer"/> property.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Writes a footer as produced by the embedded layout's <see cref="ILayout.Footer"/> property.
		/// </para>
		/// </remarks>
		protected override void WriteFooter()
		{
			if (m_stream != null)
			{
				//WriteFooter can be called even before a file is opened
				m_stream.AcquireLock();
				try
				{
					base.WriteFooter();
				}
				finally
				{
					m_stream.ReleaseLock();
				}
			}
		}

		/// <summary>
		/// Writes a header produced by the embedded layout's <see cref="ILayout.Header"/> property.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Writes a header produced by the embedded layout's <see cref="ILayout.Header"/> property.
		/// </para>
		/// </remarks>
		protected override void WriteHeader()
		{
			if (m_stream != null)
			{
				if (m_stream.AcquireLock())
				{
					try
					{
						base.WriteHeader();
					}
					finally
					{
						m_stream.ReleaseLock();
					}
				}
			}
		}

		/// <summary>
		/// Closes the underlying <see cref="TextWriter"/>.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Closes the underlying <see cref="TextWriter"/>.
		/// </para>
		/// </remarks>
		protected override void CloseWriter()
		{
			if (m_stream != null)
			{
				m_stream.AcquireLock();
				try
				{
					base.CloseWriter();
				}
				finally
				{
					m_stream.ReleaseLock();
				}
			}
		}

		#endregion Override implementation of TextWriterAppender

		#region Public Instance Methods

		/// <summary>
		/// Closes the previously opened file.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Writes the <see cref="ILayout.Footer"/> to the file and then
		/// closes the file.
		/// </para>
		/// </remarks>
		protected void CloseFile()
		{
			WriteFooterAndCloseWriter();
		}

		#endregion Public Instance Methods

		#region Protected Instance Methods

		/// <summary>
		/// Sets and <i>opens</i> the file where the log output will go. The specified file must be writable.
		/// </summary>
		/// <param name="fileName">The path to the log file. Must be a fully qualified path.</param>
		/// <param name="append">If true will append to fileName. Otherwise will truncate fileName</param>
		/// <remarks>
		/// <para>
		/// Calls <see cref="OpenFile"/> but guarantees not to throw an exception.
		/// Errors are passed to the <see cref="TextWriterAppender.ErrorHandler"/>.
		/// </para>
		/// </remarks>
		virtual protected void SafeOpenFile(string fileName, bool append)
		{
			try
			{
				OpenFile(fileName, append);
			}
			catch (Exception e)
			{
				ErrorHandler.Error("OpenFile(" + fileName + "," + append + ") call failed.", e, ErrorCode.FileOpenFailure);
			}
		}

		/// <summary>
		/// Sets and <i>opens</i> the file where the log output will go. The specified file must be writable.
		/// </summary>
		/// <param name="fileName">The path to the log file. Must be a fully qualified path.</param>
		/// <param name="append">If true will append to fileName. Otherwise will truncate fileName</param>
		/// <remarks>
		/// <para>
		/// If there was already an opened file, then the previous file
		/// is closed first.
		/// </para>
		/// <para>
		/// This method will ensure that the directory structure
		/// for the <paramref name="fileName"/> specified exists.
		/// </para>
		/// </remarks>
		virtual protected void OpenFile(string fileName, bool append)
		{
			if (LogLog.IsErrorEnabled)
			{
				// Internal check that the fileName passed in is a rooted path
				bool isPathRooted = false;
				using (SecurityContext.Impersonate(this))
				{
					isPathRooted = Path.IsPathRooted(fileName);
				}
				if (!isPathRooted)
				{
					LogLog.Error(declaringType, "INTERNAL ERROR. OpenFile(" + fileName + "): File name is not fully qualified.");
				}
			}

			lock (this)
			{
				Reset();

				LogLog.Debug(declaringType, "Opening file for writing [" + fileName + "] append [" + append + "]");

				// Save these for later, allowing retries if file open fails
				m_fileName = fileName;
				m_appendToFile = append;

				LockingModel.CurrentAppender = this;
				LockingModel.OpenFile(fileName, append, m_encoding);
				m_stream = new LockingStream(LockingModel);

				if (m_stream != null)
				{
					m_stream.AcquireLock();
					try
					{
						SetQWForFiles(m_stream);
					}
					finally
					{
						m_stream.ReleaseLock();
					}
				}

				WriteHeader();
			}
		}

		/// <summary>
		/// Sets the quiet writer used for file output
		/// </summary>
		/// <param name="fileStream">the file stream that has been opened for writing</param>
		/// <remarks>
		/// <para>
		/// This implementation of <see cref="M:SetQWForFiles(Stream)"/> creates a <see cref="StreamWriter"/>
		/// over the <paramref name="fileStream"/> and passes it to the 
		/// <see cref="M:SetQWForFiles(TextWriter)"/> method.
		/// </para>
		/// <para>
		/// This method can be overridden by sub classes that want to wrap the
		/// <see cref="Stream"/> in some way, for example to encrypt the output
		/// data using a <c>System.Security.Cryptography.CryptoStream</c>.
		/// </para>
		/// </remarks>
		virtual protected void SetQWForFiles(Stream fileStream)
		{
			SetQWForFiles(new StreamWriter(fileStream, m_encoding));
		}

		/// <summary>
		/// Sets the quiet writer being used.
		/// </summary>
		/// <param name="writer">the writer over the file stream that has been opened for writing</param>
		/// <remarks>
		/// <para>
		/// This method can be overridden by sub classes that want to
		/// wrap the <see cref="TextWriter"/> in some way.
		/// </para>
		/// </remarks>
		virtual protected void SetQWForFiles(TextWriter writer)
		{
			QuietWriter = new QuietTextWriter(writer, ErrorHandler);
		}

		#endregion Protected Instance Methods

		#region Protected Static Methods

		/// <summary>
		/// Convert a path into a fully qualified path.
		/// </summary>
		/// <param name="path">The path to convert.</param>
		/// <returns>The fully qualified path.</returns>
		/// <remarks>
		/// <para>
		/// Converts the path specified to a fully
		/// qualified path. If the path is relative it is
		/// taken as relative from the application base 
		/// directory.
		/// </para>
		/// </remarks>
		protected static string ConvertToFullPath(string path)
		{
			return SystemInfo.ConvertToFullPath(path);
		}

		#endregion Protected Static Methods

		#region Private Instance Fields

		/// <summary>
		/// Flag to indicate if we should append to the file
		/// or overwrite the file. The default is to append.
		/// </summary>
		private bool m_appendToFile = true;

		/// <summary>
		/// The name of the log file.
		/// </summary>
		private string m_fileName = null;

		/// <summary>
		/// The encoding to use for the file stream.
		/// </summary>
		private Encoding m_encoding = Encoding.GetEncoding(0);

		/// <summary>
		/// The security context to use for privileged calls
		/// </summary>
		private SecurityContext m_securityContext;

		/// <summary>
		/// The stream to log to. Has added locking semantics
		/// </summary>
		private FileAppender.LockingStream m_stream = null;

		/// <summary>
		/// The locking model to use
		/// </summary>
		private FileAppender.LockingModelBase m_lockingModel = new FileAppender.ExclusiveLock();]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <deprecation>Instead use the default constructor and set the Layout, File &amp; AppendToFile properties</deprecation>
          <declaration><![CDATA[private bool m_appendToFile = true;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="907" sc="3" el="1485" ec="91">log4net\Appender\FileAppender.cs</location>
            <body hash="eaead7825fb60596d1fcd5a35d5602ae"><![CDATA[public FileAppender(ILayout layout, string filename, bool append)
		{
			Layout = layout;
			File = filename;
			AppendToFile = append;
			ActivateOptions();
		}

		/// <summary>
		/// Construct a new appender using the layout and file specified.
		/// The file will be appended to.
		/// </summary>
		/// <param name="layout">the layout to use with this appender</param>
		/// <param name="filename">the full path to the file to write to</param>
		/// <remarks>
		/// <para>
		/// Obsolete constructor.
		/// </para>
		/// </remarks>
		[Obsolete("Instead use the default constructor and set the Layout & File properties")]
		public FileAppender(ILayout layout, string filename)
			: this(layout, filename, true)
		{
		}

		#endregion Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Gets or sets the path to the file that logging will be written to.
		/// </summary>
		/// <value>
		/// The path to the file that logging will be written to.
		/// </value>
		/// <remarks>
		/// <para>
		/// If the path is relative it is taken as relative from 
		/// the application base directory.
		/// </para>
		/// </remarks>
		virtual public string File
		{
			get { return m_fileName; }
			set { m_fileName = value; }
		}

		/// <summary>
		/// Gets or sets a flag that indicates whether the file should be
		/// appended to or overwritten.
		/// </summary>
		/// <value>
		/// Indicates whether the file should be appended to or overwritten.
		/// </value>
		/// <remarks>
		/// <para>
		/// If the value is set to false then the file will be overwritten, if 
		/// it is set to true then the file will be appended to.
		/// </para>
		/// The default value is true.
		/// </remarks>
		public bool AppendToFile
		{
			get { return m_appendToFile; }
			set { m_appendToFile = value; }
		}

		/// <summary>
		/// Gets or sets <see cref="Encoding"/> used to write to the file.
		/// </summary>
		/// <value>
		/// The <see cref="Encoding"/> used to write to the file.
		/// </value>
		/// <remarks>
		/// <para>
		/// The default encoding set is <see cref="System.Text.Encoding.Default"/>
		/// which is the encoding for the system's current ANSI code page.
		/// </para>
		/// </remarks>
		public Encoding Encoding
		{
			get { return m_encoding; }
			set { m_encoding = value; }
		}

		/// <summary>
		/// Gets or sets the <see cref="SecurityContext"/> used to write to the file.
		/// </summary>
		/// <value>
		/// The <see cref="SecurityContext"/> used to write to the file.
		/// </value>
		/// <remarks>
		/// <para>
		/// Unless a <see cref="SecurityContext"/> specified here for this appender
		/// the <see cref="SecurityContextProvider.DefaultProvider"/> is queried for the
		/// security context to use. The default behavior is to use the security context
		/// of the current thread.
		/// </para>
		/// </remarks>
		public SecurityContext SecurityContext
		{
			get { return m_securityContext; }
			set { m_securityContext = value; }
		}

#if NETCF
		/// <summary>
		/// Gets or sets the <see cref="FileAppender.LockingModel"/> used to handle locking of the file.
		/// </summary>
		/// <value>
		/// The <see cref="FileAppender.LockingModel"/> used to lock the file.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets or sets the <see cref="FileAppender.LockingModel"/> used to handle locking of the file.
		/// </para>
		/// <para>
        /// There are two built in locking models, <see cref="FileAppender.ExclusiveLock"/> and <see cref="FileAppender.MinimalLock"/>.
		/// The first locks the file from the start of logging to the end, the 
		/// second locks only for the minimal amount of time when logging each message
        /// and the last synchronizes processes using a named system wide Mutex.
		/// </para>
		/// <para>
		/// The default locking model is the <see cref="FileAppender.ExclusiveLock"/>.
		/// </para>
		/// </remarks>
#else
		/// <summary>
		/// Gets or sets the <see cref="FileAppender.LockingModel"/> used to handle locking of the file.
		/// </summary>
		/// <value>
		/// The <see cref="FileAppender.LockingModel"/> used to lock the file.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets or sets the <see cref="FileAppender.LockingModel"/> used to handle locking of the file.
		/// </para>
		/// <para>
		/// There are three built in locking models, <see cref="FileAppender.ExclusiveLock"/>, <see cref="FileAppender.MinimalLock"/> and <see cref="FileAppender.InterProcessLock"/> .
		/// The first locks the file from the start of logging to the end, the 
		/// second locks only for the minimal amount of time when logging each message
		/// and the last synchronizes processes using a named system wide Mutex.
		/// </para>
		/// <para>
		/// The default locking model is the <see cref="FileAppender.ExclusiveLock"/>.
		/// </para>
		/// </remarks>
#endif
		public FileAppender.LockingModelBase LockingModel
		{
			get { return m_lockingModel; }
			set { m_lockingModel = value; }
		}

		#endregion Public Instance Properties

		#region Override implementation of AppenderSkeleton

		/// <summary>
		/// Activate the options on the file appender. 
		/// </summary>
		/// <remarks>
		/// <para>
		/// This is part of the <see cref="IOptionHandler"/> delayed object
		/// activation scheme. The <see cref="ActivateOptions"/> method must 
		/// be called on this object after the configuration properties have
		/// been set. Until <see cref="ActivateOptions"/> is called this
		/// object is in an undefined state and must not be used. 
		/// </para>
		/// <para>
		/// If any of the configuration properties are modified then 
		/// <see cref="ActivateOptions"/> must be called again.
		/// </para>
		/// <para>
		/// This will cause the file to be opened.
		/// </para>
		/// </remarks>
		override public void ActivateOptions()
		{
			base.ActivateOptions();

			if (m_securityContext == null)
			{
				m_securityContext = SecurityContextProvider.DefaultProvider.CreateSecurityContext(this);
			}

			if (m_lockingModel == null)
			{
				m_lockingModel = new FileAppender.ExclusiveLock();
			}

			m_lockingModel.CurrentAppender = this;
			m_lockingModel.ActivateOptions();

			if (m_fileName != null)
			{
				using (SecurityContext.Impersonate(this))
				{
					m_fileName = ConvertToFullPath(m_fileName.Trim());
				}
				SafeOpenFile(m_fileName, m_appendToFile);
			}
			else
			{
				LogLog.Warn(declaringType, "FileAppender: File option not set for appender [" + Name + "].");
				LogLog.Warn(declaringType, "FileAppender: Are you using FileAppender instead of ConsoleAppender?");
			}
		}

		#endregion Override implementation of AppenderSkeleton

		#region Override implementation of TextWriterAppender

		/// <summary>
		/// Closes any previously opened file and calls the parent's <see cref="TextWriterAppender.Reset"/>.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Resets the filename and the file stream.
		/// </para>
		/// </remarks>
		override protected void Reset()
		{
			base.Reset();
			m_fileName = null;
		}

		/// <summary>
		/// Close this appender instance. The underlying stream or writer is also closed.
		/// </summary>
		override protected void OnClose()
		{
			base.OnClose();
			m_lockingModel.OnClose();
		}

		/// <summary>
		/// Called to initialize the file writer
		/// </summary>
		/// <remarks>
		/// <para>
		/// Will be called for each logged message until the file is
		/// successfully opened.
		/// </para>
		/// </remarks>
		override protected void PrepareWriter()
		{
			SafeOpenFile(m_fileName, m_appendToFile);
		}

		/// <summary>
		/// This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent)"/>
		/// method. 
		/// </summary>
		/// <param name="loggingEvent">The event to log.</param>
		/// <remarks>
		/// <para>
		/// Writes a log statement to the output stream if the output stream exists 
		/// and is writable.  
		/// </para>
		/// <para>
		/// The format of the output will depend on the appender's layout.
		/// </para>
		/// </remarks>
		override protected void Append(LoggingEvent loggingEvent)
		{
			if (m_stream.AcquireLock())
			{
				try
				{
					base.Append(loggingEvent);
				}
				finally
				{
					m_stream.ReleaseLock();
				}
			}
		}

		/// <summary>
		/// This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent[])"/>
		/// method. 
		/// </summary>
		/// <param name="loggingEvents">The array of events to log.</param>
		/// <remarks>
		/// <para>
		/// Acquires the output file locks once before writing all the events to
		/// the stream.
		/// </para>
		/// </remarks>
		override protected void Append(LoggingEvent[] loggingEvents)
		{
			if (m_stream.AcquireLock())
			{
				try
				{
					base.Append(loggingEvents);
				}
				finally
				{
					m_stream.ReleaseLock();
				}
			}
		}

		/// <summary>
		/// Writes a footer as produced by the embedded layout's <see cref="ILayout.Footer"/> property.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Writes a footer as produced by the embedded layout's <see cref="ILayout.Footer"/> property.
		/// </para>
		/// </remarks>
		protected override void WriteFooter()
		{
			if (m_stream != null)
			{
				//WriteFooter can be called even before a file is opened
				m_stream.AcquireLock();
				try
				{
					base.WriteFooter();
				}
				finally
				{
					m_stream.ReleaseLock();
				}
			}
		}

		/// <summary>
		/// Writes a header produced by the embedded layout's <see cref="ILayout.Header"/> property.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Writes a header produced by the embedded layout's <see cref="ILayout.Header"/> property.
		/// </para>
		/// </remarks>
		protected override void WriteHeader()
		{
			if (m_stream != null)
			{
				if (m_stream.AcquireLock())
				{
					try
					{
						base.WriteHeader();
					}
					finally
					{
						m_stream.ReleaseLock();
					}
				}
			}
		}

		/// <summary>
		/// Closes the underlying <see cref="TextWriter"/>.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Closes the underlying <see cref="TextWriter"/>.
		/// </para>
		/// </remarks>
		protected override void CloseWriter()
		{
			if (m_stream != null)
			{
				m_stream.AcquireLock();
				try
				{
					base.CloseWriter();
				}
				finally
				{
					m_stream.ReleaseLock();
				}
			}
		}

		#endregion Override implementation of TextWriterAppender

		#region Public Instance Methods

		/// <summary>
		/// Closes the previously opened file.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Writes the <see cref="ILayout.Footer"/> to the file and then
		/// closes the file.
		/// </para>
		/// </remarks>
		protected void CloseFile()
		{
			WriteFooterAndCloseWriter();
		}

		#endregion Public Instance Methods

		#region Protected Instance Methods

		/// <summary>
		/// Sets and <i>opens</i> the file where the log output will go. The specified file must be writable.
		/// </summary>
		/// <param name="fileName">The path to the log file. Must be a fully qualified path.</param>
		/// <param name="append">If true will append to fileName. Otherwise will truncate fileName</param>
		/// <remarks>
		/// <para>
		/// Calls <see cref="OpenFile"/> but guarantees not to throw an exception.
		/// Errors are passed to the <see cref="TextWriterAppender.ErrorHandler"/>.
		/// </para>
		/// </remarks>
		virtual protected void SafeOpenFile(string fileName, bool append)
		{
			try
			{
				OpenFile(fileName, append);
			}
			catch (Exception e)
			{
				ErrorHandler.Error("OpenFile(" + fileName + "," + append + ") call failed.", e, ErrorCode.FileOpenFailure);
			}
		}

		/// <summary>
		/// Sets and <i>opens</i> the file where the log output will go. The specified file must be writable.
		/// </summary>
		/// <param name="fileName">The path to the log file. Must be a fully qualified path.</param>
		/// <param name="append">If true will append to fileName. Otherwise will truncate fileName</param>
		/// <remarks>
		/// <para>
		/// If there was already an opened file, then the previous file
		/// is closed first.
		/// </para>
		/// <para>
		/// This method will ensure that the directory structure
		/// for the <paramref name="fileName"/> specified exists.
		/// </para>
		/// </remarks>
		virtual protected void OpenFile(string fileName, bool append)
		{
			if (LogLog.IsErrorEnabled)
			{
				// Internal check that the fileName passed in is a rooted path
				bool isPathRooted = false;
				using (SecurityContext.Impersonate(this))
				{
					isPathRooted = Path.IsPathRooted(fileName);
				}
				if (!isPathRooted)
				{
					LogLog.Error(declaringType, "INTERNAL ERROR. OpenFile(" + fileName + "): File name is not fully qualified.");
				}
			}

			lock (this)
			{
				Reset();

				LogLog.Debug(declaringType, "Opening file for writing [" + fileName + "] append [" + append + "]");

				// Save these for later, allowing retries if file open fails
				m_fileName = fileName;
				m_appendToFile = append;

				LockingModel.CurrentAppender = this;
				LockingModel.OpenFile(fileName, append, m_encoding);
				m_stream = new LockingStream(LockingModel);

				if (m_stream != null)
				{
					m_stream.AcquireLock();
					try
					{
						SetQWForFiles(m_stream);
					}
					finally
					{
						m_stream.ReleaseLock();
					}
				}

				WriteHeader();
			}
		}

		/// <summary>
		/// Sets the quiet writer used for file output
		/// </summary>
		/// <param name="fileStream">the file stream that has been opened for writing</param>
		/// <remarks>
		/// <para>
		/// This implementation of <see cref="M:SetQWForFiles(Stream)"/> creates a <see cref="StreamWriter"/>
		/// over the <paramref name="fileStream"/> and passes it to the 
		/// <see cref="M:SetQWForFiles(TextWriter)"/> method.
		/// </para>
		/// <para>
		/// This method can be overridden by sub classes that want to wrap the
		/// <see cref="Stream"/> in some way, for example to encrypt the output
		/// data using a <c>System.Security.Cryptography.CryptoStream</c>.
		/// </para>
		/// </remarks>
		virtual protected void SetQWForFiles(Stream fileStream)
		{
			SetQWForFiles(new StreamWriter(fileStream, m_encoding));
		}

		/// <summary>
		/// Sets the quiet writer being used.
		/// </summary>
		/// <param name="writer">the writer over the file stream that has been opened for writing</param>
		/// <remarks>
		/// <para>
		/// This method can be overridden by sub classes that want to
		/// wrap the <see cref="TextWriter"/> in some way.
		/// </para>
		/// </remarks>
		virtual protected void SetQWForFiles(TextWriter writer)
		{
			QuietWriter = new QuietTextWriter(writer, ErrorHandler);
		}

		#endregion Protected Instance Methods

		#region Protected Static Methods

		/// <summary>
		/// Convert a path into a fully qualified path.
		/// </summary>
		/// <param name="path">The path to convert.</param>
		/// <returns>The fully qualified path.</returns>
		/// <remarks>
		/// <para>
		/// Converts the path specified to a fully
		/// qualified path. If the path is relative it is
		/// taken as relative from the application base 
		/// directory.
		/// </para>
		/// </remarks>
		protected static string ConvertToFullPath(string path)
		{
			return SystemInfo.ConvertToFullPath(path);
		}

		#endregion Protected Static Methods

		#region Private Instance Fields

		/// <summary>
		/// Flag to indicate if we should append to the file
		/// or overwrite the file. The default is to append.
		/// </summary>
		private bool m_appendToFile = true;

		/// <summary>
		/// The name of the log file.
		/// </summary>
		private string m_fileName = null;

		/// <summary>
		/// The encoding to use for the file stream.
		/// </summary>
		private Encoding m_encoding = Encoding.GetEncoding(0);

		/// <summary>
		/// The security context to use for privileged calls
		/// </summary>
		private SecurityContext m_securityContext;

		/// <summary>
		/// The stream to log to. Has added locking semantics
		/// </summary>
		private FileAppender.LockingStream m_stream = null;

		/// <summary>
		/// The locking model to use
		/// </summary>
		private FileAppender.LockingModelBase m_lockingModel = new FileAppender.ExclusiveLock();]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <deprecation>Instead use the default constructor and set the Layout &amp; File properties</deprecation>
          <declaration><![CDATA[public FileAppender(ILayout layout, string filename) : this(layout, filename, true)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="928" sc="6" el="930" ec="4">log4net\Appender\FileAppender.cs</location>
            <body hash="52be94d067c1dd58f334c3b9672ad444"><![CDATA[this(layout, filename, true)
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static FileAppender()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1498" sc="3" el="1498" ec="69">log4net\Appender\FileAppender.cs</location>
            <body hash="c114a45cde46141cc290bbb64ade40db"><![CDATA[private readonly static Type declaringType = typeof(FileAppender)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public override void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1085" sc="3" el="1114" ec="4">log4net\Appender\FileAppender.cs</location>
            <body hash="c40e7c14bc708f0f3c5454e47864bb1f"><![CDATA[{
			base.ActivateOptions();

			if (m_securityContext == null)
			{
				m_securityContext = SecurityContextProvider.DefaultProvider.CreateSecurityContext(this);
			}

			if (m_lockingModel == null)
			{
				m_lockingModel = new FileAppender.ExclusiveLock();
			}

			m_lockingModel.CurrentAppender = this;
			m_lockingModel.ActivateOptions();

			if (m_fileName != null)
			{
				using (SecurityContext.Impersonate(this))
				{
					m_fileName = ConvertToFullPath(m_fileName.Trim());
				}
				SafeOpenFile(m_fileName, m_appendToFile);
			}
			else
			{
				LogLog.Warn(declaringType, "FileAppender: File option not set for appender [" + Name + "].");
				LogLog.Warn(declaringType, "FileAppender: Are you using FileAppender instead of ConsoleAppender?");
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Append">
          <declaration><![CDATA[protected override void Append(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1172" sc="3" el="1184" ec="4">log4net\Appender\FileAppender.cs</location>
            <body hash="53075bcb0d4ac50ff132212b9ee01829"><![CDATA[{
			if (m_stream.AcquireLock())
			{
				try
				{
					base.Append(loggingEvent);
				}
				finally
				{
					m_stream.ReleaseLock();
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Append">
          <declaration><![CDATA[protected override void Append(LoggingEvent[] loggingEvents)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1198" sc="3" el="1210" ec="4">log4net\Appender\FileAppender.cs</location>
            <body hash="a3fb69b83d2f62f5429e6d697e0713be"><![CDATA[{
			if (m_stream.AcquireLock())
			{
				try
				{
					base.Append(loggingEvents);
				}
				finally
				{
					m_stream.ReleaseLock();
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="CloseFile">
          <declaration><![CDATA[protected void CloseFile()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1301" sc="3" el="1303" ec="4">log4net\Appender\FileAppender.cs</location>
            <body hash="c0f40ee5037254b3e00b454980a09ca7"><![CDATA[{
			WriteFooterAndCloseWriter();
		}]]></body>
          </codeblock>
        </method>
        <method name="CloseWriter">
          <declaration><![CDATA[protected override void CloseWriter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1272" sc="3" el="1285" ec="4">log4net\Appender\FileAppender.cs</location>
            <body hash="dc1e59f01be0f7275ccfc14f142e733a"><![CDATA[{
			if (m_stream != null)
			{
				m_stream.AcquireLock();
				try
				{
					base.CloseWriter();
				}
				finally
				{
					m_stream.ReleaseLock();
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ConvertToFullPath">
          <declaration><![CDATA[protected static string ConvertToFullPath(string path)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1448" sc="3" el="1450" ec="4">log4net\Appender\FileAppender.cs</location>
            <body hash="f64e0410b191250f185fe0a38eeb6cb6"><![CDATA[{
			return SystemInfo.ConvertToFullPath(path);
		}]]></body>
          </codeblock>
        </method>
        <method name="OnClose">
          <declaration><![CDATA[protected override void OnClose()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1138" sc="3" el="1141" ec="4">log4net\Appender\FileAppender.cs</location>
            <body hash="122644a537db0ad5f82e2cb3d00bb621"><![CDATA[{
			base.OnClose();
			m_lockingModel.OnClose();
		}]]></body>
          </codeblock>
        </method>
        <method name="OpenFile">
          <declaration><![CDATA[protected virtual void OpenFile(string fileName, bool append)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1348" sc="3" el="1392" ec="4">log4net\Appender\FileAppender.cs</location>
            <body hash="9b7fef3028e7d209d1cefb567d0f8fc5"><![CDATA[{
			if (LogLog.IsErrorEnabled)
			{
				// Internal check that the fileName passed in is a rooted path
				bool isPathRooted = false;
				using (SecurityContext.Impersonate(this))
				{
					isPathRooted = Path.IsPathRooted(fileName);
				}
				if (!isPathRooted)
				{
					LogLog.Error(declaringType, "INTERNAL ERROR. OpenFile(" + fileName + "): File name is not fully qualified.");
				}
			}

			lock (this)
			{
				Reset();

				LogLog.Debug(declaringType, "Opening file for writing [" + fileName + "] append [" + append + "]");

				// Save these for later, allowing retries if file open fails
				m_fileName = fileName;
				m_appendToFile = append;

				LockingModel.CurrentAppender = this;
				LockingModel.OpenFile(fileName, append, m_encoding);
				m_stream = new LockingStream(LockingModel);

				if (m_stream != null)
				{
					m_stream.AcquireLock();
					try
					{
						SetQWForFiles(m_stream);
					}
					finally
					{
						m_stream.ReleaseLock();
					}
				}

				WriteHeader();
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="PrepareWriter">
          <declaration><![CDATA[protected override void PrepareWriter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1153" sc="3" el="1155" ec="4">log4net\Appender\FileAppender.cs</location>
            <body hash="7b09ecdefaa3a1fc6f1f1a047dbc47c4"><![CDATA[{
			SafeOpenFile(m_fileName, m_appendToFile);
		}]]></body>
          </codeblock>
        </method>
        <method name="Reset">
          <declaration><![CDATA[protected override void Reset()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1129" sc="3" el="1132" ec="4">log4net\Appender\FileAppender.cs</location>
            <body hash="8b74a5c27ce32c86836b1bd73a0bdb86"><![CDATA[{
			base.Reset();
			m_fileName = null;
		}]]></body>
          </codeblock>
        </method>
        <method name="SafeOpenFile">
          <declaration><![CDATA[protected virtual void SafeOpenFile(string fileName, bool append)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1321" sc="3" el="1330" ec="4">log4net\Appender\FileAppender.cs</location>
            <body hash="62b0cf21199d3f08676c8607e9fb3e48"><![CDATA[{
			try
			{
				OpenFile(fileName, append);
			}
			catch (Exception e)
			{
				ErrorHandler.Error("OpenFile(" + fileName + "," + append + ") call failed.", e, ErrorCode.FileOpenFailure);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="SetQWForFiles">
          <declaration><![CDATA[protected virtual void SetQWForFiles(Stream fileStream)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1411" sc="3" el="1413" ec="4">log4net\Appender\FileAppender.cs</location>
            <body hash="fd719f26e15e78d7d6f99bbb3547b143"><![CDATA[{
			SetQWForFiles(new StreamWriter(fileStream, m_encoding));
		}]]></body>
          </codeblock>
        </method>
        <method name="SetQWForFiles">
          <declaration><![CDATA[protected virtual void SetQWForFiles(TextWriter writer)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1426" sc="3" el="1428" ec="4">log4net\Appender\FileAppender.cs</location>
            <body hash="a91a62f2e7cfa277a4273b54fea3db59"><![CDATA[{
			QuietWriter = new QuietTextWriter(writer, ErrorHandler);
		}]]></body>
          </codeblock>
        </method>
        <method name="WriteFooter">
          <declaration><![CDATA[protected override void WriteFooter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1221" sc="3" el="1235" ec="4">log4net\Appender\FileAppender.cs</location>
            <body hash="d3a2c4fb8147f25e779df6951f4533e0"><![CDATA[{
			if (m_stream != null)
			{
				//WriteFooter can be called even before a file is opened
				m_stream.AcquireLock();
				try
				{
					base.WriteFooter();
				}
				finally
				{
					m_stream.ReleaseLock();
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="WriteHeader">
          <declaration><![CDATA[protected override void WriteHeader()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1246" sc="3" el="1261" ec="4">log4net\Appender\FileAppender.cs</location>
            <body hash="c07dec6000d1550b7256d96afec2d6d4"><![CDATA[{
			if (m_stream != null)
			{
				if (m_stream.AcquireLock())
				{
					try
					{
						base.WriteHeader();
					}
					finally
					{
						m_stream.ReleaseLock();
					}
				}
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(FileAppender);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_appendToFile">
          <declaration><![CDATA[private bool m_appendToFile = true;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_encoding">
          <declaration><![CDATA[private Encoding m_encoding = Encoding.GetEncoding(0);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_fileName">
          <declaration><![CDATA[private string m_fileName = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_lockingModel">
          <declaration><![CDATA[private FileAppender.LockingModelBase m_lockingModel = new FileAppender.ExclusiveLock();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_securityContext">
          <declaration><![CDATA[private SecurityContext m_securityContext;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_stream">
          <declaration><![CDATA[private FileAppender.LockingStream m_stream = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="AppendToFile">
          <declaration><![CDATA[public bool AppendToFile]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Encoding">
          <declaration><![CDATA[public Encoding Encoding]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="File">
          <declaration><![CDATA[public virtual string File]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="LockingModel">
          <declaration><![CDATA[public FileAppender.LockingModelBase LockingModel]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="SecurityContext">
          <declaration><![CDATA[public SecurityContext SecurityContext]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ForwardingAppender">
      <declaration><![CDATA[public class ForwardingAppender : AppenderSkeleton, IAppenderAttachable]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ForwardingAppender()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="51" sc="3" el="53" ec="4">log4net\Appender\ForwardingAppender.cs</location>
            <body hash="7723dec3557c6a228a83047dbfb6e8e8"><![CDATA[public ForwardingAppender()
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AddAppender">
          <declaration><![CDATA[public virtual void AddAppender(IAppender newAppender)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="135" sc="3" el="148" ec="4">log4net\Appender\ForwardingAppender.cs</location>
            <body hash="d9b05b0e3ecda7e2f58c4489022ccbad"><![CDATA[{
			if (newAppender == null)
			{
				throw new ArgumentNullException("newAppender");
			}
			lock(this)
			{
				if (m_appenderAttachedImpl == null) 
				{
					m_appenderAttachedImpl = new log4net.Util.AppenderAttachedImpl();
				}
				m_appenderAttachedImpl.AddAppender(newAppender);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Append">
          <declaration><![CDATA[protected override void Append(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="93" sc="3" el="99" ec="4">log4net\Appender\ForwardingAppender.cs</location>
            <body hash="4bd9754efe2ad181f291bca5dbc38cab"><![CDATA[{
			// Pass the logging event on the the attached appenders
			if (m_appenderAttachedImpl != null)
			{
				m_appenderAttachedImpl.AppendLoopOnAppenders(loggingEvent);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Append">
          <declaration><![CDATA[protected override void Append(LoggingEvent[] loggingEvents)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="111" sc="3" el="117" ec="4">log4net\Appender\ForwardingAppender.cs</location>
            <body hash="3931c9374d438d1f223cc58b1dcc9aaa"><![CDATA[{
			// Pass the logging event on the the attached appenders
			if (m_appenderAttachedImpl != null)
			{
				m_appenderAttachedImpl.AppendLoopOnAppenders(loggingEvents);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="GetAppender">
          <declaration><![CDATA[public virtual IAppender GetAppender(string name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="192" sc="3" el="202" ec="4">log4net\Appender\ForwardingAppender.cs</location>
            <body hash="7f10ebf16dd6e3f4bb18193aa5983b12"><![CDATA[{
			lock(this)
			{
				if (m_appenderAttachedImpl == null || name == null)
				{
					return null;
				}

				return m_appenderAttachedImpl.GetAppender(name);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="OnClose">
          <declaration><![CDATA[protected override void OnClose()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="72" sc="3" el="81" ec="4">log4net\Appender\ForwardingAppender.cs</location>
            <body hash="d526525cdc476a5017fdd216ac6f3578"><![CDATA[{
			// Remove all the attached appenders
			lock(this)
			{
				if (m_appenderAttachedImpl != null)
				{
					m_appenderAttachedImpl.RemoveAllAppenders();
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="RemoveAllAppenders">
          <declaration><![CDATA[public virtual void RemoveAllAppenders()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="213" sc="3" el="222" ec="4">log4net\Appender\ForwardingAppender.cs</location>
            <body hash="1940b92492970443d3573bab4baedf20"><![CDATA[{
			lock(this)
			{
				if (m_appenderAttachedImpl != null) 
				{
					m_appenderAttachedImpl.RemoveAllAppenders();
					m_appenderAttachedImpl = null;
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="RemoveAppender">
          <declaration><![CDATA[public virtual IAppender RemoveAppender(IAppender appender)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="235" sc="3" el="244" ec="4">log4net\Appender\ForwardingAppender.cs</location>
            <body hash="f3152342c0d7431a05655ba05b21c843"><![CDATA[{
			lock(this)
			{
				if (appender != null && m_appenderAttachedImpl != null) 
				{
					return m_appenderAttachedImpl.RemoveAppender(appender);
				}
			}
			return null;
		}]]></body>
          </codeblock>
        </method>
        <method name="RemoveAppender">
          <declaration><![CDATA[public virtual IAppender RemoveAppender(string name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="257" sc="3" el="266" ec="4">log4net\Appender\ForwardingAppender.cs</location>
            <body hash="1b61b04c5739b7cba116b8314c597356"><![CDATA[{
			lock(this)
			{
				if (name != null && m_appenderAttachedImpl != null)
				{
					return m_appenderAttachedImpl.RemoveAppender(name);
				}
			}
			return null;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_appenderAttachedImpl">
          <declaration><![CDATA[private AppenderAttachedImpl m_appenderAttachedImpl;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Appenders">
          <declaration><![CDATA[public virtual AppenderCollection Appenders]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="164" sc="4" el="176" ec="5">log4net\Appender\ForwardingAppender.cs</location>
            <body hash="227e454749b13f96dad67c304be66991"><![CDATA[{
				lock(this)
				{
					if (m_appenderAttachedImpl == null)
					{
						return AppenderCollection.EmptyCollection;
					}
					else 
					{
						return m_appenderAttachedImpl.Appenders;
					}
				}
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="IAppender">
      <declaration><![CDATA[public interface IAppender]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="Close">
          <declaration><![CDATA[void Close();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="DoAppend">
          <declaration><![CDATA[void DoAppend(LoggingEvent loggingEvent);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Name">
          <declaration><![CDATA[string Name]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="IBulkAppender">
      <declaration><![CDATA[public interface IBulkAppender : IAppender]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="DoAppend">
          <declaration><![CDATA[void DoAppend(LoggingEvent[] loggingEvents);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="IFlushable">
      <declaration><![CDATA[public interface IFlushable]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="Flush">
          <declaration><![CDATA[bool Flush(int millisecondsTimeout);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="LocalSyslogAppender">
      <declaration><![CDATA[public class LocalSyslogAppender : AppenderSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private LocalSyslogAppender.SyslogFacility m_facility = LocalSyslogAppender.SyslogFacility.User;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="267" sc="3" el="536" ec="60">log4net\Appender\LocalSyslogAppender.cs</location>
            <body hash="826ec40afd3c5abd6807bb2480859f6d"><![CDATA[public LocalSyslogAppender() 
		{
		}

		#endregion // Public Instance Constructors

		#region Public Instance Properties
		
		/// <summary>
		/// Message identity
		/// </summary>
		/// <remarks>
		/// <para>
		/// An identifier is specified with each log message. This can be specified
		/// by setting the <see cref="Identity"/> property. The identity (also know 
		/// as the tag) must not contain white space. The default value for the
		/// identity is the application name (from <see cref="SystemInfo.ApplicationFriendlyName"/>).
		/// </para>
		/// </remarks>
		public string Identity
		{
			get { return m_identity; }
			set { m_identity = value; }
		}

		/// <summary>
		/// Syslog facility
		/// </summary>
		/// <remarks>
		/// Set to one of the <see cref="SyslogFacility"/> values. The list of
		/// facilities is predefined and cannot be extended. The default value
		/// is <see cref="SyslogFacility.User"/>.
		/// </remarks>
		public SyslogFacility Facility
		{
			get { return m_facility; }
			set { m_facility = value; }
		}
		
		#endregion // Public Instance Properties

		/// <summary>
		/// Add a mapping of level to severity
		/// </summary>
		/// <param name="mapping">The mapping to add</param>
		/// <remarks>
		/// <para>
		/// Adds a <see cref="LevelSeverity"/> to this appender.
		/// </para>
		/// </remarks>
		public void AddMapping(LevelSeverity mapping)
		{
			m_levelMapping.Add(mapping);
		}

		#region IOptionHandler Implementation

		/// <summary>
		/// Initialize the appender based on the options set.
		/// </summary>
		/// <remarks>
		/// <para>
		/// This is part of the <see cref="IOptionHandler"/> delayed object
		/// activation scheme. The <see cref="ActivateOptions"/> method must 
		/// be called on this object after the configuration properties have
		/// been set. Until <see cref="ActivateOptions"/> is called this
		/// object is in an undefined state and must not be used. 
		/// </para>
		/// <para>
		/// If any of the configuration properties are modified then 
		/// <see cref="ActivateOptions"/> must be called again.
		/// </para>
		/// </remarks>
#if NET_4_0 || MONO_4_0 || NETSTANDARD1_3
        [System.Security.SecuritySafeCritical]
#endif
        public override void ActivateOptions()
		{
			base.ActivateOptions();
			
			m_levelMapping.ActivateOptions();

			string identString = m_identity;
			if (identString == null)
			{
				// Set to app name by default
				identString = SystemInfo.ApplicationFriendlyName;
			}

			// create the native heap ansi string. Note this is a copy of our string
			// so we do not need to hold on to the string itself, holding on to the
			// handle will keep the heap ansi string alive.
			m_handleToIdentity = Marshal.StringToHGlobalAnsi(identString);

			// open syslog
			openlog(m_handleToIdentity, 1, m_facility);
		}

		#endregion // IOptionHandler Implementation

		#region AppenderSkeleton Implementation

		/// <summary>
		/// This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent)"/> method.
		/// </summary>
		/// <param name="loggingEvent">The event to log.</param>
		/// <remarks>
		/// <para>
		/// Writes the event to a remote syslog daemon.
		/// </para>
		/// <para>
		/// The format of the output will depend on the appender's layout.
		/// </para>
		/// </remarks>
#if NET_4_0 || MONO_4_0 || NETSTANDARD1_3
        [System.Security.SecuritySafeCritical]
#endif
#if !NETSTANDARD1_3
        [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, UnmanagedCode = true)]
#endif
        protected override void Append(LoggingEvent loggingEvent) 
		{
			int priority = GeneratePriority(m_facility, GetSeverity(loggingEvent.Level));
			string message = RenderLoggingEvent(loggingEvent);

			// Call the local libc syslog method
			// The second argument is a printf style format string
			syslog(priority, "%s", message);
		}

		/// <summary>
		/// Close the syslog when the appender is closed
		/// </summary>
		/// <remarks>
		/// <para>
		/// Close the syslog when the appender is closed
		/// </para>
		/// </remarks>
#if NET_4_0 || MONO_4_0 || NETSTANDARD1_3
        [System.Security.SecuritySafeCritical]
#endif
        protected override void OnClose()
		{
			base.OnClose();

			try
			{
				// close syslog
				closelog();
			}
			catch(DllNotFoundException)
			{
				// Ignore dll not found at this point
			}
		
			if (m_handleToIdentity != IntPtr.Zero)
			{
				// free global ident
				Marshal.FreeHGlobal(m_handleToIdentity);
			}
		}

		/// <summary>
		/// This appender requires a <see cref="AppenderSkeleton.Layout"/> to be set.
		/// </summary>
		/// <value><c>true</c></value>
		/// <remarks>
		/// <para>
		/// This appender requires a <see cref="AppenderSkeleton.Layout"/> to be set.
		/// </para>
		/// </remarks>
		override protected bool RequiresLayout
		{
			get { return true; }
		}

		#endregion // AppenderSkeleton Implementation

		#region Protected Members

		/// <summary>
		/// Translates a log4net level to a syslog severity.
		/// </summary>
		/// <param name="level">A log4net level.</param>
		/// <returns>A syslog severity.</returns>
		/// <remarks>
		/// <para>
		/// Translates a log4net level to a syslog severity.
		/// </para>
		/// </remarks>
		virtual protected SyslogSeverity GetSeverity(Level level)
		{
			LevelSeverity levelSeverity = m_levelMapping.Lookup(level) as LevelSeverity;
			if (levelSeverity != null)
			{
				return levelSeverity.Severity;
			}

			//
			// Fallback to sensible default values
			//

			if (level >= Level.Alert) 
			{
				return SyslogSeverity.Alert;
			} 
			else if (level >= Level.Critical) 
			{
				return SyslogSeverity.Critical;
			} 
			else if (level >= Level.Error) 
			{
				return SyslogSeverity.Error;
			} 
			else if (level >= Level.Warn) 
			{
				return SyslogSeverity.Warning;
			} 
			else if (level >= Level.Notice) 
			{
				return SyslogSeverity.Notice;
			} 
			else if (level >= Level.Info) 
			{
				return SyslogSeverity.Informational;
			} 
			// Default setting
			return SyslogSeverity.Debug;
		}

		#endregion // Protected Members

		#region Public Static Members

		/// <summary>
		/// Generate a syslog priority.
		/// </summary>
		/// <param name="facility">The syslog facility.</param>
		/// <param name="severity">The syslog severity.</param>
		/// <returns>A syslog priority.</returns>
		private static int GeneratePriority(SyslogFacility facility, SyslogSeverity severity)
		{
			return ((int)facility * 8) + (int)severity;
		}

		#endregion // Public Static Members

		#region Private Instances Fields

		/// <summary>
		/// The facility. The default facility is <see cref="SyslogFacility.User"/>.
		/// </summary>
		private SyslogFacility m_facility = SyslogFacility.User;

		/// <summary>
		/// The message identity
		/// </summary>
		private string m_identity;

		/// <summary>
		/// Marshaled handle to the identity string. We have to hold on to the
		/// string as the <c>openlog</c> and <c>syslog</c> APIs just hold the
		/// pointer to the ident and dereference it for each log message.
		/// </summary>
		private IntPtr m_handleToIdentity = IntPtr.Zero;

		/// <summary>
		/// Mapping from level object to syslog severity
		/// </summary>
		private LevelMapping m_levelMapping = new LevelMapping();]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public override void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="344" sc="3" el="363" ec="4">log4net\Appender\LocalSyslogAppender.cs</location>
            <body hash="b1e1f99349b3fa3395a69a2c5d0e0dce"><![CDATA[{
			base.ActivateOptions();
			
			m_levelMapping.ActivateOptions();

			string identString = m_identity;
			if (identString == null)
			{
				// Set to app name by default
				identString = SystemInfo.ApplicationFriendlyName;
			}

			// create the native heap ansi string. Note this is a copy of our string
			// so we do not need to hold on to the string itself, holding on to the
			// handle will keep the heap ansi string alive.
			m_handleToIdentity = Marshal.StringToHGlobalAnsi(identString);

			// open syslog
			openlog(m_handleToIdentity, 1, m_facility);
		}]]></body>
          </codeblock>
        </method>
        <method name="AddMapping">
          <declaration><![CDATA[public void AddMapping(LocalSyslogAppender.LevelSeverity mapping)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="318" sc="3" el="320" ec="4">log4net\Appender\LocalSyslogAppender.cs</location>
            <body hash="9683e4fc6ec5e4d8a9d684ec86bdb867"><![CDATA[{
			m_levelMapping.Add(mapping);
		}]]></body>
          </codeblock>
        </method>
        <method name="Append">
          <declaration><![CDATA[protected override void Append(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="388" sc="3" el="395" ec="4">log4net\Appender\LocalSyslogAppender.cs</location>
            <body hash="4b9493e6289e2fd2f6032be8e5a0c6d5"><![CDATA[{
			int priority = GeneratePriority(m_facility, GetSeverity(loggingEvent.Level));
			string message = RenderLoggingEvent(loggingEvent);

			// Call the local libc syslog method
			// The second argument is a printf style format string
			syslog(priority, "%s", message);
		}]]></body>
          </codeblock>
        </method>
        <method name="closelog">
          <declaration><![CDATA[private static extern void closelog();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GeneratePriority">
          <declaration><![CDATA[private static int GeneratePriority(LocalSyslogAppender.SyslogFacility facility, LocalSyslogAppender.SyslogSeverity severity)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="508" sc="3" el="510" ec="4">log4net\Appender\LocalSyslogAppender.cs</location>
            <body hash="cf53311b32b387789f14e77f2997f9a2"><![CDATA[{
			return ((int)facility * 8) + (int)severity;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetSeverity">
          <declaration><![CDATA[protected virtual LocalSyslogAppender.SyslogSeverity GetSeverity(Level level)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="458" sc="3" el="495" ec="4">log4net\Appender\LocalSyslogAppender.cs</location>
            <body hash="10389785d053c86040818ac0a9bdeaf6"><![CDATA[{
			LevelSeverity levelSeverity = m_levelMapping.Lookup(level) as LevelSeverity;
			if (levelSeverity != null)
			{
				return levelSeverity.Severity;
			}

			//
			// Fallback to sensible default values
			//

			if (level >= Level.Alert) 
			{
				return SyslogSeverity.Alert;
			} 
			else if (level >= Level.Critical) 
			{
				return SyslogSeverity.Critical;
			} 
			else if (level >= Level.Error) 
			{
				return SyslogSeverity.Error;
			} 
			else if (level >= Level.Warn) 
			{
				return SyslogSeverity.Warning;
			} 
			else if (level >= Level.Notice) 
			{
				return SyslogSeverity.Notice;
			} 
			else if (level >= Level.Info) 
			{
				return SyslogSeverity.Informational;
			} 
			// Default setting
			return SyslogSeverity.Debug;
		}]]></body>
          </codeblock>
        </method>
        <method name="OnClose">
          <declaration><![CDATA[protected override void OnClose()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="409" sc="3" el="427" ec="4">log4net\Appender\LocalSyslogAppender.cs</location>
            <body hash="c8dd3cc2712b44a5ff62e1e3db086b48"><![CDATA[{
			base.OnClose();

			try
			{
				// close syslog
				closelog();
			}
			catch(DllNotFoundException)
			{
				// Ignore dll not found at this point
			}
		
			if (m_handleToIdentity != IntPtr.Zero)
			{
				// free global ident
				Marshal.FreeHGlobal(m_handleToIdentity);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="openlog">
          <declaration><![CDATA[private static extern void openlog(IntPtr ident, int option, LocalSyslogAppender.SyslogFacility facility);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="syslog">
          <declaration><![CDATA[private static extern void syslog(int priority, string format, string message);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_facility">
          <declaration><![CDATA[private LocalSyslogAppender.SyslogFacility m_facility = LocalSyslogAppender.SyslogFacility.User;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_handleToIdentity">
          <declaration><![CDATA[private IntPtr m_handleToIdentity = IntPtr.Zero;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_identity">
          <declaration><![CDATA[private string m_identity;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_levelMapping">
          <declaration><![CDATA[private LevelMapping m_levelMapping = new LevelMapping();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Facility">
          <declaration><![CDATA[public LocalSyslogAppender.SyslogFacility Facility]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Identity">
          <declaration><![CDATA[public string Identity]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="RequiresLayout">
          <declaration><![CDATA[protected override bool RequiresLayout]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ManagedColoredConsoleAppender">
      <declaration><![CDATA[public class ManagedColoredConsoleAppender : AppenderSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private bool m_writeToErrorStream = false;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="110" sc="3" el="274" ec="60">log4net\Appender\ManagedColoredConsoleAppender.cs</location>
            <body hash="f70a8fb4dcbda148f783100c2ec7fae2"><![CDATA[public ManagedColoredConsoleAppender() 
		{
		}
		
		#region Public Instance Properties
		/// <summary>
		/// Target is the value of the console output stream.
		/// This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
		/// </summary>
		/// <value>
		/// Target is the value of the console output stream.
		/// This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
		/// </value>
		/// <remarks>
		/// <para>
		/// Target is the value of the console output stream.
		/// This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
		/// </para>
		/// </remarks>
		virtual public string Target
		{
			get { return m_writeToErrorStream ? ConsoleError : ConsoleOut; }
			set
			{
				string v = value.Trim();

				if (SystemInfo.EqualsIgnoringCase(ConsoleError, v))
				{
					m_writeToErrorStream = true;
				} 
				else 
				{
					m_writeToErrorStream = false;
				}
			}
		}

		/// <summary>
		/// Add a mapping of level to color - done by the config file
		/// </summary>
		/// <param name="mapping">The mapping to add</param>
		/// <remarks>
		/// <para>
		/// Add a <see cref="LevelColors"/> mapping to this appender.
		/// Each mapping defines the foreground and background colors
		/// for a level.
		/// </para>
		/// </remarks>
		public void AddMapping(LevelColors mapping)
		{
			m_levelMapping.Add(mapping);
		}
		#endregion // Public Instance Properties

		#region Override implementation of AppenderSkeleton
		/// <summary>
		/// This method is called by the <see cref="M:AppenderSkeleton.DoAppend(log4net.Core.LoggingEvent)"/> method.
		/// </summary>
		/// <param name="loggingEvent">The event to log.</param>
		/// <remarks>
		/// <para>
		/// Writes the event to the console.
		/// </para>
		/// <para>
		/// The format of the output will depend on the appender's layout.
		/// </para>
		/// </remarks>
		override protected void Append(log4net.Core.LoggingEvent loggingEvent) 
		{
			System.IO.TextWriter writer;
			
			if (m_writeToErrorStream)
				writer = Console.Error;
			else
				writer = Console.Out;
			
			// Reset color
			Console.ResetColor();
			
			// see if there is a specified lookup
			LevelColors levelColors = m_levelMapping.Lookup(loggingEvent.Level) as LevelColors;
			if (levelColors != null)
			{
				// if the backColor has been explicitly set
				if (levelColors.HasBackColor)
					Console.BackgroundColor = levelColors.BackColor;
				// if the foreColor has been explicitly set
				if (levelColors.HasForeColor)
					Console.ForegroundColor = levelColors.ForeColor;
			}
			
			// Render the event to a string
			string strLoggingMessage = RenderLoggingEvent(loggingEvent);
			// and write it
			writer.Write(strLoggingMessage);

			// Reset color again
			Console.ResetColor();
		}

		/// <summary>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </summary>
		/// <value><c>true</c></value>
		/// <remarks>
		/// <para>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </para>
		/// </remarks>
		override protected bool RequiresLayout
		{
			get { return true; }
		}

		/// <summary>
		/// Initialize the options for this appender
		/// </summary>
		/// <remarks>
		/// <para>
		/// Initialize the level to color mappings set on this appender.
		/// </para>
		/// </remarks>
		public override void ActivateOptions()
		{
			base.ActivateOptions();
			m_levelMapping.ActivateOptions();
		}
		#endregion // Override implementation of AppenderSkeleton

		#region Public Static Fields
		/// <summary>
		/// The <see cref="ManagedColoredConsoleAppender.Target"/> to use when writing to the Console 
		/// standard output stream.
		/// </summary>
		/// <remarks>
		/// <para>
		/// The <see cref="ManagedColoredConsoleAppender.Target"/> to use when writing to the Console 
		/// standard output stream.
		/// </para>
		/// </remarks>
		public const string ConsoleOut = "Console.Out";

		/// <summary>
		/// The <see cref="ManagedColoredConsoleAppender.Target"/> to use when writing to the Console 
		/// standard error output stream.
		/// </summary>
		/// <remarks>
		/// <para>
		/// The <see cref="ManagedColoredConsoleAppender.Target"/> to use when writing to the Console 
		/// standard error output stream.
		/// </para>
		/// </remarks>
		public const string ConsoleError = "Console.Error";
		#endregion // Public Static Fields

		#region Private Instances Fields
		/// <summary>
		/// Flag to write output to the error stream rather than the standard output stream
		/// </summary>
		private bool m_writeToErrorStream = false;

		/// <summary>
		/// Mapping from level object to color value
		/// </summary>
		private LevelMapping m_levelMapping = new LevelMapping();]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public override void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="233" sc="3" el="236" ec="4">log4net\Appender\ManagedColoredConsoleAppender.cs</location>
            <body hash="087e34ab2916da3c08b5a21ce68bd8db"><![CDATA[{
			base.ActivateOptions();
			m_levelMapping.ActivateOptions();
		}]]></body>
          </codeblock>
        </method>
        <method name="AddMapping">
          <declaration><![CDATA[public void AddMapping(ManagedColoredConsoleAppender.LevelColors mapping)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="159" sc="3" el="161" ec="4">log4net\Appender\ManagedColoredConsoleAppender.cs</location>
            <body hash="9683e4fc6ec5e4d8a9d684ec86bdb867"><![CDATA[{
			m_levelMapping.Add(mapping);
		}]]></body>
          </codeblock>
        </method>
        <method name="Append">
          <declaration><![CDATA[protected override void Append(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="178" sc="3" el="208" ec="4">log4net\Appender\ManagedColoredConsoleAppender.cs</location>
            <body hash="908eafbba3c24c954561e324cdcf7f65"><![CDATA[{
			System.IO.TextWriter writer;
			
			if (m_writeToErrorStream)
				writer = Console.Error;
			else
				writer = Console.Out;
			
			// Reset color
			Console.ResetColor();
			
			// see if there is a specified lookup
			LevelColors levelColors = m_levelMapping.Lookup(loggingEvent.Level) as LevelColors;
			if (levelColors != null)
			{
				// if the backColor has been explicitly set
				if (levelColors.HasBackColor)
					Console.BackgroundColor = levelColors.BackColor;
				// if the foreColor has been explicitly set
				if (levelColors.HasForeColor)
					Console.ForegroundColor = levelColors.ForeColor;
			}
			
			// Render the event to a string
			string strLoggingMessage = RenderLoggingEvent(loggingEvent);
			// and write it
			writer.Write(strLoggingMessage);

			// Reset color again
			Console.ResetColor();
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="ConsoleError">
          <declaration><![CDATA[public const string ConsoleError = "Console.Error";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ConsoleOut">
          <declaration><![CDATA[public const string ConsoleOut = "Console.Out";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_levelMapping">
          <declaration><![CDATA[private LevelMapping m_levelMapping = new LevelMapping();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_writeToErrorStream">
          <declaration><![CDATA[private bool m_writeToErrorStream = false;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="RequiresLayout">
          <declaration><![CDATA[protected override bool RequiresLayout]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Target">
          <declaration><![CDATA[public virtual string Target]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="133" sc="4" el="144" ec="5">log4net\Appender\ManagedColoredConsoleAppender.cs</location>
            <body hash="988aece71481074ecff4654ae03f8873"><![CDATA[{
				string v = value.Trim();

				if (SystemInfo.EqualsIgnoringCase(ConsoleError, v))
				{
					m_writeToErrorStream = true;
				} 
				else 
				{
					m_writeToErrorStream = false;
				}
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="MemoryAppender">
      <declaration><![CDATA[public class MemoryAppender : AppenderSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[protected FixFlags m_fixFlags = FixFlags.All;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="69" sc="29" el="221" ec="48">log4net\Appender\MemoryAppender.cs</location>
            <body hash="4cc030153cdd2dfafad13b3f1843d1fe"><![CDATA[base()
		{
			m_eventsList = new ArrayList();
		}

		#endregion Protected Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Gets the events that have been logged.
		/// </summary>
		/// <returns>The events that have been logged</returns>
		/// <remarks>
		/// <para>
		/// Gets the events that have been logged.
		/// </para>
		/// </remarks>
		virtual public LoggingEvent[] GetEvents()
		{
            lock (m_eventsList.SyncRoot)
            {
                return (LoggingEvent[]) m_eventsList.ToArray(typeof(LoggingEvent));
            }
		}

		/// <summary>
		/// Gets or sets a value indicating whether only part of the logging event 
		/// data should be fixed.
		/// </summary>
		/// <value>
		/// <c>true</c> if the appender should only fix part of the logging event 
		/// data, otherwise <c>false</c>. The default is <c>false</c>.
		/// </value>
		/// <remarks>
		/// <para>
		/// Setting this property to <c>true</c> will cause only part of the event 
		/// data to be fixed and stored in the appender, hereby improving performance. 
		/// </para>
		/// <para>
		/// See <see cref="M:LoggingEvent.FixVolatileData(bool)"/> for more information.
		/// </para>
		/// </remarks>
		[Obsolete("Use Fix property")]
		virtual public bool OnlyFixPartialEventData
		{
			get { return (Fix == FixFlags.Partial); }
			set 
			{ 
				if (value)
				{
					Fix = FixFlags.Partial;
				}
				else
				{
					Fix = FixFlags.All;
				}
			}
		}

		/// <summary>
		/// Gets or sets the fields that will be fixed in the event
		/// </summary>
		/// <remarks>
		/// <para>
		/// The logging event needs to have certain thread specific values 
		/// captured before it can be buffered. See <see cref="LoggingEvent.Fix"/>
		/// for details.
		/// </para>
		/// </remarks>
		virtual public FixFlags Fix
		{
			get { return m_fixFlags; }
			set { m_fixFlags = value; }
		}

		#endregion Public Instance Properties

		#region Override implementation of AppenderSkeleton

		/// <summary>
		/// This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent)"/> method. 
		/// </summary>
		/// <param name="loggingEvent">the event to log</param>
		/// <remarks>
		/// <para>Stores the <paramref name="loggingEvent"/> in the events list.</para>
		/// </remarks>
		override protected void Append(LoggingEvent loggingEvent) 
		{
			// Because we are caching the LoggingEvent beyond the
			// lifetime of the Append() method we must fix any
			// volatile data in the event.
			loggingEvent.Fix = this.Fix;

            lock (m_eventsList.SyncRoot)
            {
                m_eventsList.Add(loggingEvent);
            }
		} 

		#endregion Override implementation of AppenderSkeleton

		#region Public Instance Methods

		/// <summary>
		/// Clear the list of events
		/// </summary>
		/// <remarks>
		/// Clear the list of events
		/// </remarks>
		virtual public void Clear()
		{
            lock (m_eventsList.SyncRoot)
            {
                m_eventsList.Clear();
            }
		}

        /// <summary>
        /// Gets the events that have been logged and clears the list of events.
        /// </summary>
        /// <returns>The events that have been logged</returns>
        /// <remarks>
        /// <para>
        /// Gets the events that have been logged and clears the list of events.
        /// </para>
        /// </remarks>
        virtual public LoggingEvent[] PopAllEvents()
        {
            lock (m_eventsList.SyncRoot)
            {
                LoggingEvent[] tmp = (LoggingEvent[]) m_eventsList.ToArray(typeof (LoggingEvent));
                m_eventsList.Clear();
                return tmp;
            }
        }

		#endregion Public Instance Methods

		#region Protected Instance Fields

		/// <summary>
		/// The list of events that have been appended.
		/// </summary>
		protected ArrayList m_eventsList;

		/// <summary>
		/// Value indicating which fields in the event should be fixed
		/// </summary>
		/// <remarks>
		/// By default all fields are fixed
		/// </remarks>
		protected FixFlags m_fixFlags = FixFlags.All;]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Append">
          <declaration><![CDATA[protected override void Append(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="157" sc="3" el="167" ec="4">log4net\Appender\MemoryAppender.cs</location>
            <body hash="b633187c7479c02e153fc5f29c89320c"><![CDATA[{
			// Because we are caching the LoggingEvent beyond the
			// lifetime of the Append() method we must fix any
			// volatile data in the event.
			loggingEvent.Fix = this.Fix;

            lock (m_eventsList.SyncRoot)
            {
                m_eventsList.Add(loggingEvent);
            }
		}]]></body>
          </codeblock>
        </method>
        <method name="Clear">
          <declaration><![CDATA[public virtual void Clear()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="180" sc="3" el="185" ec="4">log4net\Appender\MemoryAppender.cs</location>
            <body hash="56852152025075e04924a2e128607315"><![CDATA[{
            lock (m_eventsList.SyncRoot)
            {
                m_eventsList.Clear();
            }
		}]]></body>
          </codeblock>
        </method>
        <method name="GetEvents">
          <declaration><![CDATA[public virtual LoggingEvent[] GetEvents()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="88" sc="3" el="93" ec="4">log4net\Appender\MemoryAppender.cs</location>
            <body hash="4ce1f6150c17b9927c1e9f1d664cc63c"><![CDATA[{
            lock (m_eventsList.SyncRoot)
            {
                return (LoggingEvent[]) m_eventsList.ToArray(typeof(LoggingEvent));
            }
		}]]></body>
          </codeblock>
        </method>
        <method name="PopAllEvents">
          <declaration><![CDATA[public virtual LoggingEvent[] PopAllEvents()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="197" sc="9" el="204" ec="10">log4net\Appender\MemoryAppender.cs</location>
            <body hash="91b98a16d2c2c53141e91abaeeee6b7b"><![CDATA[{
            lock (m_eventsList.SyncRoot)
            {
                LoggingEvent[] tmp = (LoggingEvent[]) m_eventsList.ToArray(typeof (LoggingEvent));
                m_eventsList.Clear();
                return tmp;
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_eventsList">
          <declaration><![CDATA[protected ArrayList m_eventsList;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_fixFlags">
          <declaration><![CDATA[protected FixFlags m_fixFlags = FixFlags.All;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Fix">
          <declaration><![CDATA[public virtual FixFlags Fix]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="OnlyFixPartialEventData">
          <deprecation>Use Fix property</deprecation>
          <declaration><![CDATA[public virtual bool OnlyFixPartialEventData]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="117" sc="4" el="126" ec="5">log4net\Appender\MemoryAppender.cs</location>
            <body hash="211e7672d86a93d521a7ef57f2633c91"><![CDATA[{ 
				if (value)
				{
					Fix = FixFlags.Partial;
				}
				else
				{
					Fix = FixFlags.All;
				}
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="NetSendAppender">
      <declaration><![CDATA[public class NetSendAppender : AppenderSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public NetSendAppender()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="177" sc="3" el="179" ec="4">log4net\Appender\NetSendAppender.cs</location>
            <body hash="65a8961b7cd54a560fb915511cb14ffe"><![CDATA[public NetSendAppender() 
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public override void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="280" sc="3" el="292" ec="4">log4net\Appender\NetSendAppender.cs</location>
            <body hash="6e5b7f31c3cd3c638a018ff974e0217e"><![CDATA[{
			base.ActivateOptions();
	
			if (this.Recipient == null) 
			{
				throw new ArgumentNullException("Recipient", "The required property 'Recipient' was not specified.");
			}

			if (m_securityContext == null)
			{
				m_securityContext = SecurityContextProvider.DefaultProvider.CreateSecurityContext(this);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Append">
          <declaration><![CDATA[protected override void Append(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="314" sc="3" el="338" ec="4">log4net\Appender\NetSendAppender.cs</location>
            <body hash="295c5cfa9b8496aa08b532dd788d48b9"><![CDATA[{
			NativeError nativeError = null;

			// Render the event in the callers security context
			string renderedLoggingEvent = RenderLoggingEvent(loggingEvent);

			using(m_securityContext.Impersonate(this))
			{
				// Send the message
				int returnValue = NetMessageBufferSend(this.Server, this.Recipient, this.Sender, renderedLoggingEvent, renderedLoggingEvent.Length * Marshal.SystemDefaultCharSize);   

				// Log the error if the message could not be sent
				if (returnValue != 0) 
				{
					// Lookup the native error
					nativeError = NativeError.GetError(returnValue);
				}
			}

			if (nativeError != null)
			{
				// Handle the error over to the ErrorHandler
				ErrorHandler.Error(nativeError.ToString() + " (Params: Server=" + this.Server + ", Recipient=" + this.Recipient + ", Sender=" + this.Sender + ")");
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="NetMessageBufferSend">
          <declaration><![CDATA[protected static extern int NetMessageBufferSend([MarshalAs(UnmanagedType.LPWStr)] string serverName, [MarshalAs(UnmanagedType.LPWStr)] string msgName, [MarshalAs(UnmanagedType.LPWStr)] string fromName, [MarshalAs(UnmanagedType.LPWStr)] string buffer, int bufferSize);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_recipient">
          <declaration><![CDATA[private string m_recipient;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_securityContext">
          <declaration><![CDATA[private SecurityContext m_securityContext;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_sender">
          <declaration><![CDATA[private string m_sender;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_server">
          <declaration><![CDATA[private string m_server;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Recipient">
          <declaration><![CDATA[public string Recipient]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="RequiresLayout">
          <declaration><![CDATA[protected override bool RequiresLayout]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="SecurityContext">
          <declaration><![CDATA[public SecurityContext SecurityContext]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Sender">
          <declaration><![CDATA[public string Sender]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Server">
          <declaration><![CDATA[public string Server]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="OutputDebugStringAppender">
      <declaration><![CDATA[public class OutputDebugStringAppender : AppenderSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public OutputDebugStringAppender()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="61" sc="3" el="63" ec="4">log4net\Appender\OutputDebugStringAppender.cs</location>
            <body hash="b0ce1bb0ee7905ba929302a56233fe6a"><![CDATA[public OutputDebugStringAppender()
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Append">
          <declaration><![CDATA[protected override void Append(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="84" sc="3" el="93" ec="4">log4net\Appender\OutputDebugStringAppender.cs</location>
            <body hash="00a5e038b920e9cd1807a0e99f623e74"><![CDATA[{
#if NETSTANDARD1_3
			if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
			{
				throw new System.PlatformNotSupportedException("OutputDebugString is only available on Windows");
			}
#endif

			OutputDebugString(RenderLoggingEvent(loggingEvent));
		}]]></body>
          </codeblock>
        </method>
        <method name="OutputDebugString">
          <declaration><![CDATA[protected static extern void OutputDebugString(string message);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="RequiresLayout">
          <declaration><![CDATA[protected override bool RequiresLayout]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="RemoteSyslogAppender">
      <declaration><![CDATA[public class RemoteSyslogAppender : UdpAppender]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private RemoteSyslogAppender.SyslogFacility m_facility = RemoteSyslogAppender.SyslogFacility.User;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="272" sc="3" el="549" ec="60">log4net\Appender\RemoteSyslogAppender.cs</location>
            <body hash="3726dacd05d875f56a7b419ecc6cda01"><![CDATA[public RemoteSyslogAppender()
		{
			// syslog udp defaults
			this.RemotePort = DefaultSyslogPort;
			this.RemoteAddress = System.Net.IPAddress.Parse("127.0.0.1");
			this.Encoding = System.Text.Encoding.ASCII;
		}

		#endregion Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Message identity
		/// </summary>
		/// <remarks>
		/// <para>
		/// An identifier is specified with each log message. This can be specified
		/// by setting the <see cref="Identity"/> property. The identity (also know 
		/// as the tag) must not contain white space. The default value for the
		/// identity is the application name (from <see cref="LoggingEvent.Domain"/>).
		/// </para>
		/// </remarks>
		public PatternLayout Identity
		{
			get { return m_identity; }
			set { m_identity = value; }
		}

		/// <summary>
		/// Syslog facility
		/// </summary>
		/// <remarks>
		/// Set to one of the <see cref="SyslogFacility"/> values. The list of
		/// facilities is predefined and cannot be extended. The default value
		/// is <see cref="SyslogFacility.User"/>.
		/// </remarks>
		public SyslogFacility Facility
		{
			get { return m_facility; }
			set { m_facility = value; }
		}

		#endregion Public Instance Properties

		/// <summary>
		/// Add a mapping of level to severity
		/// </summary>
		/// <param name="mapping">The mapping to add</param>
		/// <remarks>
		/// <para>
		/// Add a <see cref="LevelSeverity"/> mapping to this appender.
		/// </para>
		/// </remarks>
		public void AddMapping(LevelSeverity mapping)
		{
			m_levelMapping.Add(mapping);
		}

		#region AppenderSkeleton Implementation

		/// <summary>
		/// This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent)"/> method.
		/// </summary>
		/// <param name="loggingEvent">The event to log.</param>
		/// <remarks>
		/// <para>
		/// Writes the event to a remote syslog daemon.
		/// </para>
		/// <para>
		/// The format of the output will depend on the appender's layout.
		/// </para>
		/// </remarks>
		protected override void Append(LoggingEvent loggingEvent)
		{
            try
            {
                // Priority
                int priority = GeneratePriority(m_facility, GetSeverity(loggingEvent.Level));

                // Identity
                string identity;

                if (m_identity != null)
                {
                    identity = m_identity.Format(loggingEvent);
                }
                else
                {
                    identity = loggingEvent.Domain;
                }

                // Message. The message goes after the tag/identity
                string message = RenderLoggingEvent(loggingEvent);

                Byte[] buffer;
                int i = 0;
                char c;

                StringBuilder builder = new StringBuilder();

                while (i < message.Length)
                {
                    // Clear StringBuilder
                    builder.Length = 0;

                    // Write priority
                    builder.Append('<');
                    builder.Append(priority);
                    builder.Append('>');

                    // Write identity
                    builder.Append(identity);
                    builder.Append(": ");

                    for (; i < message.Length; i++)
                    {
                        c = message[i];

                        // Accept only visible ASCII characters and space. See RFC 3164 section 4.1.3
                        if (((int)c >= 32) && ((int)c <= 126))
                        {
                            builder.Append(c);
                        }
                        // If character is newline, break and send the current line
                        else if ((c == '\r') || (c == '\n'))
                        {
                            // Check the next character to handle \r\n or \n\r
                            if ((message.Length > i + 1) && ((message[i + 1] == '\r') || (message[i + 1] == '\n')))
                            {
                                i++;
                            }
                            i++;
                            break;
                        }
                    }

                    // Grab as a byte array
                    buffer = this.Encoding.GetBytes(builder.ToString());

#if NETSTANDARD1_3
                    Client.SendAsync(buffer, buffer.Length, RemoteEndPoint).Wait();
#else
                    this.Client.Send(buffer, buffer.Length, this.RemoteEndPoint);
#endif
                }
            }
            catch (Exception e)
            {
                ErrorHandler.Error(
                    "Unable to send logging event to remote syslog " +
                    this.RemoteAddress.ToString() +
                    " on port " +
                    this.RemotePort + ".",
                    e,
                    ErrorCode.WriteFailure);
            }
		}

		/// <summary>
		/// Initialize the options for this appender
		/// </summary>
		/// <remarks>
		/// <para>
		/// Initialize the level to syslog severity mappings set on this appender.
		/// </para>
		/// </remarks>
		public override void ActivateOptions()
		{
			base.ActivateOptions();
			m_levelMapping.ActivateOptions();
		}

		#endregion AppenderSkeleton Implementation

		#region Protected Members

		/// <summary>
		/// Translates a log4net level to a syslog severity.
		/// </summary>
		/// <param name="level">A log4net level.</param>
		/// <returns>A syslog severity.</returns>
		/// <remarks>
		/// <para>
		/// Translates a log4net level to a syslog severity.
		/// </para>
		/// </remarks>
		virtual protected SyslogSeverity GetSeverity(Level level)
		{
			LevelSeverity levelSeverity = m_levelMapping.Lookup(level) as LevelSeverity;
			if (levelSeverity != null)
			{
				return levelSeverity.Severity;
			}

			//
			// Fallback to sensible default values
			//

			if (level >= Level.Alert)
			{
				return SyslogSeverity.Alert;
			}
			else if (level >= Level.Critical)
			{
				return SyslogSeverity.Critical;
			}
			else if (level >= Level.Error)
			{
				return SyslogSeverity.Error;
			}
			else if (level >= Level.Warn)
			{
				return SyslogSeverity.Warning;
			}
			else if (level >= Level.Notice)
			{
				return SyslogSeverity.Notice;
			}
			else if (level >= Level.Info)
			{
				return SyslogSeverity.Informational;
			}
			// Default setting
			return SyslogSeverity.Debug;
		}

		#endregion Protected Members

		#region Public Static Members

		/// <summary>
		/// Generate a syslog priority.
		/// </summary>
		/// <param name="facility">The syslog facility.</param>
		/// <param name="severity">The syslog severity.</param>
		/// <returns>A syslog priority.</returns>
		/// <remarks>
		/// <para>
		/// Generate a syslog priority.
		/// </para>
		/// </remarks>
		public static int GeneratePriority(SyslogFacility facility, SyslogSeverity severity)
		{
			if (facility < SyslogFacility.Kernel || facility > SyslogFacility.Local7)
			{
				throw new ArgumentException("SyslogFacility out of range", "facility");
			}

			if (severity < SyslogSeverity.Emergency || severity > SyslogSeverity.Debug)
			{
				throw new ArgumentException("SyslogSeverity out of range", "severity");
			}

			unchecked
			{
				return ((int)facility * 8) + (int)severity;
			}
		}

		#endregion Public Static Members

		#region Private Instances Fields

		/// <summary>
		/// The facility. The default facility is <see cref="SyslogFacility.User"/>.
		/// </summary>
		private SyslogFacility m_facility = SyslogFacility.User;

		/// <summary>
		/// The message identity
		/// </summary>
		private PatternLayout m_identity;

		/// <summary>
		/// Mapping from level object to syslog severity
		/// </summary>
		private LevelMapping m_levelMapping = new LevelMapping();]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public override void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="440" sc="3" el="443" ec="4">log4net\Appender\RemoteSyslogAppender.cs</location>
            <body hash="087e34ab2916da3c08b5a21ce68bd8db"><![CDATA[{
			base.ActivateOptions();
			m_levelMapping.ActivateOptions();
		}]]></body>
          </codeblock>
        </method>
        <method name="AddMapping">
          <declaration><![CDATA[public void AddMapping(RemoteSyslogAppender.LevelSeverity mapping)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="327" sc="3" el="329" ec="4">log4net\Appender\RemoteSyslogAppender.cs</location>
            <body hash="9683e4fc6ec5e4d8a9d684ec86bdb867"><![CDATA[{
			m_levelMapping.Add(mapping);
		}]]></body>
          </codeblock>
        </method>
        <method name="Append">
          <declaration><![CDATA[protected override void Append(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="346" sc="3" el="429" ec="4">log4net\Appender\RemoteSyslogAppender.cs</location>
            <body hash="21a0b3648e1e8b83177d91a3fe7ddc1e"><![CDATA[{
            try
            {
                // Priority
                int priority = GeneratePriority(m_facility, GetSeverity(loggingEvent.Level));

                // Identity
                string identity;

                if (m_identity != null)
                {
                    identity = m_identity.Format(loggingEvent);
                }
                else
                {
                    identity = loggingEvent.Domain;
                }

                // Message. The message goes after the tag/identity
                string message = RenderLoggingEvent(loggingEvent);

                Byte[] buffer;
                int i = 0;
                char c;

                StringBuilder builder = new StringBuilder();

                while (i < message.Length)
                {
                    // Clear StringBuilder
                    builder.Length = 0;

                    // Write priority
                    builder.Append('<');
                    builder.Append(priority);
                    builder.Append('>');

                    // Write identity
                    builder.Append(identity);
                    builder.Append(": ");

                    for (; i < message.Length; i++)
                    {
                        c = message[i];

                        // Accept only visible ASCII characters and space. See RFC 3164 section 4.1.3
                        if (((int)c >= 32) && ((int)c <= 126))
                        {
                            builder.Append(c);
                        }
                        // If character is newline, break and send the current line
                        else if ((c == '\r') || (c == '\n'))
                        {
                            // Check the next character to handle \r\n or \n\r
                            if ((message.Length > i + 1) && ((message[i + 1] == '\r') || (message[i + 1] == '\n')))
                            {
                                i++;
                            }
                            i++;
                            break;
                        }
                    }

                    // Grab as a byte array
                    buffer = this.Encoding.GetBytes(builder.ToString());

#if NETSTANDARD1_3
                    Client.SendAsync(buffer, buffer.Length, RemoteEndPoint).Wait();
#else
                    this.Client.Send(buffer, buffer.Length, this.RemoteEndPoint);
#endif
                }
            }
            catch (Exception e)
            {
                ErrorHandler.Error(
                    "Unable to send logging event to remote syslog " +
                    this.RemoteAddress.ToString() +
                    " on port " +
                    this.RemotePort + ".",
                    e,
                    ErrorCode.WriteFailure);
            }
		}]]></body>
          </codeblock>
        </method>
        <method name="GeneratePriority">
          <declaration><![CDATA[public static int GeneratePriority(RemoteSyslogAppender.SyslogFacility facility, RemoteSyslogAppender.SyslogSeverity severity)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="515" sc="3" el="530" ec="4">log4net\Appender\RemoteSyslogAppender.cs</location>
            <body hash="b77ca5f40554978367563a5813d4b6dc"><![CDATA[{
			if (facility < SyslogFacility.Kernel || facility > SyslogFacility.Local7)
			{
				throw new ArgumentException("SyslogFacility out of range", "facility");
			}

			if (severity < SyslogSeverity.Emergency || severity > SyslogSeverity.Debug)
			{
				throw new ArgumentException("SyslogSeverity out of range", "severity");
			}

			unchecked
			{
				return ((int)facility * 8) + (int)severity;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="GetSeverity">
          <declaration><![CDATA[protected virtual RemoteSyslogAppender.SyslogSeverity GetSeverity(Level level)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="460" sc="3" el="497" ec="4">log4net\Appender\RemoteSyslogAppender.cs</location>
            <body hash="b9b3a0d9094972933a9ed02d576503a9"><![CDATA[{
			LevelSeverity levelSeverity = m_levelMapping.Lookup(level) as LevelSeverity;
			if (levelSeverity != null)
			{
				return levelSeverity.Severity;
			}

			//
			// Fallback to sensible default values
			//

			if (level >= Level.Alert)
			{
				return SyslogSeverity.Alert;
			}
			else if (level >= Level.Critical)
			{
				return SyslogSeverity.Critical;
			}
			else if (level >= Level.Error)
			{
				return SyslogSeverity.Error;
			}
			else if (level >= Level.Warn)
			{
				return SyslogSeverity.Warning;
			}
			else if (level >= Level.Notice)
			{
				return SyslogSeverity.Notice;
			}
			else if (level >= Level.Info)
			{
				return SyslogSeverity.Informational;
			}
			// Default setting
			return SyslogSeverity.Debug;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="c_renderBufferMaxCapacity">
          <declaration><![CDATA[private const int c_renderBufferMaxCapacity = 1024;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="c_renderBufferSize">
          <declaration><![CDATA[private const int c_renderBufferSize = 256;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DefaultSyslogPort">
          <declaration><![CDATA[private const int DefaultSyslogPort = 514;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_facility">
          <declaration><![CDATA[private RemoteSyslogAppender.SyslogFacility m_facility = RemoteSyslogAppender.SyslogFacility.User;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_identity">
          <declaration><![CDATA[private PatternLayout m_identity;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_levelMapping">
          <declaration><![CDATA[private LevelMapping m_levelMapping = new LevelMapping();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Facility">
          <declaration><![CDATA[public RemoteSyslogAppender.SyslogFacility Facility]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Identity">
          <declaration><![CDATA[public PatternLayout Identity]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="RemotingAppender">
      <declaration><![CDATA[public class RemotingAppender : BufferingAppenderSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_queuedCallbackCount = 0;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="93" sc="3" el="311" ec="79">log4net\Appender\RemotingAppender.cs</location>
            <body hash="b65875a06fdfd6b13588f1afecdf271d"><![CDATA[public RemotingAppender()
		{
		}

		#endregion Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Gets or sets the URL of the well-known object that will accept 
		/// the logging events.
		/// </summary>
		/// <value>
		/// The well-known URL of the remote sink.
		/// </value>
		/// <remarks>
		/// <para>
		/// The URL of the remoting sink that will accept logging events.
		/// The sink must implement the <see cref="IRemoteLoggingSink"/>
		/// interface.
		/// </para>
		/// </remarks>
		public string Sink
		{
			get { return m_sinkUrl; }
			set { m_sinkUrl = value; }
		}

		#endregion Public Instance Properties

		#region Implementation of IOptionHandler

		/// <summary>
		/// Initialize the appender based on the options set
		/// </summary>
		/// <remarks>
		/// <para>
		/// This is part of the <see cref="IOptionHandler"/> delayed object
		/// activation scheme. The <see cref="ActivateOptions"/> method must 
		/// be called on this object after the configuration properties have
		/// been set. Until <see cref="ActivateOptions"/> is called this
		/// object is in an undefined state and must not be used. 
		/// </para>
		/// <para>
		/// If any of the configuration properties are modified then 
		/// <see cref="ActivateOptions"/> must be called again.
		/// </para>
		/// </remarks>
#if NET_4_0 || MONO_4_0
        [System.Security.SecuritySafeCritical]
#endif
        override public void ActivateOptions() 
		{
			base.ActivateOptions();

			IDictionary channelProperties = new Hashtable(); 
			channelProperties["typeFilterLevel"] = "Full";

			m_sinkObj = (IRemoteLoggingSink)Activator.GetObject(typeof(IRemoteLoggingSink), m_sinkUrl, channelProperties);
		}

		#endregion

		#region Override implementation of BufferingAppenderSkeleton

		/// <summary>
		/// Send the contents of the buffer to the remote sink.
		/// </summary>
		/// <remarks>
		/// The events are not sent immediately. They are scheduled to be sent
		/// using a pool thread. The effect is that the send occurs asynchronously.
		/// This is very important for a number of non obvious reasons. The remoting
		/// infrastructure will flow thread local variables (stored in the <see cref="CallContext"/>),
		/// if they are marked as <see cref="ILogicalThreadAffinative"/>, across the 
		/// remoting boundary. If the server is not contactable then
		/// the remoting infrastructure will clear the <see cref="ILogicalThreadAffinative"/>
		/// objects from the <see cref="CallContext"/>. To prevent a logging failure from
		/// having side effects on the calling application the remoting call must be made
		/// from a separate thread to the one used by the application. A <see cref="ThreadPool"/>
		/// thread is used for this. If no <see cref="ThreadPool"/> thread is available then
		/// the events will block in the thread pool manager until a thread is available.
		/// </remarks>
		/// <param name="events">The events to send.</param>
		override protected void SendBuffer(LoggingEvent[] events)
		{
			// Setup for an async send
			BeginAsyncSend();

			// Send the events
			if (!ThreadPool.QueueUserWorkItem(new WaitCallback(SendBufferCallback), events))
			{
				// Cancel the async send
				EndAsyncSend();

				ErrorHandler.Error("RemotingAppender ["+Name+"] failed to ThreadPool.QueueUserWorkItem logging events in SendBuffer.");
			}
		}

		/// <summary>
		/// Override base class close.
		/// </summary>
		/// <remarks>
		/// <para>
		/// This method waits while there are queued work items. The events are
		/// sent asynchronously using <see cref="ThreadPool"/> work items. These items
		/// will be sent once a thread pool thread is available to send them, therefore
		/// it is possible to close the appender before all the queued events have been
		/// sent.</para>
		/// <para>
		/// This method attempts to wait until all the queued events have been sent, but this 
		/// method will timeout after 30 seconds regardless.</para>
		/// <para>
		/// If the appender is being closed because the <see cref="AppDomain.ProcessExit"/>
		/// event has fired it may not be possible to send all the queued events. During process
		/// exit the runtime limits the time that a <see cref="AppDomain.ProcessExit"/>
		/// event handler is allowed to run for.</para>
		/// </remarks>
		override protected void OnClose()
		{
			base.OnClose();

			// Wait for the work queue to become empty before closing, timeout 30 seconds
			if (!m_workQueueEmptyEvent.WaitOne(30 * 1000, false))
			{
				ErrorHandler.Error("RemotingAppender ["+Name+"] failed to send all queued events before close, in OnClose.");
			}
		}

		/// <summary>
		/// Flushes any buffered log data.
		/// </summary>
		/// <param name="millisecondsTimeout">The maximum time to wait for logging events to be flushed.</param>
		/// <returns><c>True</c> if all logging events were flushed successfully, else <c>false</c>.</returns>
		public override bool Flush(int millisecondsTimeout)
		{
			base.Flush();
			return m_workQueueEmptyEvent.WaitOne(millisecondsTimeout, false);
		}

		#endregion

		/// <summary>
		/// A work item is being queued into the thread pool
		/// </summary>
		private void BeginAsyncSend()
		{
			// The work queue is not empty
			m_workQueueEmptyEvent.Reset();

			// Increment the queued count
			Interlocked.Increment(ref m_queuedCallbackCount);
		}

		/// <summary>
		/// A work item from the thread pool has completed
		/// </summary>
		private void EndAsyncSend()
		{
			// Decrement the queued count
			if (Interlocked.Decrement(ref m_queuedCallbackCount) <= 0)
			{
				// If the work queue is empty then set the event
				m_workQueueEmptyEvent.Set();
			}
		}

		/// <summary>
		/// Send the contents of the buffer to the remote sink.
		/// </summary>
		/// <remarks>
		/// This method is designed to be used with the <see cref="ThreadPool"/>.
		/// This method expects to be passed an array of <see cref="LoggingEvent"/>
		/// objects in the state param.
		/// </remarks>
		/// <param name="state">the logging events to send</param>
		private void SendBufferCallback(object state)
		{
			try
			{
				LoggingEvent[] events = (LoggingEvent[])state;

				// Send the events
				m_sinkObj.LogEvents(events);
			}
			catch(Exception ex)
			{
				ErrorHandler.Error("Failed in SendBufferCallback", ex);
			}
			finally
			{
				EndAsyncSend();
			}
		}

		#region Private Instance Fields

		/// <summary>
		/// The URL of the remote sink.
		/// </summary>
		private string m_sinkUrl;

		/// <summary>
		/// The local proxy (.NET remoting) for the remote logging sink.
		/// </summary>
		private IRemoteLoggingSink m_sinkObj;

		/// <summary>
		/// The number of queued callbacks currently waiting or executing
		/// </summary>
		private int m_queuedCallbackCount = 0;

		/// <summary>
		/// Event used to signal when there are no queued work items
		/// </summary>
		/// <remarks>
		/// This event is set when there are no queued work items. In this
		/// state it is safe to close the appender.
		/// </remarks>
		private ManualResetEvent m_workQueueEmptyEvent = new ManualResetEvent(true);]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public override void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="145" sc="3" el="152" ec="4">log4net\Appender\RemotingAppender.cs</location>
            <body hash="46e37890bfca608e18bbafdbda82050c"><![CDATA[{
			base.ActivateOptions();

			IDictionary channelProperties = new Hashtable(); 
			channelProperties["typeFilterLevel"] = "Full";

			m_sinkObj = (IRemoteLoggingSink)Activator.GetObject(typeof(IRemoteLoggingSink), m_sinkUrl, channelProperties);
		}]]></body>
          </codeblock>
        </method>
        <method name="BeginAsyncSend">
          <declaration><![CDATA[private void BeginAsyncSend()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="238" sc="3" el="244" ec="4">log4net\Appender\RemotingAppender.cs</location>
            <body hash="18de5f674f4af81c03b4e53f6477b3f4"><![CDATA[{
			// The work queue is not empty
			m_workQueueEmptyEvent.Reset();

			// Increment the queued count
			Interlocked.Increment(ref m_queuedCallbackCount);
		}]]></body>
          </codeblock>
        </method>
        <method name="EndAsyncSend">
          <declaration><![CDATA[private void EndAsyncSend()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="250" sc="3" el="257" ec="4">log4net\Appender\RemotingAppender.cs</location>
            <body hash="a94fc8f872d013a56009809611351499"><![CDATA[{
			// Decrement the queued count
			if (Interlocked.Decrement(ref m_queuedCallbackCount) <= 0)
			{
				// If the work queue is empty then set the event
				m_workQueueEmptyEvent.Set();
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Flush">
          <declaration><![CDATA[public override bool Flush(int millisecondsTimeout)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="227" sc="3" el="230" ec="4">log4net\Appender\RemotingAppender.cs</location>
            <body hash="7a98568f7e7ce19cd08c1002d54a5a08"><![CDATA[{
			base.Flush();
			return m_workQueueEmptyEvent.WaitOne(millisecondsTimeout, false);
		}]]></body>
          </codeblock>
        </method>
        <method name="OnClose">
          <declaration><![CDATA[protected override void OnClose()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="211" sc="3" el="219" ec="4">log4net\Appender\RemotingAppender.cs</location>
            <body hash="43ef5f4b1e62cc55ec7a6acf44e1954c"><![CDATA[{
			base.OnClose();

			// Wait for the work queue to become empty before closing, timeout 30 seconds
			if (!m_workQueueEmptyEvent.WaitOne(30 * 1000, false))
			{
				ErrorHandler.Error("RemotingAppender ["+Name+"] failed to send all queued events before close, in OnClose.");
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="SendBuffer">
          <declaration><![CDATA[protected override void SendBuffer(LoggingEvent[] events)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="177" sc="3" el="189" ec="4">log4net\Appender\RemotingAppender.cs</location>
            <body hash="c86a1c370cb9cc0cedd33e56aed69141"><![CDATA[{
			// Setup for an async send
			BeginAsyncSend();

			// Send the events
			if (!ThreadPool.QueueUserWorkItem(new WaitCallback(SendBufferCallback), events))
			{
				// Cancel the async send
				EndAsyncSend();

				ErrorHandler.Error("RemotingAppender ["+Name+"] failed to ThreadPool.QueueUserWorkItem logging events in SendBuffer.");
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="SendBufferCallback">
          <declaration><![CDATA[private void SendBufferCallback(object state)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="269" sc="3" el="285" ec="4">log4net\Appender\RemotingAppender.cs</location>
            <body hash="4e468ed69debdb9932c663f9ecd0b675"><![CDATA[{
			try
			{
				LoggingEvent[] events = (LoggingEvent[])state;

				// Send the events
				m_sinkObj.LogEvents(events);
			}
			catch(Exception ex)
			{
				ErrorHandler.Error("Failed in SendBufferCallback", ex);
			}
			finally
			{
				EndAsyncSend();
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_queuedCallbackCount">
          <declaration><![CDATA[private int m_queuedCallbackCount = 0;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_sinkObj">
          <declaration><![CDATA[private RemotingAppender.IRemoteLoggingSink m_sinkObj;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_sinkUrl">
          <declaration><![CDATA[private string m_sinkUrl;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_workQueueEmptyEvent">
          <declaration><![CDATA[private ManualResetEvent m_workQueueEmptyEvent = new ManualResetEvent(true);]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Sink">
          <declaration><![CDATA[public string Sink]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="RollingFileAppender">
      <declaration><![CDATA[public class RollingFileAppender : FileAppender]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private RollingFileAppender.IDateTime m_dateTime = null;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="235" sc="3" el="1684" ec="55">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="0e8bf4890b7a642e1bd7a1511ca61251"><![CDATA[public RollingFileAppender() 
		{
		}

		/// <summary>
		/// Cleans up all resources used by this appender.
		/// </summary>
		~RollingFileAppender()
		{
#if !NETCF
			if (m_mutexForRolling != null)
			{
#if NET_4_0 || MONO_4_0 || NETSTANDARD1_3
				m_mutexForRolling.Dispose();
#else
				m_mutexForRolling.Close();
#endif
				m_mutexForRolling = null;
			}
#endif
		}

		#endregion Public Instance Constructors

		#region Public Instance Properties

#if !NET_1_0 && !CLI_1_0 && !NETCF
        /// <summary>
		/// Gets or sets the strategy for determining the current date and time. The default
		/// implementation is to use LocalDateTime which internally calls through to DateTime.Now. 
		/// DateTime.UtcNow may be used on frameworks newer than .NET 1.0 by specifying
		/// <see cref="RollingFileAppender.UniversalDateTime"/>.
		/// </summary>
		/// <value>
		/// An implementation of the <see cref="RollingFileAppender.IDateTime"/> interface which returns the current date and time.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets or sets the <see cref="RollingFileAppender.IDateTime"/> used to return the current date and time.
		/// </para>
        /// <para>
        /// There are two built strategies for determining the current date and time, 
		/// <see cref="RollingFileAppender.LocalDateTime"/>
        /// and <see cref="RollingFileAppender.UniversalDateTime"/>.
        /// </para>
        /// <para>
		/// The default strategy is <see cref="RollingFileAppender.LocalDateTime"/>.
		/// </para>
		/// </remarks>
#else
        /// <summary>
		/// Gets or sets the strategy for determining the current date and time. The default
		/// implementation is to use LocalDateTime which internally calls through to DateTime.Now. 
		/// </summary>
		/// <value>
		/// An implementation of the <see cref="RollingFileAppender.IDateTime"/> interface which returns the current date and time.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets or sets the <see cref="RollingFileAppender.IDateTime"/> used to return the current date and time.
		/// </para>
        /// <para>
		/// The default strategy is <see cref="RollingFileAppender.LocalDateTime"/>.
		/// </para>
		/// </remarks>
#endif
        public IDateTime DateTimeStrategy
		{
			get { return m_dateTime; }
			set { m_dateTime = value; }
		}

		/// <summary>
		/// Gets or sets the date pattern to be used for generating file names
		/// when rolling over on date.
		/// </summary>
		/// <value>
		/// The date pattern to be used for generating file names when rolling 
		/// over on date.
		/// </value>
		/// <remarks>
		/// <para>
		/// Takes a string in the same format as expected by 
		/// <see cref="log4net.DateFormatter.SimpleDateFormatter" />.
		/// </para>
		/// <para>
		/// This property determines the rollover schedule when rolling over
		/// on date.
		/// </para>
		/// </remarks>
		public string DatePattern
		{
			get { return m_datePattern; }
			set { m_datePattern = value; }
		}
  
		/// <summary>
		/// Gets or sets the maximum number of backup files that are kept before
		/// the oldest is erased.
		/// </summary>
		/// <value>
		/// The maximum number of backup files that are kept before the oldest is
		/// erased.
		/// </value>
		/// <remarks>
		/// <para>
		/// If set to zero, then there will be no backup files and the log file 
		/// will be truncated when it reaches <see cref="MaxFileSize"/>.  
		/// </para>
		/// <para>
		/// If a negative number is supplied then no deletions will be made.  Note 
		/// that this could result in very slow performance as a large number of 
		/// files are rolled over unless <see cref="CountDirection"/> is used.
		/// </para>
		/// <para>
		/// The maximum applies to <b>each</b> time based group of files and 
		/// <b>not</b> the total.
		/// </para>
		/// </remarks>
		public int MaxSizeRollBackups
		{
			get { return m_maxSizeRollBackups; }
			set { m_maxSizeRollBackups = value; }
		}
  
		/// <summary>
		/// Gets or sets the maximum size that the output file is allowed to reach
		/// before being rolled over to backup files.
		/// </summary>
		/// <value>
		/// The maximum size in bytes that the output file is allowed to reach before being 
		/// rolled over to backup files.
		/// </value>
		/// <remarks>
		/// <para>
		/// This property is equivalent to <see cref="MaximumFileSize"/> except
		/// that it is required for differentiating the setter taking a
		/// <see cref="long"/> argument from the setter taking a <see cref="string"/> 
		/// argument.
		/// </para>
		/// <para>
		/// The default maximum file size is 10MB (10*1024*1024).
		/// </para>
		/// </remarks>
		public long MaxFileSize
		{
			get { return m_maxFileSize; }
			set { m_maxFileSize = value; }
		}
  
		/// <summary>
		/// Gets or sets the maximum size that the output file is allowed to reach
		/// before being rolled over to backup files.
		/// </summary>
		/// <value>
		/// The maximum size that the output file is allowed to reach before being 
		/// rolled over to backup files.
		/// </value>
		/// <remarks>
		/// <para>
		/// This property allows you to specify the maximum size with the
		/// suffixes "KB", "MB" or "GB" so that the size is interpreted being 
		/// expressed respectively in kilobytes, megabytes or gigabytes. 
		/// </para>
		/// <para>
		/// For example, the value "10KB" will be interpreted as 10240 bytes.
		/// </para>
		/// <para>
		/// The default maximum file size is 10MB.
		/// </para>
		/// <para>
		/// If you have the option to set the maximum file size programmatically
		/// consider using the <see cref="MaxFileSize"/> property instead as this
		/// allows you to set the size in bytes as a <see cref="Int64"/>.
		/// </para>
		/// </remarks>
		public string MaximumFileSize
		{
			get { return m_maxFileSize.ToString(NumberFormatInfo.InvariantInfo); }
			set { m_maxFileSize = OptionConverter.ToFileSize(value, m_maxFileSize + 1); }
		}

		/// <summary>
		/// Gets or sets the rolling file count direction. 
		/// </summary>
		/// <value>
		/// The rolling file count direction.
		/// </value>
		/// <remarks>
		/// <para>
		/// Indicates if the current file is the lowest numbered file or the
		/// highest numbered file.
		/// </para>
		/// <para>
		/// By default newer files have lower numbers (<see cref="CountDirection" /> &lt; 0),
		/// i.e. log.1 is most recent, log.5 is the 5th backup, etc...
		/// </para>
		/// <para>
		/// <see cref="CountDirection" /> &gt;= 0 does the opposite i.e.
		/// log.1 is the first backup made, log.5 is the 5th backup made, etc.
		/// For infinite backups use <see cref="CountDirection" /> &gt;= 0 to reduce 
		/// rollover costs.
		/// </para>
		/// <para>The default file count direction is -1.</para>
		/// </remarks>
		public int CountDirection
		{
			get { return m_countDirection; }
			set { m_countDirection = value; }
		}
  
		/// <summary>
		/// Gets or sets the rolling style.
		/// </summary>
		/// <value>The rolling style.</value>
		/// <remarks>
		/// <para>
		/// The default rolling style is <see cref="RollingMode.Composite" />.
		/// </para>
		/// <para>
		/// When set to <see cref="RollingMode.Once"/> this appender's
		/// <see cref="FileAppender.AppendToFile"/> property is set to <c>false</c>, otherwise
		/// the appender would append to a single file rather than rolling
		/// the file each time it is opened.
		/// </para>
		/// </remarks>
		public RollingMode RollingStyle
		{
			get { return m_rollingStyle; }
			set
			{
				m_rollingStyle = value;
				switch (m_rollingStyle) 
				{
					case RollingMode.Once:
						m_rollDate = false;
						m_rollSize = false;

						this.AppendToFile = false;
						break;

					case RollingMode.Size:
						m_rollDate = false;
						m_rollSize = true;
						break;

					case RollingMode.Date:
						m_rollDate = true;
						m_rollSize = false;
						break;

					case RollingMode.Composite:
						m_rollDate = true;
						m_rollSize = true;
						break;	  
				}
			}
		}

        /// <summary>
        /// Gets or sets a value indicating whether to preserve the file name extension when rolling.
        /// </summary>
        /// <value>
        /// <c>true</c> if the file name extension should be preserved.
        /// </value>
        /// <remarks>
        /// <para>
        /// By default file.log is rolled to file.log.yyyy-MM-dd or file.log.curSizeRollBackup.
        /// However, under Windows the new file name will loose any program associations as the
        /// extension is changed. Optionally file.log can be renamed to file.yyyy-MM-dd.log or
        /// file.curSizeRollBackup.log to maintain any program associations.
        /// </para>
        /// </remarks>
        public bool PreserveLogFileNameExtension
        {
            get { return m_preserveLogFileNameExtension; }
            set { m_preserveLogFileNameExtension = value; }
        }

		/// <summary>
		/// Gets or sets a value indicating whether to always log to
		/// the same file.
		/// </summary>
		/// <value>
		/// <c>true</c> if always should be logged to the same file, otherwise <c>false</c>.
		/// </value>
		/// <remarks>
		/// <para>
		/// By default file.log is always the current file.  Optionally
		/// file.log.yyyy-mm-dd for current formatted datePattern can by the currently
		/// logging file (or file.log.curSizeRollBackup or even
		/// file.log.yyyy-mm-dd.curSizeRollBackup).
		/// </para>
		/// <para>
		/// This will make time based rollovers with a large number of backups 
		/// much faster as the appender it won't have to rename all the backups!
		/// </para>
		/// </remarks>
		public bool StaticLogFileName
		{
			get { return m_staticLogFileName; }
			set { m_staticLogFileName = value; }
		}

		#endregion Public Instance Properties

	    #region Private Static Fields

	    /// <summary>
	    /// The fully qualified type of the RollingFileAppender class.
	    /// </summary>
	    /// <remarks>
	    /// Used by the internal logger to record the Type of the
	    /// log message.
	    /// </remarks>
	    private readonly static Type declaringType = typeof(RollingFileAppender);

	    #endregion Private Static Fields

		#region Override implementation of FileAppender 
  
		/// <summary>
		/// Sets the quiet writer being used.
		/// </summary>
		/// <remarks>
		/// This method can be overridden by sub classes.
		/// </remarks>
		/// <param name="writer">the writer to set</param>
		override protected void SetQWForFiles(TextWriter writer) 
		{
			QuietWriter = new CountingQuietTextWriter(writer, ErrorHandler);
		}

		/// <summary>
		/// Write out a logging event.
		/// </summary>
		/// <param name="loggingEvent">the event to write to file.</param>
		/// <remarks>
		/// <para>
		/// Handles append time behavior for RollingFileAppender.  This checks
		/// if a roll over either by date (checked first) or time (checked second)
		/// is need and then appends to the file last.
		/// </para>
		/// </remarks>
		override protected void Append(LoggingEvent loggingEvent) 
		{
			AdjustFileBeforeAppend();
			base.Append(loggingEvent);
		}
  
 		/// <summary>
		/// Write out an array of logging events.
		/// </summary>
		/// <param name="loggingEvents">the events to write to file.</param>
		/// <remarks>
		/// <para>
		/// Handles append time behavior for RollingFileAppender.  This checks
		/// if a roll over either by date (checked first) or time (checked second)
		/// is need and then appends to the file last.
		/// </para>
		/// </remarks>
		override protected void Append(LoggingEvent[] loggingEvents) 
		{
			AdjustFileBeforeAppend();
			base.Append(loggingEvents);
		}

		/// <summary>
		/// Performs any required rolling before outputting the next event
		/// </summary>
		/// <remarks>
		/// <para>
		/// Handles append time behavior for RollingFileAppender.  This checks
		/// if a roll over either by date (checked first) or time (checked second)
		/// is need and then appends to the file last.
		/// </para>
		/// </remarks>
		virtual protected void AdjustFileBeforeAppend()
		{
			// reuse the file appenders locking model to lock the rolling
#if !NETCF
			try
			{
				// if rolling should be locked, acquire the lock
				if (m_mutexForRolling != null)
				{
					m_mutexForRolling.WaitOne();
				}
#endif
				if (m_rollDate)
				{
					DateTime n = m_dateTime.Now;
					if (n >= m_nextCheck)
					{
						m_now = n;
						m_nextCheck = NextCheckDate(m_now, m_rollPoint);

						RollOverTime(true);
					}
				}

				if (m_rollSize)
				{
					if ((File != null) && ((CountingQuietTextWriter)QuietWriter).Count >= m_maxFileSize)
					{
						RollOverSize();
					}
				}
#if !NETCF
			}
			finally
			{
				// if rolling should be locked, release the lock
				if (m_mutexForRolling != null)
				{
					m_mutexForRolling.ReleaseMutex();
				}
			}
#endif
		}

		/// <summary>
		/// Creates and opens the file for logging.  If <see cref="StaticLogFileName"/>
		/// is false then the fully qualified name is determined and used.
		/// </summary>
		/// <param name="fileName">the name of the file to open</param>
		/// <param name="append">true to append to existing file</param>
		/// <remarks>
		/// <para>This method will ensure that the directory structure
		/// for the <paramref name="fileName"/> specified exists.</para>
		/// </remarks>
		override protected void OpenFile(string fileName, bool append)
		{
			lock(this)
			{
				fileName = GetNextOutputFileName(fileName);

				// Calculate the current size of the file
				long currentCount = 0;
				if (append) 
				{
					using(SecurityContext.Impersonate(this))
					{
						if (System.IO.File.Exists(fileName))
						{
							currentCount = (new FileInfo(fileName)).Length;
						}
					}
				}
				else
				{
					if (LogLog.IsErrorEnabled)
					{
						// Internal check that the file is not being overwritten
						// If not Appending to an existing file we should have rolled the file out of the
						// way. Therefore we should not be over-writing an existing file.
						// The only exception is if we are not allowed to roll the existing file away.
						if (m_maxSizeRollBackups != 0 && FileExists(fileName))
						{
							LogLog.Error(declaringType, "RollingFileAppender: INTERNAL ERROR. Append is False but OutputFile ["+fileName+"] already exists.");
						}
					}
				}

				if (!m_staticLogFileName) 
				{
					m_scheduledFilename = fileName;
				}

				// Open the file (call the base class to do it)
				base.OpenFile(fileName, append);

				// Set the file size onto the counting writer
				((CountingQuietTextWriter)QuietWriter).Count = currentCount;
			}
		}

		/// <summary>
		/// Get the current output file name
		/// </summary>
		/// <param name="fileName">the base file name</param>
		/// <returns>the output file name</returns>
		/// <remarks>
		/// The output file name is based on the base fileName specified.
		/// If <see cref="StaticLogFileName"/> is set then the output 
		/// file name is the same as the base file passed in. Otherwise
		/// the output file depends on the date pattern, on the count
		/// direction or both.
		/// </remarks>
		protected string GetNextOutputFileName(string fileName)
		{
			if (!m_staticLogFileName) 
			{
				fileName = fileName.Trim();

				if (m_rollDate)
				{
                    fileName = CombinePath(fileName, m_now.ToString(m_datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo));
				}

				if (m_countDirection >= 0) 
				{
                    fileName = CombinePath(fileName, "." + m_curSizeRollBackups);
				}
			}

			return fileName;
		}

		#endregion

		#region Initialize Options

		/// <summary>
		///	Determines curSizeRollBackups (only within the current roll point)
		/// </summary>
		private void DetermineCurSizeRollBackups()
		{
			m_curSizeRollBackups = 0;
	
			string fullPath = null;
			string fileName = null;

			using(SecurityContext.Impersonate(this))
			{
				fullPath = System.IO.Path.GetFullPath(m_baseFileName);
				fileName = System.IO.Path.GetFileName(fullPath);
			}

			ArrayList arrayFiles = GetExistingFiles(fullPath);
			InitializeRollBackups(fileName, arrayFiles);

			LogLog.Debug(declaringType, "curSizeRollBackups starts at ["+m_curSizeRollBackups+"]");
		}

		/// <summary>
		/// Generates a wildcard pattern that can be used to find all files
		/// that are similar to the base file name.
		/// </summary>
		/// <param name="baseFileName"></param>
		/// <returns></returns>
		private string GetWildcardPatternForFile(string baseFileName)
		{
            if (m_preserveLogFileNameExtension)
            {
                return Path.GetFileNameWithoutExtension(baseFileName) + "*" + Path.GetExtension(baseFileName);
            }
            else
            {
                return baseFileName + '*';
            }
		}

		/// <summary>
		/// Builds a list of filenames for all files matching the base filename plus a file
		/// pattern.
		/// </summary>
		/// <param name="baseFilePath"></param>
		/// <returns></returns>
		private ArrayList GetExistingFiles(string baseFilePath)
		{
			ArrayList alFiles = new ArrayList();

			string directory = null;

			using(SecurityContext.Impersonate(this))
			{
				string fullPath = Path.GetFullPath(baseFilePath);

				directory = Path.GetDirectoryName(fullPath);
				if (Directory.Exists(directory))
				{
					string baseFileName = Path.GetFileName(fullPath);

					string[] files = Directory.GetFiles(directory, GetWildcardPatternForFile(baseFileName));
	
					if (files != null)
					{
						for (int i = 0; i < files.Length; i++) 
						{
							string curFileName = Path.GetFileName(files[i]);
							if (curFileName.StartsWith(Path.GetFileNameWithoutExtension(baseFileName)))
							{
								alFiles.Add(curFileName);
							}
						}
					}
				}
			}
			LogLog.Debug(declaringType, "Searched for existing files in ["+directory+"]");
			return alFiles;
		}

		/// <summary>
		/// Initiates a roll over if needed for crossing a date boundary since the last run.
		/// </summary>
		private void RollOverIfDateBoundaryCrossing()
		{
			if (m_staticLogFileName && m_rollDate) 
			{
				if (FileExists(m_baseFileName)) 
				{
					DateTime last;
					using(SecurityContext.Impersonate(this)) {
#if !NET_1_0 && !CLI_1_0 && !NETCF
                        if (DateTimeStrategy is UniversalDateTime)
						{
							last = System.IO.File.GetLastWriteTimeUtc(m_baseFileName);
						}
						else
						{
#endif
							last = System.IO.File.GetLastWriteTime(m_baseFileName);
#if !NET_1_0 && !CLI_1_0 && !NETCF
                        }
#endif
                    }
					LogLog.Debug(declaringType, "["+last.ToString(m_datePattern,System.Globalization.DateTimeFormatInfo.InvariantInfo)+"] vs. ["+m_now.ToString(m_datePattern,System.Globalization.DateTimeFormatInfo.InvariantInfo)+"]");

					if (!(last.ToString(m_datePattern,System.Globalization.DateTimeFormatInfo.InvariantInfo).Equals(m_now.ToString(m_datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo)))) 
					{
						m_scheduledFilename = CombinePath(m_baseFileName, last.ToString(m_datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo));
						LogLog.Debug(declaringType, "Initial roll over to ["+m_scheduledFilename+"]");
						RollOverTime(false);
						LogLog.Debug(declaringType, "curSizeRollBackups after rollOver at ["+m_curSizeRollBackups+"]");
					}
				}
			}
		}

		/// <summary>
		/// Initializes based on existing conditions at time of <see cref="ActivateOptions"/>.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Initializes based on existing conditions at time of <see cref="ActivateOptions"/>.
		/// The following is done
		/// <list type="bullet">
		///	<item>determine curSizeRollBackups (only within the current roll point)</item>
		///	<item>initiates a roll over if needed for crossing a date boundary since the last run.</item>
		///	</list>
		///	</para>
		/// </remarks>
		protected void ExistingInit() 
		{
			DetermineCurSizeRollBackups();
			RollOverIfDateBoundaryCrossing();

			// If file exists and we are not appending then roll it out of the way
			if (AppendToFile == false)
			{
				bool fileExists = false;
				string fileName = GetNextOutputFileName(m_baseFileName);

				using(SecurityContext.Impersonate(this))
				{
					fileExists = System.IO.File.Exists(fileName);
				}

				if (fileExists)
				{
					if (m_maxSizeRollBackups == 0)
					{
						LogLog.Debug(declaringType, "Output file ["+fileName+"] already exists. MaxSizeRollBackups is 0; cannot roll. Overwriting existing file.");
					}
					else
					{
						LogLog.Debug(declaringType, "Output file ["+fileName+"] already exists. Not appending to file. Rolling existing file out of the way.");

						RollOverRenameFiles(fileName);
					}
				}
			}
		}

		/// <summary>
		/// Does the work of bumping the 'current' file counter higher
		/// to the highest count when an incremental file name is seen.
		/// The highest count is either the first file (when count direction
		/// is greater than 0) or the last file (when count direction less than 0).
		/// In either case, we want to know the highest count that is present.
		/// </summary>
		/// <param name="baseFile"></param>
		/// <param name="curFileName"></param>
		private void InitializeFromOneFile(string baseFile, string curFileName)
		{
            if (curFileName.StartsWith(Path.GetFileNameWithoutExtension(baseFile)) == false)
			{
				// This is not a log file, so ignore
				return;
			}
			if (curFileName.Equals(baseFile)) 
			{
				// Base log file is not an incremented logfile (.1 or .2, etc)
				return;
			}
	
            /*
			if (m_staticLogFileName) 
			{
				int endLength = curFileName.Length - index;
				if (baseFile.Length + endLength != curFileName.Length) 
				{
					// file is probably scheduledFilename + .x so I don't care
					return;
				}
			}
            */
	
			// Only look for files in the current roll point
			if (m_rollDate && !m_staticLogFileName)
			{
				string date = m_dateTime.Now.ToString(m_datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo);
				string prefix = m_preserveLogFileNameExtension ? Path.GetFileNameWithoutExtension(baseFile) + date : baseFile + date;
				string suffix = m_preserveLogFileNameExtension ? Path.GetExtension(baseFile) : "";
				if (!curFileName.StartsWith(prefix) || !curFileName.EndsWith(suffix))
				{
					LogLog.Debug(declaringType, "Ignoring file ["+curFileName+"] because it is from a different date period");
					return;
				}
			}
            
			try 
			{
				// Bump the counter up to the highest count seen so far
                int backup = GetBackUpIndex(curFileName);
                
                // caution: we might get a false positive when certain
                // date patterns such as yyyyMMdd are used...those are
                // valid number but aren't the kind of back up index
                // we're looking for
                if (backup > m_curSizeRollBackups)
                {
                    if (0 == m_maxSizeRollBackups)
                    {
                        // Stay at zero when zero backups are desired
                    }
                    else if (-1 == m_maxSizeRollBackups)
                    {
                        // Infinite backups, so go as high as the highest value
                        m_curSizeRollBackups = backup;
                    }
                    else
                    {
                        // Backups limited to a finite number
                        if (m_countDirection >= 0)
                        {
                            // Go with the highest file when counting up
                            m_curSizeRollBackups = backup;
                        }
                        else
                        {
                            // Clip to the limit when counting down
                            if (backup <= m_maxSizeRollBackups)
                            {
                                m_curSizeRollBackups = backup;
                            }
                        }
                    }
                    LogLog.Debug(declaringType, "File name [" + curFileName + "] moves current count to [" + m_curSizeRollBackups + "]");
                }
			} 
			catch(FormatException) 
			{
				//this happens when file.log -> file.log.yyyy-MM-dd which is normal
				//when staticLogFileName == false
				LogLog.Debug(declaringType, "Encountered a backup file not ending in .x ["+curFileName+"]");
			}
		}

        /// <summary>
        /// Attempts to extract a number from the end of the file name that indicates
        /// the number of the times the file has been rolled over.
        /// </summary>
        /// <remarks>
        /// Certain date pattern extensions like yyyyMMdd will be parsed as valid backup indexes.
        /// </remarks>
        /// <param name="curFileName"></param>
        /// <returns></returns>
	    private int GetBackUpIndex(string curFileName)
	    {
            int backUpIndex = -1;
            string fileName = curFileName;

            if (m_preserveLogFileNameExtension)
            {
                fileName = Path.GetFileNameWithoutExtension(fileName);
            }
            
            int index = fileName.LastIndexOf(".");
            if (index > 0)
            {
                // if the "yyyy-MM-dd" component of file.log.yyyy-MM-dd is passed to TryParse
                // it will gracefully fail and return backUpIndex will be 0
                SystemInfo.TryParse(fileName.Substring(index + 1), out backUpIndex);
            }

            return backUpIndex;
	    }

	    /// <summary>
		/// Takes a list of files and a base file name, and looks for 
		/// 'incremented' versions of the base file.  Bumps the max
		/// count up to the highest count seen.
		/// </summary>
		/// <param name="baseFile"></param>
		/// <param name="arrayFiles"></param>
		private void InitializeRollBackups(string baseFile, ArrayList arrayFiles)
		{
			if (null != arrayFiles)
			{
				string baseFileLower = baseFile.ToLower(System.Globalization.CultureInfo.InvariantCulture);

				foreach(string curFileName in arrayFiles)
				{
					InitializeFromOneFile(baseFileLower, curFileName.ToLower(System.Globalization.CultureInfo.InvariantCulture));
				}
			}
		}

		/// <summary>
		/// Calculates the RollPoint for the datePattern supplied.
		/// </summary>
		/// <param name="datePattern">the date pattern to calculate the check period for</param>
		/// <returns>The RollPoint that is most accurate for the date pattern supplied</returns>
		/// <remarks>
		/// Essentially the date pattern is examined to determine what the
		/// most suitable roll point is. The roll point chosen is the roll point
		/// with the smallest period that can be detected using the date pattern
		/// supplied. i.e. if the date pattern only outputs the year, month, day 
		/// and hour then the smallest roll point that can be detected would be
		/// and hourly roll point as minutes could not be detected.
		/// </remarks>
		private RollPoint ComputeCheckPeriod(string datePattern) 
		{
			// s_date1970 is 1970-01-01 00:00:00 this is UniversalSortableDateTimePattern 
			// (based on ISO 8601) using universal time. This date is used for reference
			// purposes to calculate the resolution of the date pattern.

			// Get string representation of base line date
			string r0 = s_date1970.ToString(datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo);

			// Check each type of rolling mode starting with the smallest increment.
			for(int i = (int)RollPoint.TopOfMinute; i <= (int)RollPoint.TopOfMonth; i++) 
			{
				// Get string representation of next pattern
				string r1 = NextCheckDate(s_date1970, (RollPoint)i).ToString(datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo);

				LogLog.Debug(declaringType, "Type = ["+i+"], r0 = ["+r0+"], r1 = ["+r1+"]");

				// Check if the string representations are different
				if (r0 != null && r1 != null && !r0.Equals(r1)) 
				{
					// Found highest precision roll point
					return (RollPoint)i;
				}
			}

			return RollPoint.InvalidRollPoint; // Deliberately head for trouble...
		}

		/// <summary>
		/// Initialize the appender based on the options set
		/// </summary>
		/// <remarks>
		/// <para>
		/// This is part of the <see cref="IOptionHandler"/> delayed object
		/// activation scheme. The <see cref="ActivateOptions"/> method must 
		/// be called on this object after the configuration properties have
		/// been set. Until <see cref="ActivateOptions"/> is called this
		/// object is in an undefined state and must not be used. 
		/// </para>
		/// <para>
		/// If any of the configuration properties are modified then 
		/// <see cref="ActivateOptions"/> must be called again.
		/// </para>
		/// <para>
		/// Sets initial conditions including date/time roll over information, first check,
		/// scheduledFilename, and calls <see cref="ExistingInit"/> to initialize
		/// the current number of backups.
		/// </para>
		/// </remarks>
		override public void ActivateOptions() 
		{
			if (m_dateTime == null)
			{
				m_dateTime = new LocalDateTime();
			}

			if (m_rollDate && m_datePattern != null) 
			{
				m_now = m_dateTime.Now;
				m_rollPoint = ComputeCheckPeriod(m_datePattern);

				if (m_rollPoint == RollPoint.InvalidRollPoint)
				{
					throw new ArgumentException("Invalid RollPoint, unable to parse ["+m_datePattern+"]");
				}

				// next line added as this removes the name check in rollOver
				m_nextCheck = NextCheckDate(m_now, m_rollPoint);
			} 
			else 
			{
				if (m_rollDate)
				{
					ErrorHandler.Error("Either DatePattern or rollingStyle options are not set for ["+Name+"].");
				}
			}

			if (SecurityContext == null)
			{
				SecurityContext = SecurityContextProvider.DefaultProvider.CreateSecurityContext(this);
			}

			using(SecurityContext.Impersonate(this))
			{
				// Must convert the FileAppender's m_filePath to an absolute path before we
				// call ExistingInit(). This will be done by the base.ActivateOptions() but
				// we need to duplicate that functionality here first.
				base.File = ConvertToFullPath(base.File.Trim());

				// Store fully qualified base file name
				m_baseFileName = base.File;
			}

#if !NETCF
			// initialize the mutex that is used to lock rolling
			m_mutexForRolling = new Mutex(false, m_baseFileName.Replace("\\", "_").Replace(":", "_").Replace("/", "_"));
#endif

			if (m_rollDate && File != null && m_scheduledFilename == null)
			{
                m_scheduledFilename = CombinePath(File, m_now.ToString(m_datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo));
			}

			ExistingInit();
	
			base.ActivateOptions();
		}

		#endregion
  
		#region Roll File

        /// <summary>
        /// 
        /// </summary>
        /// <param name="path1"></param>
        /// <param name="path2">.1, .2, .3, etc.</param>
        /// <returns></returns>
        private string CombinePath(string path1, string path2)
        {
            string extension = Path.GetExtension(path1);
            if (m_preserveLogFileNameExtension && extension.Length > 0)
            {
                return Path.Combine(Path.GetDirectoryName(path1), Path.GetFileNameWithoutExtension(path1) + path2 + extension);
            }
            else
            {
                return path1 + path2;
            }
        }

		/// <summary>
		/// Rollover the file(s) to date/time tagged file(s).
		/// </summary>
		/// <param name="fileIsOpen">set to true if the file to be rolled is currently open</param>
		/// <remarks>
		/// <para>
		/// Rollover the file(s) to date/time tagged file(s).
		/// Resets curSizeRollBackups. 
		/// If fileIsOpen is set then the new file is opened (through SafeOpenFile).
		/// </para>
		/// </remarks>
		protected void RollOverTime(bool fileIsOpen) 
		{
			if (m_staticLogFileName) 
			{
				// Compute filename, but only if datePattern is specified
				if (m_datePattern == null) 
				{
					ErrorHandler.Error("Missing DatePattern option in rollOver().");
					return;
				}
	  
				//is the new file name equivalent to the 'current' one
				//something has gone wrong if we hit this -- we should only
				//roll over if the new file will be different from the old
				string dateFormat = m_now.ToString(m_datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo);
                if (m_scheduledFilename.Equals(CombinePath(File, dateFormat))) 
				{
                    ErrorHandler.Error("Compare " + m_scheduledFilename + " : " + CombinePath(File, dateFormat));
					return;
				}
	  
				if (fileIsOpen)
				{
					// close current file, and rename it to datedFilename
					this.CloseFile();
				}
	  
				//we may have to roll over a large number of backups here
				for (int i = 1; i <= m_curSizeRollBackups; i++) 
				{
                    string from = CombinePath(File, "." + i);
                    string to = CombinePath(m_scheduledFilename, "." + i);
					RollFile(from, to);
				}
	  
				RollFile(File, m_scheduledFilename);
			}
	
			//We've cleared out the old date and are ready for the new
			m_curSizeRollBackups = 0; 
	
			//new scheduled name
            m_scheduledFilename = CombinePath(File, m_now.ToString(m_datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo));

			if (fileIsOpen)
			{
				// This will also close the file. This is OK since multiple close operations are safe.
				SafeOpenFile(m_baseFileName, false);
			}
		}
  
		/// <summary>
		/// Renames file <paramref name="fromFile"/> to file <paramref name="toFile"/>.
		/// </summary>
		/// <param name="fromFile">Name of existing file to roll.</param>
		/// <param name="toFile">New name for file.</param>
		/// <remarks>
		/// <para>
		/// Renames file <paramref name="fromFile"/> to file <paramref name="toFile"/>. It
		/// also checks for existence of target file and deletes if it does.
		/// </para>
		/// </remarks>
		protected void RollFile(string fromFile, string toFile) 
		{
			if (FileExists(fromFile))
			{
				// Delete the toFile if it exists
				DeleteFile(toFile);

				// We may not have permission to move the file, or the file may be locked
				try
				{
					LogLog.Debug(declaringType, "Moving [" + fromFile + "] -> [" + toFile + "]");
					using(SecurityContext.Impersonate(this))
					{
						System.IO.File.Move(fromFile, toFile);
					}
				}
				catch(Exception moveEx)
				{
					ErrorHandler.Error("Exception while rolling file [" + fromFile + "] -> [" + toFile + "]", moveEx, ErrorCode.GenericFailure);
				}
			}
			else
			{
				LogLog.Warn(declaringType, "Cannot RollFile [" + fromFile + "] -> [" + toFile + "]. Source does not exist");
			}
		}

		/// <summary>
		/// Test if a file exists at a specified path
		/// </summary>
		/// <param name="path">the path to the file</param>
		/// <returns>true if the file exists</returns>
		/// <remarks>
		/// <para>
		/// Test if a file exists at a specified path
		/// </para>
		/// </remarks>
		protected bool FileExists(string path)
		{
			using(SecurityContext.Impersonate(this))
			{
				return System.IO.File.Exists(path);
			}
		}
  
		/// <summary>
		/// Deletes the specified file if it exists.
		/// </summary>
		/// <param name="fileName">The file to delete.</param>
		/// <remarks>
		/// <para>
		/// Delete a file if is exists.
		/// The file is first moved to a new filename then deleted.
		/// This allows the file to be removed even when it cannot
		/// be deleted, but it still can be moved.
		/// </para>
		/// </remarks>
		protected void DeleteFile(string fileName) 
		{
			if (FileExists(fileName)) 
			{
				// We may not have permission to delete the file, or the file may be locked

				string fileToDelete = fileName;

				// Try to move the file to temp name.
				// If the file is locked we may still be able to move it
				string tempFileName = fileName + "." + Environment.TickCount + ".DeletePending";
				try
				{
					using(SecurityContext.Impersonate(this))
					{
						System.IO.File.Move(fileName, tempFileName);
					}
					fileToDelete = tempFileName;
				}
				catch(Exception moveEx)
				{
					LogLog.Debug(declaringType, "Exception while moving file to be deleted [" + fileName + "] -> [" + tempFileName + "]", moveEx);
				}

				// Try to delete the file (either the original or the moved file)
				try
				{
					using(SecurityContext.Impersonate(this))
					{
						System.IO.File.Delete(fileToDelete);
					}
					LogLog.Debug(declaringType, "Deleted file [" + fileName + "]");
				}
				catch(Exception deleteEx)
				{
					if (fileToDelete == fileName)
					{
						// Unable to move or delete the file
						ErrorHandler.Error("Exception while deleting file [" + fileToDelete + "]", deleteEx, ErrorCode.GenericFailure);
					}
					else
					{
						// Moved the file, but the delete failed. File is probably locked.
						// The file should automatically be deleted when the lock is released.
						LogLog.Debug(declaringType, "Exception while deleting temp file [" + fileToDelete + "]", deleteEx);
					}
				}
			}
		}
  
		/// <summary>
		/// Implements file roll base on file size.
		/// </summary>
		/// <remarks>
		/// <para>
		/// If the maximum number of size based backups is reached
		/// (<c>curSizeRollBackups == maxSizeRollBackups</c>) then the oldest
		/// file is deleted -- its index determined by the sign of countDirection.
		/// If <c>countDirection</c> &lt; 0, then files
		/// {<c>File.1</c>, ..., <c>File.curSizeRollBackups -1</c>}
		/// are renamed to {<c>File.2</c>, ...,
		/// <c>File.curSizeRollBackups</c>}. Moreover, <c>File</c> is
		/// renamed <c>File.1</c> and closed.
		/// </para>
		/// <para>
		/// A new file is created to receive further log output.
		/// </para>
		/// <para>
		/// If <c>maxSizeRollBackups</c> is equal to zero, then the
		/// <c>File</c> is truncated with no backup files created.
		/// </para>
		/// <para>
		/// If <c>maxSizeRollBackups</c> &lt; 0, then <c>File</c> is
		/// renamed if needed and no files are deleted.
		/// </para>
		/// </remarks>
		protected void RollOverSize() 
		{
			this.CloseFile(); // keep windows happy.
	
			LogLog.Debug(declaringType, "rolling over count ["+((CountingQuietTextWriter)QuietWriter).Count+"]");
			LogLog.Debug(declaringType, "maxSizeRollBackups ["+m_maxSizeRollBackups+"]");
			LogLog.Debug(declaringType, "curSizeRollBackups ["+m_curSizeRollBackups+"]");
			LogLog.Debug(declaringType, "countDirection ["+m_countDirection+"]");

			RollOverRenameFiles(File);
	
			if (!m_staticLogFileName && m_countDirection >= 0) 
			{
				m_curSizeRollBackups++;
			}

			// This will also close the file. This is OK since multiple close operations are safe.
			SafeOpenFile(m_baseFileName, false);
		}

		/// <summary>
		/// Implements file roll.
		/// </summary>
		/// <param name="baseFileName">the base name to rename</param>
		/// <remarks>
		/// <para>
		/// If the maximum number of size based backups is reached
		/// (<c>curSizeRollBackups == maxSizeRollBackups</c>) then the oldest
		/// file is deleted -- its index determined by the sign of countDirection.
		/// If <c>countDirection</c> &lt; 0, then files
		/// {<c>File.1</c>, ..., <c>File.curSizeRollBackups -1</c>}
		/// are renamed to {<c>File.2</c>, ...,
		/// <c>File.curSizeRollBackups</c>}. 
		/// </para>
		/// <para>
		/// If <c>maxSizeRollBackups</c> is equal to zero, then the
		/// <c>File</c> is truncated with no backup files created.
		/// </para>
		/// <para>
		/// If <c>maxSizeRollBackups</c> &lt; 0, then <c>File</c> is
		/// renamed if needed and no files are deleted.
		/// </para>
		/// <para>
		/// This is called by <see cref="RollOverSize"/> to rename the files.
		/// </para>
		/// </remarks>
		protected void RollOverRenameFiles(string baseFileName) 
		{
			// If maxBackups <= 0, then there is no file renaming to be done.
			if (m_maxSizeRollBackups != 0) 
			{
				if (m_countDirection < 0) 
				{
					// Delete the oldest file, to keep Windows happy.
					if (m_curSizeRollBackups == m_maxSizeRollBackups) 
					{
                        DeleteFile(CombinePath(baseFileName, "." + m_maxSizeRollBackups));
						m_curSizeRollBackups--;
					}
	
					// Map {(maxBackupIndex - 1), ..., 2, 1} to {maxBackupIndex, ..., 3, 2}
					for (int i = m_curSizeRollBackups; i >= 1; i--) 
					{
                        RollFile((CombinePath(baseFileName, "." + i)), (CombinePath(baseFileName, "." + (i + 1))));
					}
	
					m_curSizeRollBackups++;

					// Rename fileName to fileName.1
                    RollFile(baseFileName, CombinePath(baseFileName, ".1"));
				} 
				else 
				{
					//countDirection >= 0
					if (m_curSizeRollBackups >= m_maxSizeRollBackups && m_maxSizeRollBackups > 0) 
					{
						//delete the first and keep counting up.
						int oldestFileIndex = m_curSizeRollBackups - m_maxSizeRollBackups;

						// If static then there is 1 file without a number, therefore 1 less archive
						if (m_staticLogFileName)
						{
							oldestFileIndex++;
						}

						// If using a static log file then the base for the numbered sequence is the baseFileName passed in
						// If not using a static log file then the baseFileName will already have a numbered postfix which
						// we must remove, however it may have a date postfix which we must keep!
						string archiveFileBaseName = baseFileName;
						if (!m_staticLogFileName)
						{
							int lastDotIndex = archiveFileBaseName.LastIndexOf(".");
							if (lastDotIndex >= 0) 
							{
								archiveFileBaseName = archiveFileBaseName.Substring(0, lastDotIndex);
							}
						}

						// Delete the archive file
                        DeleteFile(CombinePath(archiveFileBaseName, "." + oldestFileIndex));
					}
	
					if (m_staticLogFileName) 
					{
						m_curSizeRollBackups++;
                        RollFile(baseFileName, CombinePath(baseFileName, "." + m_curSizeRollBackups));
					}
				}
			}
		}

		#endregion

		#region NextCheckDate

		/// <summary>
		/// Get the start time of the next window for the current rollpoint
		/// </summary>
		/// <param name="currentDateTime">the current date</param>
		/// <param name="rollPoint">the type of roll point we are working with</param>
		/// <returns>the start time for the next roll point an interval after the currentDateTime date</returns>
		/// <remarks>
		/// <para>
		/// Returns the date of the next roll point after the currentDateTime date passed to the method.
		/// </para>
		/// <para>
		/// The basic strategy is to subtract the time parts that are less significant
		/// than the rollpoint from the current time. This should roll the time back to
		/// the start of the time window for the current rollpoint. Then we add 1 window
		/// worth of time and get the start time of the next window for the rollpoint.
		/// </para>
		/// </remarks>
		protected DateTime NextCheckDate(DateTime currentDateTime, RollPoint rollPoint) 
		{
			// Local variable to work on (this does not look very efficient)
			DateTime current = currentDateTime;

			// Do slightly different things depending on what the type of roll point we want.
			switch(rollPoint) 
			{
				case RollPoint.TopOfMinute:
					current = current.AddMilliseconds(-current.Millisecond);
					current = current.AddSeconds(-current.Second);
					current = current.AddMinutes(1);
					break;

				case RollPoint.TopOfHour:
					current = current.AddMilliseconds(-current.Millisecond);
					current = current.AddSeconds(-current.Second);
					current = current.AddMinutes(-current.Minute);
					current = current.AddHours(1);
					break;

				case RollPoint.HalfDay:
					current = current.AddMilliseconds(-current.Millisecond);
					current = current.AddSeconds(-current.Second);
					current = current.AddMinutes(-current.Minute);

					if (current.Hour < 12) 
					{
						current = current.AddHours(12 - current.Hour);
					} 
					else 
					{
						current = current.AddHours(-current.Hour);
						current = current.AddDays(1);
					}
					break;

				case RollPoint.TopOfDay:
					current = current.AddMilliseconds(-current.Millisecond);
					current = current.AddSeconds(-current.Second);
					current = current.AddMinutes(-current.Minute);
					current = current.AddHours(-current.Hour);
					current = current.AddDays(1);
					break;

				case RollPoint.TopOfWeek:
					current = current.AddMilliseconds(-current.Millisecond);
					current = current.AddSeconds(-current.Second);
					current = current.AddMinutes(-current.Minute);
					current = current.AddHours(-current.Hour);
					current = current.AddDays(7 - (int)current.DayOfWeek);
					break;

				case RollPoint.TopOfMonth:
					current = current.AddMilliseconds(-current.Millisecond);
					current = current.AddSeconds(-current.Second);
					current = current.AddMinutes(-current.Minute);
					current = current.AddHours(-current.Hour);
					current = current.AddDays(1 - current.Day); /* first day of month is 1 not 0 */
					current = current.AddMonths(1);
					break;
			}	  
			return current;
		}

		#endregion

		#region Private Instance Fields

		/// <summary>
		/// This object supplies the current date/time.  Allows test code to plug in
		/// a method to control this class when testing date/time based rolling. The default
		/// implementation uses the underlying value of DateTime.Now.
		/// </summary>
		private IDateTime m_dateTime = null;

		/// <summary>
		/// The date pattern. By default, the pattern is set to <c>".yyyy-MM-dd"</c> 
		/// meaning daily rollover.
		/// </summary>
		private string m_datePattern = ".yyyy-MM-dd";
  
		/// <summary>
		/// The actual formatted filename that is currently being written to
		/// or will be the file transferred to on roll over
		/// (based on staticLogFileName).
		/// </summary>
		private string m_scheduledFilename = null;
  
		/// <summary>
		/// The timestamp when we shall next recompute the filename.
		/// </summary>
		private DateTime m_nextCheck = DateTime.MaxValue;
  
		/// <summary>
		/// Holds date of last roll over
		/// </summary>
		private DateTime m_now;
  
		/// <summary>
		/// The type of rolling done
		/// </summary>
		private RollPoint m_rollPoint;
  
		/// <summary>
		/// The default maximum file size is 10MB
		/// </summary>
		private long m_maxFileSize = 10*1024*1024;
  
		/// <summary>
		/// There is zero backup files by default
		/// </summary>
		private int m_maxSizeRollBackups  = 0;

		/// <summary>
		/// How many sized based backups have been made so far
		/// </summary>
		private int m_curSizeRollBackups = 0;
  
		/// <summary>
		/// The rolling file count direction. 
		/// </summary>
		private int m_countDirection = -1;
  
		/// <summary>
		/// The rolling mode used in this appender.
		/// </summary>
		private RollingMode m_rollingStyle = RollingMode.Composite;

		/// <summary>
		/// Cache flag set if we are rolling by date.
		/// </summary>
		private bool m_rollDate = true;

		/// <summary>
		/// Cache flag set if we are rolling by size.
		/// </summary>
		private bool m_rollSize = true;
  
		/// <summary>
		/// Value indicating whether to always log to the same file.
		/// </summary>
		private bool m_staticLogFileName = true;
  
   		/// <summary>
		/// Value indicating whether to preserve the file name extension when rolling.
		/// </summary>
		private bool m_preserveLogFileNameExtension = false;]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static RollingFileAppender()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="550" sc="6" el="1706" ec="74">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="49c0b8994ebe6119c7ecf6d57b7d3bad"><![CDATA[private readonly static Type declaringType = typeof(RollingFileAppender);

	    #endregion Private Static Fields

		#region Override implementation of FileAppender 
  
		/// <summary>
		/// Sets the quiet writer being used.
		/// </summary>
		/// <remarks>
		/// This method can be overridden by sub classes.
		/// </remarks>
		/// <param name="writer">the writer to set</param>
		override protected void SetQWForFiles(TextWriter writer) 
		{
			QuietWriter = new CountingQuietTextWriter(writer, ErrorHandler);
		}

		/// <summary>
		/// Write out a logging event.
		/// </summary>
		/// <param name="loggingEvent">the event to write to file.</param>
		/// <remarks>
		/// <para>
		/// Handles append time behavior for RollingFileAppender.  This checks
		/// if a roll over either by date (checked first) or time (checked second)
		/// is need and then appends to the file last.
		/// </para>
		/// </remarks>
		override protected void Append(LoggingEvent loggingEvent) 
		{
			AdjustFileBeforeAppend();
			base.Append(loggingEvent);
		}
  
 		/// <summary>
		/// Write out an array of logging events.
		/// </summary>
		/// <param name="loggingEvents">the events to write to file.</param>
		/// <remarks>
		/// <para>
		/// Handles append time behavior for RollingFileAppender.  This checks
		/// if a roll over either by date (checked first) or time (checked second)
		/// is need and then appends to the file last.
		/// </para>
		/// </remarks>
		override protected void Append(LoggingEvent[] loggingEvents) 
		{
			AdjustFileBeforeAppend();
			base.Append(loggingEvents);
		}

		/// <summary>
		/// Performs any required rolling before outputting the next event
		/// </summary>
		/// <remarks>
		/// <para>
		/// Handles append time behavior for RollingFileAppender.  This checks
		/// if a roll over either by date (checked first) or time (checked second)
		/// is need and then appends to the file last.
		/// </para>
		/// </remarks>
		virtual protected void AdjustFileBeforeAppend()
		{
			// reuse the file appenders locking model to lock the rolling
#if !NETCF
			try
			{
				// if rolling should be locked, acquire the lock
				if (m_mutexForRolling != null)
				{
					m_mutexForRolling.WaitOne();
				}
#endif
				if (m_rollDate)
				{
					DateTime n = m_dateTime.Now;
					if (n >= m_nextCheck)
					{
						m_now = n;
						m_nextCheck = NextCheckDate(m_now, m_rollPoint);

						RollOverTime(true);
					}
				}

				if (m_rollSize)
				{
					if ((File != null) && ((CountingQuietTextWriter)QuietWriter).Count >= m_maxFileSize)
					{
						RollOverSize();
					}
				}
#if !NETCF
			}
			finally
			{
				// if rolling should be locked, release the lock
				if (m_mutexForRolling != null)
				{
					m_mutexForRolling.ReleaseMutex();
				}
			}
#endif
		}

		/// <summary>
		/// Creates and opens the file for logging.  If <see cref="StaticLogFileName"/>
		/// is false then the fully qualified name is determined and used.
		/// </summary>
		/// <param name="fileName">the name of the file to open</param>
		/// <param name="append">true to append to existing file</param>
		/// <remarks>
		/// <para>This method will ensure that the directory structure
		/// for the <paramref name="fileName"/> specified exists.</para>
		/// </remarks>
		override protected void OpenFile(string fileName, bool append)
		{
			lock(this)
			{
				fileName = GetNextOutputFileName(fileName);

				// Calculate the current size of the file
				long currentCount = 0;
				if (append) 
				{
					using(SecurityContext.Impersonate(this))
					{
						if (System.IO.File.Exists(fileName))
						{
							currentCount = (new FileInfo(fileName)).Length;
						}
					}
				}
				else
				{
					if (LogLog.IsErrorEnabled)
					{
						// Internal check that the file is not being overwritten
						// If not Appending to an existing file we should have rolled the file out of the
						// way. Therefore we should not be over-writing an existing file.
						// The only exception is if we are not allowed to roll the existing file away.
						if (m_maxSizeRollBackups != 0 && FileExists(fileName))
						{
							LogLog.Error(declaringType, "RollingFileAppender: INTERNAL ERROR. Append is False but OutputFile ["+fileName+"] already exists.");
						}
					}
				}

				if (!m_staticLogFileName) 
				{
					m_scheduledFilename = fileName;
				}

				// Open the file (call the base class to do it)
				base.OpenFile(fileName, append);

				// Set the file size onto the counting writer
				((CountingQuietTextWriter)QuietWriter).Count = currentCount;
			}
		}

		/// <summary>
		/// Get the current output file name
		/// </summary>
		/// <param name="fileName">the base file name</param>
		/// <returns>the output file name</returns>
		/// <remarks>
		/// The output file name is based on the base fileName specified.
		/// If <see cref="StaticLogFileName"/> is set then the output 
		/// file name is the same as the base file passed in. Otherwise
		/// the output file depends on the date pattern, on the count
		/// direction or both.
		/// </remarks>
		protected string GetNextOutputFileName(string fileName)
		{
			if (!m_staticLogFileName) 
			{
				fileName = fileName.Trim();

				if (m_rollDate)
				{
                    fileName = CombinePath(fileName, m_now.ToString(m_datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo));
				}

				if (m_countDirection >= 0) 
				{
                    fileName = CombinePath(fileName, "." + m_curSizeRollBackups);
				}
			}

			return fileName;
		}

		#endregion

		#region Initialize Options

		/// <summary>
		///	Determines curSizeRollBackups (only within the current roll point)
		/// </summary>
		private void DetermineCurSizeRollBackups()
		{
			m_curSizeRollBackups = 0;
	
			string fullPath = null;
			string fileName = null;

			using(SecurityContext.Impersonate(this))
			{
				fullPath = System.IO.Path.GetFullPath(m_baseFileName);
				fileName = System.IO.Path.GetFileName(fullPath);
			}

			ArrayList arrayFiles = GetExistingFiles(fullPath);
			InitializeRollBackups(fileName, arrayFiles);

			LogLog.Debug(declaringType, "curSizeRollBackups starts at ["+m_curSizeRollBackups+"]");
		}

		/// <summary>
		/// Generates a wildcard pattern that can be used to find all files
		/// that are similar to the base file name.
		/// </summary>
		/// <param name="baseFileName"></param>
		/// <returns></returns>
		private string GetWildcardPatternForFile(string baseFileName)
		{
            if (m_preserveLogFileNameExtension)
            {
                return Path.GetFileNameWithoutExtension(baseFileName) + "*" + Path.GetExtension(baseFileName);
            }
            else
            {
                return baseFileName + '*';
            }
		}

		/// <summary>
		/// Builds a list of filenames for all files matching the base filename plus a file
		/// pattern.
		/// </summary>
		/// <param name="baseFilePath"></param>
		/// <returns></returns>
		private ArrayList GetExistingFiles(string baseFilePath)
		{
			ArrayList alFiles = new ArrayList();

			string directory = null;

			using(SecurityContext.Impersonate(this))
			{
				string fullPath = Path.GetFullPath(baseFilePath);

				directory = Path.GetDirectoryName(fullPath);
				if (Directory.Exists(directory))
				{
					string baseFileName = Path.GetFileName(fullPath);

					string[] files = Directory.GetFiles(directory, GetWildcardPatternForFile(baseFileName));
	
					if (files != null)
					{
						for (int i = 0; i < files.Length; i++) 
						{
							string curFileName = Path.GetFileName(files[i]);
							if (curFileName.StartsWith(Path.GetFileNameWithoutExtension(baseFileName)))
							{
								alFiles.Add(curFileName);
							}
						}
					}
				}
			}
			LogLog.Debug(declaringType, "Searched for existing files in ["+directory+"]");
			return alFiles;
		}

		/// <summary>
		/// Initiates a roll over if needed for crossing a date boundary since the last run.
		/// </summary>
		private void RollOverIfDateBoundaryCrossing()
		{
			if (m_staticLogFileName && m_rollDate) 
			{
				if (FileExists(m_baseFileName)) 
				{
					DateTime last;
					using(SecurityContext.Impersonate(this)) {
#if !NET_1_0 && !CLI_1_0 && !NETCF
                        if (DateTimeStrategy is UniversalDateTime)
						{
							last = System.IO.File.GetLastWriteTimeUtc(m_baseFileName);
						}
						else
						{
#endif
							last = System.IO.File.GetLastWriteTime(m_baseFileName);
#if !NET_1_0 && !CLI_1_0 && !NETCF
                        }
#endif
                    }
					LogLog.Debug(declaringType, "["+last.ToString(m_datePattern,System.Globalization.DateTimeFormatInfo.InvariantInfo)+"] vs. ["+m_now.ToString(m_datePattern,System.Globalization.DateTimeFormatInfo.InvariantInfo)+"]");

					if (!(last.ToString(m_datePattern,System.Globalization.DateTimeFormatInfo.InvariantInfo).Equals(m_now.ToString(m_datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo)))) 
					{
						m_scheduledFilename = CombinePath(m_baseFileName, last.ToString(m_datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo));
						LogLog.Debug(declaringType, "Initial roll over to ["+m_scheduledFilename+"]");
						RollOverTime(false);
						LogLog.Debug(declaringType, "curSizeRollBackups after rollOver at ["+m_curSizeRollBackups+"]");
					}
				}
			}
		}

		/// <summary>
		/// Initializes based on existing conditions at time of <see cref="ActivateOptions"/>.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Initializes based on existing conditions at time of <see cref="ActivateOptions"/>.
		/// The following is done
		/// <list type="bullet">
		///	<item>determine curSizeRollBackups (only within the current roll point)</item>
		///	<item>initiates a roll over if needed for crossing a date boundary since the last run.</item>
		///	</list>
		///	</para>
		/// </remarks>
		protected void ExistingInit() 
		{
			DetermineCurSizeRollBackups();
			RollOverIfDateBoundaryCrossing();

			// If file exists and we are not appending then roll it out of the way
			if (AppendToFile == false)
			{
				bool fileExists = false;
				string fileName = GetNextOutputFileName(m_baseFileName);

				using(SecurityContext.Impersonate(this))
				{
					fileExists = System.IO.File.Exists(fileName);
				}

				if (fileExists)
				{
					if (m_maxSizeRollBackups == 0)
					{
						LogLog.Debug(declaringType, "Output file ["+fileName+"] already exists. MaxSizeRollBackups is 0; cannot roll. Overwriting existing file.");
					}
					else
					{
						LogLog.Debug(declaringType, "Output file ["+fileName+"] already exists. Not appending to file. Rolling existing file out of the way.");

						RollOverRenameFiles(fileName);
					}
				}
			}
		}

		/// <summary>
		/// Does the work of bumping the 'current' file counter higher
		/// to the highest count when an incremental file name is seen.
		/// The highest count is either the first file (when count direction
		/// is greater than 0) or the last file (when count direction less than 0).
		/// In either case, we want to know the highest count that is present.
		/// </summary>
		/// <param name="baseFile"></param>
		/// <param name="curFileName"></param>
		private void InitializeFromOneFile(string baseFile, string curFileName)
		{
            if (curFileName.StartsWith(Path.GetFileNameWithoutExtension(baseFile)) == false)
			{
				// This is not a log file, so ignore
				return;
			}
			if (curFileName.Equals(baseFile)) 
			{
				// Base log file is not an incremented logfile (.1 or .2, etc)
				return;
			}
	
            /*
			if (m_staticLogFileName) 
			{
				int endLength = curFileName.Length - index;
				if (baseFile.Length + endLength != curFileName.Length) 
				{
					// file is probably scheduledFilename + .x so I don't care
					return;
				}
			}
            */
	
			// Only look for files in the current roll point
			if (m_rollDate && !m_staticLogFileName)
			{
				string date = m_dateTime.Now.ToString(m_datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo);
				string prefix = m_preserveLogFileNameExtension ? Path.GetFileNameWithoutExtension(baseFile) + date : baseFile + date;
				string suffix = m_preserveLogFileNameExtension ? Path.GetExtension(baseFile) : "";
				if (!curFileName.StartsWith(prefix) || !curFileName.EndsWith(suffix))
				{
					LogLog.Debug(declaringType, "Ignoring file ["+curFileName+"] because it is from a different date period");
					return;
				}
			}
            
			try 
			{
				// Bump the counter up to the highest count seen so far
                int backup = GetBackUpIndex(curFileName);
                
                // caution: we might get a false positive when certain
                // date patterns such as yyyyMMdd are used...those are
                // valid number but aren't the kind of back up index
                // we're looking for
                if (backup > m_curSizeRollBackups)
                {
                    if (0 == m_maxSizeRollBackups)
                    {
                        // Stay at zero when zero backups are desired
                    }
                    else if (-1 == m_maxSizeRollBackups)
                    {
                        // Infinite backups, so go as high as the highest value
                        m_curSizeRollBackups = backup;
                    }
                    else
                    {
                        // Backups limited to a finite number
                        if (m_countDirection >= 0)
                        {
                            // Go with the highest file when counting up
                            m_curSizeRollBackups = backup;
                        }
                        else
                        {
                            // Clip to the limit when counting down
                            if (backup <= m_maxSizeRollBackups)
                            {
                                m_curSizeRollBackups = backup;
                            }
                        }
                    }
                    LogLog.Debug(declaringType, "File name [" + curFileName + "] moves current count to [" + m_curSizeRollBackups + "]");
                }
			} 
			catch(FormatException) 
			{
				//this happens when file.log -> file.log.yyyy-MM-dd which is normal
				//when staticLogFileName == false
				LogLog.Debug(declaringType, "Encountered a backup file not ending in .x ["+curFileName+"]");
			}
		}

        /// <summary>
        /// Attempts to extract a number from the end of the file name that indicates
        /// the number of the times the file has been rolled over.
        /// </summary>
        /// <remarks>
        /// Certain date pattern extensions like yyyyMMdd will be parsed as valid backup indexes.
        /// </remarks>
        /// <param name="curFileName"></param>
        /// <returns></returns>
	    private int GetBackUpIndex(string curFileName)
	    {
            int backUpIndex = -1;
            string fileName = curFileName;

            if (m_preserveLogFileNameExtension)
            {
                fileName = Path.GetFileNameWithoutExtension(fileName);
            }
            
            int index = fileName.LastIndexOf(".");
            if (index > 0)
            {
                // if the "yyyy-MM-dd" component of file.log.yyyy-MM-dd is passed to TryParse
                // it will gracefully fail and return backUpIndex will be 0
                SystemInfo.TryParse(fileName.Substring(index + 1), out backUpIndex);
            }

            return backUpIndex;
	    }

	    /// <summary>
		/// Takes a list of files and a base file name, and looks for 
		/// 'incremented' versions of the base file.  Bumps the max
		/// count up to the highest count seen.
		/// </summary>
		/// <param name="baseFile"></param>
		/// <param name="arrayFiles"></param>
		private void InitializeRollBackups(string baseFile, ArrayList arrayFiles)
		{
			if (null != arrayFiles)
			{
				string baseFileLower = baseFile.ToLower(System.Globalization.CultureInfo.InvariantCulture);

				foreach(string curFileName in arrayFiles)
				{
					InitializeFromOneFile(baseFileLower, curFileName.ToLower(System.Globalization.CultureInfo.InvariantCulture));
				}
			}
		}

		/// <summary>
		/// Calculates the RollPoint for the datePattern supplied.
		/// </summary>
		/// <param name="datePattern">the date pattern to calculate the check period for</param>
		/// <returns>The RollPoint that is most accurate for the date pattern supplied</returns>
		/// <remarks>
		/// Essentially the date pattern is examined to determine what the
		/// most suitable roll point is. The roll point chosen is the roll point
		/// with the smallest period that can be detected using the date pattern
		/// supplied. i.e. if the date pattern only outputs the year, month, day 
		/// and hour then the smallest roll point that can be detected would be
		/// and hourly roll point as minutes could not be detected.
		/// </remarks>
		private RollPoint ComputeCheckPeriod(string datePattern) 
		{
			// s_date1970 is 1970-01-01 00:00:00 this is UniversalSortableDateTimePattern 
			// (based on ISO 8601) using universal time. This date is used for reference
			// purposes to calculate the resolution of the date pattern.

			// Get string representation of base line date
			string r0 = s_date1970.ToString(datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo);

			// Check each type of rolling mode starting with the smallest increment.
			for(int i = (int)RollPoint.TopOfMinute; i <= (int)RollPoint.TopOfMonth; i++) 
			{
				// Get string representation of next pattern
				string r1 = NextCheckDate(s_date1970, (RollPoint)i).ToString(datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo);

				LogLog.Debug(declaringType, "Type = ["+i+"], r0 = ["+r0+"], r1 = ["+r1+"]");

				// Check if the string representations are different
				if (r0 != null && r1 != null && !r0.Equals(r1)) 
				{
					// Found highest precision roll point
					return (RollPoint)i;
				}
			}

			return RollPoint.InvalidRollPoint; // Deliberately head for trouble...
		}

		/// <summary>
		/// Initialize the appender based on the options set
		/// </summary>
		/// <remarks>
		/// <para>
		/// This is part of the <see cref="IOptionHandler"/> delayed object
		/// activation scheme. The <see cref="ActivateOptions"/> method must 
		/// be called on this object after the configuration properties have
		/// been set. Until <see cref="ActivateOptions"/> is called this
		/// object is in an undefined state and must not be used. 
		/// </para>
		/// <para>
		/// If any of the configuration properties are modified then 
		/// <see cref="ActivateOptions"/> must be called again.
		/// </para>
		/// <para>
		/// Sets initial conditions including date/time roll over information, first check,
		/// scheduledFilename, and calls <see cref="ExistingInit"/> to initialize
		/// the current number of backups.
		/// </para>
		/// </remarks>
		override public void ActivateOptions() 
		{
			if (m_dateTime == null)
			{
				m_dateTime = new LocalDateTime();
			}

			if (m_rollDate && m_datePattern != null) 
			{
				m_now = m_dateTime.Now;
				m_rollPoint = ComputeCheckPeriod(m_datePattern);

				if (m_rollPoint == RollPoint.InvalidRollPoint)
				{
					throw new ArgumentException("Invalid RollPoint, unable to parse ["+m_datePattern+"]");
				}

				// next line added as this removes the name check in rollOver
				m_nextCheck = NextCheckDate(m_now, m_rollPoint);
			} 
			else 
			{
				if (m_rollDate)
				{
					ErrorHandler.Error("Either DatePattern or rollingStyle options are not set for ["+Name+"].");
				}
			}

			if (SecurityContext == null)
			{
				SecurityContext = SecurityContextProvider.DefaultProvider.CreateSecurityContext(this);
			}

			using(SecurityContext.Impersonate(this))
			{
				// Must convert the FileAppender's m_filePath to an absolute path before we
				// call ExistingInit(). This will be done by the base.ActivateOptions() but
				// we need to duplicate that functionality here first.
				base.File = ConvertToFullPath(base.File.Trim());

				// Store fully qualified base file name
				m_baseFileName = base.File;
			}

#if !NETCF
			// initialize the mutex that is used to lock rolling
			m_mutexForRolling = new Mutex(false, m_baseFileName.Replace("\\", "_").Replace(":", "_").Replace("/", "_"));
#endif

			if (m_rollDate && File != null && m_scheduledFilename == null)
			{
                m_scheduledFilename = CombinePath(File, m_now.ToString(m_datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo));
			}

			ExistingInit();
	
			base.ActivateOptions();
		}

		#endregion
  
		#region Roll File

        /// <summary>
        /// 
        /// </summary>
        /// <param name="path1"></param>
        /// <param name="path2">.1, .2, .3, etc.</param>
        /// <returns></returns>
        private string CombinePath(string path1, string path2)
        {
            string extension = Path.GetExtension(path1);
            if (m_preserveLogFileNameExtension && extension.Length > 0)
            {
                return Path.Combine(Path.GetDirectoryName(path1), Path.GetFileNameWithoutExtension(path1) + path2 + extension);
            }
            else
            {
                return path1 + path2;
            }
        }

		/// <summary>
		/// Rollover the file(s) to date/time tagged file(s).
		/// </summary>
		/// <param name="fileIsOpen">set to true if the file to be rolled is currently open</param>
		/// <remarks>
		/// <para>
		/// Rollover the file(s) to date/time tagged file(s).
		/// Resets curSizeRollBackups. 
		/// If fileIsOpen is set then the new file is opened (through SafeOpenFile).
		/// </para>
		/// </remarks>
		protected void RollOverTime(bool fileIsOpen) 
		{
			if (m_staticLogFileName) 
			{
				// Compute filename, but only if datePattern is specified
				if (m_datePattern == null) 
				{
					ErrorHandler.Error("Missing DatePattern option in rollOver().");
					return;
				}
	  
				//is the new file name equivalent to the 'current' one
				//something has gone wrong if we hit this -- we should only
				//roll over if the new file will be different from the old
				string dateFormat = m_now.ToString(m_datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo);
                if (m_scheduledFilename.Equals(CombinePath(File, dateFormat))) 
				{
                    ErrorHandler.Error("Compare " + m_scheduledFilename + " : " + CombinePath(File, dateFormat));
					return;
				}
	  
				if (fileIsOpen)
				{
					// close current file, and rename it to datedFilename
					this.CloseFile();
				}
	  
				//we may have to roll over a large number of backups here
				for (int i = 1; i <= m_curSizeRollBackups; i++) 
				{
                    string from = CombinePath(File, "." + i);
                    string to = CombinePath(m_scheduledFilename, "." + i);
					RollFile(from, to);
				}
	  
				RollFile(File, m_scheduledFilename);
			}
	
			//We've cleared out the old date and are ready for the new
			m_curSizeRollBackups = 0; 
	
			//new scheduled name
            m_scheduledFilename = CombinePath(File, m_now.ToString(m_datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo));

			if (fileIsOpen)
			{
				// This will also close the file. This is OK since multiple close operations are safe.
				SafeOpenFile(m_baseFileName, false);
			}
		}
  
		/// <summary>
		/// Renames file <paramref name="fromFile"/> to file <paramref name="toFile"/>.
		/// </summary>
		/// <param name="fromFile">Name of existing file to roll.</param>
		/// <param name="toFile">New name for file.</param>
		/// <remarks>
		/// <para>
		/// Renames file <paramref name="fromFile"/> to file <paramref name="toFile"/>. It
		/// also checks for existence of target file and deletes if it does.
		/// </para>
		/// </remarks>
		protected void RollFile(string fromFile, string toFile) 
		{
			if (FileExists(fromFile))
			{
				// Delete the toFile if it exists
				DeleteFile(toFile);

				// We may not have permission to move the file, or the file may be locked
				try
				{
					LogLog.Debug(declaringType, "Moving [" + fromFile + "] -> [" + toFile + "]");
					using(SecurityContext.Impersonate(this))
					{
						System.IO.File.Move(fromFile, toFile);
					}
				}
				catch(Exception moveEx)
				{
					ErrorHandler.Error("Exception while rolling file [" + fromFile + "] -> [" + toFile + "]", moveEx, ErrorCode.GenericFailure);
				}
			}
			else
			{
				LogLog.Warn(declaringType, "Cannot RollFile [" + fromFile + "] -> [" + toFile + "]. Source does not exist");
			}
		}

		/// <summary>
		/// Test if a file exists at a specified path
		/// </summary>
		/// <param name="path">the path to the file</param>
		/// <returns>true if the file exists</returns>
		/// <remarks>
		/// <para>
		/// Test if a file exists at a specified path
		/// </para>
		/// </remarks>
		protected bool FileExists(string path)
		{
			using(SecurityContext.Impersonate(this))
			{
				return System.IO.File.Exists(path);
			}
		}
  
		/// <summary>
		/// Deletes the specified file if it exists.
		/// </summary>
		/// <param name="fileName">The file to delete.</param>
		/// <remarks>
		/// <para>
		/// Delete a file if is exists.
		/// The file is first moved to a new filename then deleted.
		/// This allows the file to be removed even when it cannot
		/// be deleted, but it still can be moved.
		/// </para>
		/// </remarks>
		protected void DeleteFile(string fileName) 
		{
			if (FileExists(fileName)) 
			{
				// We may not have permission to delete the file, or the file may be locked

				string fileToDelete = fileName;

				// Try to move the file to temp name.
				// If the file is locked we may still be able to move it
				string tempFileName = fileName + "." + Environment.TickCount + ".DeletePending";
				try
				{
					using(SecurityContext.Impersonate(this))
					{
						System.IO.File.Move(fileName, tempFileName);
					}
					fileToDelete = tempFileName;
				}
				catch(Exception moveEx)
				{
					LogLog.Debug(declaringType, "Exception while moving file to be deleted [" + fileName + "] -> [" + tempFileName + "]", moveEx);
				}

				// Try to delete the file (either the original or the moved file)
				try
				{
					using(SecurityContext.Impersonate(this))
					{
						System.IO.File.Delete(fileToDelete);
					}
					LogLog.Debug(declaringType, "Deleted file [" + fileName + "]");
				}
				catch(Exception deleteEx)
				{
					if (fileToDelete == fileName)
					{
						// Unable to move or delete the file
						ErrorHandler.Error("Exception while deleting file [" + fileToDelete + "]", deleteEx, ErrorCode.GenericFailure);
					}
					else
					{
						// Moved the file, but the delete failed. File is probably locked.
						// The file should automatically be deleted when the lock is released.
						LogLog.Debug(declaringType, "Exception while deleting temp file [" + fileToDelete + "]", deleteEx);
					}
				}
			}
		}
  
		/// <summary>
		/// Implements file roll base on file size.
		/// </summary>
		/// <remarks>
		/// <para>
		/// If the maximum number of size based backups is reached
		/// (<c>curSizeRollBackups == maxSizeRollBackups</c>) then the oldest
		/// file is deleted -- its index determined by the sign of countDirection.
		/// If <c>countDirection</c> &lt; 0, then files
		/// {<c>File.1</c>, ..., <c>File.curSizeRollBackups -1</c>}
		/// are renamed to {<c>File.2</c>, ...,
		/// <c>File.curSizeRollBackups</c>}. Moreover, <c>File</c> is
		/// renamed <c>File.1</c> and closed.
		/// </para>
		/// <para>
		/// A new file is created to receive further log output.
		/// </para>
		/// <para>
		/// If <c>maxSizeRollBackups</c> is equal to zero, then the
		/// <c>File</c> is truncated with no backup files created.
		/// </para>
		/// <para>
		/// If <c>maxSizeRollBackups</c> &lt; 0, then <c>File</c> is
		/// renamed if needed and no files are deleted.
		/// </para>
		/// </remarks>
		protected void RollOverSize() 
		{
			this.CloseFile(); // keep windows happy.
	
			LogLog.Debug(declaringType, "rolling over count ["+((CountingQuietTextWriter)QuietWriter).Count+"]");
			LogLog.Debug(declaringType, "maxSizeRollBackups ["+m_maxSizeRollBackups+"]");
			LogLog.Debug(declaringType, "curSizeRollBackups ["+m_curSizeRollBackups+"]");
			LogLog.Debug(declaringType, "countDirection ["+m_countDirection+"]");

			RollOverRenameFiles(File);
	
			if (!m_staticLogFileName && m_countDirection >= 0) 
			{
				m_curSizeRollBackups++;
			}

			// This will also close the file. This is OK since multiple close operations are safe.
			SafeOpenFile(m_baseFileName, false);
		}

		/// <summary>
		/// Implements file roll.
		/// </summary>
		/// <param name="baseFileName">the base name to rename</param>
		/// <remarks>
		/// <para>
		/// If the maximum number of size based backups is reached
		/// (<c>curSizeRollBackups == maxSizeRollBackups</c>) then the oldest
		/// file is deleted -- its index determined by the sign of countDirection.
		/// If <c>countDirection</c> &lt; 0, then files
		/// {<c>File.1</c>, ..., <c>File.curSizeRollBackups -1</c>}
		/// are renamed to {<c>File.2</c>, ...,
		/// <c>File.curSizeRollBackups</c>}. 
		/// </para>
		/// <para>
		/// If <c>maxSizeRollBackups</c> is equal to zero, then the
		/// <c>File</c> is truncated with no backup files created.
		/// </para>
		/// <para>
		/// If <c>maxSizeRollBackups</c> &lt; 0, then <c>File</c> is
		/// renamed if needed and no files are deleted.
		/// </para>
		/// <para>
		/// This is called by <see cref="RollOverSize"/> to rename the files.
		/// </para>
		/// </remarks>
		protected void RollOverRenameFiles(string baseFileName) 
		{
			// If maxBackups <= 0, then there is no file renaming to be done.
			if (m_maxSizeRollBackups != 0) 
			{
				if (m_countDirection < 0) 
				{
					// Delete the oldest file, to keep Windows happy.
					if (m_curSizeRollBackups == m_maxSizeRollBackups) 
					{
                        DeleteFile(CombinePath(baseFileName, "." + m_maxSizeRollBackups));
						m_curSizeRollBackups--;
					}
	
					// Map {(maxBackupIndex - 1), ..., 2, 1} to {maxBackupIndex, ..., 3, 2}
					for (int i = m_curSizeRollBackups; i >= 1; i--) 
					{
                        RollFile((CombinePath(baseFileName, "." + i)), (CombinePath(baseFileName, "." + (i + 1))));
					}
	
					m_curSizeRollBackups++;

					// Rename fileName to fileName.1
                    RollFile(baseFileName, CombinePath(baseFileName, ".1"));
				} 
				else 
				{
					//countDirection >= 0
					if (m_curSizeRollBackups >= m_maxSizeRollBackups && m_maxSizeRollBackups > 0) 
					{
						//delete the first and keep counting up.
						int oldestFileIndex = m_curSizeRollBackups - m_maxSizeRollBackups;

						// If static then there is 1 file without a number, therefore 1 less archive
						if (m_staticLogFileName)
						{
							oldestFileIndex++;
						}

						// If using a static log file then the base for the numbered sequence is the baseFileName passed in
						// If not using a static log file then the baseFileName will already have a numbered postfix which
						// we must remove, however it may have a date postfix which we must keep!
						string archiveFileBaseName = baseFileName;
						if (!m_staticLogFileName)
						{
							int lastDotIndex = archiveFileBaseName.LastIndexOf(".");
							if (lastDotIndex >= 0) 
							{
								archiveFileBaseName = archiveFileBaseName.Substring(0, lastDotIndex);
							}
						}

						// Delete the archive file
                        DeleteFile(CombinePath(archiveFileBaseName, "." + oldestFileIndex));
					}
	
					if (m_staticLogFileName) 
					{
						m_curSizeRollBackups++;
                        RollFile(baseFileName, CombinePath(baseFileName, "." + m_curSizeRollBackups));
					}
				}
			}
		}

		#endregion

		#region NextCheckDate

		/// <summary>
		/// Get the start time of the next window for the current rollpoint
		/// </summary>
		/// <param name="currentDateTime">the current date</param>
		/// <param name="rollPoint">the type of roll point we are working with</param>
		/// <returns>the start time for the next roll point an interval after the currentDateTime date</returns>
		/// <remarks>
		/// <para>
		/// Returns the date of the next roll point after the currentDateTime date passed to the method.
		/// </para>
		/// <para>
		/// The basic strategy is to subtract the time parts that are less significant
		/// than the rollpoint from the current time. This should roll the time back to
		/// the start of the time window for the current rollpoint. Then we add 1 window
		/// worth of time and get the start time of the next window for the rollpoint.
		/// </para>
		/// </remarks>
		protected DateTime NextCheckDate(DateTime currentDateTime, RollPoint rollPoint) 
		{
			// Local variable to work on (this does not look very efficient)
			DateTime current = currentDateTime;

			// Do slightly different things depending on what the type of roll point we want.
			switch(rollPoint) 
			{
				case RollPoint.TopOfMinute:
					current = current.AddMilliseconds(-current.Millisecond);
					current = current.AddSeconds(-current.Second);
					current = current.AddMinutes(1);
					break;

				case RollPoint.TopOfHour:
					current = current.AddMilliseconds(-current.Millisecond);
					current = current.AddSeconds(-current.Second);
					current = current.AddMinutes(-current.Minute);
					current = current.AddHours(1);
					break;

				case RollPoint.HalfDay:
					current = current.AddMilliseconds(-current.Millisecond);
					current = current.AddSeconds(-current.Second);
					current = current.AddMinutes(-current.Minute);

					if (current.Hour < 12) 
					{
						current = current.AddHours(12 - current.Hour);
					} 
					else 
					{
						current = current.AddHours(-current.Hour);
						current = current.AddDays(1);
					}
					break;

				case RollPoint.TopOfDay:
					current = current.AddMilliseconds(-current.Millisecond);
					current = current.AddSeconds(-current.Second);
					current = current.AddMinutes(-current.Minute);
					current = current.AddHours(-current.Hour);
					current = current.AddDays(1);
					break;

				case RollPoint.TopOfWeek:
					current = current.AddMilliseconds(-current.Millisecond);
					current = current.AddSeconds(-current.Second);
					current = current.AddMinutes(-current.Minute);
					current = current.AddHours(-current.Hour);
					current = current.AddDays(7 - (int)current.DayOfWeek);
					break;

				case RollPoint.TopOfMonth:
					current = current.AddMilliseconds(-current.Millisecond);
					current = current.AddSeconds(-current.Second);
					current = current.AddMinutes(-current.Minute);
					current = current.AddHours(-current.Hour);
					current = current.AddDays(1 - current.Day); /* first day of month is 1 not 0 */
					current = current.AddMonths(1);
					break;
			}	  
			return current;
		}

		#endregion

		#region Private Instance Fields

		/// <summary>
		/// This object supplies the current date/time.  Allows test code to plug in
		/// a method to control this class when testing date/time based rolling. The default
		/// implementation uses the underlying value of DateTime.Now.
		/// </summary>
		private IDateTime m_dateTime = null;

		/// <summary>
		/// The date pattern. By default, the pattern is set to <c>".yyyy-MM-dd"</c> 
		/// meaning daily rollover.
		/// </summary>
		private string m_datePattern = ".yyyy-MM-dd";
  
		/// <summary>
		/// The actual formatted filename that is currently being written to
		/// or will be the file transferred to on roll over
		/// (based on staticLogFileName).
		/// </summary>
		private string m_scheduledFilename = null;
  
		/// <summary>
		/// The timestamp when we shall next recompute the filename.
		/// </summary>
		private DateTime m_nextCheck = DateTime.MaxValue;
  
		/// <summary>
		/// Holds date of last roll over
		/// </summary>
		private DateTime m_now;
  
		/// <summary>
		/// The type of rolling done
		/// </summary>
		private RollPoint m_rollPoint;
  
		/// <summary>
		/// The default maximum file size is 10MB
		/// </summary>
		private long m_maxFileSize = 10*1024*1024;
  
		/// <summary>
		/// There is zero backup files by default
		/// </summary>
		private int m_maxSizeRollBackups  = 0;

		/// <summary>
		/// How many sized based backups have been made so far
		/// </summary>
		private int m_curSizeRollBackups = 0;
  
		/// <summary>
		/// The rolling file count direction. 
		/// </summary>
		private int m_countDirection = -1;
  
		/// <summary>
		/// The rolling mode used in this appender.
		/// </summary>
		private RollingMode m_rollingStyle = RollingMode.Composite;

		/// <summary>
		/// Cache flag set if we are rolling by date.
		/// </summary>
		private bool m_rollDate = true;

		/// <summary>
		/// Cache flag set if we are rolling by size.
		/// </summary>
		private bool m_rollSize = true;
  
		/// <summary>
		/// Value indicating whether to always log to the same file.
		/// </summary>
		private bool m_staticLogFileName = true;
  
   		/// <summary>
		/// Value indicating whether to preserve the file name extension when rolling.
		/// </summary>
		private bool m_preserveLogFileNameExtension = false;


		/// <summary>
		/// FileName provided in configuration.  Used for rolling properly
		/// </summary>
		private string m_baseFileName;

#if !NETCF
		/// <summary>
		/// A mutex that is used to lock rolling of files.
		/// </summary>
		private Mutex m_mutexForRolling;
#endif

		#endregion Private Instance Fields

		#region Static Members

		/// <summary>
		/// The 1st of January 1970 in UTC
		/// </summary>
		private static readonly DateTime s_date1970 = new DateTime(1970, 1, 1);]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public override void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1118" sc="3" el="1174" ec="4">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="ad5d34f34b60ac3b3c3c35670cebc8b6"><![CDATA[{
			if (m_dateTime == null)
			{
				m_dateTime = new LocalDateTime();
			}

			if (m_rollDate && m_datePattern != null) 
			{
				m_now = m_dateTime.Now;
				m_rollPoint = ComputeCheckPeriod(m_datePattern);

				if (m_rollPoint == RollPoint.InvalidRollPoint)
				{
					throw new ArgumentException("Invalid RollPoint, unable to parse ["+m_datePattern+"]");
				}

				// next line added as this removes the name check in rollOver
				m_nextCheck = NextCheckDate(m_now, m_rollPoint);
			} 
			else 
			{
				if (m_rollDate)
				{
					ErrorHandler.Error("Either DatePattern or rollingStyle options are not set for ["+Name+"].");
				}
			}

			if (SecurityContext == null)
			{
				SecurityContext = SecurityContextProvider.DefaultProvider.CreateSecurityContext(this);
			}

			using(SecurityContext.Impersonate(this))
			{
				// Must convert the FileAppender's m_filePath to an absolute path before we
				// call ExistingInit(). This will be done by the base.ActivateOptions() but
				// we need to duplicate that functionality here first.
				base.File = ConvertToFullPath(base.File.Trim());

				// Store fully qualified base file name
				m_baseFileName = base.File;
			}

#if !NETCF
			// initialize the mutex that is used to lock rolling
			m_mutexForRolling = new Mutex(false, m_baseFileName.Replace("\\", "_").Replace(":", "_").Replace("/", "_"));
#endif

			if (m_rollDate && File != null && m_scheduledFilename == null)
			{
                m_scheduledFilename = CombinePath(File, m_now.ToString(m_datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo));
			}

			ExistingInit();
	
			base.ActivateOptions();
		}]]></body>
          </codeblock>
        </method>
        <method name="AdjustFileBeforeAppend">
          <declaration><![CDATA[protected virtual void AdjustFileBeforeAppend()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="613" sc="3" el="654" ec="4">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="109ab8dcfba5a97c16f40c979891c115"><![CDATA[{
			// reuse the file appenders locking model to lock the rolling
#if !NETCF
			try
			{
				// if rolling should be locked, acquire the lock
				if (m_mutexForRolling != null)
				{
					m_mutexForRolling.WaitOne();
				}
#endif
				if (m_rollDate)
				{
					DateTime n = m_dateTime.Now;
					if (n >= m_nextCheck)
					{
						m_now = n;
						m_nextCheck = NextCheckDate(m_now, m_rollPoint);

						RollOverTime(true);
					}
				}

				if (m_rollSize)
				{
					if ((File != null) && ((CountingQuietTextWriter)QuietWriter).Count >= m_maxFileSize)
					{
						RollOverSize();
					}
				}
#if !NETCF
			}
			finally
			{
				// if rolling should be locked, release the lock
				if (m_mutexForRolling != null)
				{
					m_mutexForRolling.ReleaseMutex();
				}
			}
#endif
		}]]></body>
          </codeblock>
        </method>
        <method name="Append">
          <declaration><![CDATA[protected override void Append(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="580" sc="3" el="583" ec="4">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="5fa7ec2cb8f971c86c71474b4060cd42"><![CDATA[{
			AdjustFileBeforeAppend();
			base.Append(loggingEvent);
		}]]></body>
          </codeblock>
        </method>
        <method name="Append">
          <declaration><![CDATA[protected override void Append(LoggingEvent[] loggingEvents)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="597" sc="3" el="600" ec="4">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="1d95c78abdcb6f3a54eebd1860bac4a0"><![CDATA[{
			AdjustFileBeforeAppend();
			base.Append(loggingEvents);
		}]]></body>
          </codeblock>
        </method>
        <method name="CombinePath">
          <declaration><![CDATA[private string CombinePath(string path1, string path2)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1187" sc="9" el="1197" ec="10">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="21213be1ccbe33090b801e25abdf437d"><![CDATA[{
            string extension = Path.GetExtension(path1);
            if (m_preserveLogFileNameExtension && extension.Length > 0)
            {
                return Path.Combine(Path.GetDirectoryName(path1), Path.GetFileNameWithoutExtension(path1) + path2 + extension);
            }
            else
            {
                return path1 + path2;
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="ComputeCheckPeriod">
          <declaration><![CDATA[private RollingFileAppender.RollPoint ComputeCheckPeriod(string datePattern)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1069" sc="3" el="1094" ec="4">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="31f59d246508b3eed8bcd3e5f7ed6299"><![CDATA[{
			// s_date1970 is 1970-01-01 00:00:00 this is UniversalSortableDateTimePattern 
			// (based on ISO 8601) using universal time. This date is used for reference
			// purposes to calculate the resolution of the date pattern.

			// Get string representation of base line date
			string r0 = s_date1970.ToString(datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo);

			// Check each type of rolling mode starting with the smallest increment.
			for(int i = (int)RollPoint.TopOfMinute; i <= (int)RollPoint.TopOfMonth; i++) 
			{
				// Get string representation of next pattern
				string r1 = NextCheckDate(s_date1970, (RollPoint)i).ToString(datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo);

				LogLog.Debug(declaringType, "Type = ["+i+"], r0 = ["+r0+"], r1 = ["+r1+"]");

				// Check if the string representations are different
				if (r0 != null && r1 != null && !r0.Equals(r1)) 
				{
					// Found highest precision roll point
					return (RollPoint)i;
				}
			}

			return RollPoint.InvalidRollPoint; // Deliberately head for trouble...
		}]]></body>
          </codeblock>
        </method>
        <method name="DeleteFile">
          <declaration><![CDATA[protected void DeleteFile(string fileName)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1330" sc="3" el="1377" ec="4">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="9909016d0b15b65b7c1a5360d819bb07"><![CDATA[{
			if (FileExists(fileName)) 
			{
				// We may not have permission to delete the file, or the file may be locked

				string fileToDelete = fileName;

				// Try to move the file to temp name.
				// If the file is locked we may still be able to move it
				string tempFileName = fileName + "." + Environment.TickCount + ".DeletePending";
				try
				{
					using(SecurityContext.Impersonate(this))
					{
						System.IO.File.Move(fileName, tempFileName);
					}
					fileToDelete = tempFileName;
				}
				catch(Exception moveEx)
				{
					LogLog.Debug(declaringType, "Exception while moving file to be deleted [" + fileName + "] -> [" + tempFileName + "]", moveEx);
				}

				// Try to delete the file (either the original or the moved file)
				try
				{
					using(SecurityContext.Impersonate(this))
					{
						System.IO.File.Delete(fileToDelete);
					}
					LogLog.Debug(declaringType, "Deleted file [" + fileName + "]");
				}
				catch(Exception deleteEx)
				{
					if (fileToDelete == fileName)
					{
						// Unable to move or delete the file
						ErrorHandler.Error("Exception while deleting file [" + fileToDelete + "]", deleteEx, ErrorCode.GenericFailure);
					}
					else
					{
						// Moved the file, but the delete failed. File is probably locked.
						// The file should automatically be deleted when the lock is released.
						LogLog.Debug(declaringType, "Exception while deleting temp file [" + fileToDelete + "]", deleteEx);
					}
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="DetermineCurSizeRollBackups">
          <declaration><![CDATA[private void DetermineCurSizeRollBackups()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="752" sc="3" el="768" ec="4">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="05eb092a2b5bb887622f688b8c7ae6fa"><![CDATA[{
			m_curSizeRollBackups = 0;
	
			string fullPath = null;
			string fileName = null;

			using(SecurityContext.Impersonate(this))
			{
				fullPath = System.IO.Path.GetFullPath(m_baseFileName);
				fileName = System.IO.Path.GetFileName(fullPath);
			}

			ArrayList arrayFiles = GetExistingFiles(fullPath);
			InitializeRollBackups(fileName, arrayFiles);

			LogLog.Debug(declaringType, "curSizeRollBackups starts at ["+m_curSizeRollBackups+"]");
		}]]></body>
          </codeblock>
        </method>
        <method name="ExistingInit">
          <declaration><![CDATA[protected void ExistingInit()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="879" sc="3" el="908" ec="4">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="9e0d7b1ad6cb929829d7e9e520c54081"><![CDATA[{
			DetermineCurSizeRollBackups();
			RollOverIfDateBoundaryCrossing();

			// If file exists and we are not appending then roll it out of the way
			if (AppendToFile == false)
			{
				bool fileExists = false;
				string fileName = GetNextOutputFileName(m_baseFileName);

				using(SecurityContext.Impersonate(this))
				{
					fileExists = System.IO.File.Exists(fileName);
				}

				if (fileExists)
				{
					if (m_maxSizeRollBackups == 0)
					{
						LogLog.Debug(declaringType, "Output file ["+fileName+"] already exists. MaxSizeRollBackups is 0; cannot roll. Overwriting existing file.");
					}
					else
					{
						LogLog.Debug(declaringType, "Output file ["+fileName+"] already exists. Not appending to file. Rolling existing file out of the way.");

						RollOverRenameFiles(fileName);
					}
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="FileExists">
          <declaration><![CDATA[protected bool FileExists(string path)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1310" sc="3" el="1315" ec="4">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="a614372d080d20c83cd0c21d9d1e2834"><![CDATA[{
			using(SecurityContext.Impersonate(this))
			{
				return System.IO.File.Exists(path);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Finalize">
          <declaration><![CDATA[protected override void Finalize()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="243" sc="3" el="255" ec="4">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="59a6a1a280457ee6cc16d97e78d21671"><![CDATA[{
#if !NETCF
			if (m_mutexForRolling != null)
			{
#if NET_4_0 || MONO_4_0 || NETSTANDARD1_3
				m_mutexForRolling.Dispose();
#else
				m_mutexForRolling.Close();
#endif
				m_mutexForRolling = null;
			}
#endif
		}]]></body>
          </codeblock>
        </method>
        <method name="GetBackUpIndex">
          <declaration><![CDATA[private int GetBackUpIndex(string curFileName)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1015" sc="6" el="1033" ec="7">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="b72d1798cb31a4298c46233320a9fcb6"><![CDATA[{
            int backUpIndex = -1;
            string fileName = curFileName;

            if (m_preserveLogFileNameExtension)
            {
                fileName = Path.GetFileNameWithoutExtension(fileName);
            }
            
            int index = fileName.LastIndexOf(".");
            if (index > 0)
            {
                // if the "yyyy-MM-dd" component of file.log.yyyy-MM-dd is passed to TryParse
                // it will gracefully fail and return backUpIndex will be 0
                SystemInfo.TryParse(fileName.Substring(index + 1), out backUpIndex);
            }

            return backUpIndex;
	    }]]></body>
          </codeblock>
        </method>
        <method name="GetExistingFiles">
          <declaration><![CDATA[private ArrayList GetExistingFiles(string baseFilePath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="795" sc="3" el="826" ec="4">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="3f33b888b7e785a3f286b0375383e73e"><![CDATA[{
			ArrayList alFiles = new ArrayList();

			string directory = null;

			using(SecurityContext.Impersonate(this))
			{
				string fullPath = Path.GetFullPath(baseFilePath);

				directory = Path.GetDirectoryName(fullPath);
				if (Directory.Exists(directory))
				{
					string baseFileName = Path.GetFileName(fullPath);

					string[] files = Directory.GetFiles(directory, GetWildcardPatternForFile(baseFileName));
	
					if (files != null)
					{
						for (int i = 0; i < files.Length; i++) 
						{
							string curFileName = Path.GetFileName(files[i]);
							if (curFileName.StartsWith(Path.GetFileNameWithoutExtension(baseFileName)))
							{
								alFiles.Add(curFileName);
							}
						}
					}
				}
			}
			LogLog.Debug(declaringType, "Searched for existing files in ["+directory+"]");
			return alFiles;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetNextOutputFileName">
          <declaration><![CDATA[protected string GetNextOutputFileName(string fileName)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="725" sc="3" el="742" ec="4">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="c875b3f6e39f4b956e59890f1891842e"><![CDATA[{
			if (!m_staticLogFileName) 
			{
				fileName = fileName.Trim();

				if (m_rollDate)
				{
                    fileName = CombinePath(fileName, m_now.ToString(m_datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo));
				}

				if (m_countDirection >= 0) 
				{
                    fileName = CombinePath(fileName, "." + m_curSizeRollBackups);
				}
			}

			return fileName;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetWildcardPatternForFile">
          <declaration><![CDATA[private string GetWildcardPatternForFile(string baseFileName)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="777" sc="3" el="786" ec="4">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="34bcf517e3aff0aa355f37f9e104bc2b"><![CDATA[{
            if (m_preserveLogFileNameExtension)
            {
                return Path.GetFileNameWithoutExtension(baseFileName) + "*" + Path.GetExtension(baseFileName);
            }
            else
            {
                return baseFileName + '*';
            }
		}]]></body>
          </codeblock>
        </method>
        <method name="InitializeFromOneFile">
          <declaration><![CDATA[private void InitializeFromOneFile(string baseFile, string curFileName)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="920" sc="3" el="1003" ec="4">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="d4711d4d2164afd33706f5dae209acda"><![CDATA[{
            if (curFileName.StartsWith(Path.GetFileNameWithoutExtension(baseFile)) == false)
			{
				// This is not a log file, so ignore
				return;
			}
			if (curFileName.Equals(baseFile)) 
			{
				// Base log file is not an incremented logfile (.1 or .2, etc)
				return;
			}
	
            /*
			if (m_staticLogFileName) 
			{
				int endLength = curFileName.Length - index;
				if (baseFile.Length + endLength != curFileName.Length) 
				{
					// file is probably scheduledFilename + .x so I don't care
					return;
				}
			}
            */
	
			// Only look for files in the current roll point
			if (m_rollDate && !m_staticLogFileName)
			{
				string date = m_dateTime.Now.ToString(m_datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo);
				string prefix = m_preserveLogFileNameExtension ? Path.GetFileNameWithoutExtension(baseFile) + date : baseFile + date;
				string suffix = m_preserveLogFileNameExtension ? Path.GetExtension(baseFile) : "";
				if (!curFileName.StartsWith(prefix) || !curFileName.EndsWith(suffix))
				{
					LogLog.Debug(declaringType, "Ignoring file ["+curFileName+"] because it is from a different date period");
					return;
				}
			}
            
			try 
			{
				// Bump the counter up to the highest count seen so far
                int backup = GetBackUpIndex(curFileName);
                
                // caution: we might get a false positive when certain
                // date patterns such as yyyyMMdd are used...those are
                // valid number but aren't the kind of back up index
                // we're looking for
                if (backup > m_curSizeRollBackups)
                {
                    if (0 == m_maxSizeRollBackups)
                    {
                        // Stay at zero when zero backups are desired
                    }
                    else if (-1 == m_maxSizeRollBackups)
                    {
                        // Infinite backups, so go as high as the highest value
                        m_curSizeRollBackups = backup;
                    }
                    else
                    {
                        // Backups limited to a finite number
                        if (m_countDirection >= 0)
                        {
                            // Go with the highest file when counting up
                            m_curSizeRollBackups = backup;
                        }
                        else
                        {
                            // Clip to the limit when counting down
                            if (backup <= m_maxSizeRollBackups)
                            {
                                m_curSizeRollBackups = backup;
                            }
                        }
                    }
                    LogLog.Debug(declaringType, "File name [" + curFileName + "] moves current count to [" + m_curSizeRollBackups + "]");
                }
			} 
			catch(FormatException) 
			{
				//this happens when file.log -> file.log.yyyy-MM-dd which is normal
				//when staticLogFileName == false
				LogLog.Debug(declaringType, "Encountered a backup file not ending in .x ["+curFileName+"]");
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="InitializeRollBackups">
          <declaration><![CDATA[private void InitializeRollBackups(string baseFile, ArrayList arrayFiles)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1043" sc="3" el="1053" ec="4">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="59d2404af99eafafff724ef87a66eed9"><![CDATA[{
			if (null != arrayFiles)
			{
				string baseFileLower = baseFile.ToLower(System.Globalization.CultureInfo.InvariantCulture);

				foreach(string curFileName in arrayFiles)
				{
					InitializeFromOneFile(baseFileLower, curFileName.ToLower(System.Globalization.CultureInfo.InvariantCulture));
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="NextCheckDate">
          <declaration><![CDATA[protected DateTime NextCheckDate(DateTime currentDateTime, RollingFileAppender.RollPoint rollPoint)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1538" sc="3" el="1600" ec="4">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="993c4c6220543480d1d6f2779ad09333"><![CDATA[{
			// Local variable to work on (this does not look very efficient)
			DateTime current = currentDateTime;

			// Do slightly different things depending on what the type of roll point we want.
			switch(rollPoint) 
			{
				case RollPoint.TopOfMinute:
					current = current.AddMilliseconds(-current.Millisecond);
					current = current.AddSeconds(-current.Second);
					current = current.AddMinutes(1);
					break;

				case RollPoint.TopOfHour:
					current = current.AddMilliseconds(-current.Millisecond);
					current = current.AddSeconds(-current.Second);
					current = current.AddMinutes(-current.Minute);
					current = current.AddHours(1);
					break;

				case RollPoint.HalfDay:
					current = current.AddMilliseconds(-current.Millisecond);
					current = current.AddSeconds(-current.Second);
					current = current.AddMinutes(-current.Minute);

					if (current.Hour < 12) 
					{
						current = current.AddHours(12 - current.Hour);
					} 
					else 
					{
						current = current.AddHours(-current.Hour);
						current = current.AddDays(1);
					}
					break;

				case RollPoint.TopOfDay:
					current = current.AddMilliseconds(-current.Millisecond);
					current = current.AddSeconds(-current.Second);
					current = current.AddMinutes(-current.Minute);
					current = current.AddHours(-current.Hour);
					current = current.AddDays(1);
					break;

				case RollPoint.TopOfWeek:
					current = current.AddMilliseconds(-current.Millisecond);
					current = current.AddSeconds(-current.Second);
					current = current.AddMinutes(-current.Minute);
					current = current.AddHours(-current.Hour);
					current = current.AddDays(7 - (int)current.DayOfWeek);
					break;

				case RollPoint.TopOfMonth:
					current = current.AddMilliseconds(-current.Millisecond);
					current = current.AddSeconds(-current.Second);
					current = current.AddMinutes(-current.Minute);
					current = current.AddHours(-current.Hour);
					current = current.AddDays(1 - current.Day); /* first day of month is 1 not 0 */
					current = current.AddMonths(1);
					break;
			}	  
			return current;
		}]]></body>
          </codeblock>
        </method>
        <method name="OpenFile">
          <declaration><![CDATA[protected override void OpenFile(string fileName, bool append)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="667" sc="3" el="710" ec="4">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="c1686a4cfa607a75b18990d05e9ac2ce"><![CDATA[{
			lock(this)
			{
				fileName = GetNextOutputFileName(fileName);

				// Calculate the current size of the file
				long currentCount = 0;
				if (append) 
				{
					using(SecurityContext.Impersonate(this))
					{
						if (System.IO.File.Exists(fileName))
						{
							currentCount = (new FileInfo(fileName)).Length;
						}
					}
				}
				else
				{
					if (LogLog.IsErrorEnabled)
					{
						// Internal check that the file is not being overwritten
						// If not Appending to an existing file we should have rolled the file out of the
						// way. Therefore we should not be over-writing an existing file.
						// The only exception is if we are not allowed to roll the existing file away.
						if (m_maxSizeRollBackups != 0 && FileExists(fileName))
						{
							LogLog.Error(declaringType, "RollingFileAppender: INTERNAL ERROR. Append is False but OutputFile ["+fileName+"] already exists.");
						}
					}
				}

				if (!m_staticLogFileName) 
				{
					m_scheduledFilename = fileName;
				}

				// Open the file (call the base class to do it)
				base.OpenFile(fileName, append);

				// Set the file size onto the counting writer
				((CountingQuietTextWriter)QuietWriter).Count = currentCount;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="RollFile">
          <declaration><![CDATA[protected void RollFile(string fromFile, string toFile)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1273" sc="3" el="1297" ec="4">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="304dc918697f91cad6a82dc4af2e18cd"><![CDATA[{
			if (FileExists(fromFile))
			{
				// Delete the toFile if it exists
				DeleteFile(toFile);

				// We may not have permission to move the file, or the file may be locked
				try
				{
					LogLog.Debug(declaringType, "Moving [" + fromFile + "] -> [" + toFile + "]");
					using(SecurityContext.Impersonate(this))
					{
						System.IO.File.Move(fromFile, toFile);
					}
				}
				catch(Exception moveEx)
				{
					ErrorHandler.Error("Exception while rolling file [" + fromFile + "] -> [" + toFile + "]", moveEx, ErrorCode.GenericFailure);
				}
			}
			else
			{
				LogLog.Warn(declaringType, "Cannot RollFile [" + fromFile + "] -> [" + toFile + "]. Source does not exist");
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="RollOverIfDateBoundaryCrossing">
          <declaration><![CDATA[private void RollOverIfDateBoundaryCrossing()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="832" sc="3" el="863" ec="4">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="09b6dc4d25bc0bc4d8e8c1089bb370cf"><![CDATA[{
			if (m_staticLogFileName && m_rollDate) 
			{
				if (FileExists(m_baseFileName)) 
				{
					DateTime last;
					using(SecurityContext.Impersonate(this)) {
#if !NET_1_0 && !CLI_1_0 && !NETCF
                        if (DateTimeStrategy is UniversalDateTime)
						{
							last = System.IO.File.GetLastWriteTimeUtc(m_baseFileName);
						}
						else
						{
#endif
							last = System.IO.File.GetLastWriteTime(m_baseFileName);
#if !NET_1_0 && !CLI_1_0 && !NETCF
                        }
#endif
                    }
					LogLog.Debug(declaringType, "["+last.ToString(m_datePattern,System.Globalization.DateTimeFormatInfo.InvariantInfo)+"] vs. ["+m_now.ToString(m_datePattern,System.Globalization.DateTimeFormatInfo.InvariantInfo)+"]");

					if (!(last.ToString(m_datePattern,System.Globalization.DateTimeFormatInfo.InvariantInfo).Equals(m_now.ToString(m_datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo)))) 
					{
						m_scheduledFilename = CombinePath(m_baseFileName, last.ToString(m_datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo));
						LogLog.Debug(declaringType, "Initial roll over to ["+m_scheduledFilename+"]");
						RollOverTime(false);
						LogLog.Debug(declaringType, "curSizeRollBackups after rollOver at ["+m_curSizeRollBackups+"]");
					}
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="RollOverRenameFiles">
          <declaration><![CDATA[protected void RollOverRenameFiles(string baseFileName)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1452" sc="3" el="1514" ec="4">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="7efdb7292404a9bacc31496c7d0f6723"><![CDATA[{
			// If maxBackups <= 0, then there is no file renaming to be done.
			if (m_maxSizeRollBackups != 0) 
			{
				if (m_countDirection < 0) 
				{
					// Delete the oldest file, to keep Windows happy.
					if (m_curSizeRollBackups == m_maxSizeRollBackups) 
					{
                        DeleteFile(CombinePath(baseFileName, "." + m_maxSizeRollBackups));
						m_curSizeRollBackups--;
					}
	
					// Map {(maxBackupIndex - 1), ..., 2, 1} to {maxBackupIndex, ..., 3, 2}
					for (int i = m_curSizeRollBackups; i >= 1; i--) 
					{
                        RollFile((CombinePath(baseFileName, "." + i)), (CombinePath(baseFileName, "." + (i + 1))));
					}
	
					m_curSizeRollBackups++;

					// Rename fileName to fileName.1
                    RollFile(baseFileName, CombinePath(baseFileName, ".1"));
				} 
				else 
				{
					//countDirection >= 0
					if (m_curSizeRollBackups >= m_maxSizeRollBackups && m_maxSizeRollBackups > 0) 
					{
						//delete the first and keep counting up.
						int oldestFileIndex = m_curSizeRollBackups - m_maxSizeRollBackups;

						// If static then there is 1 file without a number, therefore 1 less archive
						if (m_staticLogFileName)
						{
							oldestFileIndex++;
						}

						// If using a static log file then the base for the numbered sequence is the baseFileName passed in
						// If not using a static log file then the baseFileName will already have a numbered postfix which
						// we must remove, however it may have a date postfix which we must keep!
						string archiveFileBaseName = baseFileName;
						if (!m_staticLogFileName)
						{
							int lastDotIndex = archiveFileBaseName.LastIndexOf(".");
							if (lastDotIndex >= 0) 
							{
								archiveFileBaseName = archiveFileBaseName.Substring(0, lastDotIndex);
							}
						}

						// Delete the archive file
                        DeleteFile(CombinePath(archiveFileBaseName, "." + oldestFileIndex));
					}
	
					if (m_staticLogFileName) 
					{
						m_curSizeRollBackups++;
                        RollFile(baseFileName, CombinePath(baseFileName, "." + m_curSizeRollBackups));
					}
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="RollOverSize">
          <declaration><![CDATA[protected void RollOverSize()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1406" sc="3" el="1423" ec="4">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="755783a6001ff7f33cebb253c9d6bd62"><![CDATA[{
			this.CloseFile(); // keep windows happy.
	
			LogLog.Debug(declaringType, "rolling over count ["+((CountingQuietTextWriter)QuietWriter).Count+"]");
			LogLog.Debug(declaringType, "maxSizeRollBackups ["+m_maxSizeRollBackups+"]");
			LogLog.Debug(declaringType, "curSizeRollBackups ["+m_curSizeRollBackups+"]");
			LogLog.Debug(declaringType, "countDirection ["+m_countDirection+"]");

			RollOverRenameFiles(File);
	
			if (!m_staticLogFileName && m_countDirection >= 0) 
			{
				m_curSizeRollBackups++;
			}

			// This will also close the file. This is OK since multiple close operations are safe.
			SafeOpenFile(m_baseFileName, false);
		}]]></body>
          </codeblock>
        </method>
        <method name="RollOverTime">
          <declaration><![CDATA[protected void RollOverTime(bool fileIsOpen)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1211" sc="3" el="1259" ec="4">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="a406348be6cb621e1ff860a9021ba901"><![CDATA[{
			if (m_staticLogFileName) 
			{
				// Compute filename, but only if datePattern is specified
				if (m_datePattern == null) 
				{
					ErrorHandler.Error("Missing DatePattern option in rollOver().");
					return;
				}
	  
				//is the new file name equivalent to the 'current' one
				//something has gone wrong if we hit this -- we should only
				//roll over if the new file will be different from the old
				string dateFormat = m_now.ToString(m_datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo);
                if (m_scheduledFilename.Equals(CombinePath(File, dateFormat))) 
				{
                    ErrorHandler.Error("Compare " + m_scheduledFilename + " : " + CombinePath(File, dateFormat));
					return;
				}
	  
				if (fileIsOpen)
				{
					// close current file, and rename it to datedFilename
					this.CloseFile();
				}
	  
				//we may have to roll over a large number of backups here
				for (int i = 1; i <= m_curSizeRollBackups; i++) 
				{
                    string from = CombinePath(File, "." + i);
                    string to = CombinePath(m_scheduledFilename, "." + i);
					RollFile(from, to);
				}
	  
				RollFile(File, m_scheduledFilename);
			}
	
			//We've cleared out the old date and are ready for the new
			m_curSizeRollBackups = 0; 
	
			//new scheduled name
            m_scheduledFilename = CombinePath(File, m_now.ToString(m_datePattern, System.Globalization.DateTimeFormatInfo.InvariantInfo));

			if (fileIsOpen)
			{
				// This will also close the file. This is OK since multiple close operations are safe.
				SafeOpenFile(m_baseFileName, false);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="SetQWForFiles">
          <declaration><![CDATA[protected override void SetQWForFiles(TextWriter writer)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="564" sc="3" el="566" ec="4">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="3a45579501dfb5818e6075e7b994bc25"><![CDATA[{
			QuietWriter = new CountingQuietTextWriter(writer, ErrorHandler);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(RollingFileAppender);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_baseFileName">
          <declaration><![CDATA[private string m_baseFileName;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_countDirection">
          <declaration><![CDATA[private int m_countDirection = -1;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_curSizeRollBackups">
          <declaration><![CDATA[private int m_curSizeRollBackups = 0;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_datePattern">
          <declaration><![CDATA[private string m_datePattern = ".yyyy-MM-dd";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_dateTime">
          <declaration><![CDATA[private RollingFileAppender.IDateTime m_dateTime = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_maxFileSize">
          <declaration><![CDATA[private long m_maxFileSize = 10485760L;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_maxSizeRollBackups">
          <declaration><![CDATA[private int m_maxSizeRollBackups = 0;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_mutexForRolling">
          <declaration><![CDATA[private Mutex m_mutexForRolling;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_nextCheck">
          <declaration><![CDATA[private DateTime m_nextCheck = DateTime.MaxValue;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_now">
          <declaration><![CDATA[private DateTime m_now;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_preserveLogFileNameExtension">
          <declaration><![CDATA[private bool m_preserveLogFileNameExtension = false;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_rollDate">
          <declaration><![CDATA[private bool m_rollDate = true;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_rollingStyle">
          <declaration><![CDATA[private RollingFileAppender.RollingMode m_rollingStyle = RollingFileAppender.RollingMode.Composite;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_rollPoint">
          <declaration><![CDATA[private RollingFileAppender.RollPoint m_rollPoint;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_rollSize">
          <declaration><![CDATA[private bool m_rollSize = true;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_scheduledFilename">
          <declaration><![CDATA[private string m_scheduledFilename = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_staticLogFileName">
          <declaration><![CDATA[private bool m_staticLogFileName = true;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="s_date1970">
          <declaration><![CDATA[private static readonly DateTime s_date1970 = new DateTime(1970, 1, 1);]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="CountDirection">
          <declaration><![CDATA[public int CountDirection]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="DatePattern">
          <declaration><![CDATA[public string DatePattern]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="DateTimeStrategy">
          <declaration><![CDATA[public RollingFileAppender.IDateTime DateTimeStrategy]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="MaxFileSize">
          <declaration><![CDATA[public long MaxFileSize]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="MaximumFileSize">
          <declaration><![CDATA[public string MaximumFileSize]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="MaxSizeRollBackups">
          <declaration><![CDATA[public int MaxSizeRollBackups]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="PreserveLogFileNameExtension">
          <declaration><![CDATA[public bool PreserveLogFileNameExtension]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="RollingStyle">
          <declaration><![CDATA[public RollingFileAppender.RollingMode RollingStyle]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="465" sc="4" el="491" ec="5">log4net\Appender\RollingFileAppender.cs</location>
            <body hash="991a2cbd0cdc498f6a02d53bb2a357cc"><![CDATA[{
				m_rollingStyle = value;
				switch (m_rollingStyle) 
				{
					case RollingMode.Once:
						m_rollDate = false;
						m_rollSize = false;

						this.AppendToFile = false;
						break;

					case RollingMode.Size:
						m_rollDate = false;
						m_rollSize = true;
						break;

					case RollingMode.Date:
						m_rollDate = true;
						m_rollSize = false;
						break;

					case RollingMode.Composite:
						m_rollDate = true;
						m_rollSize = true;
						break;	  
				}
			}]]></body>
          </codeblock>
        </property>
        <property name="StaticLogFileName">
          <declaration><![CDATA[public bool StaticLogFileName]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="SmtpAppender">
      <declaration><![CDATA[public class SmtpAppender : BufferingAppenderSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private Encoding m_subjectEncoding = Encoding.UTF8;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="84" sc="3" el="608" ec="42">log4net\Appender\SmtpAppender.cs</location>
            <body hash="f13453e9e340f85deb95690a5833b491"><![CDATA[public SmtpAppender()
		{	
		}

		#endregion // Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Gets or sets a comma- or semicolon-delimited list of recipient e-mail addresses (use semicolon on .NET 1.1 and comma for later versions).
		/// </summary>
		/// <value>
        /// <para>
        /// For .NET 1.1 (System.Web.Mail): A semicolon-delimited list of e-mail addresses.
        /// </para>
        /// <para>
        /// For .NET 2.0 (System.Net.Mail): A comma-delimited list of e-mail addresses.
        /// </para>
		/// </value>
		/// <remarks>
        /// <para>
        /// For .NET 1.1 (System.Web.Mail): A semicolon-delimited list of e-mail addresses.
        /// </para>
        /// <para>
        /// For .NET 2.0 (System.Net.Mail): A comma-delimited list of e-mail addresses.
        /// </para>
		/// </remarks>
		public string To
		{
			get { return m_to; }
			set { m_to = MaybeTrimSeparators(value); }
		}

        /// <summary>
        /// Gets or sets a comma- or semicolon-delimited list of recipient e-mail addresses 
        /// that will be carbon copied (use semicolon on .NET 1.1 and comma for later versions).
        /// </summary>
        /// <value>
        /// <para>
        /// For .NET 1.1 (System.Web.Mail): A semicolon-delimited list of e-mail addresses.
        /// </para>
        /// <para>
        /// For .NET 2.0 (System.Net.Mail): A comma-delimited list of e-mail addresses.
        /// </para>
        /// </value>
        /// <remarks>
        /// <para>
        /// For .NET 1.1 (System.Web.Mail): A semicolon-delimited list of e-mail addresses.
        /// </para>
        /// <para>
        /// For .NET 2.0 (System.Net.Mail): A comma-delimited list of e-mail addresses.
        /// </para>
        /// </remarks>
        public string Cc
        {
            get { return m_cc; }
            set { m_cc = MaybeTrimSeparators(value); }
        }

        /// <summary>
        /// Gets or sets a semicolon-delimited list of recipient e-mail addresses
        /// that will be blind carbon copied.
        /// </summary>
        /// <value>
        /// A semicolon-delimited list of e-mail addresses.
        /// </value>
        /// <remarks>
        /// <para>
        /// A semicolon-delimited list of recipient e-mail addresses.
        /// </para>
        /// </remarks>
        public string Bcc
        {
            get { return m_bcc; }
            set { m_bcc = MaybeTrimSeparators(value); }
        }

		/// <summary>
		/// Gets or sets the e-mail address of the sender.
		/// </summary>
		/// <value>
		/// The e-mail address of the sender.
		/// </value>
		/// <remarks>
		/// <para>
		/// The e-mail address of the sender.
		/// </para>
		/// </remarks>
		public string From 
		{
			get { return m_from; }
			set { m_from = value; }
		}

		/// <summary>
		/// Gets or sets the subject line of the e-mail message.
		/// </summary>
		/// <value>
		/// The subject line of the e-mail message.
		/// </value>
		/// <remarks>
		/// <para>
		/// The subject line of the e-mail message.
		/// </para>
		/// </remarks>
		public string Subject 
		{
			get { return m_subject; }
			set { m_subject = value; }
		}
  
		/// <summary>
		/// Gets or sets the name of the SMTP relay mail server to use to send 
		/// the e-mail messages.
		/// </summary>
		/// <value>
		/// The name of the e-mail relay server. If SmtpServer is not set, the 
		/// name of the local SMTP server is used.
		/// </value>
		/// <remarks>
		/// <para>
		/// The name of the e-mail relay server. If SmtpServer is not set, the 
		/// name of the local SMTP server is used.
		/// </para>
		/// </remarks>
		public string SmtpHost
		{
			get { return m_smtpHost; }
			set { m_smtpHost = value; }
		}

		/// <summary>
		/// Obsolete
		/// </summary>
		/// <remarks>
		/// Use the BufferingAppenderSkeleton Fix methods instead 
		/// </remarks>
		/// <remarks>
		/// <para>
		/// Obsolete property.
		/// </para>
		/// </remarks>
		[Obsolete("Use the BufferingAppenderSkeleton Fix methods")]
		public bool LocationInfo
		{
			get { return false; }
			set { ; }
		}

		/// <summary>
		/// The mode to use to authentication with the SMTP server
		/// </summary>
		/// <remarks>
		/// <note type="caution">Authentication is only available on the MS .NET 1.1 runtime.</note>
		/// <para>
		/// Valid Authentication mode values are: <see cref="SmtpAuthentication.None"/>, 
		/// <see cref="SmtpAuthentication.Basic"/>, and <see cref="SmtpAuthentication.Ntlm"/>. 
		/// The default value is <see cref="SmtpAuthentication.None"/>. When using 
		/// <see cref="SmtpAuthentication.Basic"/> you must specify the <see cref="Username"/> 
		/// and <see cref="Password"/> to use to authenticate.
		/// When using <see cref="SmtpAuthentication.Ntlm"/> the Windows credentials for the current
		/// thread, if impersonating, or the process will be used to authenticate. 
		/// </para>
		/// </remarks>
		public SmtpAuthentication Authentication
		{
			get { return m_authentication; }
			set { m_authentication = value; }
		}

		/// <summary>
		/// The username to use to authenticate with the SMTP server
		/// </summary>
		/// <remarks>
		/// <note type="caution">Authentication is only available on the MS .NET 1.1 runtime.</note>
		/// <para>
		/// A <see cref="Username"/> and <see cref="Password"/> must be specified when 
		/// <see cref="Authentication"/> is set to <see cref="SmtpAuthentication.Basic"/>, 
		/// otherwise the username will be ignored. 
		/// </para>
		/// </remarks>
		public string Username
		{
			get { return m_username; }
			set { m_username = value; }
		}

		/// <summary>
		/// The password to use to authenticate with the SMTP server
		/// </summary>
		/// <remarks>
		/// <note type="caution">Authentication is only available on the MS .NET 1.1 runtime.</note>
		/// <para>
		/// A <see cref="Username"/> and <see cref="Password"/> must be specified when 
		/// <see cref="Authentication"/> is set to <see cref="SmtpAuthentication.Basic"/>, 
		/// otherwise the password will be ignored. 
		/// </para>
		/// </remarks>
		public string Password
		{
			get { return m_password; }
			set { m_password = value; }
		}

		/// <summary>
		/// The port on which the SMTP server is listening
		/// </summary>
		/// <remarks>
		/// <note type="caution">Server Port is only available on the MS .NET 1.1 runtime.</note>
		/// <para>
		/// The port on which the SMTP server is listening. The default
		/// port is <c>25</c>. The Port can only be changed when running on
		/// the MS .NET 1.1 runtime.
		/// </para>
		/// </remarks>
		public int Port
		{
			get { return m_port; }
			set { m_port = value; }
		}

		/// <summary>
		/// Gets or sets the priority of the e-mail message
		/// </summary>
		/// <value>
		/// One of the <see cref="MailPriority"/> values.
		/// </value>
		/// <remarks>
		/// <para>
		/// Sets the priority of the e-mails generated by this
		/// appender. The default priority is <see cref="MailPriority.Normal"/>.
		/// </para>
		/// <para>
		/// If you are using this appender to report errors then
		/// you may want to set the priority to <see cref="MailPriority.High"/>.
		/// </para>
		/// </remarks>
		public MailPriority Priority
		{
			get { return m_mailPriority; }
			set { m_mailPriority = value; }
		}

#if NET_2_0 || MONO_2_0
        /// <summary>
        /// Enable or disable use of SSL when sending e-mail message
        /// </summary>
        /// <remarks>
        /// This is available on MS .NET 2.0 runtime and higher
        /// </remarks>
        public bool EnableSsl
        {
            get { return m_enableSsl; }
            set { m_enableSsl = value; }
        }

        /// <summary>
        /// Gets or sets the reply-to e-mail address.
        /// </summary>
        /// <remarks>
        /// This is available on MS .NET 2.0 runtime and higher
        /// </remarks>
        public string ReplyTo
        {
            get { return m_replyTo; }
            set { m_replyTo = value; }
        }
#endif

		/// <summary>
		/// Gets or sets the subject encoding to be used.
		/// </summary>
		/// <remarks>
		/// The default encoding is the operating system's current ANSI codepage.
		/// </remarks>
		public Encoding SubjectEncoding
		{
			get { return m_subjectEncoding; }
			set { m_subjectEncoding = value; }
		}

		/// <summary>
		/// Gets or sets the body encoding to be used.
		/// </summary>
		/// <remarks>
		/// The default encoding is the operating system's current ANSI codepage.
		/// </remarks>
		public Encoding BodyEncoding
		{
			get { return m_bodyEncoding; }
			set { m_bodyEncoding = value; }
		}

		#endregion // Public Instance Properties

		#region Override implementation of BufferingAppenderSkeleton

		/// <summary>
		/// Sends the contents of the cyclic buffer as an e-mail message.
		/// </summary>
		/// <param name="events">The logging events to send.</param>
		override protected void SendBuffer(LoggingEvent[] events) 
		{
			// Note: this code already owns the monitor for this
			// appender. This frees us from needing to synchronize again.
			try 
			{	  
				StringWriter writer = new StringWriter(System.Globalization.CultureInfo.InvariantCulture);

				string t = Layout.Header;
				if (t != null)
				{
					writer.Write(t);
				}

				for(int i = 0; i < events.Length; i++) 
				{
					// Render the event and append the text to the buffer
					RenderLoggingEvent(writer, events[i]);
				}

				t = Layout.Footer;
				if (t != null)
				{
					writer.Write(t);
				}

				SendEmail(writer.ToString());
			} 
			catch(Exception e) 
			{
				ErrorHandler.Error("Error occurred while sending e-mail notification.", e);
			}
		}

		#endregion // Override implementation of BufferingAppenderSkeleton

		#region Override implementation of AppenderSkeleton

		/// <summary>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </summary>
		/// <value><c>true</c></value>
		/// <remarks>
		/// <para>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </para>
		/// </remarks>
		override protected bool RequiresLayout
		{
			get { return true; }
		}

		#endregion // Override implementation of AppenderSkeleton

		#region Protected Methods

		/// <summary>
		/// Send the email message
		/// </summary>
		/// <param name="messageBody">the body text to include in the mail</param>
		virtual protected void SendEmail(string messageBody)
		{
#if NET_2_0 || MONO_2_0
			// .NET 2.0 has a new API for SMTP email System.Net.Mail
			// This API supports credentials and multiple hosts correctly.
			// The old API is deprecated.

			// Create and configure the smtp client
			SmtpClient smtpClient = new SmtpClient();
			if (!String.IsNullOrEmpty(m_smtpHost))
			{
				smtpClient.Host = m_smtpHost;
			}
			smtpClient.Port = m_port;
			smtpClient.DeliveryMethod = SmtpDeliveryMethod.Network;
            smtpClient.EnableSsl = m_enableSsl;

			if (m_authentication == SmtpAuthentication.Basic)
			{
				// Perform basic authentication
				smtpClient.Credentials = new System.Net.NetworkCredential(m_username, m_password);
			}
			else if (m_authentication == SmtpAuthentication.Ntlm)
			{
				// Perform integrated authentication (NTLM)
				smtpClient.Credentials = System.Net.CredentialCache.DefaultNetworkCredentials;
			}

            using (MailMessage mailMessage = new MailMessage())
            {
                mailMessage.Body = messageBody;
				mailMessage.BodyEncoding = m_bodyEncoding;
                mailMessage.From = new MailAddress(m_from);
                mailMessage.To.Add(m_to);
                if (!String.IsNullOrEmpty(m_cc))
                {
                    mailMessage.CC.Add(m_cc);
                }
                if (!String.IsNullOrEmpty(m_bcc))
                {
                    mailMessage.Bcc.Add(m_bcc);
                }
                if (!String.IsNullOrEmpty(m_replyTo))
                {
                    // .NET 4.0 warning CS0618: 'System.Net.Mail.MailMessage.ReplyTo' is obsolete:
                    // 'ReplyTo is obsoleted for this type.  Please use ReplyToList instead which can accept multiple addresses. http://go.microsoft.com/fwlink/?linkid=14202'
#if !NET_4_0 && !MONO_4_0
                    mailMessage.ReplyTo = new MailAddress(m_replyTo);
#else
                    mailMessage.ReplyToList.Add(new MailAddress(m_replyTo));
#endif
                }
                mailMessage.Subject = m_subject;
				mailMessage.SubjectEncoding = m_subjectEncoding;
                mailMessage.Priority = m_mailPriority;

                // TODO: Consider using SendAsync to send the message without blocking. This would be a change in
                // behaviour compared to .NET 1.x. We would need a SendCompletedCallback to log errors.
                smtpClient.Send(mailMessage);
            }
#else
				// .NET 1.x uses the System.Web.Mail API for sending Mail

				MailMessage mailMessage = new MailMessage();
				mailMessage.Body = messageBody;
				mailMessage.BodyEncoding = m_bodyEncoding;
				mailMessage.From = m_from;
				mailMessage.To = m_to;
                if (m_cc != null && m_cc.Length > 0)
                {
                    mailMessage.Cc = m_cc;
                }
                if (m_bcc != null && m_bcc.Length > 0)
                {
                    mailMessage.Bcc = m_bcc;
                }
				mailMessage.Subject = m_subject;
#if !MONO && !NET_1_0 && !NET_1_1 && !CLI_1_0
				mailMessage.SubjectEncoding = m_subjectEncoding;
#endif
				mailMessage.Priority = m_mailPriority;

#if NET_1_1
				// The Fields property on the MailMessage allows the CDO properties to be set directly.
				// This property is only available on .NET Framework 1.1 and the implementation must understand
				// the CDO properties. For details of the fields available in CDO see:
				//
				// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cdosys/html/_cdosys_configuration_coclass.asp
				// 

				try
				{
					if (m_authentication == SmtpAuthentication.Basic)
					{
						// Perform basic authentication
						mailMessage.Fields.Add("http://schemas.microsoft.com/cdo/configuration/smtpauthenticate", 1);
						mailMessage.Fields.Add("http://schemas.microsoft.com/cdo/configuration/sendusername", m_username);
						mailMessage.Fields.Add("http://schemas.microsoft.com/cdo/configuration/sendpassword", m_password);
					}
					else if (m_authentication == SmtpAuthentication.Ntlm)
					{
						// Perform integrated authentication (NTLM)
						mailMessage.Fields.Add("http://schemas.microsoft.com/cdo/configuration/smtpauthenticate", 2);
					}

					// Set the port if not the default value
					if (m_port != 25) 
					{
						mailMessage.Fields.Add("http://schemas.microsoft.com/cdo/configuration/smtpserverport", m_port);
					}
				}
				catch(MissingMethodException missingMethodException)
				{
					// If we were compiled against .NET 1.1 but are running against .NET 1.0 then
					// we will get a MissingMethodException when accessing the MailMessage.Fields property.

					ErrorHandler.Error("SmtpAppender: Authentication and server Port are only supported when running on the MS .NET 1.1 framework", missingMethodException);
				}
#else
				if (m_authentication != SmtpAuthentication.None)
				{
					ErrorHandler.Error("SmtpAppender: Authentication is only supported on the MS .NET 1.1 or MS .NET 2.0 builds of log4net");
				}

				if (m_port != 25)
				{
					ErrorHandler.Error("SmtpAppender: Server Port is only supported on the MS .NET 1.1 or MS .NET 2.0 builds of log4net");
				}
#endif // if NET_1_1

				if (m_smtpHost != null && m_smtpHost.Length > 0)
				{
					SmtpMail.SmtpServer = m_smtpHost;
				}

				SmtpMail.Send(mailMessage);
#endif // if NET_2_0
		}

		#endregion // Protected Methods

		#region Private Instance Fields

		private string m_to;
        private string m_cc;
        private string m_bcc;
		private string m_from;
		private string m_subject;
		private string m_smtpHost;
		private Encoding m_subjectEncoding = Encoding.UTF8;
		private Encoding m_bodyEncoding = Encoding.UTF8;

		// authentication fields
		private SmtpAuthentication m_authentication = SmtpAuthentication.None;
		private string m_username;
		private string m_password;

		// server port, default port 25
		private int m_port = 25;

		private MailPriority m_mailPriority = MailPriority.Normal;

#if NET_2_0 || MONO_2_0
        private bool m_enableSsl = false;]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static SmtpAppender()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="650" sc="13" el="650" ec="89">log4net\Appender\SmtpAppender.cs</location>
            <body hash="ba37b8b108492b8ff829a85cf393b917"><![CDATA[private static readonly char[] ADDRESS_DELIMITERS = new char[] { ',', ';' }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="MaybeTrimSeparators">
          <declaration><![CDATA[private static string MaybeTrimSeparators(string s)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="655" sc="65" el="661" ec="14">log4net\Appender\SmtpAppender.cs</location>
            <body hash="8c973c9267a3a5d882cb1612593e940a"><![CDATA[{
#if NET_2_0 || MONO_2_0
                return string.IsNullOrEmpty(s) ? s : s.Trim(ADDRESS_DELIMITERS);
#else
                return s != null && s.Length > 0 ? s : s.Trim(ADDRESS_DELIMITERS);
#endif
            }]]></body>
          </codeblock>
        </method>
        <method name="SendBuffer">
          <declaration><![CDATA[protected override void SendBuffer(LoggingEvent[] events)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="386" sc="3" el="417" ec="4">log4net\Appender\SmtpAppender.cs</location>
            <body hash="a447b0831a1e99f1315d8b25191bce43"><![CDATA[{
			// Note: this code already owns the monitor for this
			// appender. This frees us from needing to synchronize again.
			try 
			{	  
				StringWriter writer = new StringWriter(System.Globalization.CultureInfo.InvariantCulture);

				string t = Layout.Header;
				if (t != null)
				{
					writer.Write(t);
				}

				for(int i = 0; i < events.Length; i++) 
				{
					// Render the event and append the text to the buffer
					RenderLoggingEvent(writer, events[i]);
				}

				t = Layout.Footer;
				if (t != null)
				{
					writer.Write(t);
				}

				SendEmail(writer.ToString());
			} 
			catch(Exception e) 
			{
				ErrorHandler.Error("Error occurred while sending e-mail notification.", e);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="SendEmail">
          <declaration><![CDATA[protected virtual void SendEmail(string messageBody)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="446" sc="3" el="582" ec="4">log4net\Appender\SmtpAppender.cs</location>
            <body hash="ab19764c9af91252e9a82a0d2566f2fa"><![CDATA[{
#if NET_2_0 || MONO_2_0
			// .NET 2.0 has a new API for SMTP email System.Net.Mail
			// This API supports credentials and multiple hosts correctly.
			// The old API is deprecated.

			// Create and configure the smtp client
			SmtpClient smtpClient = new SmtpClient();
			if (!String.IsNullOrEmpty(m_smtpHost))
			{
				smtpClient.Host = m_smtpHost;
			}
			smtpClient.Port = m_port;
			smtpClient.DeliveryMethod = SmtpDeliveryMethod.Network;
            smtpClient.EnableSsl = m_enableSsl;

			if (m_authentication == SmtpAuthentication.Basic)
			{
				// Perform basic authentication
				smtpClient.Credentials = new System.Net.NetworkCredential(m_username, m_password);
			}
			else if (m_authentication == SmtpAuthentication.Ntlm)
			{
				// Perform integrated authentication (NTLM)
				smtpClient.Credentials = System.Net.CredentialCache.DefaultNetworkCredentials;
			}

            using (MailMessage mailMessage = new MailMessage())
            {
                mailMessage.Body = messageBody;
				mailMessage.BodyEncoding = m_bodyEncoding;
                mailMessage.From = new MailAddress(m_from);
                mailMessage.To.Add(m_to);
                if (!String.IsNullOrEmpty(m_cc))
                {
                    mailMessage.CC.Add(m_cc);
                }
                if (!String.IsNullOrEmpty(m_bcc))
                {
                    mailMessage.Bcc.Add(m_bcc);
                }
                if (!String.IsNullOrEmpty(m_replyTo))
                {
                    // .NET 4.0 warning CS0618: 'System.Net.Mail.MailMessage.ReplyTo' is obsolete:
                    // 'ReplyTo is obsoleted for this type.  Please use ReplyToList instead which can accept multiple addresses. http://go.microsoft.com/fwlink/?linkid=14202'
#if !NET_4_0 && !MONO_4_0
                    mailMessage.ReplyTo = new MailAddress(m_replyTo);
#else
                    mailMessage.ReplyToList.Add(new MailAddress(m_replyTo));
#endif
                }
                mailMessage.Subject = m_subject;
				mailMessage.SubjectEncoding = m_subjectEncoding;
                mailMessage.Priority = m_mailPriority;

                // TODO: Consider using SendAsync to send the message without blocking. This would be a change in
                // behaviour compared to .NET 1.x. We would need a SendCompletedCallback to log errors.
                smtpClient.Send(mailMessage);
            }
#else
				// .NET 1.x uses the System.Web.Mail API for sending Mail

				MailMessage mailMessage = new MailMessage();
				mailMessage.Body = messageBody;
				mailMessage.BodyEncoding = m_bodyEncoding;
				mailMessage.From = m_from;
				mailMessage.To = m_to;
                if (m_cc != null && m_cc.Length > 0)
                {
                    mailMessage.Cc = m_cc;
                }
                if (m_bcc != null && m_bcc.Length > 0)
                {
                    mailMessage.Bcc = m_bcc;
                }
				mailMessage.Subject = m_subject;
#if !MONO && !NET_1_0 && !NET_1_1 && !CLI_1_0
				mailMessage.SubjectEncoding = m_subjectEncoding;
#endif
				mailMessage.Priority = m_mailPriority;

#if NET_1_1
				// The Fields property on the MailMessage allows the CDO properties to be set directly.
				// This property is only available on .NET Framework 1.1 and the implementation must understand
				// the CDO properties. For details of the fields available in CDO see:
				//
				// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cdosys/html/_cdosys_configuration_coclass.asp
				// 

				try
				{
					if (m_authentication == SmtpAuthentication.Basic)
					{
						// Perform basic authentication
						mailMessage.Fields.Add("http://schemas.microsoft.com/cdo/configuration/smtpauthenticate", 1);
						mailMessage.Fields.Add("http://schemas.microsoft.com/cdo/configuration/sendusername", m_username);
						mailMessage.Fields.Add("http://schemas.microsoft.com/cdo/configuration/sendpassword", m_password);
					}
					else if (m_authentication == SmtpAuthentication.Ntlm)
					{
						// Perform integrated authentication (NTLM)
						mailMessage.Fields.Add("http://schemas.microsoft.com/cdo/configuration/smtpauthenticate", 2);
					}

					// Set the port if not the default value
					if (m_port != 25) 
					{
						mailMessage.Fields.Add("http://schemas.microsoft.com/cdo/configuration/smtpserverport", m_port);
					}
				}
				catch(MissingMethodException missingMethodException)
				{
					// If we were compiled against .NET 1.1 but are running against .NET 1.0 then
					// we will get a MissingMethodException when accessing the MailMessage.Fields property.

					ErrorHandler.Error("SmtpAppender: Authentication and server Port are only supported when running on the MS .NET 1.1 framework", missingMethodException);
				}
#else
				if (m_authentication != SmtpAuthentication.None)
				{
					ErrorHandler.Error("SmtpAppender: Authentication is only supported on the MS .NET 1.1 or MS .NET 2.0 builds of log4net");
				}

				if (m_port != 25)
				{
					ErrorHandler.Error("SmtpAppender: Server Port is only supported on the MS .NET 1.1 or MS .NET 2.0 builds of log4net");
				}
#endif // if NET_1_1

				if (m_smtpHost != null && m_smtpHost.Length > 0)
				{
					SmtpMail.SmtpServer = m_smtpHost;
				}

				SmtpMail.Send(mailMessage);
#endif // if NET_2_0
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="ADDRESS_DELIMITERS">
          <declaration><![CDATA[private static readonly char[] ADDRESS_DELIMITERS = new char[]]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_authentication">
          <declaration><![CDATA[private SmtpAppender.SmtpAuthentication m_authentication = SmtpAppender.SmtpAuthentication.None;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_bcc">
          <declaration><![CDATA[private string m_bcc;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_bodyEncoding">
          <declaration><![CDATA[private Encoding m_bodyEncoding = Encoding.UTF8;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_cc">
          <declaration><![CDATA[private string m_cc;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_enableSsl">
          <declaration><![CDATA[private bool m_enableSsl = false;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_from">
          <declaration><![CDATA[private string m_from;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_mailPriority">
          <declaration><![CDATA[private MailPriority m_mailPriority = MailPriority.Normal;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_password">
          <declaration><![CDATA[private string m_password;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_port">
          <declaration><![CDATA[private int m_port = 25;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_replyTo">
          <declaration><![CDATA[private string m_replyTo;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_smtpHost">
          <declaration><![CDATA[private string m_smtpHost;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_subject">
          <declaration><![CDATA[private string m_subject;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_subjectEncoding">
          <declaration><![CDATA[private Encoding m_subjectEncoding = Encoding.UTF8;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_to">
          <declaration><![CDATA[private string m_to;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_username">
          <declaration><![CDATA[private string m_username;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Authentication">
          <declaration><![CDATA[public SmtpAppender.SmtpAuthentication Authentication]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Bcc">
          <declaration><![CDATA[public string Bcc]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="BodyEncoding">
          <declaration><![CDATA[public Encoding BodyEncoding]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Cc">
          <declaration><![CDATA[public string Cc]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="EnableSsl">
          <declaration><![CDATA[public bool EnableSsl]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="From">
          <declaration><![CDATA[public string From]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="LocationInfo">
          <deprecation>Use the BufferingAppenderSkeleton Fix methods</deprecation>
          <declaration><![CDATA[public bool LocationInfo]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Password">
          <declaration><![CDATA[public string Password]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Port">
          <declaration><![CDATA[public int Port]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Priority">
          <declaration><![CDATA[public MailPriority Priority]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="ReplyTo">
          <declaration><![CDATA[public string ReplyTo]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="RequiresLayout">
          <declaration><![CDATA[protected override bool RequiresLayout]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="SmtpHost">
          <declaration><![CDATA[public string SmtpHost]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Subject">
          <declaration><![CDATA[public string Subject]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="SubjectEncoding">
          <declaration><![CDATA[public Encoding SubjectEncoding]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="To">
          <declaration><![CDATA[public string To]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Username">
          <declaration><![CDATA[public string Username]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="SmtpPickupDirAppender">
      <declaration><![CDATA[public class SmtpPickupDirAppender : BufferingAppenderSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public SmtpPickupDirAppender()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="65" sc="3" el="68" ec="4">log4net\Appender\SmtpPickupDirAppender.cs</location>
            <body hash="4f2580fa8d2af2b618b57de539fc5a44"><![CDATA[public SmtpPickupDirAppender()
		{
			m_fileExtension = string.Empty; // Default to empty string, not null
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public override void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="286" sc="3" el="298" ec="4">log4net\Appender\SmtpPickupDirAppender.cs</location>
            <body hash="3f66dc136734d2834148b6b1e869703d"><![CDATA[{	
			base.ActivateOptions();

			if (m_securityContext == null)
			{
				m_securityContext = SecurityContextProvider.DefaultProvider.CreateSecurityContext(this);
			}

			using(SecurityContext.Impersonate(this))
			{
				m_pickupDir = ConvertToFullPath(m_pickupDir.Trim());
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ConvertToFullPath">
          <declaration><![CDATA[protected static string ConvertToFullPath(string path)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="332" sc="3" el="334" ec="4">log4net\Appender\SmtpPickupDirAppender.cs</location>
            <body hash="f64e0410b191250f185fe0a38eeb6cb6"><![CDATA[{
			return SystemInfo.ConvertToFullPath(path);
		}]]></body>
          </codeblock>
        </method>
        <method name="SendBuffer">
          <declaration><![CDATA[protected override void SendBuffer(LoggingEvent[] events)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="207" sc="3" el="263" ec="4">log4net\Appender\SmtpPickupDirAppender.cs</location>
            <body hash="7e41b575a20761148832294e960e59b2"><![CDATA[{
			// Note: this code already owns the monitor for this
			// appender. This frees us from needing to synchronize again.
			try 
			{
				string filePath = null;
				StreamWriter writer = null;

				// Impersonate to open the file
				using(SecurityContext.Impersonate(this))
				{
					filePath = Path.Combine(m_pickupDir, SystemInfo.NewGuid().ToString("N") + m_fileExtension);
					writer = File.CreateText(filePath);
				}

				if (writer == null)
				{
					ErrorHandler.Error("Failed to create output file for writing ["+filePath+"]", null, ErrorCode.FileOpenFailure);
				}
				else
				{
					using(writer)
					{
						writer.WriteLine("To: " + m_to);
						writer.WriteLine("From: " + m_from);
						writer.WriteLine("Subject: " + m_subject);
						writer.WriteLine("Date: " + DateTime.UtcNow.ToString("r"));
						writer.WriteLine("");

						string t = Layout.Header;
						if (t != null)
						{
							writer.Write(t);
						}

						for(int i = 0; i < events.Length; i++) 
						{
							// Render the event and append the text to the buffer
							RenderLoggingEvent(writer, events[i]);
						}

						t = Layout.Footer;
						if (t != null)
						{
							writer.Write(t);
						}

						writer.WriteLine("");
						writer.WriteLine(".");
					}
				}
			} 
			catch(Exception e) 
			{
				ErrorHandler.Error("Error occurred while sending e-mail notification.", e);
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_fileExtension">
          <declaration><![CDATA[private string m_fileExtension;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_from">
          <declaration><![CDATA[private string m_from;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_pickupDir">
          <declaration><![CDATA[private string m_pickupDir;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_securityContext">
          <declaration><![CDATA[private SecurityContext m_securityContext;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_subject">
          <declaration><![CDATA[private string m_subject;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_to">
          <declaration><![CDATA[private string m_to;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="FileExtension">
          <declaration><![CDATA[public string FileExtension]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="155" sc="4" el="170" ec="5">log4net\Appender\SmtpPickupDirAppender.cs</location>
            <body hash="d9bfb37764c021dc64c7c64a169012a3"><![CDATA[{
				m_fileExtension = value;
				if (m_fileExtension == null)
				{
					m_fileExtension = string.Empty;
				}
				// Make sure any non empty extension starts with a dot
#if NET_2_0 || MONO_2_0
				if (!string.IsNullOrEmpty(m_fileExtension) && !m_fileExtension.StartsWith("."))
#else
				if (m_fileExtension != null && m_fileExtension.Length > 0 && !m_fileExtension.StartsWith("."))
#endif
				{
					m_fileExtension = "." + m_fileExtension;
				}
			}]]></body>
          </codeblock>
        </property>
        <property name="From">
          <declaration><![CDATA[public string From]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="PickupDir">
          <declaration><![CDATA[public string PickupDir]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="RequiresLayout">
          <declaration><![CDATA[protected override bool RequiresLayout]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="SecurityContext">
          <declaration><![CDATA[public SecurityContext SecurityContext]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Subject">
          <declaration><![CDATA[public string Subject]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="To">
          <declaration><![CDATA[public string To]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="TelnetAppender">
      <declaration><![CDATA[public class TelnetAppender : AppenderSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_listeningPort = 23;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="57" sc="3" el="71" ec="4">log4net\Appender\TelnetAppender.cs</location>
            <body hash="d056f8e388c2d45ed7a041d754e3d9d4"><![CDATA[private int m_listeningPort = 23;

		#region Constructor

		/// <summary>
		/// Default constructor
		/// </summary>
		/// <remarks>
		/// <para>
		/// Default constructor
		/// </para>
		/// </remarks>
		public TelnetAppender()
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static TelnetAppender()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="84" sc="6" el="84" ec="74">log4net\Appender\TelnetAppender.cs</location>
            <body hash="5365f0f6af351853bc6f7965dcbd01be"><![CDATA[private readonly static Type declaringType = typeof(TelnetAppender)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public override void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="180" sc="3" el="192" ec="4">log4net\Appender\TelnetAppender.cs</location>
            <body hash="e47b95c047ae36b506e72d5cfd9604a0"><![CDATA[{
			base.ActivateOptions();
			try 
			{
				LogLog.Debug(declaringType, "Creating SocketHandler to listen on port ["+m_listeningPort+"]");
				m_handler = new SocketHandler(m_listeningPort);
			}
			catch(Exception ex) 
			{
				LogLog.Error(declaringType, "Failed to create SocketHandler", ex);
				throw;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Append">
          <declaration><![CDATA[protected override void Append(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="204" sc="3" el="209" ec="4">log4net\Appender\TelnetAppender.cs</location>
            <body hash="51569c4c9a727ba2070fbb37fc964e94"><![CDATA[{
			if (m_handler != null && m_handler.HasConnections)
			{
				m_handler.Send(RenderLoggingEvent(loggingEvent));
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="OnClose">
          <declaration><![CDATA[protected override void OnClose()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="136" sc="3" el="144" ec="4">log4net\Appender\TelnetAppender.cs</location>
            <body hash="a9b790fa9a7ee4be09f58ec034c49095"><![CDATA[{
			base.OnClose();

			if (m_handler != null)
			{
				m_handler.Dispose();
				m_handler = null;
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(TelnetAppender);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_handler">
          <declaration><![CDATA[private TelnetAppender.SocketHandler m_handler;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_listeningPort">
          <declaration><![CDATA[private int m_listeningPort = 23;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Port">
          <declaration><![CDATA[public int Port]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="105" sc="4" el="107" ec="5">log4net\Appender\TelnetAppender.cs</location>
            <body hash="edef450bef3fb4358c2258f3f2731154"><![CDATA[{
				return m_listeningPort;
			}]]></body>
          </codeblock>
          <codeblock>
            <location sl="109" sc="4" el="122" ec="5">log4net\Appender\TelnetAppender.cs</location>
            <body hash="5565b4f02863b70804dadc395b73f4b7"><![CDATA[{
				if (value < IPEndPoint.MinPort || value > IPEndPoint.MaxPort)
				{
					throw log4net.Util.SystemInfo.CreateArgumentOutOfRangeException("value", (object)value,
						"The value specified for Port is less than " + 
						IPEndPoint.MinPort.ToString(NumberFormatInfo.InvariantInfo) + 
						" or greater than " + 
						IPEndPoint.MaxPort.ToString(NumberFormatInfo.InvariantInfo) + ".");
				}
				else
				{
					m_listeningPort = value;
				}
			}]]></body>
          </codeblock>
        </property>
        <property name="RequiresLayout">
          <declaration><![CDATA[protected override bool RequiresLayout]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="TextWriterAppender">
      <declaration><![CDATA[public class TextWriterAppender : AppenderSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private bool m_immediateFlush = true;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="57" sc="3" el="468" ec="40">log4net\Appender\TextWriterAppender.cs</location>
            <body hash="3e97d8e4ef4c5df3996c6c3d279dca87"><![CDATA[public TextWriterAppender() 
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="TextWriterAppender" /> class and
		/// sets the output destination to a new <see cref="StreamWriter"/> initialized 
		/// with the specified <see cref="Stream"/>.
		/// </summary>
		/// <param name="layout">The layout to use with this appender.</param>
		/// <param name="os">The <see cref="Stream"/> to output to.</param>
		/// <remarks>
		/// <para>
		/// Obsolete constructor.
		/// </para>
		/// </remarks>
		[Obsolete("Instead use the default constructor and set the Layout & Writer properties")]
		public TextWriterAppender(ILayout layout, Stream os) : this(layout, new StreamWriter(os))
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="TextWriterAppender" /> class and sets
		/// the output destination to the specified <see cref="StreamWriter" />.
		/// </summary>
		/// <param name="layout">The layout to use with this appender</param>
		/// <param name="writer">The <see cref="TextWriter" /> to output to</param>
		/// <remarks>
		/// The <see cref="TextWriter" /> must have been previously opened.
		/// </remarks>
		/// <remarks>
		/// <para>
		/// Obsolete constructor.
		/// </para>
		/// </remarks>
		[Obsolete("Instead use the default constructor and set the Layout & Writer properties")]
		public TextWriterAppender(ILayout layout, TextWriter writer) 
		{
			Layout = layout;
			Writer = writer;
		}

		#endregion

		#region Public Instance Properties

		/// <summary>
		/// Gets or set whether the appender will flush at the end 
		/// of each append operation.
		/// </summary>
		/// <value>
		/// <para>
		/// The default behavior is to flush at the end of each 
		/// append operation.
		/// </para>
		/// <para>
		/// If this option is set to <c>false</c>, then the underlying 
		/// stream can defer persisting the logging event to a later 
		/// time.
		/// </para>
		/// </value>
		/// <remarks>
		/// Avoiding the flush operation at the end of each append results in
		/// a performance gain of 10 to 20 percent. However, there is safety
		/// trade-off involved in skipping flushing. Indeed, when flushing is
		/// skipped, then it is likely that the last few log events will not
		/// be recorded on disk when the application exits. This is a high
		/// price to pay even for a 20% performance gain.
		/// </remarks>
		public bool ImmediateFlush 
		{
			get { return m_immediateFlush; }
			set { m_immediateFlush = value; }
		}

		/// <summary>
		/// Sets the <see cref="TextWriter"/> where the log output will go.
		/// </summary>
		/// <remarks>
		/// <para>
		/// The specified <see cref="TextWriter"/> must be open and writable.
		/// </para>
		/// <para>
		/// The <see cref="TextWriter"/> will be closed when the appender 
		/// instance is closed.
		/// </para>
		/// <para>
		/// <b>Note:</b> Logging to an unopened <see cref="TextWriter"/> will fail.
		/// </para>
		/// </remarks>
		virtual public TextWriter Writer 
		{
			get { return m_qtw; }
			set 
			{
				lock(this) 
				{
					Reset();
					if (value != null)
					{
						m_qtw = new QuietTextWriter(value, ErrorHandler);
						WriteHeader();
					}
				}
			}
		}

		#endregion Public Instance Properties

		#region Override implementation of AppenderSkeleton

		/// <summary>
		/// This method determines if there is a sense in attempting to append.
		/// </summary>
		/// <remarks>
		/// <para>
		/// This method checks if an output target has been set and if a
		/// layout has been set. 
		/// </para>
		/// </remarks>
		/// <returns><c>false</c> if any of the preconditions fail.</returns>
		override protected bool PreAppendCheck() 
		{
			if (!base.PreAppendCheck()) 
			{
				return false;
			}

			if (m_qtw == null) 
			{
				// Allow subclass to lazily create the writer
				PrepareWriter();

				if (m_qtw == null) 
				{
					ErrorHandler.Error("No output stream or file set for the appender named ["+ Name +"].");
					return false;
				}
			}
			if (m_qtw.Closed) 
			{
				ErrorHandler.Error("Output stream for appender named ["+ Name +"] has been closed.");
				return false;
			}

			return true;
		}

		/// <summary>
		/// This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent)"/>
		/// method. 
		/// </summary>
		/// <param name="loggingEvent">The event to log.</param>
		/// <remarks>
		/// <para>
		/// Writes a log statement to the output stream if the output stream exists 
		/// and is writable.  
		/// </para>
		/// <para>
		/// The format of the output will depend on the appender's layout.
		/// </para>
		/// </remarks>
		override protected void Append(LoggingEvent loggingEvent) 
		{
			RenderLoggingEvent(m_qtw, loggingEvent);

			if (m_immediateFlush) 
			{
				m_qtw.Flush();
			} 
		}

		/// <summary>
		/// This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent[])"/>
		/// method. 
		/// </summary>
		/// <param name="loggingEvents">The array of events to log.</param>
		/// <remarks>
		/// <para>
		/// This method writes all the bulk logged events to the output writer
		/// before flushing the stream.
		/// </para>
		/// </remarks>
		override protected void Append(LoggingEvent[] loggingEvents) 
		{
			foreach(LoggingEvent loggingEvent in loggingEvents)
			{
				RenderLoggingEvent(m_qtw, loggingEvent);
			}

			if (m_immediateFlush) 
			{
				m_qtw.Flush();
			} 
		}

		/// <summary>
		/// Close this appender instance. The underlying stream or writer is also closed.
		/// </summary>
		/// <remarks>
		/// Closed appenders cannot be reused.
		/// </remarks>
		override protected void OnClose() 
		{
			lock(this)
			{
				Reset();
			}
		}

		/// <summary>
		/// Gets or set the <see cref="IErrorHandler"/> and the underlying 
		/// <see cref="QuietTextWriter"/>, if any, for this appender. 
		/// </summary>
		/// <value>
		/// The <see cref="IErrorHandler"/> for this appender.
		/// </value>
		override public IErrorHandler ErrorHandler
		{
			get { return base.ErrorHandler; }
			set
			{
				lock(this)
				{
					if (value == null) 
					{
						LogLog.Warn(declaringType, "TextWriterAppender: You have tried to set a null error-handler.");
					} 
					else 
					{
						base.ErrorHandler = value;
						if (m_qtw != null) 
						{
							m_qtw.ErrorHandler = value;
						}
					}	
				}
			}
		}

		/// <summary>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </summary>
		/// <value><c>true</c></value>
		/// <remarks>
		/// <para>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </para>
		/// </remarks>
		override protected bool RequiresLayout
		{
			get { return true; }
		}

		#endregion Override implementation of AppenderSkeleton

		#region Protected Instance Methods

		/// <summary>
		/// Writes the footer and closes the underlying <see cref="TextWriter"/>.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Writes the footer and closes the underlying <see cref="TextWriter"/>.
		/// </para>
		/// </remarks>
		virtual protected void WriteFooterAndCloseWriter()
		{
			WriteFooter();
			CloseWriter();
		}

		/// <summary>
		/// Closes the underlying <see cref="TextWriter"/>.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Closes the underlying <see cref="TextWriter"/>.
		/// </para>
		/// </remarks>
		virtual protected void CloseWriter() 
		{
			if (m_qtw != null) 
			{
				try 
				{
					m_qtw.Close();
				} 
				catch(Exception e) 
				{
					ErrorHandler.Error("Could not close writer ["+m_qtw+"]", e); 
					// do need to invoke an error handler
					// at this late stage
				}
			}
		}

		/// <summary>
		/// Clears internal references to the underlying <see cref="TextWriter" /> 
		/// and other variables.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Subclasses can override this method for an alternate closing behavior.
		/// </para>
		/// </remarks>
		virtual protected void Reset() 
		{
			WriteFooterAndCloseWriter();
			m_qtw = null;
		}

		/// <summary>
		/// Writes a footer as produced by the embedded layout's <see cref="ILayout.Footer"/> property.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Writes a footer as produced by the embedded layout's <see cref="ILayout.Footer"/> property.
		/// </para>
		/// </remarks>
		virtual protected void WriteFooter() 
		{
			if (Layout != null && m_qtw != null && !m_qtw.Closed) 
			{
				string f = Layout.Footer;
				if (f != null)
				{
					m_qtw.Write(f);
				}
			}
		}

		/// <summary>
		/// Writes a header produced by the embedded layout's <see cref="ILayout.Header"/> property.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Writes a header produced by the embedded layout's <see cref="ILayout.Header"/> property.
		/// </para>
		/// </remarks>
		virtual protected void WriteHeader() 
		{
			if (Layout != null && m_qtw != null && !m_qtw.Closed) 
			{
				string h = Layout.Header;
				if (h != null)
				{
					m_qtw.Write(h);
				}
			}
		}

		/// <summary>
		/// Called to allow a subclass to lazily initialize the writer
		/// </summary>
		/// <remarks>
		/// <para>
		/// This method is called when an event is logged and the <see cref="Writer"/> or
		/// <see cref="QuietWriter"/> have not been set. This allows a subclass to
		/// attempt to initialize the writer multiple times.
		/// </para>
		/// </remarks>
		virtual protected void PrepareWriter()
		{
		}

		/// <summary>
		/// Gets or sets the <see cref="log4net.Util.QuietTextWriter"/> where logging events
		/// will be written to. 
		/// </summary>
		/// <value>
		/// The <see cref="log4net.Util.QuietTextWriter"/> where logging events are written.
		/// </value>
		/// <remarks>
		/// <para>
		/// This is the <see cref="log4net.Util.QuietTextWriter"/> where logging events
		/// will be written to. 
		/// </para>
		/// </remarks>
		protected QuietTextWriter QuietWriter
		{
			get { return m_qtw; }
			set { m_qtw = value; }
        }

        #endregion Protected Instance Methods

        #region Private Instance Fields

        /// <summary>
		/// This is the <see cref="log4net.Util.QuietTextWriter"/> where logging events
		/// will be written to. 
		/// </summary>
		private QuietTextWriter m_qtw;

		/// <summary>
		/// Immediate flush means that the underlying <see cref="TextWriter" /> 
		/// or output stream will be flushed at the end of each append operation.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Immediate flush is slower but ensures that each append request is 
		/// actually written. If <see cref="ImmediateFlush"/> is set to
		/// <c>false</c>, then there is a good chance that the last few
		/// logging events are not actually persisted if and when the application 
		/// crashes.
		/// </para>
		/// <para>
		/// The default value is <c>true</c>.
		/// </para>
		/// </remarks>
		private bool m_immediateFlush = true;]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <deprecation>Instead use the default constructor and set the Layout &amp; Writer properties</deprecation>
          <declaration><![CDATA[public TextWriterAppender(ILayout layout, Stream os) : this(layout, new StreamWriter(os))]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="74" sc="58" el="76" ec="4">log4net\Appender\TextWriterAppender.cs</location>
            <body hash="34ff04b245ed97f24a2e2334e1fd49d3"><![CDATA[this(layout, new StreamWriter(os))
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <deprecation>Instead use the default constructor and set the Layout &amp; Writer properties</deprecation>
          <declaration><![CDATA[private bool m_immediateFlush = true;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="93" sc="3" el="468" ec="40">log4net\Appender\TextWriterAppender.cs</location>
            <body hash="29cada6e7a68b5025b774cc40bdd20e6"><![CDATA[public TextWriterAppender(ILayout layout, TextWriter writer) 
		{
			Layout = layout;
			Writer = writer;
		}

		#endregion

		#region Public Instance Properties

		/// <summary>
		/// Gets or set whether the appender will flush at the end 
		/// of each append operation.
		/// </summary>
		/// <value>
		/// <para>
		/// The default behavior is to flush at the end of each 
		/// append operation.
		/// </para>
		/// <para>
		/// If this option is set to <c>false</c>, then the underlying 
		/// stream can defer persisting the logging event to a later 
		/// time.
		/// </para>
		/// </value>
		/// <remarks>
		/// Avoiding the flush operation at the end of each append results in
		/// a performance gain of 10 to 20 percent. However, there is safety
		/// trade-off involved in skipping flushing. Indeed, when flushing is
		/// skipped, then it is likely that the last few log events will not
		/// be recorded on disk when the application exits. This is a high
		/// price to pay even for a 20% performance gain.
		/// </remarks>
		public bool ImmediateFlush 
		{
			get { return m_immediateFlush; }
			set { m_immediateFlush = value; }
		}

		/// <summary>
		/// Sets the <see cref="TextWriter"/> where the log output will go.
		/// </summary>
		/// <remarks>
		/// <para>
		/// The specified <see cref="TextWriter"/> must be open and writable.
		/// </para>
		/// <para>
		/// The <see cref="TextWriter"/> will be closed when the appender 
		/// instance is closed.
		/// </para>
		/// <para>
		/// <b>Note:</b> Logging to an unopened <see cref="TextWriter"/> will fail.
		/// </para>
		/// </remarks>
		virtual public TextWriter Writer 
		{
			get { return m_qtw; }
			set 
			{
				lock(this) 
				{
					Reset();
					if (value != null)
					{
						m_qtw = new QuietTextWriter(value, ErrorHandler);
						WriteHeader();
					}
				}
			}
		}

		#endregion Public Instance Properties

		#region Override implementation of AppenderSkeleton

		/// <summary>
		/// This method determines if there is a sense in attempting to append.
		/// </summary>
		/// <remarks>
		/// <para>
		/// This method checks if an output target has been set and if a
		/// layout has been set. 
		/// </para>
		/// </remarks>
		/// <returns><c>false</c> if any of the preconditions fail.</returns>
		override protected bool PreAppendCheck() 
		{
			if (!base.PreAppendCheck()) 
			{
				return false;
			}

			if (m_qtw == null) 
			{
				// Allow subclass to lazily create the writer
				PrepareWriter();

				if (m_qtw == null) 
				{
					ErrorHandler.Error("No output stream or file set for the appender named ["+ Name +"].");
					return false;
				}
			}
			if (m_qtw.Closed) 
			{
				ErrorHandler.Error("Output stream for appender named ["+ Name +"] has been closed.");
				return false;
			}

			return true;
		}

		/// <summary>
		/// This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent)"/>
		/// method. 
		/// </summary>
		/// <param name="loggingEvent">The event to log.</param>
		/// <remarks>
		/// <para>
		/// Writes a log statement to the output stream if the output stream exists 
		/// and is writable.  
		/// </para>
		/// <para>
		/// The format of the output will depend on the appender's layout.
		/// </para>
		/// </remarks>
		override protected void Append(LoggingEvent loggingEvent) 
		{
			RenderLoggingEvent(m_qtw, loggingEvent);

			if (m_immediateFlush) 
			{
				m_qtw.Flush();
			} 
		}

		/// <summary>
		/// This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent[])"/>
		/// method. 
		/// </summary>
		/// <param name="loggingEvents">The array of events to log.</param>
		/// <remarks>
		/// <para>
		/// This method writes all the bulk logged events to the output writer
		/// before flushing the stream.
		/// </para>
		/// </remarks>
		override protected void Append(LoggingEvent[] loggingEvents) 
		{
			foreach(LoggingEvent loggingEvent in loggingEvents)
			{
				RenderLoggingEvent(m_qtw, loggingEvent);
			}

			if (m_immediateFlush) 
			{
				m_qtw.Flush();
			} 
		}

		/// <summary>
		/// Close this appender instance. The underlying stream or writer is also closed.
		/// </summary>
		/// <remarks>
		/// Closed appenders cannot be reused.
		/// </remarks>
		override protected void OnClose() 
		{
			lock(this)
			{
				Reset();
			}
		}

		/// <summary>
		/// Gets or set the <see cref="IErrorHandler"/> and the underlying 
		/// <see cref="QuietTextWriter"/>, if any, for this appender. 
		/// </summary>
		/// <value>
		/// The <see cref="IErrorHandler"/> for this appender.
		/// </value>
		override public IErrorHandler ErrorHandler
		{
			get { return base.ErrorHandler; }
			set
			{
				lock(this)
				{
					if (value == null) 
					{
						LogLog.Warn(declaringType, "TextWriterAppender: You have tried to set a null error-handler.");
					} 
					else 
					{
						base.ErrorHandler = value;
						if (m_qtw != null) 
						{
							m_qtw.ErrorHandler = value;
						}
					}	
				}
			}
		}

		/// <summary>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </summary>
		/// <value><c>true</c></value>
		/// <remarks>
		/// <para>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </para>
		/// </remarks>
		override protected bool RequiresLayout
		{
			get { return true; }
		}

		#endregion Override implementation of AppenderSkeleton

		#region Protected Instance Methods

		/// <summary>
		/// Writes the footer and closes the underlying <see cref="TextWriter"/>.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Writes the footer and closes the underlying <see cref="TextWriter"/>.
		/// </para>
		/// </remarks>
		virtual protected void WriteFooterAndCloseWriter()
		{
			WriteFooter();
			CloseWriter();
		}

		/// <summary>
		/// Closes the underlying <see cref="TextWriter"/>.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Closes the underlying <see cref="TextWriter"/>.
		/// </para>
		/// </remarks>
		virtual protected void CloseWriter() 
		{
			if (m_qtw != null) 
			{
				try 
				{
					m_qtw.Close();
				} 
				catch(Exception e) 
				{
					ErrorHandler.Error("Could not close writer ["+m_qtw+"]", e); 
					// do need to invoke an error handler
					// at this late stage
				}
			}
		}

		/// <summary>
		/// Clears internal references to the underlying <see cref="TextWriter" /> 
		/// and other variables.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Subclasses can override this method for an alternate closing behavior.
		/// </para>
		/// </remarks>
		virtual protected void Reset() 
		{
			WriteFooterAndCloseWriter();
			m_qtw = null;
		}

		/// <summary>
		/// Writes a footer as produced by the embedded layout's <see cref="ILayout.Footer"/> property.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Writes a footer as produced by the embedded layout's <see cref="ILayout.Footer"/> property.
		/// </para>
		/// </remarks>
		virtual protected void WriteFooter() 
		{
			if (Layout != null && m_qtw != null && !m_qtw.Closed) 
			{
				string f = Layout.Footer;
				if (f != null)
				{
					m_qtw.Write(f);
				}
			}
		}

		/// <summary>
		/// Writes a header produced by the embedded layout's <see cref="ILayout.Header"/> property.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Writes a header produced by the embedded layout's <see cref="ILayout.Header"/> property.
		/// </para>
		/// </remarks>
		virtual protected void WriteHeader() 
		{
			if (Layout != null && m_qtw != null && !m_qtw.Closed) 
			{
				string h = Layout.Header;
				if (h != null)
				{
					m_qtw.Write(h);
				}
			}
		}

		/// <summary>
		/// Called to allow a subclass to lazily initialize the writer
		/// </summary>
		/// <remarks>
		/// <para>
		/// This method is called when an event is logged and the <see cref="Writer"/> or
		/// <see cref="QuietWriter"/> have not been set. This allows a subclass to
		/// attempt to initialize the writer multiple times.
		/// </para>
		/// </remarks>
		virtual protected void PrepareWriter()
		{
		}

		/// <summary>
		/// Gets or sets the <see cref="log4net.Util.QuietTextWriter"/> where logging events
		/// will be written to. 
		/// </summary>
		/// <value>
		/// The <see cref="log4net.Util.QuietTextWriter"/> where logging events are written.
		/// </value>
		/// <remarks>
		/// <para>
		/// This is the <see cref="log4net.Util.QuietTextWriter"/> where logging events
		/// will be written to. 
		/// </para>
		/// </remarks>
		protected QuietTextWriter QuietWriter
		{
			get { return m_qtw; }
			set { m_qtw = value; }
        }

        #endregion Protected Instance Methods

        #region Private Instance Fields

        /// <summary>
		/// This is the <see cref="log4net.Util.QuietTextWriter"/> where logging events
		/// will be written to. 
		/// </summary>
		private QuietTextWriter m_qtw;

		/// <summary>
		/// Immediate flush means that the underlying <see cref="TextWriter" /> 
		/// or output stream will be flushed at the end of each append operation.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Immediate flush is slower but ensures that each append request is 
		/// actually written. If <see cref="ImmediateFlush"/> is set to
		/// <c>false</c>, then there is a good chance that the last few
		/// logging events are not actually persisted if and when the application 
		/// crashes.
		/// </para>
		/// <para>
		/// The default value is <c>true</c>.
		/// </para>
		/// </remarks>
		private bool m_immediateFlush = true;]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static TextWriterAppender()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="481" sc="6" el="481" ec="78">log4net\Appender\TextWriterAppender.cs</location>
            <body hash="ac0530cf20b0e11d2cd10cdcc2607009"><![CDATA[private readonly static Type declaringType = typeof(TextWriterAppender)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Append">
          <declaration><![CDATA[protected override void Append(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="220" sc="3" el="227" ec="4">log4net\Appender\TextWriterAppender.cs</location>
            <body hash="20f06f27309ffde5f38bec2184307642"><![CDATA[{
			RenderLoggingEvent(m_qtw, loggingEvent);

			if (m_immediateFlush) 
			{
				m_qtw.Flush();
			} 
		}]]></body>
          </codeblock>
        </method>
        <method name="Append">
          <declaration><![CDATA[protected override void Append(LoggingEvent[] loggingEvents)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="241" sc="3" el="251" ec="4">log4net\Appender\TextWriterAppender.cs</location>
            <body hash="6fdcc090ea910afb9d9ab3c5daf78964"><![CDATA[{
			foreach(LoggingEvent loggingEvent in loggingEvents)
			{
				RenderLoggingEvent(m_qtw, loggingEvent);
			}

			if (m_immediateFlush) 
			{
				m_qtw.Flush();
			} 
		}]]></body>
          </codeblock>
        </method>
        <method name="CloseWriter">
          <declaration><![CDATA[protected virtual void CloseWriter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="338" sc="3" el="352" ec="4">log4net\Appender\TextWriterAppender.cs</location>
            <body hash="696992ff94744cc2e81dd6f2497cd8a6"><![CDATA[{
			if (m_qtw != null) 
			{
				try 
				{
					m_qtw.Close();
				} 
				catch(Exception e) 
				{
					ErrorHandler.Error("Could not close writer ["+m_qtw+"]", e); 
					// do need to invoke an error handler
					// at this late stage
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Flush">
          <declaration><![CDATA[public override bool Flush(int millisecondsTimeout)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="491" sc="13" el="502" ec="14">log4net\Appender\TextWriterAppender.cs</location>
            <body hash="47ea4688c0b0b203531a692c33d3ed38"><![CDATA[{
                // Nothing to do if ImmediateFlush is true
                if (m_immediateFlush) return true;

                // lock(this) will block any Appends while the buffer is flushed.
                lock (this)
                {
                    m_qtw.Flush();
                }

                return true;
            }]]></body>
          </codeblock>
        </method>
        <method name="OnClose">
          <declaration><![CDATA[protected override void OnClose()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="260" sc="3" el="265" ec="4">log4net\Appender\TextWriterAppender.cs</location>
            <body hash="601ada967be4115b7502a01f4c6e5f82"><![CDATA[{
			lock(this)
			{
				Reset();
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="PreAppendCheck">
          <declaration><![CDATA[protected override bool PreAppendCheck()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="179" sc="3" el="203" ec="4">log4net\Appender\TextWriterAppender.cs</location>
            <body hash="09be066cde136b1bef25a89cb9cbb4bf"><![CDATA[{
			if (!base.PreAppendCheck()) 
			{
				return false;
			}

			if (m_qtw == null) 
			{
				// Allow subclass to lazily create the writer
				PrepareWriter();

				if (m_qtw == null) 
				{
					ErrorHandler.Error("No output stream or file set for the appender named ["+ Name +"].");
					return false;
				}
			}
			if (m_qtw.Closed) 
			{
				ErrorHandler.Error("Output stream for appender named ["+ Name +"] has been closed.");
				return false;
			}

			return true;
		}]]></body>
          </codeblock>
        </method>
        <method name="PrepareWriter">
          <declaration><![CDATA[protected virtual void PrepareWriter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="420" sc="3" el="421" ec="4">log4net\Appender\TextWriterAppender.cs</location>
            <body hash="d2c65ffc45d1c7103cabbde916faf7e7"><![CDATA[{
		}]]></body>
          </codeblock>
        </method>
        <method name="Reset">
          <declaration><![CDATA[protected virtual void Reset()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="364" sc="3" el="367" ec="4">log4net\Appender\TextWriterAppender.cs</location>
            <body hash="07915f5080ee27f332937872f77de63a"><![CDATA[{
			WriteFooterAndCloseWriter();
			m_qtw = null;
		}]]></body>
          </codeblock>
        </method>
        <method name="WriteFooter">
          <declaration><![CDATA[protected virtual void WriteFooter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="378" sc="3" el="387" ec="4">log4net\Appender\TextWriterAppender.cs</location>
            <body hash="2e6da29e61f6853a488ba96d26459fb8"><![CDATA[{
			if (Layout != null && m_qtw != null && !m_qtw.Closed) 
			{
				string f = Layout.Footer;
				if (f != null)
				{
					m_qtw.Write(f);
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="WriteFooterAndCloseWriter">
          <declaration><![CDATA[protected virtual void WriteFooterAndCloseWriter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="324" sc="3" el="327" ec="4">log4net\Appender\TextWriterAppender.cs</location>
            <body hash="0e6669f7d6bcf0689f0aca8787738e44"><![CDATA[{
			WriteFooter();
			CloseWriter();
		}]]></body>
          </codeblock>
        </method>
        <method name="WriteHeader">
          <declaration><![CDATA[protected virtual void WriteHeader()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="398" sc="3" el="407" ec="4">log4net\Appender\TextWriterAppender.cs</location>
            <body hash="5a5c4b835b2fe804bfdd818c1692f13f"><![CDATA[{
			if (Layout != null && m_qtw != null && !m_qtw.Closed) 
			{
				string h = Layout.Header;
				if (h != null)
				{
					m_qtw.Write(h);
				}
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(TextWriterAppender);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_immediateFlush">
          <declaration><![CDATA[private bool m_immediateFlush = true;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_qtw">
          <declaration><![CDATA[private QuietTextWriter m_qtw;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="ErrorHandler">
          <declaration><![CDATA[public override IErrorHandler ErrorHandler]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="278" sc="4" el="294" ec="5">log4net\Appender\TextWriterAppender.cs</location>
            <body hash="d7dea5754eab2e6fe8c6d20d6b6c1660"><![CDATA[{
				lock(this)
				{
					if (value == null) 
					{
						LogLog.Warn(declaringType, "TextWriterAppender: You have tried to set a null error-handler.");
					} 
					else 
					{
						base.ErrorHandler = value;
						if (m_qtw != null) 
						{
							m_qtw.ErrorHandler = value;
						}
					}	
				}
			}]]></body>
          </codeblock>
        </property>
        <property name="ImmediateFlush">
          <declaration><![CDATA[public bool ImmediateFlush]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="QuietWriter">
          <declaration><![CDATA[protected QuietTextWriter QuietWriter]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="RequiresLayout">
          <declaration><![CDATA[protected override bool RequiresLayout]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Writer">
          <declaration><![CDATA[public virtual TextWriter Writer]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="151" sc="4" el="161" ec="5">log4net\Appender\TextWriterAppender.cs</location>
            <body hash="3bc6c09a3f4299840ee080be2874dbe9"><![CDATA[{
				lock(this) 
				{
					Reset();
					if (value != null)
					{
						m_qtw = new QuietTextWriter(value, ErrorHandler);
						WriteHeader();
					}
				}
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="TraceAppender">
      <declaration><![CDATA[public class TraceAppender : AppenderSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private bool m_immediateFlush = true;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="66" sc="3" el="206" ec="73">log4net\Appender\TraceAppender.cs</location>
            <body hash="a730dc76e7ba97513df971a2ab6876de"><![CDATA[public TraceAppender()
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="TraceAppender" /> 
		/// with a specified layout.
		/// </summary>
		/// <param name="layout">The layout to use with this appender.</param>
		/// <remarks>
		/// <para>
		/// Obsolete constructor.
		/// </para>
		/// </remarks>
		[System.Obsolete("Instead use the default constructor and set the Layout property")]
		public TraceAppender(ILayout layout)
		{
			Layout = layout;
		}

		#endregion Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Gets or sets a value that indicates whether the appender will 
		/// flush at the end of each write.
		/// </summary>
		/// <remarks>
		/// <para>The default behavior is to flush at the end of each 
		/// write. If the option is set to<c>false</c>, then the underlying 
		/// stream can defer writing to physical medium to a later time. 
		/// </para>
		/// <para>
		/// Avoiding the flush operation at the end of each append results 
		/// in a performance gain of 10 to 20 percent. However, there is safety
		/// trade-off involved in skipping flushing. Indeed, when flushing is
		/// skipped, then it is likely that the last few log events will not
		/// be recorded on disk when the application exits. This is a high
		/// price to pay even for a 20% performance gain.
		/// </para>
		/// </remarks>
		public bool ImmediateFlush
		{
			get { return m_immediateFlush; }
			set { m_immediateFlush = value; }
		}

        /// <summary>
        /// The category parameter sent to the Trace method.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Defaults to %logger which will use the logger name of the current 
        /// <see cref="LoggingEvent"/> as the category parameter.
        /// </para>
        /// <para>
        /// </para> 
        /// </remarks>
	    public PatternLayout Category
	    {
	        get { return m_category; }
	        set { m_category = value; }
	    }

	    #endregion Public Instance Properties

		#region Override implementation of AppenderSkeleton

		/// <summary>
		/// Writes the logging event to the <see cref="System.Diagnostics.Trace"/> system.
		/// </summary>
		/// <param name="loggingEvent">The event to log.</param>
		/// <remarks>
		/// <para>
		/// Writes the logging event to the <see cref="System.Diagnostics.Trace"/> system.
		/// </para>
		/// </remarks>
		override protected void Append(LoggingEvent loggingEvent) 
		{
			//
			// Write the string to the Trace system
			//
#if NETCF
			System.Diagnostics.Debug.Write(RenderLoggingEvent(loggingEvent), m_category.Format(loggingEvent));
#else
            System.Diagnostics.Trace.Write(RenderLoggingEvent(loggingEvent), m_category.Format(loggingEvent));
#endif
	 
			//
			// Flush the Trace system if needed
			//
			if (m_immediateFlush) 
			{
#if NETCF
				System.Diagnostics.Debug.Flush();
#else
				System.Diagnostics.Trace.Flush();
#endif
			} 
		}

		/// <summary>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </summary>
		/// <value><c>true</c></value>
		/// <remarks>
		/// <para>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </para>
		/// </remarks>
		override protected bool RequiresLayout
		{
			get { return true; }
		}

		#endregion Override implementation of AppenderSkeleton

		#region Private Instance Fields

		/// <summary>
		/// Immediate flush means that the underlying writer or output stream
		/// will be flushed at the end of each append operation.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Immediate flush is slower but ensures that each append request is 
		/// actually written. If <see cref="ImmediateFlush"/> is set to
		/// <c>false</c>, then there is a good chance that the last few
		/// logs events are not actually written to persistent media if and
		/// when the application crashes.
		/// </para>
		/// <para>
		/// The default value is <c>true</c>.</para>
		/// </remarks>
		private bool m_immediateFlush = true;

        /// <summary>
        /// Defaults to %logger
        /// </summary>
        private PatternLayout m_category = new PatternLayout("%logger");]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <deprecation>Instead use the default constructor and set the Layout property</deprecation>
          <declaration><![CDATA[private bool m_immediateFlush = true;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="81" sc="3" el="206" ec="73">log4net\Appender\TraceAppender.cs</location>
            <body hash="7867b02ac528b5f5183c14014ad62095"><![CDATA[public TraceAppender(ILayout layout)
		{
			Layout = layout;
		}

		#endregion Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Gets or sets a value that indicates whether the appender will 
		/// flush at the end of each write.
		/// </summary>
		/// <remarks>
		/// <para>The default behavior is to flush at the end of each 
		/// write. If the option is set to<c>false</c>, then the underlying 
		/// stream can defer writing to physical medium to a later time. 
		/// </para>
		/// <para>
		/// Avoiding the flush operation at the end of each append results 
		/// in a performance gain of 10 to 20 percent. However, there is safety
		/// trade-off involved in skipping flushing. Indeed, when flushing is
		/// skipped, then it is likely that the last few log events will not
		/// be recorded on disk when the application exits. This is a high
		/// price to pay even for a 20% performance gain.
		/// </para>
		/// </remarks>
		public bool ImmediateFlush
		{
			get { return m_immediateFlush; }
			set { m_immediateFlush = value; }
		}

        /// <summary>
        /// The category parameter sent to the Trace method.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Defaults to %logger which will use the logger name of the current 
        /// <see cref="LoggingEvent"/> as the category parameter.
        /// </para>
        /// <para>
        /// </para> 
        /// </remarks>
	    public PatternLayout Category
	    {
	        get { return m_category; }
	        set { m_category = value; }
	    }

	    #endregion Public Instance Properties

		#region Override implementation of AppenderSkeleton

		/// <summary>
		/// Writes the logging event to the <see cref="System.Diagnostics.Trace"/> system.
		/// </summary>
		/// <param name="loggingEvent">The event to log.</param>
		/// <remarks>
		/// <para>
		/// Writes the logging event to the <see cref="System.Diagnostics.Trace"/> system.
		/// </para>
		/// </remarks>
		override protected void Append(LoggingEvent loggingEvent) 
		{
			//
			// Write the string to the Trace system
			//
#if NETCF
			System.Diagnostics.Debug.Write(RenderLoggingEvent(loggingEvent), m_category.Format(loggingEvent));
#else
            System.Diagnostics.Trace.Write(RenderLoggingEvent(loggingEvent), m_category.Format(loggingEvent));
#endif
	 
			//
			// Flush the Trace system if needed
			//
			if (m_immediateFlush) 
			{
#if NETCF
				System.Diagnostics.Debug.Flush();
#else
				System.Diagnostics.Trace.Flush();
#endif
			} 
		}

		/// <summary>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </summary>
		/// <value><c>true</c></value>
		/// <remarks>
		/// <para>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </para>
		/// </remarks>
		override protected bool RequiresLayout
		{
			get { return true; }
		}

		#endregion Override implementation of AppenderSkeleton

		#region Private Instance Fields

		/// <summary>
		/// Immediate flush means that the underlying writer or output stream
		/// will be flushed at the end of each append operation.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Immediate flush is slower but ensures that each append request is 
		/// actually written. If <see cref="ImmediateFlush"/> is set to
		/// <c>false</c>, then there is a good chance that the last few
		/// logs events are not actually written to persistent media if and
		/// when the application crashes.
		/// </para>
		/// <para>
		/// The default value is <c>true</c>.</para>
		/// </remarks>
		private bool m_immediateFlush = true;

        /// <summary>
        /// Defaults to %logger
        /// </summary>
        private PatternLayout m_category = new PatternLayout("%logger");]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Append">
          <declaration><![CDATA[protected override void Append(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="145" sc="3" el="166" ec="4">log4net\Appender\TraceAppender.cs</location>
            <body hash="e098ee034ae1659b8b043aad5ebec248"><![CDATA[{
			//
			// Write the string to the Trace system
			//
#if NETCF
			System.Diagnostics.Debug.Write(RenderLoggingEvent(loggingEvent), m_category.Format(loggingEvent));
#else
            System.Diagnostics.Trace.Write(RenderLoggingEvent(loggingEvent), m_category.Format(loggingEvent));
#endif
	 
			//
			// Flush the Trace system if needed
			//
			if (m_immediateFlush) 
			{
#if NETCF
				System.Diagnostics.Debug.Flush();
#else
				System.Diagnostics.Trace.Flush();
#endif
			} 
		}]]></body>
          </codeblock>
        </method>
        <method name="Flush">
          <declaration><![CDATA[public override bool Flush(int millisecondsTimeout)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="216" sc="9" el="227" ec="10">log4net\Appender\TraceAppender.cs</location>
            <body hash="c1ed1b5582337cff8ed1d5468178c10f"><![CDATA[{
            // Nothing to do if ImmediateFlush is true
            if (m_immediateFlush) return true;

            // System.Diagnostics.Trace and System.Diagnostics.Debug are thread-safe, so no need for lock(this).
#if NETCF
			System.Diagnostics.Debug.Flush();
#else
            System.Diagnostics.Trace.Flush();
#endif
            return true;
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_category">
          <declaration><![CDATA[private PatternLayout m_category = new PatternLayout("%logger");]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_immediateFlush">
          <declaration><![CDATA[private bool m_immediateFlush = true;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Category">
          <declaration><![CDATA[public PatternLayout Category]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="ImmediateFlush">
          <declaration><![CDATA[public bool ImmediateFlush]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="RequiresLayout">
          <declaration><![CDATA[protected override bool RequiresLayout]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="UdpAppender">
      <declaration><![CDATA[public class UdpAppender : AppenderSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private Encoding m_encoding = Encoding.Default;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="119" sc="3" el="546" ec="50">log4net\Appender\UdpAppender.cs</location>
            <body hash="df408ba2f53f46154bbae0af870a7c56"><![CDATA[public UdpAppender() 
		{
		}

		#endregion Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Gets or sets the IP address of the remote host or multicast group to which
		/// the underlying <see cref="UdpClient" /> should sent the logging event.
		/// </summary>
		/// <value>
		/// The IP address of the remote host or multicast group to which the logging event 
		/// will be sent.
		/// </value>
		/// <remarks>
		/// <para>
		/// Multicast addresses are identified by IP class <b>D</b> addresses (in the range 224.0.0.0 to
		/// 239.255.255.255).  Multicast packets can pass across different networks through routers, so
		/// it is possible to use multicasts in an Internet scenario as long as your network provider 
		/// supports multicasting.
		/// </para>
		/// <para>
		/// Hosts that want to receive particular multicast messages must register their interest by joining
		/// the multicast group.  Multicast messages are not sent to networks where no host has joined
		/// the multicast group.  Class <b>D</b> IP addresses are used for multicast groups, to differentiate
		/// them from normal host addresses, allowing nodes to easily detect if a message is of interest.
		/// </para>
		/// <para>
		/// Static multicast addresses that are needed globally are assigned by IANA.  A few examples are listed in the table below:
		/// </para>
		/// <para>
		/// <list type="table">
		///     <listheader>
		///         <term>IP Address</term>
		///         <description>Description</description>
		///     </listheader>
		///     <item>
		///         <term>224.0.0.1</term>
		///         <description>
		///             <para>
		///             Sends a message to all system on the subnet.
		///             </para>
		///         </description>
		///     </item>
		///     <item>
		///         <term>224.0.0.2</term>
		///         <description>
		///             <para>
		///             Sends a message to all routers on the subnet.
		///             </para>
		///         </description>
		///     </item>
		///     <item>
		///         <term>224.0.0.12</term>
		///         <description>
		///             <para>
		///             The DHCP server answers messages on the IP address 224.0.0.12, but only on a subnet.
		///             </para>
		///         </description>
		///     </item>
		/// </list>
		/// </para>
		/// <para>
		/// A complete list of actually reserved multicast addresses and their owners in the ranges
		/// defined by RFC 3171 can be found at the <A href="http://www.iana.org/assignments/multicast-addresses">IANA web site</A>. 
		/// </para>
		/// <para>
		/// The address range 239.0.0.0 to 239.255.255.255 is reserved for administrative scope-relative 
		/// addresses.  These addresses can be reused with other local groups.  Routers are typically 
		/// configured with filters to prevent multicast traffic in this range from flowing outside
		/// of the local network.
		/// </para>
		/// </remarks>
		public IPAddress RemoteAddress
		{
			get { return m_remoteAddress; }
			set { m_remoteAddress = value; }
		}

		/// <summary>
		/// Gets or sets the TCP port number of the remote host or multicast group to which 
		/// the underlying <see cref="UdpClient" /> should sent the logging event.
		/// </summary>
		/// <value>
		/// An integer value in the range <see cref="IPEndPoint.MinPort" /> to <see cref="IPEndPoint.MaxPort" /> 
		/// indicating the TCP port number of the remote host or multicast group to which the logging event 
		/// will be sent.
		/// </value>
		/// <remarks>
		/// The underlying <see cref="UdpClient" /> will send messages to this TCP port number
		/// on the remote host or multicast group.
		/// </remarks>
		/// <exception cref="ArgumentOutOfRangeException">The value specified is less than <see cref="IPEndPoint.MinPort" /> or greater than <see cref="IPEndPoint.MaxPort" />.</exception>
		public int RemotePort
		{
			get { return m_remotePort; }
			set 
			{
				if (value < IPEndPoint.MinPort || value > IPEndPoint.MaxPort) 
				{
					throw log4net.Util.SystemInfo.CreateArgumentOutOfRangeException("value", (object)value,
						"The value specified is less than " + 
						IPEndPoint.MinPort.ToString(NumberFormatInfo.InvariantInfo) + 
						" or greater than " + 
						IPEndPoint.MaxPort.ToString(NumberFormatInfo.InvariantInfo) + ".");
				} 
				else 
				{
					m_remotePort = value;
				}
			}
		}

		/// <summary>
		/// Gets or sets the TCP port number from which the underlying <see cref="UdpClient" /> will communicate.
		/// </summary>
		/// <value>
		/// An integer value in the range <see cref="IPEndPoint.MinPort" /> to <see cref="IPEndPoint.MaxPort" /> 
		/// indicating the TCP port number from which the underlying <see cref="UdpClient" /> will communicate.
		/// </value>
		/// <remarks>
		/// <para>
		/// The underlying <see cref="UdpClient" /> will bind to this port for sending messages.
		/// </para>
		/// <para>
		/// Setting the value to 0 (the default) will cause the udp client not to bind to
		/// a local port.
		/// </para>
		/// </remarks>
		/// <exception cref="ArgumentOutOfRangeException">The value specified is less than <see cref="IPEndPoint.MinPort" /> or greater than <see cref="IPEndPoint.MaxPort" />.</exception>
		public int LocalPort
		{
			get { return m_localPort; }
			set 
			{
				if (value != 0 && (value < IPEndPoint.MinPort || value > IPEndPoint.MaxPort))
				{
					throw log4net.Util.SystemInfo.CreateArgumentOutOfRangeException("value", (object)value,
						"The value specified is less than " + 
						IPEndPoint.MinPort.ToString(NumberFormatInfo.InvariantInfo) + 
						" or greater than " + 
						IPEndPoint.MaxPort.ToString(NumberFormatInfo.InvariantInfo) + ".");
				} 
				else 
				{
					m_localPort = value;
				}
			}
		}

		/// <summary>
		/// Gets or sets <see cref="Encoding"/> used to write the packets.
		/// </summary>
		/// <value>
		/// The <see cref="Encoding"/> used to write the packets.
		/// </value>
		/// <remarks>
		/// <para>
		/// The <see cref="Encoding"/> used to write the packets.
		/// </para>
		/// </remarks>
		public Encoding Encoding
		{
			get { return m_encoding; }
			set { m_encoding = value; }
		}

		#endregion Public Instance Properties

		#region Protected Instance Properties

		/// <summary>
		/// Gets or sets the underlying <see cref="UdpClient" />.
		/// </summary>
		/// <value>
		/// The underlying <see cref="UdpClient" />.
		/// </value>
		/// <remarks>
		/// <see cref="UdpAppender" /> creates a <see cref="UdpClient" /> to send logging events 
		/// over a network.  Classes deriving from <see cref="UdpAppender" /> can use this
		/// property to get or set this <see cref="UdpClient" />.  Use the underlying <see cref="UdpClient" />
		/// returned from <see cref="Client" /> if you require access beyond that which 
		/// <see cref="UdpAppender" /> provides.
		/// </remarks>
		protected UdpClient Client
		{
			get { return this.m_client; }
			set { this.m_client = value; }
		}

		/// <summary>
		/// Gets or sets the cached remote endpoint to which the logging events should be sent.
		/// </summary>
		/// <value>
		/// The cached remote endpoint to which the logging events will be sent.
		/// </value>
		/// <remarks>
		/// The <see cref="ActivateOptions" /> method will initialize the remote endpoint 
		/// with the values of the <see cref="RemoteAddress" /> and <see cref="RemotePort"/>
		/// properties.
		/// </remarks>
		protected IPEndPoint RemoteEndPoint
		{
			get { return this.m_remoteEndPoint; }
			set { this.m_remoteEndPoint = value; }
		}

		#endregion Protected Instance Properties

		#region Implementation of IOptionHandler

		/// <summary>
		/// Initialize the appender based on the options set.
		/// </summary>
		/// <remarks>
		/// <para>
		/// This is part of the <see cref="IOptionHandler"/> delayed object
		/// activation scheme. The <see cref="ActivateOptions"/> method must 
		/// be called on this object after the configuration properties have
		/// been set. Until <see cref="ActivateOptions"/> is called this
		/// object is in an undefined state and must not be used. 
		/// </para>
		/// <para>
		/// If any of the configuration properties are modified then 
		/// <see cref="ActivateOptions"/> must be called again.
		/// </para>
		/// <para>
		/// The appender will be ignored if no <see cref="RemoteAddress" /> was specified or 
		/// an invalid remote or local TCP port number was specified.
		/// </para>
		/// </remarks>
		/// <exception cref="ArgumentNullException">The required property <see cref="RemoteAddress" /> was not specified.</exception>
		/// <exception cref="ArgumentOutOfRangeException">The TCP port number assigned to <see cref="LocalPort" /> or <see cref="RemotePort" /> is less than <see cref="IPEndPoint.MinPort" /> or greater than <see cref="IPEndPoint.MaxPort" />.</exception>
		public override void ActivateOptions()
		{
			base.ActivateOptions();

			if (this.RemoteAddress == null) 
			{
				throw new ArgumentNullException("The required property 'Address' was not specified.");
			} 
			else if (this.RemotePort < IPEndPoint.MinPort || this.RemotePort > IPEndPoint.MaxPort) 
			{
				throw log4net.Util.SystemInfo.CreateArgumentOutOfRangeException("this.RemotePort", (object)this.RemotePort,
					"The RemotePort is less than " + 
					IPEndPoint.MinPort.ToString(NumberFormatInfo.InvariantInfo) + 
					" or greater than " + 
					IPEndPoint.MaxPort.ToString(NumberFormatInfo.InvariantInfo) + ".");
			} 
			else if (this.LocalPort != 0 && (this.LocalPort < IPEndPoint.MinPort || this.LocalPort > IPEndPoint.MaxPort))
			{
				throw log4net.Util.SystemInfo.CreateArgumentOutOfRangeException("this.LocalPort", (object)this.LocalPort,
					"The LocalPort is less than " + 
					IPEndPoint.MinPort.ToString(NumberFormatInfo.InvariantInfo) + 
					" or greater than " + 
					IPEndPoint.MaxPort.ToString(NumberFormatInfo.InvariantInfo) + ".");
			} 
			else 
			{
				this.RemoteEndPoint = new IPEndPoint(this.RemoteAddress, this.RemotePort);
				this.InitializeClientConnection();
			}
		}

		#endregion

		#region Override implementation of AppenderSkeleton

		/// <summary>
		/// This method is called by the <see cref="M:AppenderSkeleton.DoAppend(LoggingEvent)"/> method.
		/// </summary>
		/// <param name="loggingEvent">The event to log.</param>
		/// <remarks>
		/// <para>
		/// Sends the event using an UDP datagram.
		/// </para>
		/// <para>
		/// Exceptions are passed to the <see cref="AppenderSkeleton.ErrorHandler"/>.
		/// </para>
		/// </remarks>
		protected override void Append(LoggingEvent loggingEvent) 
		{
			try 
			{
				Byte [] buffer = m_encoding.GetBytes(RenderLoggingEvent(loggingEvent).ToCharArray());
#if NETSTANDARD1_3
				Client.SendAsync(buffer, buffer.Length, RemoteEndPoint).Wait();
#else
				this.Client.Send(buffer, buffer.Length, this.RemoteEndPoint);
#endif
			} 
			catch (Exception ex) 
			{
				ErrorHandler.Error(
					"Unable to send logging event to remote host " + 
					this.RemoteAddress.ToString() + 
					" on port " + 
					this.RemotePort + ".", 
					ex, 
					ErrorCode.WriteFailure);
			}
		}

		/// <summary>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </summary>
		/// <value><c>true</c></value>
		/// <remarks>
		/// <para>
		/// This appender requires a <see cref="Layout"/> to be set.
		/// </para>
		/// </remarks>
		override protected bool RequiresLayout
		{
			get { return true; }
		}

		/// <summary>
		/// Closes the UDP connection and releases all resources associated with 
		/// this <see cref="UdpAppender" /> instance.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Disables the underlying <see cref="UdpClient" /> and releases all managed 
		/// and unmanaged resources associated with the <see cref="UdpAppender" />.
		/// </para>
		/// </remarks>
		override protected void OnClose() 
		{
			base.OnClose();

			if (this.Client != null) 
			{
				this.Client.Close();
				this.Client = null;
			}
		}

		#endregion Override implementation of AppenderSkeleton

		#region Protected Instance Methods

		/// <summary>
		/// Initializes the underlying  <see cref="UdpClient" /> connection.
		/// </summary>
		/// <remarks>
		/// <para>
		/// The underlying <see cref="UdpClient"/> is initialized and binds to the 
		/// port number from which you intend to communicate.
		/// </para>
		/// <para>
		/// Exceptions are passed to the <see cref="AppenderSkeleton.ErrorHandler"/>.
		/// </para>
		/// </remarks>
		protected virtual void InitializeClientConnection() 
		{
			try 
			{
				if (this.LocalPort == 0)
				{
#if NETCF || NET_1_0 || SSCLI_1_0 || CLI_1_0
					this.Client = new UdpClient();
#else
					this.Client = new UdpClient(RemoteAddress.AddressFamily);
#endif
				}
				else
				{
#if NETCF || NET_1_0 || SSCLI_1_0 || CLI_1_0
					this.Client = new UdpClient(this.LocalPort);
#else
					this.Client = new UdpClient(this.LocalPort, RemoteAddress.AddressFamily);
#endif
				}
			} 
			catch (Exception ex) 
			{
				ErrorHandler.Error(
					"Could not initialize the UdpClient connection on port " + 
					this.LocalPort.ToString(NumberFormatInfo.InvariantInfo) + ".", 
					ex, 
					ErrorCode.GenericFailure);

				this.Client = null;
			}
		}

		#endregion Protected Instance Methods

		#region Private Instance Fields

		/// <summary>
		/// The IP address of the remote host or multicast group to which 
		/// the logging event will be sent.
		/// </summary>
		private IPAddress m_remoteAddress;
		
		/// <summary>
		/// The TCP port number of the remote host or multicast group to 
		/// which the logging event will be sent.
		/// </summary>
		private int m_remotePort;

		/// <summary>
		/// The cached remote endpoint to which the logging events will be sent.
		/// </summary>
		private IPEndPoint m_remoteEndPoint;

		/// <summary>
		/// The TCP port number from which the <see cref="UdpClient" /> will communicate.
		/// </summary>
		private int m_localPort;

		/// <summary>
		/// The <see cref="UdpClient" /> instance that will be used for sending the 
		/// logging events.
		/// </summary>
		private UdpClient m_client;

		/// <summary>
		/// The encoding to use for the packet.
		/// </summary>
#if NETSTANDARD1_3
		private Encoding m_encoding = Encoding.Unicode;
#else
		private Encoding m_encoding = Encoding.Default;]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public override void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="355" sc="3" el="383" ec="4">log4net\Appender\UdpAppender.cs</location>
            <body hash="d2d7a29aa0cc54333e9425c791ba08bf"><![CDATA[{
			base.ActivateOptions();

			if (this.RemoteAddress == null) 
			{
				throw new ArgumentNullException("The required property 'Address' was not specified.");
			} 
			else if (this.RemotePort < IPEndPoint.MinPort || this.RemotePort > IPEndPoint.MaxPort) 
			{
				throw log4net.Util.SystemInfo.CreateArgumentOutOfRangeException("this.RemotePort", (object)this.RemotePort,
					"The RemotePort is less than " + 
					IPEndPoint.MinPort.ToString(NumberFormatInfo.InvariantInfo) + 
					" or greater than " + 
					IPEndPoint.MaxPort.ToString(NumberFormatInfo.InvariantInfo) + ".");
			} 
			else if (this.LocalPort != 0 && (this.LocalPort < IPEndPoint.MinPort || this.LocalPort > IPEndPoint.MaxPort))
			{
				throw log4net.Util.SystemInfo.CreateArgumentOutOfRangeException("this.LocalPort", (object)this.LocalPort,
					"The LocalPort is less than " + 
					IPEndPoint.MinPort.ToString(NumberFormatInfo.InvariantInfo) + 
					" or greater than " + 
					IPEndPoint.MaxPort.ToString(NumberFormatInfo.InvariantInfo) + ".");
			} 
			else 
			{
				this.RemoteEndPoint = new IPEndPoint(this.RemoteAddress, this.RemotePort);
				this.InitializeClientConnection();
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Append">
          <declaration><![CDATA[protected override void Append(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="402" sc="3" el="422" ec="4">log4net\Appender\UdpAppender.cs</location>
            <body hash="779028079085ad875b51704a6c106b2c"><![CDATA[{
			try 
			{
				Byte [] buffer = m_encoding.GetBytes(RenderLoggingEvent(loggingEvent).ToCharArray());
#if NETSTANDARD1_3
				Client.SendAsync(buffer, buffer.Length, RemoteEndPoint).Wait();
#else
				this.Client.Send(buffer, buffer.Length, this.RemoteEndPoint);
#endif
			} 
			catch (Exception ex) 
			{
				ErrorHandler.Error(
					"Unable to send logging event to remote host " + 
					this.RemoteAddress.ToString() + 
					" on port " + 
					this.RemotePort + ".", 
					ex, 
					ErrorCode.WriteFailure);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="InitializeClientConnection">
          <declaration><![CDATA[protected virtual void InitializeClientConnection()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="476" sc="3" el="506" ec="4">log4net\Appender\UdpAppender.cs</location>
            <body hash="2950303a3c838cc455cdcf15aa5f38d5"><![CDATA[{
			try 
			{
				if (this.LocalPort == 0)
				{
#if NETCF || NET_1_0 || SSCLI_1_0 || CLI_1_0
					this.Client = new UdpClient();
#else
					this.Client = new UdpClient(RemoteAddress.AddressFamily);
#endif
				}
				else
				{
#if NETCF || NET_1_0 || SSCLI_1_0 || CLI_1_0
					this.Client = new UdpClient(this.LocalPort);
#else
					this.Client = new UdpClient(this.LocalPort, RemoteAddress.AddressFamily);
#endif
				}
			} 
			catch (Exception ex) 
			{
				ErrorHandler.Error(
					"Could not initialize the UdpClient connection on port " + 
					this.LocalPort.ToString(NumberFormatInfo.InvariantInfo) + ".", 
					ex, 
					ErrorCode.GenericFailure);

				this.Client = null;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="OnClose">
          <declaration><![CDATA[protected override void OnClose()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="449" sc="3" el="457" ec="4">log4net\Appender\UdpAppender.cs</location>
            <body hash="ec49f2ca3f96f69dfaf0d09b1187ca13"><![CDATA[{
			base.OnClose();

			if (this.Client != null) 
			{
				this.Client.Close();
				this.Client = null;
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_client">
          <declaration><![CDATA[private UdpClient m_client;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_encoding">
          <declaration><![CDATA[private Encoding m_encoding = Encoding.Default;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_localPort">
          <declaration><![CDATA[private int m_localPort;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_remoteAddress">
          <declaration><![CDATA[private IPAddress m_remoteAddress;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_remoteEndPoint">
          <declaration><![CDATA[private IPEndPoint m_remoteEndPoint;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_remotePort">
          <declaration><![CDATA[private int m_remotePort;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Client">
          <declaration><![CDATA[protected UdpClient Client]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Encoding">
          <declaration><![CDATA[public Encoding Encoding]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="LocalPort">
          <declaration><![CDATA[public int LocalPort]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="255" sc="4" el="268" ec="5">log4net\Appender\UdpAppender.cs</location>
            <body hash="e913285485b188570b9861ec1ceb1ee6"><![CDATA[{
				if (value != 0 && (value < IPEndPoint.MinPort || value > IPEndPoint.MaxPort))
				{
					throw log4net.Util.SystemInfo.CreateArgumentOutOfRangeException("value", (object)value,
						"The value specified is less than " + 
						IPEndPoint.MinPort.ToString(NumberFormatInfo.InvariantInfo) + 
						" or greater than " + 
						IPEndPoint.MaxPort.ToString(NumberFormatInfo.InvariantInfo) + ".");
				} 
				else 
				{
					m_localPort = value;
				}
			}]]></body>
          </codeblock>
        </property>
        <property name="RemoteAddress">
          <declaration><![CDATA[public IPAddress RemoteAddress]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="RemoteEndPoint">
          <declaration><![CDATA[protected IPEndPoint RemoteEndPoint]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="RemotePort">
          <declaration><![CDATA[public int RemotePort]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="218" sc="4" el="231" ec="5">log4net\Appender\UdpAppender.cs</location>
            <body hash="bba6a5fb2cb5d9b2d36d1c0f9cbcbec7"><![CDATA[{
				if (value < IPEndPoint.MinPort || value > IPEndPoint.MaxPort) 
				{
					throw log4net.Util.SystemInfo.CreateArgumentOutOfRangeException("value", (object)value,
						"The value specified is less than " + 
						IPEndPoint.MinPort.ToString(NumberFormatInfo.InvariantInfo) + 
						" or greater than " + 
						IPEndPoint.MaxPort.ToString(NumberFormatInfo.InvariantInfo) + ".");
				} 
				else 
				{
					m_remotePort = value;
				}
			}]]></body>
          </codeblock>
        </property>
        <property name="RequiresLayout">
          <declaration><![CDATA[protected override bool RequiresLayout]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="log4net.Config">
    <class name="AliasDomainAttribute">
      <deprecation>Use AliasRepositoryAttribute instead of AliasDomainAttribute</deprecation>
      <declaration><![CDATA[public sealed class AliasDomainAttribute : AliasRepositoryAttribute]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public AliasDomainAttribute(string name) : base(name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="66" sc="46" el="68" ec="4">log4net\Config\AliasDomainAttribute.cs</location>
            <body hash="d8baaca86fe7813fff1228ee9fa69a44"><![CDATA[base(name)
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="AliasRepositoryAttribute">
      <declaration><![CDATA[public class AliasRepositoryAttribute : Attribute]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private string m_name = null;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="67" sc="3" el="97" ec="32">log4net\Config\AliasRepositoryAttribute.cs</location>
            <body hash="d84799ab9e839b192397348c9581297c"><![CDATA[public AliasRepositoryAttribute(string name)
		{
			Name = name;
		}

		#endregion Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Gets or sets the repository to alias to this assembly's repository.
		/// </summary>
		/// <value>
		/// The repository to alias to this assemby's repository.
		/// </value>
		/// <remarks>
		/// <para>
		/// The name of the repository to alias to this assembly's repository.
		/// </para>
		/// </remarks>
		public string Name
		{
			get { return m_name; }
			set { m_name = value ; }
		}

		#endregion Public Instance Properties

		#region Private Instance Fields

		private string m_name = null;]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="m_name">
          <declaration><![CDATA[private string m_name = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Name">
          <declaration><![CDATA[public string Name]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="BasicConfigurator">
      <declaration><![CDATA[public sealed class BasicConfigurator]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private BasicConfigurator()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="77" sc="3" el="79" ec="4">log4net\Config\BasicConfigurator.cs</location>
            <body hash="c0ca7db214e2605abb996c2689c1e3f9"><![CDATA[private BasicConfigurator()
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static BasicConfigurator()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="63" sc="6" el="63" ec="77">log4net\Config\BasicConfigurator.cs</location>
            <body hash="3c39520a3a0c8f73600595246e98b374"><![CDATA[private readonly static Type declaringType = typeof(BasicConfigurator)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Configure">
          <declaration><![CDATA[public static ICollection Configure()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="99" sc="3" el="101" ec="10">log4net\Config\BasicConfigurator.cs</location>
            <body hash="29592b1d23879582f8d61e9c1992e74c"><![CDATA[{
            return BasicConfigurator.Configure(LogManager.GetRepository(Assembly.GetCallingAssembly()));
        }]]></body>
          </codeblock>
        </method>
        <method name="Configure">
          <declaration><![CDATA[public static ICollection Configure(params IAppender[] appenders)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="113" sc="9" el="126" ec="10">log4net\Config\BasicConfigurator.cs</location>
            <body hash="995442e7134ba855ab3425629a20ee96"><![CDATA[{
            ArrayList configurationMessages = new ArrayList();

            ILoggerRepository repository = LogManager.GetRepository(Assembly.GetCallingAssembly());

            using (new LogLog.LogReceivedAdapter(configurationMessages))
            {
                InternalConfigure(repository, appenders);
            }

            repository.ConfigurationMessages = configurationMessages;

            return configurationMessages;
        }]]></body>
          </codeblock>
        </method>
        <method name="Configure">
          <declaration><![CDATA[public static ICollection Configure(IAppender appender)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="138" sc="3" el="140" ec="4">log4net\Config\BasicConfigurator.cs</location>
            <body hash="fb389a2840799cd5e8d2ff7b451193e1"><![CDATA[{
            return Configure(new IAppender[] { appender });
		}]]></body>
          </codeblock>
        </method>
        <method name="Configure">
          <declaration><![CDATA[public static ICollection Configure(ILoggerRepository repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="157" sc="3" el="178" ec="4">log4net\Config\BasicConfigurator.cs</location>
            <body hash="9878c8a85466e2dbaf0d69c0b625d0bd"><![CDATA[{
            ArrayList configurationMessages = new ArrayList();

            using (new LogLog.LogReceivedAdapter(configurationMessages))
            {
                // Create the layout
                PatternLayout layout = new PatternLayout();
                layout.ConversionPattern = PatternLayout.DetailConversionPattern;
                layout.ActivateOptions();

                // Create the appender
                ConsoleAppender appender = new ConsoleAppender();
                appender.Layout = layout;
                appender.ActivateOptions();

                InternalConfigure(repository, appender);
            }

            repository.ConfigurationMessages = configurationMessages;

            return configurationMessages;
		}]]></body>
          </codeblock>
        </method>
        <method name="Configure">
          <declaration><![CDATA[public static ICollection Configure(ILoggerRepository repository, IAppender appender)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="191" sc="9" el="193" ec="10">log4net\Config\BasicConfigurator.cs</location>
            <body hash="825c7e8538b6019487977ba05eeff2b7"><![CDATA[{
            return Configure(repository, new IAppender[] { appender });
        }]]></body>
          </codeblock>
        </method>
        <method name="Configure">
          <declaration><![CDATA[public static ICollection Configure(ILoggerRepository repository, params IAppender[] appenders)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="206" sc="9" el="217" ec="10">log4net\Config\BasicConfigurator.cs</location>
            <body hash="996b676f6f33fabd146a627fcb1d80e0"><![CDATA[{
            ArrayList configurationMessages = new ArrayList();

            using (new LogLog.LogReceivedAdapter(configurationMessages))
            {
                InternalConfigure(repository, appenders);
            }

            repository.ConfigurationMessages = configurationMessages;

            return configurationMessages;
        }]]></body>
          </codeblock>
        </method>
        <method name="InternalConfigure">
          <declaration><![CDATA[private static void InternalConfigure(ILoggerRepository repository, params IAppender[] appenders)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="220" sc="3" el="230" ec="4">log4net\Config\BasicConfigurator.cs</location>
            <body hash="f6c3782679ff3caf77e4fb34a191b12e"><![CDATA[{
            IBasicRepositoryConfigurator configurableRepository = repository as IBasicRepositoryConfigurator;
            if (configurableRepository != null)
            {
                configurableRepository.Configure(appenders);
            }
            else
            {
                LogLog.Warn(declaringType, "BasicConfigurator: Repository [" + repository + "] does not support the BasicConfigurator");
            }
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(BasicConfigurator);]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="ConfiguratorAttribute">
      <declaration><![CDATA[public abstract class ConfiguratorAttribute : Attribute, IComparable]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_priority = 0;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="44" sc="3" el="60" ec="4">log4net\Config\ConfiguratorAttribute.cs</location>
            <body hash="67913807b510d942f06493455ca634d3"><![CDATA[private int m_priority = 0;

		/// <summary>
		/// Constructor used by subclasses.
		/// </summary>
		/// <param name="priority">the ordering priority for this configurator</param>
		/// <remarks>
		/// <para>
		/// The <paramref name="priority"/> is used to order the configurator
		/// attributes before they are invoked. Higher priority configurators are executed
		/// before lower priority ones.
		/// </para>
		/// </remarks>
		protected ConfiguratorAttribute(int priority)
		{
			m_priority = priority;
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CompareTo">
          <declaration><![CDATA[public int CompareTo(object obj)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="88" sc="3" el="109" ec="4">log4net\Config\ConfiguratorAttribute.cs</location>
            <body hash="72961706371e592251401c3d26fafde6"><![CDATA[{
			// Reference equals
			if ((object)this == obj)
			{
				return 0;
			}

			int result = -1;

			ConfiguratorAttribute target = obj as ConfiguratorAttribute;
			if (target != null)
			{
				// Compare the priorities
				result = target.m_priority.CompareTo(m_priority);
				if (result == 0)
				{
					// Same priority, so have to provide some ordering
					result = -1;
				}
			}
			return result;
		}]]></body>
          </codeblock>
        </method>
        <method name="Configure">
          <declaration><![CDATA[public abstract void Configure(Assembly sourceAssembly, ILoggerRepository targetRepository);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_priority">
          <declaration><![CDATA[private int m_priority = 0;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="DomainAttribute">
      <deprecation>Use RepositoryAttribute instead of DomainAttribute</deprecation>
      <declaration><![CDATA[public sealed class DomainAttribute : RepositoryAttribute]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public DomainAttribute()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="65" sc="30" el="67" ec="4">log4net\Config\DomainAttribute.cs</location>
            <body hash="f89283f9c37548ffdc754964dc9b26fe"><![CDATA[base()
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public DomainAttribute(string name) : base(name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="79" sc="41" el="81" ec="4">log4net\Config\DomainAttribute.cs</location>
            <body hash="d8baaca86fe7813fff1228ee9fa69a44"><![CDATA[base(name)
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="DOMConfigurator">
      <deprecation>Use XmlConfigurator instead of DOMConfigurator</deprecation>
      <declaration><![CDATA[public sealed class DOMConfigurator]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private DOMConfigurator()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="54" sc="3" el="56" ec="4">log4net\Config\DOMConfigurator.cs</location>
            <body hash="86867b1e7a0aec13113ffbdf3b4b43de"><![CDATA[private DOMConfigurator() 
		{ 
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Configure">
          <deprecation>Use XmlConfigurator.Configure instead of DOMConfigurator.Configure</deprecation>
          <declaration><![CDATA[public static void Configure()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="78" sc="3" el="80" ec="4">log4net\Config\DOMConfigurator.cs</location>
            <body hash="d4170f76c3ed956cb0cc636af4eed365"><![CDATA[{
			XmlConfigurator.Configure(LogManager.GetRepository(Assembly.GetCallingAssembly()));
		}]]></body>
          </codeblock>
        </method>
        <method name="Configure">
          <deprecation>Use XmlConfigurator.Configure instead of DOMConfigurator.Configure</deprecation>
          <declaration><![CDATA[public static void Configure(ILoggerRepository repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="99" sc="3" el="101" ec="4">log4net\Config\DOMConfigurator.cs</location>
            <body hash="78661b6fc6e2aa0abbed7d8598b681e1"><![CDATA[{
			XmlConfigurator.Configure(repository);
		}]]></body>
          </codeblock>
        </method>
        <method name="Configure">
          <deprecation>Use XmlConfigurator.Configure instead of DOMConfigurator.Configure</deprecation>
          <declaration><![CDATA[public static void Configure(XmlElement element)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="116" sc="3" el="118" ec="4">log4net\Config\DOMConfigurator.cs</location>
            <body hash="717ee50c7498b3e38e95ff60dee06449"><![CDATA[{
			XmlConfigurator.Configure(LogManager.GetRepository(Assembly.GetCallingAssembly()), element);
		}]]></body>
          </codeblock>
        </method>
        <method name="Configure">
          <deprecation>Use XmlConfigurator.Configure instead of DOMConfigurator.Configure</deprecation>
          <declaration><![CDATA[public static void Configure(ILoggerRepository repository, XmlElement element)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="135" sc="3" el="137" ec="4">log4net\Config\DOMConfigurator.cs</location>
            <body hash="f8b97fdb267b615d006b89a2340aa539"><![CDATA[{
			XmlConfigurator.Configure(repository, element);
		}]]></body>
          </codeblock>
        </method>
        <method name="Configure">
          <deprecation>Use XmlConfigurator.Configure instead of DOMConfigurator.Configure</deprecation>
          <declaration><![CDATA[public static void Configure(FileInfo configFile)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="183" sc="3" el="185" ec="4">log4net\Config\DOMConfigurator.cs</location>
            <body hash="56403f8202e2a4a04fc0a2714feab21c"><![CDATA[{
			XmlConfigurator.Configure(LogManager.GetRepository(Assembly.GetCallingAssembly()), configFile);
		}]]></body>
          </codeblock>
        </method>
        <method name="Configure">
          <deprecation>Use XmlConfigurator.Configure instead of DOMConfigurator.Configure</deprecation>
          <declaration><![CDATA[public static void Configure(Stream configStream)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="206" sc="3" el="208" ec="4">log4net\Config\DOMConfigurator.cs</location>
            <body hash="2234c0f3e26a2c57f0fcd7ad29d570cd"><![CDATA[{
			XmlConfigurator.Configure(LogManager.GetRepository(Assembly.GetCallingAssembly()), configStream);
		}]]></body>
          </codeblock>
        </method>
        <method name="Configure">
          <deprecation>Use XmlConfigurator.Configure instead of DOMConfigurator.Configure</deprecation>
          <declaration><![CDATA[public static void Configure(ILoggerRepository repository, FileInfo configFile)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="256" sc="3" el="258" ec="4">log4net\Config\DOMConfigurator.cs</location>
            <body hash="be6bcb9c9bbb004d7d10fff3dc951026"><![CDATA[{
			XmlConfigurator.Configure(repository, configFile);
		}]]></body>
          </codeblock>
        </method>
        <method name="Configure">
          <deprecation>Use XmlConfigurator.Configure instead of DOMConfigurator.Configure</deprecation>
          <declaration><![CDATA[public static void Configure(ILoggerRepository repository, Stream configStream)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="282" sc="3" el="284" ec="4">log4net\Config\DOMConfigurator.cs</location>
            <body hash="9f91a0ba9206d13fdea0638fa583c5d2"><![CDATA[{
			XmlConfigurator.Configure(repository, configStream);
		}]]></body>
          </codeblock>
        </method>
        <method name="ConfigureAndWatch">
          <deprecation>Use XmlConfigurator.ConfigureAndWatch instead of DOMConfigurator.ConfigureAndWatch</deprecation>
          <declaration><![CDATA[public static void ConfigureAndWatch(FileInfo configFile)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="318" sc="3" el="320" ec="4">log4net\Config\DOMConfigurator.cs</location>
            <body hash="6abf420299cbb12126825a9b3ed8badd"><![CDATA[{
			XmlConfigurator.ConfigureAndWatch(LogManager.GetRepository(Assembly.GetCallingAssembly()), configFile);
		}]]></body>
          </codeblock>
        </method>
        <method name="ConfigureAndWatch">
          <deprecation>Use XmlConfigurator.ConfigureAndWatch instead of DOMConfigurator.ConfigureAndWatch</deprecation>
          <declaration><![CDATA[public static void ConfigureAndWatch(ILoggerRepository repository, FileInfo configFile)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="350" sc="3" el="352" ec="4">log4net\Config\DOMConfigurator.cs</location>
            <body hash="235139f2f71a519349bd12751f81da88"><![CDATA[{
			XmlConfigurator.ConfigureAndWatch(repository, configFile);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="DOMConfiguratorAttribute">
      <deprecation>Use XmlConfiguratorAttribute instead of DOMConfiguratorAttribute</deprecation>
      <declaration><![CDATA[public sealed class DOMConfiguratorAttribute : XmlConfiguratorAttribute]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public DOMConfiguratorAttribute()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="Log4NetConfigurationSectionHandler">
      <declaration><![CDATA[public class Log4NetConfigurationSectionHandler : IConfigurationSectionHandler]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public Log4NetConfigurationSectionHandler()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="63" sc="3" el="65" ec="4">log4net\Config\Log4NetConfigurationSectionHandler.cs</location>
            <body hash="7270ade9f5f89bcf856198c9cacfa89f"><![CDATA[public Log4NetConfigurationSectionHandler()
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Create">
          <declaration><![CDATA[public object Create(object parent, object configContext, XmlNode section)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="84" sc="3" el="86" ec="4">log4net\Config\Log4NetConfigurationSectionHandler.cs</location>
            <body hash="027bc13073db99c7bcefa42c3d5a5490"><![CDATA[{
			return section;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="PluginAttribute">
      <declaration><![CDATA[public sealed class PluginAttribute : Attribute, IPluginFactory]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private string m_typeName = null;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="66" sc="3" el="192" ec="30">log4net\Config\PluginAttribute.cs</location>
            <body hash="373a3778264c7e9e611012623466d3b1"><![CDATA[public PluginAttribute(string typeName)
		{
			m_typeName = typeName;
		}
#endif

		/// <summary>
		/// Initializes a new instance of the <see cref="PluginAttribute" /> class
		/// with the specified type.
		/// </summary>
		/// <param name="type">The type of plugin to create.</param>
		/// <remarks>
		/// <para>
		/// Create the attribute with the plugin type specified.
		/// </para>
		/// </remarks>
		public PluginAttribute(Type type)
		{
			m_type = type;
		}

		#endregion Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Gets or sets the type for the plugin.
		/// </summary>
		/// <value>
		/// The type for the plugin.
		/// </value>
		/// <remarks>
		/// <para>
		/// The type for the plugin.
		/// </para>
		/// </remarks>
		public Type Type
		{
			get { return m_type; }
			set { m_type = value ; }
		}

		/// <summary>
		/// Gets or sets the type name for the plugin.
		/// </summary>
		/// <value>
		/// The type name for the plugin.
		/// </value>
		/// <remarks>
		/// <para>
		/// The type name for the plugin.
		/// </para>
		/// <para>
		/// Where possible use the <see cref="Type"/> property instead.
		/// </para>
		/// </remarks>
		public string TypeName
		{
			get { return m_typeName; }
			set { m_typeName = value ; }
		}

		#endregion Public Instance Properties

		#region Implementation of IPluginFactory

		/// <summary>
		/// Creates the plugin object defined by this attribute.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Creates the instance of the <see cref="IPlugin"/> object as 
		/// specified by this attribute.
		/// </para>
		/// </remarks>
		/// <returns>The plugin object.</returns>
		public IPlugin CreatePlugin()
		{
			Type pluginType = m_type;
#if !NETSTANDARD1_3
			if (m_type == null)
			{
				// Get the plugin object type from the string type name
				pluginType = SystemInfo.GetTypeFromString(m_typeName, true, true);
			}
#endif
			// Check that the type is a plugin
			if (!(typeof(IPlugin).IsAssignableFrom(pluginType)))
			{
				throw new LogException("Plugin type [" + pluginType.FullName + "] does not implement the log4net.IPlugin interface");
			}

			// Create an instance of the plugin using the default constructor
			IPlugin plugin = (IPlugin)Activator.CreateInstance(pluginType);

			return plugin;
		}

		#endregion Implementation of IPluginFactory

		#region Override implementation of Object

		/// <summary>
		/// Returns a representation of the properties of this object.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Overrides base class <see cref="M:Object.ToString()" /> method to 
		/// return a representation of the properties of this object.
		/// </para>
		/// </remarks>
		/// <returns>A representation of the properties of this object</returns>
		override public string ToString()
		{
			if (m_type != null)
			{
				return "PluginAttribute[Type=" + m_type.FullName + "]";
			}
			return "PluginAttribute[Type=" + m_typeName + "]";
		}

		#endregion Override implementation of Object

		#region Private Instance Fields

		private string m_typeName = null;
		private Type m_type = null;]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private string m_typeName = null;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="82" sc="3" el="192" ec="30">log4net\Config\PluginAttribute.cs</location>
            <body hash="5da31d4ce8d4e6faad8dc21c55b8a8ab"><![CDATA[public PluginAttribute(Type type)
		{
			m_type = type;
		}

		#endregion Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Gets or sets the type for the plugin.
		/// </summary>
		/// <value>
		/// The type for the plugin.
		/// </value>
		/// <remarks>
		/// <para>
		/// The type for the plugin.
		/// </para>
		/// </remarks>
		public Type Type
		{
			get { return m_type; }
			set { m_type = value ; }
		}

		/// <summary>
		/// Gets or sets the type name for the plugin.
		/// </summary>
		/// <value>
		/// The type name for the plugin.
		/// </value>
		/// <remarks>
		/// <para>
		/// The type name for the plugin.
		/// </para>
		/// <para>
		/// Where possible use the <see cref="Type"/> property instead.
		/// </para>
		/// </remarks>
		public string TypeName
		{
			get { return m_typeName; }
			set { m_typeName = value ; }
		}

		#endregion Public Instance Properties

		#region Implementation of IPluginFactory

		/// <summary>
		/// Creates the plugin object defined by this attribute.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Creates the instance of the <see cref="IPlugin"/> object as 
		/// specified by this attribute.
		/// </para>
		/// </remarks>
		/// <returns>The plugin object.</returns>
		public IPlugin CreatePlugin()
		{
			Type pluginType = m_type;
#if !NETSTANDARD1_3
			if (m_type == null)
			{
				// Get the plugin object type from the string type name
				pluginType = SystemInfo.GetTypeFromString(m_typeName, true, true);
			}
#endif
			// Check that the type is a plugin
			if (!(typeof(IPlugin).IsAssignableFrom(pluginType)))
			{
				throw new LogException("Plugin type [" + pluginType.FullName + "] does not implement the log4net.IPlugin interface");
			}

			// Create an instance of the plugin using the default constructor
			IPlugin plugin = (IPlugin)Activator.CreateInstance(pluginType);

			return plugin;
		}

		#endregion Implementation of IPluginFactory

		#region Override implementation of Object

		/// <summary>
		/// Returns a representation of the properties of this object.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Overrides base class <see cref="M:Object.ToString()" /> method to 
		/// return a representation of the properties of this object.
		/// </para>
		/// </remarks>
		/// <returns>A representation of the properties of this object</returns>
		override public string ToString()
		{
			if (m_type != null)
			{
				return "PluginAttribute[Type=" + m_type.FullName + "]";
			}
			return "PluginAttribute[Type=" + m_typeName + "]";
		}

		#endregion Override implementation of Object

		#region Private Instance Fields

		private string m_typeName = null;
		private Type m_type = null;]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CreatePlugin">
          <declaration><![CDATA[public IPlugin CreatePlugin()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="143" sc="3" el="162" ec="4">log4net\Config\PluginAttribute.cs</location>
            <body hash="5eb5d77d8d3f104a6d34b51f4c860680"><![CDATA[{
			Type pluginType = m_type;
#if !NETSTANDARD1_3
			if (m_type == null)
			{
				// Get the plugin object type from the string type name
				pluginType = SystemInfo.GetTypeFromString(m_typeName, true, true);
			}
#endif
			// Check that the type is a plugin
			if (!(typeof(IPlugin).IsAssignableFrom(pluginType)))
			{
				throw new LogException("Plugin type [" + pluginType.FullName + "] does not implement the log4net.IPlugin interface");
			}

			// Create an instance of the plugin using the default constructor
			IPlugin plugin = (IPlugin)Activator.CreateInstance(pluginType);

			return plugin;
		}]]></body>
          </codeblock>
        </method>
        <method name="ToString">
          <declaration><![CDATA[public override string ToString()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="179" sc="3" el="185" ec="4">log4net\Config\PluginAttribute.cs</location>
            <body hash="d6e808bda77837cf268164230886d0b8"><![CDATA[{
			if (m_type != null)
			{
				return "PluginAttribute[Type=" + m_type.FullName + "]";
			}
			return "PluginAttribute[Type=" + m_typeName + "]";
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_type">
          <declaration><![CDATA[private Type m_type = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_typeName">
          <declaration><![CDATA[private string m_typeName = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Type">
          <declaration><![CDATA[public Type Type]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="TypeName">
          <declaration><![CDATA[public string TypeName]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="RepositoryAttribute">
      <declaration><![CDATA[public class RepositoryAttribute : Attribute]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private string m_name = null;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="65" sc="3" el="138" ec="40">log4net\Config\RepositoryAttribute.cs</location>
            <body hash="0e074fb3ba7e9dc6e4676c264cf972a7"><![CDATA[public RepositoryAttribute()
		{
		}

		/// <summary>
		/// Initialize a new instance of the <see cref="RepositoryAttribute" /> class 
		/// with the name of the repository.
		/// </summary>
		/// <param name="name">The name of the repository.</param>
		/// <remarks>
		/// <para>
		/// Initialize the attribute with the name for the assembly's repository.
		/// </para>
		/// </remarks>
		public RepositoryAttribute(string name)
		{
			m_name = name;
		}

		#endregion Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Gets or sets the name of the logging repository.
		/// </summary>
		/// <value>
		/// The string name to use as the name of the repository associated with this
		/// assembly.
		/// </value>
		/// <remarks>
		/// <para>
		/// This value does not have to be unique. Several assemblies can share the
		/// same repository. They will share the logging configuration of the repository.
		/// </para>
		/// </remarks>
		public string Name
		{
			get { return m_name; }
			set { m_name = value ; }
		}

		/// <summary>
		/// Gets or sets the type of repository to create for this assembly.
		/// </summary>
		/// <value>
		/// The type of repository to create for this assembly.
		/// </value>
		/// <remarks>
		/// <para>
		/// The type of the repository to create for the assembly.
		/// The type must implement the <see cref="log4net.Repository.ILoggerRepository"/>
		/// interface.
		/// </para>
		/// <para>
		/// This will be the type of repository created when 
		/// the repository is created. If multiple assemblies reference the
		/// same repository then the repository is only created once using the
		/// <see cref="RepositoryType" /> of the first assembly to call into the 
		/// repository.
		/// </para>
		/// </remarks>
		public Type RepositoryType
		{
			get { return m_repositoryType; }
			set { m_repositoryType = value ; }
		}

		#endregion Public Instance Properties

		#region Private Instance Fields

		private string m_name = null;
		private Type m_repositoryType = null;]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private string m_name = null;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="79" sc="3" el="138" ec="40">log4net\Config\RepositoryAttribute.cs</location>
            <body hash="a77e5feb9ecc95364083f071b58d5cce"><![CDATA[public RepositoryAttribute(string name)
		{
			m_name = name;
		}

		#endregion Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Gets or sets the name of the logging repository.
		/// </summary>
		/// <value>
		/// The string name to use as the name of the repository associated with this
		/// assembly.
		/// </value>
		/// <remarks>
		/// <para>
		/// This value does not have to be unique. Several assemblies can share the
		/// same repository. They will share the logging configuration of the repository.
		/// </para>
		/// </remarks>
		public string Name
		{
			get { return m_name; }
			set { m_name = value ; }
		}

		/// <summary>
		/// Gets or sets the type of repository to create for this assembly.
		/// </summary>
		/// <value>
		/// The type of repository to create for this assembly.
		/// </value>
		/// <remarks>
		/// <para>
		/// The type of the repository to create for the assembly.
		/// The type must implement the <see cref="log4net.Repository.ILoggerRepository"/>
		/// interface.
		/// </para>
		/// <para>
		/// This will be the type of repository created when 
		/// the repository is created. If multiple assemblies reference the
		/// same repository then the repository is only created once using the
		/// <see cref="RepositoryType" /> of the first assembly to call into the 
		/// repository.
		/// </para>
		/// </remarks>
		public Type RepositoryType
		{
			get { return m_repositoryType; }
			set { m_repositoryType = value ; }
		}

		#endregion Public Instance Properties

		#region Private Instance Fields

		private string m_name = null;
		private Type m_repositoryType = null;]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="m_name">
          <declaration><![CDATA[private string m_name = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_repositoryType">
          <declaration><![CDATA[private Type m_repositoryType = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Name">
          <declaration><![CDATA[public string Name]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="RepositoryType">
          <declaration><![CDATA[public Type RepositoryType]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="SecurityContextProviderAttribute">
      <declaration><![CDATA[public sealed class SecurityContextProviderAttribute : ConfiguratorAttribute]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private Type m_providerType = null;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="63" sc="64" el="132" ec="38">log4net\Config\SecurityContextProviderAttribute.cs</location>
            <body hash="edcf38e5a5c3f4d6e268c728e48257b4"><![CDATA[base(100) /* configurator priority 100 to execute before the XmlConfigurator */
		{
			m_providerType = providerType;
		}

		#endregion

		#region Public Instance Properties

		/// <summary>
		/// Gets or sets the type of the provider to use.
		/// </summary>
		/// <value>
		/// the type of the provider to use.
		/// </value>
		/// <remarks>
		/// <para>
		/// The provider specified must subclass the <see cref="SecurityContextProvider"/>
		/// class.
		/// </para>
		/// </remarks>
		public Type ProviderType
		{
			get { return m_providerType; }
			set { m_providerType = value; }
		}

		#endregion Public Instance Properties

		#region Override ConfiguratorAttribute

		/// <summary>
		/// Configures the SecurityContextProvider
		/// </summary>
		/// <param name="sourceAssembly">The assembly that this attribute was defined on.</param>
		/// <param name="targetRepository">The repository to configure.</param>
		/// <remarks>
		/// <para>
		/// Creates a provider instance from the <see cref="ProviderType"/> specified.
		/// Sets this as the default security context provider <see cref="SecurityContextProvider.DefaultProvider"/>.
		/// </para>
		/// </remarks>
		override public void Configure(Assembly sourceAssembly, ILoggerRepository targetRepository)
		{
			if (m_providerType == null)
			{
				LogLog.Error(declaringType, "Attribute specified on assembly ["+sourceAssembly.FullName+"] with null ProviderType.");
			}
			else
			{
				LogLog.Debug(declaringType, "Creating provider of type ["+ m_providerType.FullName +"]");

				SecurityContextProvider provider = Activator.CreateInstance(m_providerType) as SecurityContextProvider;

				if (provider == null)
				{
					LogLog.Error(declaringType, "Failed to create SecurityContextProvider instance of type ["+m_providerType.Name+"].");
				}
				else
				{
					SecurityContextProvider.DefaultProvider = provider;
				}
			}
		}

		#endregion

		#region Private Instance Fields

		private Type m_providerType = null;]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static SecurityContextProviderAttribute()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="145" sc="6" el="145" ec="92">log4net\Config\SecurityContextProviderAttribute.cs</location>
            <body hash="d5091e1dfa4acd4e3b32792d67e0dfa4"><![CDATA[private readonly static Type declaringType = typeof(SecurityContextProviderAttribute)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Configure">
          <declaration><![CDATA[public override void Configure(Assembly sourceAssembly, ILoggerRepository targetRepository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="106" sc="3" el="126" ec="4">log4net\Config\SecurityContextProviderAttribute.cs</location>
            <body hash="3b6a1f16147a43bf62e8df33673f47eb"><![CDATA[{
			if (m_providerType == null)
			{
				LogLog.Error(declaringType, "Attribute specified on assembly ["+sourceAssembly.FullName+"] with null ProviderType.");
			}
			else
			{
				LogLog.Debug(declaringType, "Creating provider of type ["+ m_providerType.FullName +"]");

				SecurityContextProvider provider = Activator.CreateInstance(m_providerType) as SecurityContextProvider;

				if (provider == null)
				{
					LogLog.Error(declaringType, "Failed to create SecurityContextProvider instance of type ["+m_providerType.Name+"].");
				}
				else
				{
					SecurityContextProvider.DefaultProvider = provider;
				}
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(SecurityContextProviderAttribute);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_providerType">
          <declaration><![CDATA[private Type m_providerType = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="ProviderType">
          <declaration><![CDATA[public Type ProviderType]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="XmlConfigurator">
      <declaration><![CDATA[public sealed class XmlConfigurator]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private XmlConfigurator()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="51" sc="3" el="53" ec="4">log4net\Config\XmlConfigurator.cs</location>
            <body hash="27e3fb49a1e689199204218032c20727"><![CDATA[private XmlConfigurator() 
		{ 
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static XmlConfigurator()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1125" sc="9" el="1134" ec="75">log4net\Config\XmlConfigurator.cs</location>
            <body hash="e13f0803b8653ac2f7b8875f2b1f2740"><![CDATA[private readonly static Hashtable m_repositoryName2ConfigAndWatchHandler = new Hashtable();

	    /// <summary>
	    /// The fully qualified type of the XmlConfigurator class.
	    /// </summary>
	    /// <remarks>
	    /// Used by the internal logger to record the Type of the
	    /// log message.
	    /// </remarks>
	    private readonly static Type declaringType = typeof(XmlConfigurator);]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Configure">
          <declaration><![CDATA[public static ICollection Configure(ILoggerRepository repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="97" sc="9" el="108" ec="10">log4net\Config\XmlConfigurator.cs</location>
            <body hash="85ac522ede70ab1f4094129318899acc"><![CDATA[{
            ArrayList configurationMessages = new ArrayList();

            using (new LogLog.LogReceivedAdapter(configurationMessages))
            {
                InternalConfigure(repository);
            }

            repository.ConfigurationMessages = configurationMessages;

            return configurationMessages;
        }]]></body>
          </codeblock>
        </method>
        <method name="Configure">
          <declaration><![CDATA[public static ICollection Configure()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="202" sc="9" el="204" ec="10">log4net\Config\XmlConfigurator.cs</location>
            <body hash="45eff1bdf962816642a78acb68378c02"><![CDATA[{
            return Configure(LogManager.GetRepository(Assembly.GetCallingAssembly()));
        }]]></body>
          </codeblock>
        </method>
        <method name="Configure">
          <declaration><![CDATA[public static ICollection Configure(XmlElement element)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="217" sc="3" el="230" ec="4">log4net\Config\XmlConfigurator.cs</location>
            <body hash="07ad5881e703c1199076b9071295ac0a"><![CDATA[{
            ArrayList configurationMessages = new ArrayList();

            ILoggerRepository repository = LogManager.GetRepository(Assembly.GetCallingAssembly());

            using (new LogLog.LogReceivedAdapter(configurationMessages))
            {
                InternalConfigureFromXml(repository, element);
            }

            repository.ConfigurationMessages = configurationMessages;

            return configurationMessages;
		}]]></body>
          </codeblock>
        </method>
        <method name="Configure">
          <declaration><![CDATA[public static ICollection Configure(FileInfo configFile)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="320" sc="3" el="329" ec="4">log4net\Config\XmlConfigurator.cs</location>
            <body hash="c1676485e60e54d0a9a223d9852699bb"><![CDATA[{
            ArrayList configurationMessages = new ArrayList();

            using (new LogLog.LogReceivedAdapter(configurationMessages))
            {
                InternalConfigure(LogManager.GetRepository(Assembly.GetCallingAssembly()), configFile);
            }

            return configurationMessages;
		}]]></body>
          </codeblock>
        </method>
        <method name="Configure">
          <declaration><![CDATA[public static ICollection Configure(Uri configUri)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="346" sc="3" el="358" ec="4">log4net\Config\XmlConfigurator.cs</location>
            <body hash="abc0402785e473df7ec9912ef925d4e6"><![CDATA[{
            ArrayList configurationMessages = new ArrayList();

            ILoggerRepository repository = LogManager.GetRepository(Assembly.GetCallingAssembly());
            using (new LogLog.LogReceivedAdapter(configurationMessages))
            {
                InternalConfigure(repository, configUri);
            }

            repository.ConfigurationMessages = configurationMessages;

            return configurationMessages;
		}]]></body>
          </codeblock>
        </method>
        <method name="Configure">
          <declaration><![CDATA[public static ICollection Configure(Stream configStream)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="375" sc="3" el="387" ec="4">log4net\Config\XmlConfigurator.cs</location>
            <body hash="1b77a253241b06ce4729da355836b8ef"><![CDATA[{
            ArrayList configurationMessages = new ArrayList();

            ILoggerRepository repository = LogManager.GetRepository(Assembly.GetCallingAssembly());
            using (new LogLog.LogReceivedAdapter(configurationMessages))
            {
                InternalConfigure(repository, configStream);
            }

            repository.ConfigurationMessages = configurationMessages;

            return configurationMessages;
		}]]></body>
          </codeblock>
        </method>
        <method name="Configure">
          <declaration><![CDATA[public static ICollection Configure(ILoggerRepository repository, XmlElement element)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="401" sc="9" el="414" ec="10">log4net\Config\XmlConfigurator.cs</location>
            <body hash="e734b5fba9bec339371128ed611acc2f"><![CDATA[{
            ArrayList configurationMessages = new ArrayList();

            using (new LogLog.LogReceivedAdapter(configurationMessages))
            {
                LogLog.Debug(declaringType, "configuring repository [" + repository.Name + "] using XML element");

                InternalConfigureFromXml(repository, element);
            }

            repository.ConfigurationMessages = configurationMessages;

            return configurationMessages;
        }]]></body>
          </codeblock>
        </method>
        <method name="Configure">
          <declaration><![CDATA[public static ICollection Configure(ILoggerRepository repository, FileInfo configFile)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="508" sc="9" el="519" ec="10">log4net\Config\XmlConfigurator.cs</location>
            <body hash="6bbf1175152c0db5a75b515f52407715"><![CDATA[{
            ArrayList configurationMessages = new ArrayList();

            using (new LogLog.LogReceivedAdapter(configurationMessages))
            {
                InternalConfigure(repository, configFile);
            }

            repository.ConfigurationMessages = configurationMessages;

            return configurationMessages;
        }]]></body>
          </codeblock>
        </method>
        <method name="Configure">
          <declaration><![CDATA[public static ICollection Configure(ILoggerRepository repository, Uri configUri)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="597" sc="9" el="608" ec="10">log4net\Config\XmlConfigurator.cs</location>
            <body hash="ffeee836ee7bbd456412161643b579f2"><![CDATA[{
            ArrayList configurationMessages = new ArrayList();

            using (new LogLog.LogReceivedAdapter(configurationMessages))
            {
                InternalConfigure(repository, configUri);
            }

            repository.ConfigurationMessages = configurationMessages;

            return configurationMessages;
        }]]></body>
          </codeblock>
        </method>
        <method name="Configure">
          <declaration><![CDATA[public static ICollection Configure(ILoggerRepository repository, Stream configStream)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="701" sc="9" el="712" ec="10">log4net\Config\XmlConfigurator.cs</location>
            <body hash="3ee70ab0c645456d807b921638e4bb95"><![CDATA[{
            ArrayList configurationMessages = new ArrayList();

            using (new LogLog.LogReceivedAdapter(configurationMessages))
            {
                InternalConfigure(repository, configStream);
            }

            repository.ConfigurationMessages = configurationMessages;

            return configurationMessages;
        }]]></body>
          </codeblock>
        </method>
        <method name="ConfigureAndWatch">
          <declaration><![CDATA[public static ICollection ConfigureAndWatch(FileInfo configFile)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="817" sc="3" el="830" ec="4">log4net\Config\XmlConfigurator.cs</location>
            <body hash="9c3c1fe20323623335c4e96cc5c9cee1"><![CDATA[{
            ArrayList configurationMessages = new ArrayList();

            ILoggerRepository repository = LogManager.GetRepository(Assembly.GetCallingAssembly());

            using (new LogLog.LogReceivedAdapter(configurationMessages))
            {
                InternalConfigureAndWatch(repository, configFile);
            }

            repository.ConfigurationMessages = configurationMessages;

            return configurationMessages;
		}]]></body>
          </codeblock>
        </method>
        <method name="ConfigureAndWatch">
          <declaration><![CDATA[public static ICollection ConfigureAndWatch(ILoggerRepository repository, FileInfo configFile)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="857" sc="9" el="868" ec="10">log4net\Config\XmlConfigurator.cs</location>
            <body hash="db938f499481c003ebf845afe028ef60"><![CDATA[{
            ArrayList configurationMessages = new ArrayList();

            using (new LogLog.LogReceivedAdapter(configurationMessages))
            {
                InternalConfigureAndWatch(repository, configFile);
            }

            repository.ConfigurationMessages = configurationMessages;

            return configurationMessages;
        }]]></body>
          </codeblock>
        </method>
        <method name="InternalConfigure">
          <declaration><![CDATA[private static void InternalConfigure(ILoggerRepository repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="111" sc="3" el="162" ec="4">log4net\Config\XmlConfigurator.cs</location>
            <body hash="9d8dc2b83cd55e17563c74ac1e06b569"><![CDATA[{
			LogLog.Debug(declaringType, "configuring repository [" + repository.Name + "] using .config file section");

			try
			{
				LogLog.Debug(declaringType, "Application config file is [" + SystemInfo.ConfigurationFileLocation + "]");
			}
			catch
			{
				// ignore error
				LogLog.Debug(declaringType, "Application config file location unknown");
			}

#if NETCF || NETSTANDARD1_3
			// No config file reading stuff. Just go straight for the file
			Configure(repository, new FileInfo(SystemInfo.ConfigurationFileLocation));
#else
			try
			{
				XmlElement configElement = null;
#if NET_2_0
				configElement = System.Configuration.ConfigurationManager.GetSection("log4net") as XmlElement;
#else
				configElement = System.Configuration.ConfigurationSettings.GetConfig("log4net") as XmlElement;
#endif
				if (configElement == null)
				{
					// Failed to load the xml config using configuration settings handler
					LogLog.Error(declaringType, "Failed to find configuration section 'log4net' in the application's .config file. Check your .config file for the <log4net> and <configSections> elements. The configuration section should look like: <section name=\"log4net\" type=\"log4net.Config.Log4NetConfigurationSectionHandler,log4net\" />");
				}
				else
				{
					// Configure using the xml loaded from the config file
					InternalConfigureFromXml(repository, configElement);
				}
			}
			catch(System.Configuration.ConfigurationException confEx)
			{
				if (confEx.BareMessage.IndexOf("Unrecognized element") >= 0)
				{
					// Looks like the XML file is not valid
					LogLog.Error(declaringType, "Failed to parse config file. Check your .config file is well formed XML.", confEx);
				}
				else
				{
					// This exception is typically due to the assembly name not being correctly specified in the section type.
					string configSectionStr = "<section name=\"log4net\" type=\"log4net.Config.Log4NetConfigurationSectionHandler," + Assembly.GetExecutingAssembly().FullName + "\" />";
					LogLog.Error(declaringType, "Failed to parse config file. Is the <configSections> specified as: " + configSectionStr, confEx);
				}
			}
#endif
		}]]></body>
          </codeblock>
        </method>
        <method name="InternalConfigure">
          <declaration><![CDATA[private static void InternalConfigure(ILoggerRepository repository, FileInfo configFile)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="522" sc="3" el="578" ec="4">log4net\Config\XmlConfigurator.cs</location>
            <body hash="7a271649eda8a1a5fa6d366945ba3016"><![CDATA[{
			LogLog.Debug(declaringType, "configuring repository [" + repository.Name + "] using file [" + configFile + "]");

			if (configFile == null)
			{
				LogLog.Error(declaringType, "Configure called with null 'configFile' parameter");
			}
			else
			{
				// Have to use File.Exists() rather than configFile.Exists()
				// because configFile.Exists() caches the value, not what we want.
				if (File.Exists(configFile.FullName))
				{
					// Open the file for reading
					FileStream fs = null;
					
					// Try hard to open the file
					for(int retry = 5; --retry >= 0; )
					{
						try
						{
							fs = configFile.Open(FileMode.Open, FileAccess.Read, FileShare.Read);
							break;
						}
						catch(IOException ex)
						{
							if (retry == 0)
							{
								LogLog.Error(declaringType, "Failed to open XML config file [" + configFile.Name + "]", ex);

								// The stream cannot be valid
								fs = null;
							}
							System.Threading.Thread.Sleep(250);
						}
					}

					if (fs != null)
					{
						try
						{
							// Load the configuration from the stream
							InternalConfigure(repository, fs);
						}
						finally
						{
							// Force the file closed whatever happens
							fs.Close();
						}
					}
				}
				else
				{
					LogLog.Debug(declaringType, "config file [" + configFile.FullName + "] not found. Configuration unchanged.");
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="InternalConfigure">
          <declaration><![CDATA[private static void InternalConfigure(ILoggerRepository repository, Uri configUri)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="611" sc="3" el="682" ec="4">log4net\Config\XmlConfigurator.cs</location>
            <body hash="6ff27c26efdc1039f7210f263fbde957"><![CDATA[{
			LogLog.Debug(declaringType, "configuring repository [" + repository.Name + "] using URI ["+configUri+"]");

			if (configUri == null)
			{
				LogLog.Error(declaringType, "Configure called with null 'configUri' parameter");
			}
			else
			{
				if (configUri.IsFile)
				{
					// If URI is local file then call Configure with FileInfo
					InternalConfigure(repository, new FileInfo(configUri.LocalPath));
				}
				else
				{
					// NETCF dose not support WebClient
					WebRequest configRequest = null;

					try
					{
						configRequest = WebRequest.Create(configUri);
					}
					catch(Exception ex)
					{
						LogLog.Error(declaringType, "Failed to create WebRequest for URI ["+configUri+"]", ex);
					}

					if (configRequest != null)
					{
#if !NETCF_1_0
						// authentication may be required, set client to use default credentials
						try
						{
							configRequest.Credentials = CredentialCache.DefaultCredentials;
						}
						catch
						{
							// ignore security exception
						}
#endif
						try
						{
#if NETSTANDARD1_3
							WebResponse response = configRequest.GetResponseAsync().GetAwaiter().GetResult();
#else
							WebResponse response = configRequest.GetResponse();
#endif
							if (response != null)
							{
								try
								{
									// Open stream on config URI
									using(Stream configStream = response.GetResponseStream())
									{
										InternalConfigure(repository, configStream);
									}
								}
								finally
								{
									response.Close();
								}
							}
						}
						catch(Exception ex)
						{
							LogLog.Error(declaringType, "Failed to request config from URI ["+configUri+"]", ex);
						}
					}
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="InternalConfigure">
          <declaration><![CDATA[private static void InternalConfigure(ILoggerRepository repository, Stream configStream)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="715" sc="3" el="787" ec="4">log4net\Config\XmlConfigurator.cs</location>
            <body hash="7478a0258e96032e5c276d31a681cb69"><![CDATA[{
			LogLog.Debug(declaringType, "configuring repository [" + repository.Name + "] using stream");

			if (configStream == null)
			{
				LogLog.Error(declaringType, "Configure called with null 'configStream' parameter");
			}
			else
			{
				// Load the config file into a document
				XmlDocument doc = new XmlDocument();
				try
				{
#if (NETCF)
					// Create a text reader for the file stream
					XmlTextReader xmlReader = new XmlTextReader(configStream);
#elif NET_2_0 || NETSTANDARD1_3
					// Allow the DTD to specify entity includes
					XmlReaderSettings settings = new XmlReaderSettings();
                                        // .NET 4.0 warning CS0618: 'System.Xml.XmlReaderSettings.ProhibitDtd'
                                        // is obsolete: 'Use XmlReaderSettings.DtdProcessing property instead.'
#if NETSTANDARD1_3 // TODO DtdProcessing.Parse not yet available (https://github.com/dotnet/corefx/issues/4376)
					settings.DtdProcessing = DtdProcessing.Ignore;
#elif !NET_4_0 && !MONO_4_0
					settings.ProhibitDtd = false;
#else
					settings.DtdProcessing = DtdProcessing.Parse;
#endif

					// Create a reader over the input stream
					XmlReader xmlReader = XmlReader.Create(configStream, settings);
#else
					// Create a validating reader around a text reader for the file stream
					XmlValidatingReader xmlReader = new XmlValidatingReader(new XmlTextReader(configStream));

					// Specify that the reader should not perform validation, but that it should
					// expand entity refs.
					xmlReader.ValidationType = ValidationType.None;
					xmlReader.EntityHandling = EntityHandling.ExpandEntities;
#endif
					
					// load the data into the document
					doc.Load(xmlReader);
				}
				catch(Exception ex)
				{
					LogLog.Error(declaringType, "Error while loading XML configuration", ex);

					// The document is invalid
					doc = null;
				}

				if (doc != null)
				{
					LogLog.Debug(declaringType, "loading XML configuration");

					// Configure using the 'log4net' element
					XmlNodeList configNodeList = doc.GetElementsByTagName("log4net");
					if (configNodeList.Count == 0)
					{
						LogLog.Debug(declaringType, "XML configuration does not contain a <log4net> element. Configuration Aborted.");
					}
					else if (configNodeList.Count > 1)
					{
						LogLog.Error(declaringType, "XML configuration contains [" + configNodeList.Count + "] <log4net> elements. Only one is allowed. Configuration Aborted.");
					}
					else
					{
						InternalConfigureFromXml(repository, configNodeList[0] as XmlElement);
					}
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="InternalConfigureAndWatch">
          <declaration><![CDATA[private static void InternalConfigureAndWatch(ILoggerRepository repository, FileInfo configFile)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="871" sc="3" el="908" ec="4">log4net\Config\XmlConfigurator.cs</location>
            <body hash="3a372934add6f620d6472e95c6fe31de"><![CDATA[{
			LogLog.Debug(declaringType, "configuring repository [" + repository.Name + "] using file [" + configFile + "] watching for file updates");

			if (configFile == null)
			{
				LogLog.Error(declaringType, "ConfigureAndWatch called with null 'configFile' parameter");
			}
			else
			{
				// Configure log4net now
				InternalConfigure(repository, configFile);

				try
				{
                    lock (m_repositoryName2ConfigAndWatchHandler)
                    {
                        // support multiple repositories each having their own watcher
                        ConfigureAndWatchHandler handler =
							(ConfigureAndWatchHandler)m_repositoryName2ConfigAndWatchHandler[configFile.FullName];

                        if (handler != null)
                        {
							m_repositoryName2ConfigAndWatchHandler.Remove(configFile.FullName);
                            handler.Dispose();
                        }

                        // Create and start a watch handler that will reload the
                        // configuration whenever the config file is modified.
                        handler = new ConfigureAndWatchHandler(repository, configFile);
						m_repositoryName2ConfigAndWatchHandler[configFile.FullName] = handler;
                    }
				}
				catch(Exception ex)
				{
					LogLog.Error(declaringType, "Failed to initialize configuration file watcher for file ["+configFile.FullName+"]", ex);
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="InternalConfigureFromXml">
          <declaration><![CDATA[private static void InternalConfigureFromXml(ILoggerRepository repository, XmlElement element)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1084" sc="3" el="1114" ec="4">log4net\Config\XmlConfigurator.cs</location>
            <body hash="d7de1fd00c8ad5adb391e4c79de8fccd"><![CDATA[{
			if (element == null)
			{
				LogLog.Error(declaringType, "ConfigureFromXml called with null 'element' parameter");
			}
			else if (repository == null)
			{
				LogLog.Error(declaringType, "ConfigureFromXml called with null 'repository' parameter");
			}
			else
			{
				LogLog.Debug(declaringType, "Configuring Repository [" + repository.Name + "]");

				IXmlRepositoryConfigurator configurableRepository = repository as IXmlRepositoryConfigurator;
				if (configurableRepository == null)
				{
					LogLog.Warn(declaringType, "Repository [" + repository + "] does not support the XmlConfigurator");
				}
				else
				{
					// Copy the xml data into the root of a new document
					// this isolates the xml config data from the rest of
					// the document
					XmlDocument newDoc = new XmlDocument();
					XmlElement newElement = (XmlElement)newDoc.AppendChild(newDoc.ImportNode(element, true));

					// Pass the configurator the config element
					configurableRepository.Configure(newElement);
				}			
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(XmlConfigurator);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_repositoryName2ConfigAndWatchHandler">
          <declaration><![CDATA[private static readonly Hashtable m_repositoryName2ConfigAndWatchHandler = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="XmlConfiguratorAttribute">
      <declaration><![CDATA[public class XmlConfiguratorAttribute : ConfiguratorAttribute]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private string m_configFile = null;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="97" sc="39" el="450" ec="44">log4net\Config\XmlConfiguratorAttribute.cs</location>
            <body hash="33b2ad3d596b95a469503305a1aca5f9"><![CDATA[base(0) /* configurator priority 0 */
		{
		}

		#region Public Instance Properties

		/// <summary>
		/// Gets or sets the filename of the configuration file.
		/// </summary>
		/// <value>
		/// The filename of the configuration file.
		/// </value>
		/// <remarks>
		/// <para>
		/// If specified, this is the name of the configuration file to use with
		/// the <see cref="XmlConfigurator"/>. This file path is relative to the
		/// <b>application base</b> directory (<see cref="AppDomain.BaseDirectory"/>).
		/// </para>
		/// <para>
		/// The <see cref="ConfigFile"/> takes priority over the <see cref="ConfigFileExtension"/>.
		/// </para>
		/// </remarks>
		public string ConfigFile
		{
			get { return m_configFile; }
			set { m_configFile = value; }
		}

		/// <summary>
		/// Gets or sets the extension of the configuration file.
		/// </summary>
		/// <value>
		/// The extension of the configuration file.
		/// </value>
		/// <remarks>
		/// <para>
		/// If specified this is the extension for the configuration file.
		/// The path to the config file is built by using the <b>application 
		/// base</b> directory (<see cref="AppDomain.BaseDirectory"/>),
		/// the <b>assembly file name</b> and the config file extension.
		/// </para>
		/// <para>
		/// If the <see cref="ConfigFileExtension"/> is set to <c>MyExt</c> then
		/// possible config file names would be: <c>MyConsoleApp.exe.MyExt</c> or
		/// <c>MyClassLibrary.dll.MyExt</c>.
		/// </para>
		/// <para>
		/// The <see cref="ConfigFile"/> takes priority over the <see cref="ConfigFileExtension"/>.
		/// </para>
		/// </remarks>
		public string ConfigFileExtension
		{
			get { return m_configFileExtension; }
			set { m_configFileExtension = value; }
		}

		/// <summary>
		/// Gets or sets a value indicating whether to watch the configuration file.
		/// </summary>
		/// <value>
		/// <c>true</c> if the configuration should be watched, <c>false</c> otherwise.
		/// </value>
		/// <remarks>
		/// <para>
		/// If this flag is specified and set to <c>true</c> then the framework
		/// will watch the configuration file and will reload the config each time 
		/// the file is modified.
		/// </para>
		/// <para>
		/// The config file can only be watched if it is loaded from local disk.
		/// In a No-Touch (Smart Client) deployment where the application is downloaded
		/// from a web server the config file may not reside on the local disk
		/// and therefore it may not be able to watch it.
		/// </para>
		/// <note>
		/// Watching configuration is not supported on the SSCLI.
		/// </note>
		/// </remarks>
		public bool Watch
		{
			get { return m_configureAndWatch; }
			set { m_configureAndWatch = value; }
		}

		#endregion Public Instance Properties

		#region Override ConfiguratorAttribute

		/// <summary>
		/// Configures the <see cref="ILoggerRepository"/> for the specified assembly.
		/// </summary>
		/// <param name="sourceAssembly">The assembly that this attribute was defined on.</param>
		/// <param name="targetRepository">The repository to configure.</param>
		/// <remarks>
		/// <para>
		/// Configure the repository using the <see cref="XmlConfigurator"/>.
		/// The <paramref name="targetRepository"/> specified must extend the <see cref="Hierarchy"/>
		/// class otherwise the <see cref="XmlConfigurator"/> will not be able to
		/// configure it.
		/// </para>
		/// </remarks>
        /// <exception cref="ArgumentOutOfRangeException">The <paramref name="targetRepository" /> does not extend <see cref="Hierarchy"/>.</exception>
		override public void Configure(Assembly sourceAssembly, ILoggerRepository targetRepository)
		{
            IList configurationMessages = new ArrayList();

            using (new LogLog.LogReceivedAdapter(configurationMessages))
            {
                string applicationBaseDirectory = null;
                try
                {
                    applicationBaseDirectory = SystemInfo.ApplicationBaseDirectory;
                }
                catch
                {
                    // Ignore this exception because it is only thrown when ApplicationBaseDirectory is a file
                    // and the application does not have PathDiscovery permission
                }

                if (applicationBaseDirectory == null || (new Uri(applicationBaseDirectory)).IsFile)
                {
                    ConfigureFromFile(sourceAssembly, targetRepository);
                }
                else
                {
                    ConfigureFromUri(sourceAssembly, targetRepository);
                }
            }

            targetRepository.ConfigurationMessages = configurationMessages;
		}

		#endregion

		/// <summary>
		/// Attempt to load configuration from the local file system
		/// </summary>
		/// <param name="sourceAssembly">The assembly that this attribute was defined on.</param>
		/// <param name="targetRepository">The repository to configure.</param>
		private void ConfigureFromFile(Assembly sourceAssembly, ILoggerRepository targetRepository)
		{
			// Work out the full path to the config file
			string fullPath2ConfigFile = null;
			
			// Select the config file
			if (m_configFile == null || m_configFile.Length == 0)
			{
				if (m_configFileExtension == null || m_configFileExtension.Length == 0)
				{
					// Use the default .config file for the AppDomain
					try
					{
						fullPath2ConfigFile = SystemInfo.ConfigurationFileLocation;
					}
					catch(Exception ex)
					{
						LogLog.Error(declaringType, "XmlConfiguratorAttribute: Exception getting ConfigurationFileLocation. Must be able to resolve ConfigurationFileLocation when ConfigFile and ConfigFileExtension properties are not set.", ex);
					}
				}
				else
				{
					// Force the extension to start with a '.'
					if (m_configFileExtension[0] != '.')
					{
						m_configFileExtension = "." + m_configFileExtension;
					}

					string applicationBaseDirectory = null;
					try
					{
						applicationBaseDirectory = SystemInfo.ApplicationBaseDirectory;
					}
					catch(Exception ex)
					{
						LogLog.Error(declaringType, "Exception getting ApplicationBaseDirectory. Must be able to resolve ApplicationBaseDirectory and AssemblyFileName when ConfigFileExtension property is set.", ex);
					}

					if (applicationBaseDirectory != null)
					{
						fullPath2ConfigFile = Path.Combine(applicationBaseDirectory, SystemInfo.AssemblyFileName(sourceAssembly) + m_configFileExtension);
					}
				}
			}
			else
			{
				string applicationBaseDirectory = null;
				try
				{
					applicationBaseDirectory = SystemInfo.ApplicationBaseDirectory;
				}
				catch(Exception ex)
				{
					LogLog.Warn(declaringType, "Exception getting ApplicationBaseDirectory. ConfigFile property path ["+m_configFile+"] will be treated as an absolute path.", ex);
				}

				if (applicationBaseDirectory != null)
				{
					// Just the base dir + the config file
					fullPath2ConfigFile = Path.Combine(applicationBaseDirectory, m_configFile);
				}
				else
				{
					fullPath2ConfigFile = m_configFile;
				}
			}

			if (fullPath2ConfigFile != null)
			{
				ConfigureFromFile(targetRepository, new FileInfo(fullPath2ConfigFile));
			}
		}

		/// <summary>
		/// Configure the specified repository using a <see cref="FileInfo"/>
		/// </summary>
		/// <param name="targetRepository">The repository to configure.</param>
		/// <param name="configFile">the FileInfo pointing to the config file</param>
		private void ConfigureFromFile(ILoggerRepository targetRepository, FileInfo configFile)
		{
#if (SSCLI)
			if (m_configureAndWatch)
			{
				LogLog.Warn(declaringType, "XmlConfiguratorAttribute: Unable to watch config file not supported on SSCLI");
			}
			XmlConfigurator.Configure(targetRepository, configFile);
#else
			// Do we configure just once or do we configure and then watch?
			if (m_configureAndWatch)
			{
				XmlConfigurator.ConfigureAndWatch(targetRepository, configFile);
			}
			else
			{
				XmlConfigurator.Configure(targetRepository, configFile);
			}
#endif
		}

		/// <summary>
		/// Attempt to load configuration from a URI
		/// </summary>
		/// <param name="sourceAssembly">The assembly that this attribute was defined on.</param>
		/// <param name="targetRepository">The repository to configure.</param>
		private void ConfigureFromUri(Assembly sourceAssembly, ILoggerRepository targetRepository)
		{
			// Work out the full path to the config file
			Uri fullPath2ConfigFile = null;
			
			// Select the config file
			if (m_configFile == null || m_configFile.Length == 0)
			{
				if (m_configFileExtension == null || m_configFileExtension.Length == 0)
				{
					string systemConfigFilePath = null;
					try
					{
						systemConfigFilePath = SystemInfo.ConfigurationFileLocation;
					}
					catch(Exception ex)
					{
						LogLog.Error(declaringType, "XmlConfiguratorAttribute: Exception getting ConfigurationFileLocation. Must be able to resolve ConfigurationFileLocation when ConfigFile and ConfigFileExtension properties are not set.", ex);
					}

					if (systemConfigFilePath != null)
					{
						Uri systemConfigFileUri = new Uri(systemConfigFilePath);

						// Use the default .config file for the AppDomain
						fullPath2ConfigFile = systemConfigFileUri;
					}
				}
				else
				{
					// Force the extension to start with a '.'
					if (m_configFileExtension[0] != '.')
					{
						m_configFileExtension = "." + m_configFileExtension;
					}

					string systemConfigFilePath = null;
					try
					{
						systemConfigFilePath = SystemInfo.ConfigurationFileLocation;
					}
					catch(Exception ex)
					{
						LogLog.Error(declaringType, "XmlConfiguratorAttribute: Exception getting ConfigurationFileLocation. Must be able to resolve ConfigurationFileLocation when the ConfigFile property are not set.", ex);
					}

					if (systemConfigFilePath != null)
					{
						UriBuilder builder = new UriBuilder(new Uri(systemConfigFilePath));

						// Remove the current extension from the systemConfigFileUri path
						string path = builder.Path;
						int startOfExtension = path.LastIndexOf(".");
						if (startOfExtension >= 0)
						{
							path = path.Substring(0, startOfExtension);
						}
						path += m_configFileExtension;

						builder.Path = path;
						fullPath2ConfigFile = builder.Uri;
					}
				}
			}
			else
			{
				string applicationBaseDirectory = null;
				try
				{
					applicationBaseDirectory = SystemInfo.ApplicationBaseDirectory;
				}
				catch(Exception ex)
				{
					LogLog.Warn(declaringType, "Exception getting ApplicationBaseDirectory. ConfigFile property path ["+m_configFile+"] will be treated as an absolute URI.", ex);
				}

				if (applicationBaseDirectory != null)
				{
					// Just the base dir + the config file
					fullPath2ConfigFile = new Uri(new Uri(applicationBaseDirectory), m_configFile);
				}
				else
				{
					fullPath2ConfigFile = new Uri(m_configFile);
				}
			}

			if (fullPath2ConfigFile != null)
			{
				if (fullPath2ConfigFile.IsFile)
				{
					// The m_configFile could be an absolute local path, therefore we have to be
					// prepared to switch back to using FileInfos here
					ConfigureFromFile(targetRepository, new FileInfo(fullPath2ConfigFile.LocalPath));
				}
				else
				{
					if (m_configureAndWatch)
					{
						LogLog.Warn(declaringType, "XmlConfiguratorAttribute: Unable to watch config file loaded from a URI");
					}
					XmlConfigurator.Configure(targetRepository, fullPath2ConfigFile);
				}
			}
		}

		#region Private Instance Fields

		private string m_configFile = null;
		private string m_configFileExtension = null;
		private bool m_configureAndWatch = false;]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static XmlConfiguratorAttribute()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="463" sc="6" el="463" ec="84">log4net\Config\XmlConfiguratorAttribute.cs</location>
            <body hash="4771a858a292bec0e6664e60a494b24a"><![CDATA[private readonly static Type declaringType = typeof(XmlConfiguratorAttribute)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Configure">
          <declaration><![CDATA[public override void Configure(Assembly sourceAssembly, ILoggerRepository targetRepository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="200" sc="3" el="227" ec="4">log4net\Config\XmlConfiguratorAttribute.cs</location>
            <body hash="c11747d8d2c14f4272faa748f75c873f"><![CDATA[{
            IList configurationMessages = new ArrayList();

            using (new LogLog.LogReceivedAdapter(configurationMessages))
            {
                string applicationBaseDirectory = null;
                try
                {
                    applicationBaseDirectory = SystemInfo.ApplicationBaseDirectory;
                }
                catch
                {
                    // Ignore this exception because it is only thrown when ApplicationBaseDirectory is a file
                    // and the application does not have PathDiscovery permission
                }

                if (applicationBaseDirectory == null || (new Uri(applicationBaseDirectory)).IsFile)
                {
                    ConfigureFromFile(sourceAssembly, targetRepository);
                }
                else
                {
                    ConfigureFromUri(sourceAssembly, targetRepository);
                }
            }

            targetRepository.ConfigurationMessages = configurationMessages;
		}]]></body>
          </codeblock>
        </method>
        <method name="ConfigureFromFile">
          <declaration><![CDATA[private void ConfigureFromFile(Assembly sourceAssembly, ILoggerRepository targetRepository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="237" sc="3" el="307" ec="4">log4net\Config\XmlConfiguratorAttribute.cs</location>
            <body hash="fd5009a8b53bffb39086fb40ab437866"><![CDATA[{
			// Work out the full path to the config file
			string fullPath2ConfigFile = null;
			
			// Select the config file
			if (m_configFile == null || m_configFile.Length == 0)
			{
				if (m_configFileExtension == null || m_configFileExtension.Length == 0)
				{
					// Use the default .config file for the AppDomain
					try
					{
						fullPath2ConfigFile = SystemInfo.ConfigurationFileLocation;
					}
					catch(Exception ex)
					{
						LogLog.Error(declaringType, "XmlConfiguratorAttribute: Exception getting ConfigurationFileLocation. Must be able to resolve ConfigurationFileLocation when ConfigFile and ConfigFileExtension properties are not set.", ex);
					}
				}
				else
				{
					// Force the extension to start with a '.'
					if (m_configFileExtension[0] != '.')
					{
						m_configFileExtension = "." + m_configFileExtension;
					}

					string applicationBaseDirectory = null;
					try
					{
						applicationBaseDirectory = SystemInfo.ApplicationBaseDirectory;
					}
					catch(Exception ex)
					{
						LogLog.Error(declaringType, "Exception getting ApplicationBaseDirectory. Must be able to resolve ApplicationBaseDirectory and AssemblyFileName when ConfigFileExtension property is set.", ex);
					}

					if (applicationBaseDirectory != null)
					{
						fullPath2ConfigFile = Path.Combine(applicationBaseDirectory, SystemInfo.AssemblyFileName(sourceAssembly) + m_configFileExtension);
					}
				}
			}
			else
			{
				string applicationBaseDirectory = null;
				try
				{
					applicationBaseDirectory = SystemInfo.ApplicationBaseDirectory;
				}
				catch(Exception ex)
				{
					LogLog.Warn(declaringType, "Exception getting ApplicationBaseDirectory. ConfigFile property path ["+m_configFile+"] will be treated as an absolute path.", ex);
				}

				if (applicationBaseDirectory != null)
				{
					// Just the base dir + the config file
					fullPath2ConfigFile = Path.Combine(applicationBaseDirectory, m_configFile);
				}
				else
				{
					fullPath2ConfigFile = m_configFile;
				}
			}

			if (fullPath2ConfigFile != null)
			{
				ConfigureFromFile(targetRepository, new FileInfo(fullPath2ConfigFile));
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ConfigureFromFile">
          <declaration><![CDATA[private void ConfigureFromFile(ILoggerRepository targetRepository, FileInfo configFile)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="315" sc="3" el="333" ec="4">log4net\Config\XmlConfiguratorAttribute.cs</location>
            <body hash="fb34edb2d960f416dc6449908113fd91"><![CDATA[{
#if (SSCLI)
			if (m_configureAndWatch)
			{
				LogLog.Warn(declaringType, "XmlConfiguratorAttribute: Unable to watch config file not supported on SSCLI");
			}
			XmlConfigurator.Configure(targetRepository, configFile);
#else
			// Do we configure just once or do we configure and then watch?
			if (m_configureAndWatch)
			{
				XmlConfigurator.ConfigureAndWatch(targetRepository, configFile);
			}
			else
			{
				XmlConfigurator.Configure(targetRepository, configFile);
			}
#endif
		}]]></body>
          </codeblock>
        </method>
        <method name="ConfigureFromUri">
          <declaration><![CDATA[private void ConfigureFromUri(Assembly sourceAssembly, ILoggerRepository targetRepository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="341" sc="3" el="444" ec="4">log4net\Config\XmlConfiguratorAttribute.cs</location>
            <body hash="1b60f4a0ad42867863e84cdc8da788c4"><![CDATA[{
			// Work out the full path to the config file
			Uri fullPath2ConfigFile = null;
			
			// Select the config file
			if (m_configFile == null || m_configFile.Length == 0)
			{
				if (m_configFileExtension == null || m_configFileExtension.Length == 0)
				{
					string systemConfigFilePath = null;
					try
					{
						systemConfigFilePath = SystemInfo.ConfigurationFileLocation;
					}
					catch(Exception ex)
					{
						LogLog.Error(declaringType, "XmlConfiguratorAttribute: Exception getting ConfigurationFileLocation. Must be able to resolve ConfigurationFileLocation when ConfigFile and ConfigFileExtension properties are not set.", ex);
					}

					if (systemConfigFilePath != null)
					{
						Uri systemConfigFileUri = new Uri(systemConfigFilePath);

						// Use the default .config file for the AppDomain
						fullPath2ConfigFile = systemConfigFileUri;
					}
				}
				else
				{
					// Force the extension to start with a '.'
					if (m_configFileExtension[0] != '.')
					{
						m_configFileExtension = "." + m_configFileExtension;
					}

					string systemConfigFilePath = null;
					try
					{
						systemConfigFilePath = SystemInfo.ConfigurationFileLocation;
					}
					catch(Exception ex)
					{
						LogLog.Error(declaringType, "XmlConfiguratorAttribute: Exception getting ConfigurationFileLocation. Must be able to resolve ConfigurationFileLocation when the ConfigFile property are not set.", ex);
					}

					if (systemConfigFilePath != null)
					{
						UriBuilder builder = new UriBuilder(new Uri(systemConfigFilePath));

						// Remove the current extension from the systemConfigFileUri path
						string path = builder.Path;
						int startOfExtension = path.LastIndexOf(".");
						if (startOfExtension >= 0)
						{
							path = path.Substring(0, startOfExtension);
						}
						path += m_configFileExtension;

						builder.Path = path;
						fullPath2ConfigFile = builder.Uri;
					}
				}
			}
			else
			{
				string applicationBaseDirectory = null;
				try
				{
					applicationBaseDirectory = SystemInfo.ApplicationBaseDirectory;
				}
				catch(Exception ex)
				{
					LogLog.Warn(declaringType, "Exception getting ApplicationBaseDirectory. ConfigFile property path ["+m_configFile+"] will be treated as an absolute URI.", ex);
				}

				if (applicationBaseDirectory != null)
				{
					// Just the base dir + the config file
					fullPath2ConfigFile = new Uri(new Uri(applicationBaseDirectory), m_configFile);
				}
				else
				{
					fullPath2ConfigFile = new Uri(m_configFile);
				}
			}

			if (fullPath2ConfigFile != null)
			{
				if (fullPath2ConfigFile.IsFile)
				{
					// The m_configFile could be an absolute local path, therefore we have to be
					// prepared to switch back to using FileInfos here
					ConfigureFromFile(targetRepository, new FileInfo(fullPath2ConfigFile.LocalPath));
				}
				else
				{
					if (m_configureAndWatch)
					{
						LogLog.Warn(declaringType, "XmlConfiguratorAttribute: Unable to watch config file loaded from a URI");
					}
					XmlConfigurator.Configure(targetRepository, fullPath2ConfigFile);
				}
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(XmlConfiguratorAttribute);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_configFile">
          <declaration><![CDATA[private string m_configFile = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_configFileExtension">
          <declaration><![CDATA[private string m_configFileExtension = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_configureAndWatch">
          <declaration><![CDATA[private bool m_configureAndWatch = false;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="ConfigFile">
          <declaration><![CDATA[public string ConfigFile]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="ConfigFileExtension">
          <declaration><![CDATA[public string ConfigFileExtension]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Watch">
          <declaration><![CDATA[public bool Watch]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="log4net.Core">
    <class name="CompactRepositorySelector">
      <declaration><![CDATA[public class CompactRepositorySelector : IRepositorySelector]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private readonly Hashtable m_name2repositoryMap = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="54" sc="3" el="92" ec="4">log4net\Core\CompactRepositorySelector.cs</location>
            <body hash="1bc1d09e2be81d5c017db7a802f50ddf"><![CDATA[private readonly Hashtable m_name2repositoryMap = new Hashtable();
		private readonly Type m_defaultRepositoryType;

		private event LoggerRepositoryCreationEventHandler m_loggerRepositoryCreatedEvent;

		#endregion

		#region Constructors

		/// <summary>
		/// Create a new repository selector
		/// </summary>
		/// <param name="defaultRepositoryType">the type of the repositories to create, must implement <see cref="ILoggerRepository"/></param>
		/// <remarks>
		/// <para>
		/// Create an new compact repository selector.
		/// The default type for repositories must be specified,
		/// an appropriate value would be <see cref="log4net.Repository.Hierarchy.Hierarchy"/>.
		/// </para>
		/// </remarks>
		/// <exception cref="ArgumentNullException">throw if <paramref name="defaultRepositoryType"/> is null</exception>
		/// <exception cref="ArgumentOutOfRangeException">throw if <paramref name="defaultRepositoryType"/> does not implement <see cref="ILoggerRepository"/></exception>
		public CompactRepositorySelector(Type defaultRepositoryType)
		{
			if (defaultRepositoryType == null)
			{
				throw new ArgumentNullException("defaultRepositoryType");
			}

			// Check that the type is a repository
			if (! (typeof(ILoggerRepository).IsAssignableFrom(defaultRepositoryType)) )
			{
				throw log4net.Util.SystemInfo.CreateArgumentOutOfRangeException("defaultRepositoryType", (object)defaultRepositoryType, "Parameter: defaultRepositoryType, Value: ["+defaultRepositoryType+"] out of range. Argument must implement the ILoggerRepository interface");
			}

			m_defaultRepositoryType = defaultRepositoryType;

			LogLog.Debug(declaringType, "defaultRepositoryType ["+m_defaultRepositoryType+"]");
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static CompactRepositorySelector()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="314" sc="6" el="314" ec="85">log4net\Core\CompactRepositorySelector.cs</location>
            <body hash="184e777e7403d96c7705a08dd196315f"><![CDATA[private readonly static Type declaringType = typeof(CompactRepositorySelector)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="add_LoggerRepositoryCreatedEvent">
          <declaration><![CDATA[public void add_LoggerRepositoryCreatedEvent(LoggerRepositoryCreationEventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="334" sc="8" el="334" ec="9">log4net\Core\CompactRepositorySelector.cs</location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="add_m_loggerRepositoryCreatedEvent">
          <declaration><![CDATA[private void add_m_loggerRepositoryCreatedEvent(LoggerRepositoryCreationEventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="CreateRepository">
          <declaration><![CDATA[public ILoggerRepository CreateRepository(Assembly assembly, Type repositoryType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="173" sc="3" el="194" ec="4">log4net\Core\CompactRepositorySelector.cs</location>
            <body hash="709745c35d35fb65f3ee10cd853e1bc6"><![CDATA[{
			// If the type is not set then use the default type
			if (repositoryType == null)
			{
				repositoryType = m_defaultRepositoryType;
			}

			lock(this)
			{
				// This method should not throw if the default repository already exists.

				// First check that the repository does not exist
				ILoggerRepository rep = m_name2repositoryMap[DefaultRepositoryName] as ILoggerRepository;
				if (rep == null)
				{
					// Must create the repository
					rep = CreateRepository(DefaultRepositoryName, repositoryType);
				}

				return rep;
			}		
		}]]></body>
          </codeblock>
        </method>
        <method name="CreateRepository">
          <declaration><![CDATA[public ILoggerRepository CreateRepository(string repositoryName, Type repositoryType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="220" sc="3" el="261" ec="4">log4net\Core\CompactRepositorySelector.cs</location>
            <body hash="dcbeb2b016ae3816e07df03921ac1ccb"><![CDATA[{
			if (repositoryName == null)
			{
				throw new ArgumentNullException("repositoryName");
			}

			// If the type is not set then use the default type
			if (repositoryType == null)
			{
				repositoryType = m_defaultRepositoryType;
			}

			lock(this)
			{
				ILoggerRepository rep = null;

				// First check that the repository does not exist
				rep = m_name2repositoryMap[repositoryName] as ILoggerRepository;
				if (rep != null)
				{
					throw new LogException("Repository ["+repositoryName+"] is already defined. Repositories cannot be redefined.");
				}
				else
				{
					LogLog.Debug(declaringType, "Creating repository ["+repositoryName+"] using type ["+repositoryType+"]");

					// Call the no arg constructor for the repositoryType
					rep = (ILoggerRepository)Activator.CreateInstance(repositoryType);

					// Set the name of the repository
					rep.Name = repositoryName;

					// Store in map
					m_name2repositoryMap[repositoryName] = rep;

					// Notify listeners that the repository has been created
					OnLoggerRepositoryCreatedEvent(rep);
				}

				return rep;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ExistsRepository">
          <declaration><![CDATA[public bool ExistsRepository(string repositoryName)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="276" sc="3" el="281" ec="4">log4net\Core\CompactRepositorySelector.cs</location>
            <body hash="7ca82b37cc2a01eaa1bddf41d123231f"><![CDATA[{
			lock(this)
			{
				return m_name2repositoryMap.ContainsKey(repositoryName);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="GetAllRepositories">
          <declaration><![CDATA[public ILoggerRepository[] GetAllRepositories()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="293" sc="3" el="301" ec="4">log4net\Core\CompactRepositorySelector.cs</location>
            <body hash="29b29fda57ff2322ce5f88779802a5e2"><![CDATA[{
			lock(this)
			{
				ICollection reps = m_name2repositoryMap.Values;
				ILoggerRepository[] all = new ILoggerRepository[reps.Count];
				reps.CopyTo(all, 0);
				return all;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="GetRepository">
          <declaration><![CDATA[public ILoggerRepository GetRepository(Assembly assembly)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="114" sc="3" el="116" ec="4">log4net\Core\CompactRepositorySelector.cs</location>
            <body hash="e94ea847805ea2e69995fc8b860e0d00"><![CDATA[{
			return CreateRepository(assembly, m_defaultRepositoryType);
		}]]></body>
          </codeblock>
        </method>
        <method name="GetRepository">
          <declaration><![CDATA[public ILoggerRepository GetRepository(string repositoryName)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="134" sc="3" el="150" ec="4">log4net\Core\CompactRepositorySelector.cs</location>
            <body hash="3f5dcc0dcd6ca02c2ddc13d3759d8a7d"><![CDATA[{
			if (repositoryName == null)
			{
				throw new ArgumentNullException("repositoryName");
			}

			lock(this)
			{
				// Lookup in map
				ILoggerRepository rep = m_name2repositoryMap[repositoryName] as ILoggerRepository;
				if (rep == null)
				{
					throw new LogException("Repository ["+repositoryName+"] is NOT defined.");
				}
				return rep;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="OnLoggerRepositoryCreatedEvent">
          <declaration><![CDATA[protected virtual void OnLoggerRepositoryCreatedEvent(ILoggerRepository repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="349" sc="3" el="355" ec="4">log4net\Core\CompactRepositorySelector.cs</location>
            <body hash="2ef64c474912557e2c68d05966eb6f9e"><![CDATA[{
			LoggerRepositoryCreationEventHandler handler = m_loggerRepositoryCreatedEvent;
			if (handler != null)
			{
				handler(this, new LoggerRepositoryCreationEventArgs(repository));
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="remove_LoggerRepositoryCreatedEvent">
          <declaration><![CDATA[public void remove_LoggerRepositoryCreatedEvent(LoggerRepositoryCreationEventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="335" sc="11" el="335" ec="12">log4net\Core\CompactRepositorySelector.cs</location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="remove_m_loggerRepositoryCreatedEvent">
          <declaration><![CDATA[private void remove_m_loggerRepositoryCreatedEvent(LoggerRepositoryCreationEventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(CompactRepositorySelector);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DefaultRepositoryName">
          <declaration><![CDATA[private const string DefaultRepositoryName = "log4net-default-repository";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_defaultRepositoryType">
          <declaration><![CDATA[private readonly Type m_defaultRepositoryType;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_loggerRepositoryCreatedEvent">
          <declaration><![CDATA[private LoggerRepositoryCreationEventHandler m_loggerRepositoryCreatedEvent;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_name2repositoryMap">
          <declaration><![CDATA[private readonly Hashtable m_name2repositoryMap = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
        <event name="LoggerRepositoryCreatedEvent">
          <declaration><![CDATA[public event LoggerRepositoryCreationEventHandler LoggerRepositoryCreatedEvent]]></declaration>
          <documentation>
          </documentation>
        </event>
        <event name="m_loggerRepositoryCreatedEvent">
          <declaration><![CDATA[private event LoggerRepositoryCreationEventHandler m_loggerRepositoryCreatedEvent;]]></declaration>
          <documentation>
          </documentation>
        </event>
      </events>
    </class>
    <class name="DefaultRepositorySelector">
      <declaration><![CDATA[public class DefaultRepositorySelector : IRepositorySelector]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private readonly Hashtable m_name2repositoryMap = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="92" sc="3" el="904" ec="70">log4net\Core\DefaultRepositorySelector.cs</location>
            <body hash="56d6f9016b012287a9a3aa07b5aafb8c"><![CDATA[public DefaultRepositorySelector(Type defaultRepositoryType)
		{
			if (defaultRepositoryType == null)
			{
				throw new ArgumentNullException("defaultRepositoryType");
			}

			// Check that the type is a repository
			if (! (typeof(ILoggerRepository).IsAssignableFrom(defaultRepositoryType)) )
			{
				throw log4net.Util.SystemInfo.CreateArgumentOutOfRangeException("defaultRepositoryType", defaultRepositoryType, "Parameter: defaultRepositoryType, Value: [" + defaultRepositoryType + "] out of range. Argument must implement the ILoggerRepository interface");
			}

			m_defaultRepositoryType = defaultRepositoryType;

			LogLog.Debug(declaringType, "defaultRepositoryType [" + m_defaultRepositoryType + "]");
		}

		#endregion Public Instance Constructors

		#region Implementation of IRepositorySelector

		/// <summary>
		/// Gets the <see cref="ILoggerRepository"/> for the specified assembly.
		/// </summary>
		/// <param name="repositoryAssembly">The assembly use to lookup the <see cref="ILoggerRepository"/>.</param>
		/// <remarks>
		/// <para>
		/// The type of the <see cref="ILoggerRepository"/> created and the repository 
		/// to create can be overridden by specifying the <see cref="log4net.Config.RepositoryAttribute"/> 
		/// attribute on the <paramref name="repositoryAssembly"/>.
		/// </para>
		/// <para>
		/// The default values are to use the <see cref="log4net.Repository.Hierarchy.Hierarchy"/> 
		/// implementation of the <see cref="ILoggerRepository"/> interface and to use the
		/// <see cref="AssemblyName.Name"/> as the name of the repository.
		/// </para>
		/// <para>
		/// The <see cref="ILoggerRepository"/> created will be automatically configured using 
		/// any <see cref="log4net.Config.ConfiguratorAttribute"/> attributes defined on
		/// the <paramref name="repositoryAssembly"/>.
		/// </para>
		/// </remarks>
		/// <returns>The <see cref="ILoggerRepository"/> for the assembly</returns>
		/// <exception cref="ArgumentNullException"><paramref name="repositoryAssembly"/> is <see langword="null" />.</exception>
		public ILoggerRepository GetRepository(Assembly repositoryAssembly)
		{
			if (repositoryAssembly == null)
			{
				throw new ArgumentNullException("repositoryAssembly");
			}
			return CreateRepository(repositoryAssembly, m_defaultRepositoryType);
		}

		/// <summary>
		/// Gets the <see cref="ILoggerRepository"/> for the specified repository.
		/// </summary>
		/// <param name="repositoryName">The repository to use to lookup the <see cref="ILoggerRepository"/>.</param>
		/// <returns>The <see cref="ILoggerRepository"/> for the specified repository.</returns>
		/// <remarks>
		/// <para>
		/// Returns the named repository. If <paramref name="repositoryName"/> is <c>null</c>
		/// a <see cref="ArgumentNullException"/> is thrown. If the repository 
		/// does not exist a <see cref="LogException"/> is thrown.
		/// </para>
		/// <para>
		/// Use <see cref="M:CreateRepository(string, Type)"/> to create a repository.
		/// </para>
		/// </remarks>
		/// <exception cref="ArgumentNullException"><paramref name="repositoryName"/> is <see langword="null" />.</exception>
		/// <exception cref="LogException"><paramref name="repositoryName"/> does not exist.</exception>
		public ILoggerRepository GetRepository(string repositoryName)
		{
			if (repositoryName == null)
			{
				throw new ArgumentNullException("repositoryName");
			}

			lock(this)
			{
				// Lookup in map
				ILoggerRepository rep = m_name2repositoryMap[repositoryName] as ILoggerRepository;
				if (rep == null)
				{
					throw new LogException("Repository [" + repositoryName + "] is NOT defined.");
				}
				return rep;
			}
		}

		/// <summary>
		/// Create a new repository for the assembly specified 
		/// </summary>
		/// <param name="repositoryAssembly">the assembly to use to create the repository to associate with the <see cref="ILoggerRepository"/>.</param>
		/// <param name="repositoryType">The type of repository to create, must implement <see cref="ILoggerRepository"/>.</param>
		/// <returns>The repository created.</returns>
		/// <remarks>
		/// <para>
		/// The <see cref="ILoggerRepository"/> created will be associated with the repository
		/// specified such that a call to <see cref="M:GetRepository(Assembly)"/> with the
		/// same assembly specified will return the same repository instance.
		/// </para>
		/// <para>
		/// The type of the <see cref="ILoggerRepository"/> created and
		/// the repository to create can be overridden by specifying the
		/// <see cref="log4net.Config.RepositoryAttribute"/> attribute on the 
		/// <paramref name="repositoryAssembly"/>.  The default values are to use the 
		/// <paramref name="repositoryType"/> implementation of the 
		/// <see cref="ILoggerRepository"/> interface and to use the
		/// <see cref="AssemblyName.Name"/> as the name of the repository.
		/// </para>
		/// <para>
		/// The <see cref="ILoggerRepository"/> created will be automatically
		/// configured using any <see cref="log4net.Config.ConfiguratorAttribute"/> 
		/// attributes defined on the <paramref name="repositoryAssembly"/>.
		/// </para>
		/// <para>
		/// If a repository for the <paramref name="repositoryAssembly"/> already exists
		/// that repository will be returned. An error will not be raised and that 
		/// repository may be of a different type to that specified in <paramref name="repositoryType"/>.
		/// Also the <see cref="log4net.Config.RepositoryAttribute"/> attribute on the
		/// assembly may be used to override the repository type specified in 
		/// <paramref name="repositoryType"/>.
		/// </para>
		/// </remarks>
		/// <exception cref="ArgumentNullException"><paramref name="repositoryAssembly"/> is <see langword="null" />.</exception>
		public ILoggerRepository CreateRepository(Assembly repositoryAssembly, Type repositoryType)
		{
			return CreateRepository(repositoryAssembly, repositoryType, DefaultRepositoryName, true);
		}

		/// <summary>
		/// Creates a new repository for the assembly specified.
		/// </summary>
		/// <param name="repositoryAssembly">the assembly to use to create the repository to associate with the <see cref="ILoggerRepository"/>.</param>
		/// <param name="repositoryType">The type of repository to create, must implement <see cref="ILoggerRepository"/>.</param>
		/// <param name="repositoryName">The name to assign to the created repository</param>
		/// <param name="readAssemblyAttributes">Set to <c>true</c> to read and apply the assembly attributes</param>
		/// <returns>The repository created.</returns>
		/// <remarks>
		/// <para>
		/// The <see cref="ILoggerRepository"/> created will be associated with the repository
		/// specified such that a call to <see cref="M:GetRepository(Assembly)"/> with the
		/// same assembly specified will return the same repository instance.
		/// </para>
		/// <para>
		/// The type of the <see cref="ILoggerRepository"/> created and
		/// the repository to create can be overridden by specifying the
		/// <see cref="log4net.Config.RepositoryAttribute"/> attribute on the 
		/// <paramref name="repositoryAssembly"/>.  The default values are to use the 
		/// <paramref name="repositoryType"/> implementation of the 
		/// <see cref="ILoggerRepository"/> interface and to use the
		/// <see cref="AssemblyName.Name"/> as the name of the repository.
		/// </para>
		/// <para>
		/// The <see cref="ILoggerRepository"/> created will be automatically
		/// configured using any <see cref="log4net.Config.ConfiguratorAttribute"/> 
		/// attributes defined on the <paramref name="repositoryAssembly"/>.
		/// </para>
		/// <para>
		/// If a repository for the <paramref name="repositoryAssembly"/> already exists
		/// that repository will be returned. An error will not be raised and that 
		/// repository may be of a different type to that specified in <paramref name="repositoryType"/>.
		/// Also the <see cref="log4net.Config.RepositoryAttribute"/> attribute on the
		/// assembly may be used to override the repository type specified in 
		/// <paramref name="repositoryType"/>.
		/// </para>
		/// </remarks>
		/// <exception cref="ArgumentNullException"><paramref name="repositoryAssembly"/> is <see langword="null" />.</exception>
		public ILoggerRepository CreateRepository(Assembly repositoryAssembly, Type repositoryType, string repositoryName, bool readAssemblyAttributes)
		{
			if (repositoryAssembly == null)
			{
				throw new ArgumentNullException("repositoryAssembly");
			}

			// If the type is not set then use the default type
			if (repositoryType == null)
			{
				repositoryType = m_defaultRepositoryType;
			}

			lock(this)
			{
				// Lookup in map
				ILoggerRepository rep = m_assembly2repositoryMap[repositoryAssembly] as ILoggerRepository;
				if (rep == null)
				{
					// Not found, therefore create
					LogLog.Debug(declaringType, "Creating repository for assembly [" + repositoryAssembly + "]");

					// Must specify defaults
					string actualRepositoryName = repositoryName;
					Type actualRepositoryType = repositoryType;

					if (readAssemblyAttributes)
					{
						// Get the repository and type from the assembly attributes
						GetInfoForAssembly(repositoryAssembly, ref actualRepositoryName, ref actualRepositoryType);
					}

					LogLog.Debug(declaringType, "Assembly [" + repositoryAssembly + "] using repository [" + actualRepositoryName + "] and repository type [" + actualRepositoryType + "]");

					// Lookup the repository in the map (as this may already be defined)
					rep = m_name2repositoryMap[actualRepositoryName] as ILoggerRepository;
					if (rep == null)
					{
						// Create the repository
						rep = CreateRepository(actualRepositoryName, actualRepositoryType);

						if (readAssemblyAttributes)
						{
							try
							{
								// Look for aliasing attributes
								LoadAliases(repositoryAssembly, rep);

								// Look for plugins defined on the assembly
								LoadPlugins(repositoryAssembly, rep);

								// Configure the repository using the assembly attributes
								ConfigureRepository(repositoryAssembly, rep);
							}
							catch (Exception ex)
							{
								LogLog.Error(declaringType, "Failed to configure repository [" + actualRepositoryName + "] from assembly attributes.", ex);
							}
						}
					}
					else
					{
						LogLog.Debug(declaringType, "repository [" + actualRepositoryName + "] already exists, using repository type [" + rep.GetType().FullName + "]");

						if (readAssemblyAttributes)
						{
							try
							{
								// Look for plugins defined on the assembly
								LoadPlugins(repositoryAssembly, rep);
							}
							catch (Exception ex)
							{
								LogLog.Error(declaringType, "Failed to configure repository [" + actualRepositoryName + "] from assembly attributes.", ex);
							}
						}
					}
					m_assembly2repositoryMap[repositoryAssembly] = rep;
				}
				return rep;
			}
		}

		/// <summary>
		/// Creates a new repository for the specified repository.
		/// </summary>
		/// <param name="repositoryName">The repository to associate with the <see cref="ILoggerRepository"/>.</param>
		/// <param name="repositoryType">The type of repository to create, must implement <see cref="ILoggerRepository"/>.
		/// If this param is <see langword="null" /> then the default repository type is used.</param>
		/// <returns>The new repository.</returns>
		/// <remarks>
		/// <para>
		/// The <see cref="ILoggerRepository"/> created will be associated with the repository
		/// specified such that a call to <see cref="M:GetRepository(string)"/> with the
		/// same repository specified will return the same repository instance.
		/// </para>
		/// </remarks>
		/// <exception cref="ArgumentNullException"><paramref name="repositoryName"/> is <see langword="null" />.</exception>
		/// <exception cref="LogException"><paramref name="repositoryName"/> already exists.</exception>
		public ILoggerRepository CreateRepository(string repositoryName, Type repositoryType)
		{
			if (repositoryName == null)
			{
				throw new ArgumentNullException("repositoryName");
			}

			// If the type is not set then use the default type
			if (repositoryType == null)
			{
				repositoryType = m_defaultRepositoryType;
			}

			lock(this)
			{
				ILoggerRepository rep = null;

				// First check that the repository does not exist
				rep = m_name2repositoryMap[repositoryName] as ILoggerRepository;
				if (rep != null)
				{
					throw new LogException("Repository [" + repositoryName + "] is already defined. Repositories cannot be redefined.");
				}
				else
				{
					// Lookup an alias before trying to create the new repository
					ILoggerRepository aliasedRepository = m_alias2repositoryMap[repositoryName] as ILoggerRepository;
					if (aliasedRepository != null)
					{
						// Found an alias

						// Check repository type
						if (aliasedRepository.GetType() == repositoryType)
						{
							// Repository type is compatible
							LogLog.Debug(declaringType, "Aliasing repository [" + repositoryName + "] to existing repository [" + aliasedRepository.Name + "]");
							rep = aliasedRepository;

							// Store in map
							m_name2repositoryMap[repositoryName] = rep;
						}
						else
						{
							// Invalid repository type for alias
							LogLog.Error(declaringType, "Failed to alias repository [" + repositoryName + "] to existing repository ["+aliasedRepository.Name+"]. Requested repository type ["+repositoryType.FullName+"] is not compatible with existing type [" + aliasedRepository.GetType().FullName + "]");

							// We now drop through to create the repository without aliasing
						}
					}

					// If we could not find an alias
					if (rep == null)
					{
						LogLog.Debug(declaringType, "Creating repository [" + repositoryName + "] using type [" + repositoryType + "]");

						// Call the no arg constructor for the repositoryType
						rep = (ILoggerRepository)Activator.CreateInstance(repositoryType);

						// Set the name of the repository
						rep.Name = repositoryName;

						// Store in map
						m_name2repositoryMap[repositoryName] = rep;

						// Notify listeners that the repository has been created
						OnLoggerRepositoryCreatedEvent(rep);
					}
				}

				return rep;
			}
		}

		/// <summary>
		/// Test if a named repository exists
		/// </summary>
		/// <param name="repositoryName">the named repository to check</param>
		/// <returns><c>true</c> if the repository exists</returns>
		/// <remarks>
		/// <para>
		/// Test if a named repository exists. Use <see cref="M:CreateRepository(string, Type)"/>
		/// to create a new repository and <see cref="M:GetRepository(string)"/> to retrieve 
		/// a repository.
		/// </para>
		/// </remarks>
		public bool ExistsRepository(string repositoryName)
		{
			lock(this)
			{
				return m_name2repositoryMap.ContainsKey(repositoryName);
			}
		}

		/// <summary>
		/// Gets a list of <see cref="ILoggerRepository"/> objects
		/// </summary>
		/// <returns>an array of all known <see cref="ILoggerRepository"/> objects</returns>
		/// <remarks>
		/// <para>
		/// Gets an array of all of the repositories created by this selector.
		/// </para>
		/// </remarks>
		public ILoggerRepository[] GetAllRepositories()
		{
			lock(this)
			{
				ICollection reps = m_name2repositoryMap.Values;
				ILoggerRepository[] all = new ILoggerRepository[reps.Count];
				reps.CopyTo(all, 0);
				return all;
			}
		}

		#endregion Implementation of IRepositorySelector

		#region Public Instance Methods

		/// <summary>
		/// Aliases a repository to an existing repository.
		/// </summary>
		/// <param name="repositoryAlias">The repository to alias.</param>
		/// <param name="repositoryTarget">The repository that the repository is aliased to.</param>
		/// <remarks>
		/// <para>
		/// The repository specified will be aliased to the repository when created. 
		/// The repository must not already exist.
		/// </para>
		/// <para>
		/// When the repository is created it must utilize the same repository type as 
		/// the repository it is aliased to, otherwise the aliasing will fail.
		/// </para>
		/// </remarks>
		/// <exception cref="ArgumentNullException">
		///	<para><paramref name="repositoryAlias" /> is <see langword="null" />.</para>
		///	<para>-or-</para>
		///	<para><paramref name="repositoryTarget" /> is <see langword="null" />.</para>
		/// </exception>
		public void AliasRepository(string repositoryAlias, ILoggerRepository repositoryTarget) 
		{
			if (repositoryAlias == null) 
			{
				throw new ArgumentNullException("repositoryAlias");
			}
			if (repositoryTarget == null) 
			{
				throw new ArgumentNullException("repositoryTarget");
			}

			lock(this) 
			{
				// Check if the alias is already set
				if (m_alias2repositoryMap.Contains(repositoryAlias)) 
				{
					// Check if this is a duplicate of the current alias
					if (repositoryTarget != ((ILoggerRepository)m_alias2repositoryMap[repositoryAlias])) 
					{
						// Cannot redefine existing alias
						throw new InvalidOperationException("Repository [" + repositoryAlias + "] is already aliased to repository [" + ((ILoggerRepository)m_alias2repositoryMap[repositoryAlias]).Name + "]. Aliases cannot be redefined.");
					}
				}
					// Check if the alias is already mapped to a repository
				else if (m_name2repositoryMap.Contains(repositoryAlias)) 
				{
					// Check if this is a duplicate of the current mapping
					if ( repositoryTarget != ((ILoggerRepository)m_name2repositoryMap[repositoryAlias]) ) 
					{
						// Cannot define alias for already mapped repository
						throw new InvalidOperationException("Repository [" + repositoryAlias + "] already exists and cannot be aliased to repository [" + repositoryTarget.Name + "].");
					}
				}
				else 
				{
					// Set the alias
					m_alias2repositoryMap[repositoryAlias] = repositoryTarget;
				}
			}
		}

		#endregion Public Instance Methods

		#region Protected Instance Methods

		/// <summary>
		/// Notifies the registered listeners that the repository has been created.
		/// </summary>
		/// <param name="repository">The repository that has been created.</param>
		/// <remarks>
		/// <para>
		/// Raises the <see cref="LoggerRepositoryCreatedEvent"/> event.
		/// </para>
		/// </remarks>
		protected virtual void OnLoggerRepositoryCreatedEvent(ILoggerRepository repository) 
		{
			LoggerRepositoryCreationEventHandler handler = m_loggerRepositoryCreatedEvent;
			if (handler != null) 
			{
				handler(this, new LoggerRepositoryCreationEventArgs(repository));
			}
		}

		#endregion Protected Instance Methods

		#region Private Instance Methods

		/// <summary>
		/// Gets the repository name and repository type for the specified assembly.
		/// </summary>
		/// <param name="assembly">The assembly that has a <see cref="log4net.Config.RepositoryAttribute"/>.</param>
		/// <param name="repositoryName">in/out param to hold the repository name to use for the assembly, caller should set this to the default value before calling.</param>
		/// <param name="repositoryType">in/out param to hold the type of the repository to create for the assembly, caller should set this to the default value before calling.</param>
		/// <exception cref="ArgumentNullException"><paramref name="assembly" /> is <see langword="null" />.</exception>
		private void GetInfoForAssembly(Assembly assembly, ref string repositoryName, ref Type repositoryType)
		{
			if (assembly == null)
			{
				throw new ArgumentNullException("assembly");
			}

			try
			{
				LogLog.Debug(declaringType, "Assembly [" + assembly.FullName + "] Loaded From [" + SystemInfo.AssemblyLocationInfo(assembly) + "]");
			}
			catch
			{
				// Ignore exception from debug call
			}

			try
			{
				// Look for the RepositoryAttribute on the assembly 
#if NETSTANDARD1_3
				object[] repositoryAttributes = assembly.GetCustomAttributes(typeof(log4net.Config.RepositoryAttribute)).ToArray();
#else
				object[] repositoryAttributes = Attribute.GetCustomAttributes(assembly, typeof(log4net.Config.RepositoryAttribute), false);
#endif
				if (repositoryAttributes == null || repositoryAttributes.Length == 0)
				{
					// This is not a problem, but its nice to know what is going on.
					LogLog.Debug(declaringType, "Assembly [" + assembly + "] does not have a RepositoryAttribute specified.");
				}
				else
				{
					if (repositoryAttributes.Length > 1)
					{
						LogLog.Error(declaringType, "Assembly [" + assembly + "] has multiple log4net.Config.RepositoryAttribute assembly attributes. Only using first occurrence.");
					}

					log4net.Config.RepositoryAttribute domAttr = repositoryAttributes[0] as log4net.Config.RepositoryAttribute;

					if (domAttr == null)
					{
						LogLog.Error(declaringType, "Assembly [" + assembly + "] has a RepositoryAttribute but it does not!.");
					}
					else
					{
						// If the Name property is set then override the default
						if (domAttr.Name != null)
						{
							repositoryName = domAttr.Name;
						}

						// If the RepositoryType property is set then override the default
						if (domAttr.RepositoryType != null)
						{
							// Check that the type is a repository
							if (typeof(ILoggerRepository).IsAssignableFrom(domAttr.RepositoryType))
							{
								repositoryType = domAttr.RepositoryType;
							}
							else
							{
								LogLog.Error(declaringType, "DefaultRepositorySelector: Repository Type [" + domAttr.RepositoryType + "] must implement the ILoggerRepository interface.");
							}
						}
					}
				}
			}
			catch (Exception ex)
			{
				LogLog.Error(declaringType, "Unhandled exception in GetInfoForAssembly", ex);
			}
		}

		/// <summary>
		/// Configures the repository using information from the assembly.
		/// </summary>
		/// <param name="assembly">The assembly containing <see cref="log4net.Config.ConfiguratorAttribute"/>
		/// attributes which define the configuration for the repository.</param>
		/// <param name="repository">The repository to configure.</param>
		/// <exception cref="ArgumentNullException">
		///	<para><paramref name="assembly" /> is <see langword="null" />.</para>
		///	<para>-or-</para>
		///	<para><paramref name="repository" /> is <see langword="null" />.</para>
		/// </exception>
		private void ConfigureRepository(Assembly assembly, ILoggerRepository repository)
		{
			if (assembly == null)
			{
				throw new ArgumentNullException("assembly");
			}
			if (repository == null)
			{
				throw new ArgumentNullException("repository");
			}

			// Look for the Configurator attributes (e.g. XmlConfiguratorAttribute) on the assembly
#if NETSTANDARD1_3
			object[] configAttributes = assembly.GetCustomAttributes(typeof(log4net.Config.ConfiguratorAttribute)).ToArray();
#else
			object[] configAttributes = Attribute.GetCustomAttributes(assembly, typeof(log4net.Config.ConfiguratorAttribute), false);
#endif
			if (configAttributes != null && configAttributes.Length > 0)
			{
				// Sort the ConfiguratorAttributes in priority order
				Array.Sort(configAttributes);

				// Delegate to the attribute the job of configuring the repository
				foreach(log4net.Config.ConfiguratorAttribute configAttr in configAttributes)
				{
					if (configAttr != null)
					{
						try
						{
							configAttr.Configure(assembly, repository);
						}
						catch (Exception ex)
						{
							LogLog.Error(declaringType, "Exception calling ["+configAttr.GetType().FullName+"] .Configure method.", ex);
						}
					}
				}
			}

			if (repository.Name == DefaultRepositoryName)
			{
				// Try to configure the default repository using an AppSettings specified config file
				// Do this even if the repository has been configured (or claims to be), this allows overriding
				// of the default config files etc, if that is required.

				string repositoryConfigFile = SystemInfo.GetAppSetting("log4net.Config");
				if (repositoryConfigFile != null && repositoryConfigFile.Length > 0)
				{
					string applicationBaseDirectory = null;
					try
					{
						applicationBaseDirectory = SystemInfo.ApplicationBaseDirectory;
					}
					catch(Exception ex)
					{
						LogLog.Warn(declaringType, "Exception getting ApplicationBaseDirectory. appSettings log4net.Config path ["+repositoryConfigFile+"] will be treated as an absolute URI", ex);
					}

                    string repositoryConfigFilePath = repositoryConfigFile;
                    if (applicationBaseDirectory != null)
                    {
                        repositoryConfigFilePath = Path.Combine(applicationBaseDirectory, repositoryConfigFile);
                    }

                    // Determine whether to watch the file or not based on an app setting value:
				    bool watchRepositoryConfigFile = false;
#if NET_2_0 || MONO_2_0 || MONO_3_5 || MONO_4_0 || NETSTANDARD1_3
				    Boolean.TryParse(SystemInfo.GetAppSetting("log4net.Config.Watch"), out watchRepositoryConfigFile);
#else
                                    {
                                        string watch = SystemInfo.GetAppSetting("log4net.Config.Watch");
                                        if (watch != null && watch.Length > 0)
                                        {
                                            try
                                            {
                                                watchRepositoryConfigFile = Boolean.Parse(watch);
                                            }
                                            catch (FormatException)
                                            {
                                                // simply not a Boolean
                                            }
                                        }
                                    }
#endif

					if (watchRepositoryConfigFile)
					{
 						// As we are going to watch the config file it is required to resolve it as a 
 						// physical file system path pass that in a FileInfo object to the Configurator
						FileInfo repositoryConfigFileInfo = null;
						try
						{
							repositoryConfigFileInfo = new FileInfo(repositoryConfigFilePath);
						}
						catch (Exception ex)
						{
                            LogLog.Error(declaringType, "DefaultRepositorySelector: Exception while parsing log4net.Config file physical path [" + repositoryConfigFilePath + "]", ex);
						}
						try
						{
                            LogLog.Debug(declaringType, "Loading and watching configuration for default repository from AppSettings specified Config path [" + repositoryConfigFilePath + "]");

                            XmlConfigurator.ConfigureAndWatch(repository, repositoryConfigFileInfo);
						}
						catch (Exception ex)
						{
                            LogLog.Error(declaringType, "DefaultRepositorySelector: Exception calling XmlConfigurator.ConfigureAndWatch method with ConfigFilePath [" + repositoryConfigFilePath + "]", ex);
						}
					}
					else
					{
                    // As we are not going to watch the config file it is easiest to just resolve it as a 
					// URI and pass that to the Configurator
					Uri repositoryConfigUri = null;
					try
					{
					    repositoryConfigUri = new Uri(repositoryConfigFilePath);
					}
					catch(Exception ex)
					{
						LogLog.Error(declaringType, "Exception while parsing log4net.Config file path ["+repositoryConfigFile+"]", ex);
					}

					if (repositoryConfigUri != null)
					{
						LogLog.Debug(declaringType, "Loading configuration for default repository from AppSettings specified Config URI ["+repositoryConfigUri.ToString()+"]");

						try
						{
							// TODO: Support other types of configurator
							XmlConfigurator.Configure(repository, repositoryConfigUri);
						}
						catch (Exception ex)
						{
							LogLog.Error(declaringType, "Exception calling XmlConfigurator.Configure method with ConfigUri ["+repositoryConfigUri+"]", ex);
						}
					}
                    }
				}
			}
		}

		/// <summary>
		/// Loads the attribute defined plugins on the assembly.
		/// </summary>
		/// <param name="assembly">The assembly that contains the attributes.</param>
		/// <param name="repository">The repository to add the plugins to.</param>
		/// <exception cref="ArgumentNullException">
		///	<para><paramref name="assembly" /> is <see langword="null" />.</para>
		///	<para>-or-</para>
		///	<para><paramref name="repository" /> is <see langword="null" />.</para>
		/// </exception>
		private void LoadPlugins(Assembly assembly, ILoggerRepository repository)
		{
			if (assembly == null)
			{
				throw new ArgumentNullException("assembly");
			}
			if (repository == null)
			{
				throw new ArgumentNullException("repository");
			}

			// Look for the PluginAttribute on the assembly
#if NETSTANDARD1_3
			object[] configAttributes = assembly.GetCustomAttributes(typeof(log4net.Config.PluginAttribute)).ToArray();
#else
			object[] configAttributes = Attribute.GetCustomAttributes(assembly, typeof(log4net.Config.PluginAttribute), false);
#endif
			if (configAttributes != null && configAttributes.Length > 0)
			{
				foreach(log4net.Plugin.IPluginFactory configAttr in configAttributes)
				{
					try
					{
						// Create the plugin and add it to the repository
						repository.PluginMap.Add(configAttr.CreatePlugin());
					}
					catch(Exception ex)
					{
						LogLog.Error(declaringType, "Failed to create plugin. Attribute [" + configAttr.ToString() + "]", ex);
					}
				}
			}
		}

		/// <summary>
		/// Loads the attribute defined aliases on the assembly.
		/// </summary>
		/// <param name="assembly">The assembly that contains the attributes.</param>
		/// <param name="repository">The repository to alias to.</param>
		/// <exception cref="ArgumentNullException">
		///	<para><paramref name="assembly" /> is <see langword="null" />.</para>
		///	<para>-or-</para>
		///	<para><paramref name="repository" /> is <see langword="null" />.</para>
		/// </exception>
		private void LoadAliases(Assembly assembly, ILoggerRepository repository)
		{
			if (assembly == null)
			{
				throw new ArgumentNullException("assembly");
			}
			if (repository == null)
			{
				throw new ArgumentNullException("repository");
			}

			// Look for the AliasRepositoryAttribute on the assembly
#if NETSTANDARD1_3
			object[] configAttributes = assembly.GetCustomAttributes(typeof(log4net.Config.AliasRepositoryAttribute)).ToArray();
#else
			object[] configAttributes = Attribute.GetCustomAttributes(assembly, typeof(log4net.Config.AliasRepositoryAttribute), false);
#endif
			if (configAttributes != null && configAttributes.Length > 0)
			{
				foreach(log4net.Config.AliasRepositoryAttribute configAttr in configAttributes)
				{
					try
					{
						AliasRepository(configAttr.Name, repository);
					}
					catch(Exception ex)
					{
						LogLog.Error(declaringType, "Failed to alias repository [" + configAttr.Name + "]", ex);
					}
				}
			}
		}

		#endregion Private Instance Methods

		#region Private Static Fields

        /// <summary>
        /// The fully qualified type of the DefaultRepositorySelector class.
        /// </summary>
        /// <remarks>
        /// Used by the internal logger to record the Type of the
        /// log message.
        /// </remarks>
        private readonly static Type declaringType = typeof(DefaultRepositorySelector);

		private const string DefaultRepositoryName = "log4net-default-repository";

		#endregion Private Static Fields

		#region Private Instance Fields

		private readonly Hashtable m_name2repositoryMap = new Hashtable();
		private readonly Hashtable m_assembly2repositoryMap = new Hashtable();
		private readonly Hashtable m_alias2repositoryMap = new Hashtable();]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static DefaultRepositorySelector()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="894" sc="9" el="894" ec="88">log4net\Core\DefaultRepositorySelector.cs</location>
            <body hash="92b9ccd2152bc962d2b9cd234e584389"><![CDATA[private readonly static Type declaringType = typeof(DefaultRepositorySelector)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="add_LoggerRepositoryCreatedEvent">
          <declaration><![CDATA[public void add_LoggerRepositoryCreatedEvent(LoggerRepositoryCreationEventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="71" sc="8" el="71" ec="9">log4net\Core\DefaultRepositorySelector.cs</location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="add_m_loggerRepositoryCreatedEvent">
          <declaration><![CDATA[private void add_m_loggerRepositoryCreatedEvent(LoggerRepositoryCreationEventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="AliasRepository">
          <declaration><![CDATA[public void AliasRepository(string repositoryAlias, ILoggerRepository repositoryTarget)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="498" sc="3" el="536" ec="4">log4net\Core\DefaultRepositorySelector.cs</location>
            <body hash="daccb0bee4cf49806dc1020118ad684a"><![CDATA[{
			if (repositoryAlias == null) 
			{
				throw new ArgumentNullException("repositoryAlias");
			}
			if (repositoryTarget == null) 
			{
				throw new ArgumentNullException("repositoryTarget");
			}

			lock(this) 
			{
				// Check if the alias is already set
				if (m_alias2repositoryMap.Contains(repositoryAlias)) 
				{
					// Check if this is a duplicate of the current alias
					if (repositoryTarget != ((ILoggerRepository)m_alias2repositoryMap[repositoryAlias])) 
					{
						// Cannot redefine existing alias
						throw new InvalidOperationException("Repository [" + repositoryAlias + "] is already aliased to repository [" + ((ILoggerRepository)m_alias2repositoryMap[repositoryAlias]).Name + "]. Aliases cannot be redefined.");
					}
				}
					// Check if the alias is already mapped to a repository
				else if (m_name2repositoryMap.Contains(repositoryAlias)) 
				{
					// Check if this is a duplicate of the current mapping
					if ( repositoryTarget != ((ILoggerRepository)m_name2repositoryMap[repositoryAlias]) ) 
					{
						// Cannot define alias for already mapped repository
						throw new InvalidOperationException("Repository [" + repositoryAlias + "] already exists and cannot be aliased to repository [" + repositoryTarget.Name + "].");
					}
				}
				else 
				{
					// Set the alias
					m_alias2repositoryMap[repositoryAlias] = repositoryTarget;
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ConfigureRepository">
          <declaration><![CDATA[private void ConfigureRepository(Assembly assembly, ILoggerRepository repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="655" sc="3" el="794" ec="4">log4net\Core\DefaultRepositorySelector.cs</location>
            <body hash="902460d4b53b578d112ce47bb470ffe4"><![CDATA[{
			if (assembly == null)
			{
				throw new ArgumentNullException("assembly");
			}
			if (repository == null)
			{
				throw new ArgumentNullException("repository");
			}

			// Look for the Configurator attributes (e.g. XmlConfiguratorAttribute) on the assembly
#if NETSTANDARD1_3
			object[] configAttributes = assembly.GetCustomAttributes(typeof(log4net.Config.ConfiguratorAttribute)).ToArray();
#else
			object[] configAttributes = Attribute.GetCustomAttributes(assembly, typeof(log4net.Config.ConfiguratorAttribute), false);
#endif
			if (configAttributes != null && configAttributes.Length > 0)
			{
				// Sort the ConfiguratorAttributes in priority order
				Array.Sort(configAttributes);

				// Delegate to the attribute the job of configuring the repository
				foreach(log4net.Config.ConfiguratorAttribute configAttr in configAttributes)
				{
					if (configAttr != null)
					{
						try
						{
							configAttr.Configure(assembly, repository);
						}
						catch (Exception ex)
						{
							LogLog.Error(declaringType, "Exception calling ["+configAttr.GetType().FullName+"] .Configure method.", ex);
						}
					}
				}
			}

			if (repository.Name == DefaultRepositoryName)
			{
				// Try to configure the default repository using an AppSettings specified config file
				// Do this even if the repository has been configured (or claims to be), this allows overriding
				// of the default config files etc, if that is required.

				string repositoryConfigFile = SystemInfo.GetAppSetting("log4net.Config");
				if (repositoryConfigFile != null && repositoryConfigFile.Length > 0)
				{
					string applicationBaseDirectory = null;
					try
					{
						applicationBaseDirectory = SystemInfo.ApplicationBaseDirectory;
					}
					catch(Exception ex)
					{
						LogLog.Warn(declaringType, "Exception getting ApplicationBaseDirectory. appSettings log4net.Config path ["+repositoryConfigFile+"] will be treated as an absolute URI", ex);
					}

                    string repositoryConfigFilePath = repositoryConfigFile;
                    if (applicationBaseDirectory != null)
                    {
                        repositoryConfigFilePath = Path.Combine(applicationBaseDirectory, repositoryConfigFile);
                    }

                    // Determine whether to watch the file or not based on an app setting value:
				    bool watchRepositoryConfigFile = false;
#if NET_2_0 || MONO_2_0 || MONO_3_5 || MONO_4_0 || NETSTANDARD1_3
				    Boolean.TryParse(SystemInfo.GetAppSetting("log4net.Config.Watch"), out watchRepositoryConfigFile);
#else
                                    {
                                        string watch = SystemInfo.GetAppSetting("log4net.Config.Watch");
                                        if (watch != null && watch.Length > 0)
                                        {
                                            try
                                            {
                                                watchRepositoryConfigFile = Boolean.Parse(watch);
                                            }
                                            catch (FormatException)
                                            {
                                                // simply not a Boolean
                                            }
                                        }
                                    }
#endif

					if (watchRepositoryConfigFile)
					{
 						// As we are going to watch the config file it is required to resolve it as a 
 						// physical file system path pass that in a FileInfo object to the Configurator
						FileInfo repositoryConfigFileInfo = null;
						try
						{
							repositoryConfigFileInfo = new FileInfo(repositoryConfigFilePath);
						}
						catch (Exception ex)
						{
                            LogLog.Error(declaringType, "DefaultRepositorySelector: Exception while parsing log4net.Config file physical path [" + repositoryConfigFilePath + "]", ex);
						}
						try
						{
                            LogLog.Debug(declaringType, "Loading and watching configuration for default repository from AppSettings specified Config path [" + repositoryConfigFilePath + "]");

                            XmlConfigurator.ConfigureAndWatch(repository, repositoryConfigFileInfo);
						}
						catch (Exception ex)
						{
                            LogLog.Error(declaringType, "DefaultRepositorySelector: Exception calling XmlConfigurator.ConfigureAndWatch method with ConfigFilePath [" + repositoryConfigFilePath + "]", ex);
						}
					}
					else
					{
                    // As we are not going to watch the config file it is easiest to just resolve it as a 
					// URI and pass that to the Configurator
					Uri repositoryConfigUri = null;
					try
					{
					    repositoryConfigUri = new Uri(repositoryConfigFilePath);
					}
					catch(Exception ex)
					{
						LogLog.Error(declaringType, "Exception while parsing log4net.Config file path ["+repositoryConfigFile+"]", ex);
					}

					if (repositoryConfigUri != null)
					{
						LogLog.Debug(declaringType, "Loading configuration for default repository from AppSettings specified Config URI ["+repositoryConfigUri.ToString()+"]");

						try
						{
							// TODO: Support other types of configurator
							XmlConfigurator.Configure(repository, repositoryConfigUri);
						}
						catch (Exception ex)
						{
							LogLog.Error(declaringType, "Exception calling XmlConfigurator.Configure method with ConfigUri ["+repositoryConfigUri+"]", ex);
						}
					}
                    }
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="CreateRepository">
          <declaration><![CDATA[public ILoggerRepository CreateRepository(Assembly repositoryAssembly, Type repositoryType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="219" sc="3" el="221" ec="4">log4net\Core\DefaultRepositorySelector.cs</location>
            <body hash="3483082c751c1d22afe547b481267cd6"><![CDATA[{
			return CreateRepository(repositoryAssembly, repositoryType, DefaultRepositoryName, true);
		}]]></body>
          </codeblock>
        </method>
        <method name="CreateRepository">
          <declaration><![CDATA[public ILoggerRepository CreateRepository(Assembly repositoryAssembly, Type repositoryType, string repositoryName, bool readAssemblyAttributes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="262" sc="3" el="342" ec="4">log4net\Core\DefaultRepositorySelector.cs</location>
            <body hash="f43395b6f910a076b2e0ee0ca80077ce"><![CDATA[{
			if (repositoryAssembly == null)
			{
				throw new ArgumentNullException("repositoryAssembly");
			}

			// If the type is not set then use the default type
			if (repositoryType == null)
			{
				repositoryType = m_defaultRepositoryType;
			}

			lock(this)
			{
				// Lookup in map
				ILoggerRepository rep = m_assembly2repositoryMap[repositoryAssembly] as ILoggerRepository;
				if (rep == null)
				{
					// Not found, therefore create
					LogLog.Debug(declaringType, "Creating repository for assembly [" + repositoryAssembly + "]");

					// Must specify defaults
					string actualRepositoryName = repositoryName;
					Type actualRepositoryType = repositoryType;

					if (readAssemblyAttributes)
					{
						// Get the repository and type from the assembly attributes
						GetInfoForAssembly(repositoryAssembly, ref actualRepositoryName, ref actualRepositoryType);
					}

					LogLog.Debug(declaringType, "Assembly [" + repositoryAssembly + "] using repository [" + actualRepositoryName + "] and repository type [" + actualRepositoryType + "]");

					// Lookup the repository in the map (as this may already be defined)
					rep = m_name2repositoryMap[actualRepositoryName] as ILoggerRepository;
					if (rep == null)
					{
						// Create the repository
						rep = CreateRepository(actualRepositoryName, actualRepositoryType);

						if (readAssemblyAttributes)
						{
							try
							{
								// Look for aliasing attributes
								LoadAliases(repositoryAssembly, rep);

								// Look for plugins defined on the assembly
								LoadPlugins(repositoryAssembly, rep);

								// Configure the repository using the assembly attributes
								ConfigureRepository(repositoryAssembly, rep);
							}
							catch (Exception ex)
							{
								LogLog.Error(declaringType, "Failed to configure repository [" + actualRepositoryName + "] from assembly attributes.", ex);
							}
						}
					}
					else
					{
						LogLog.Debug(declaringType, "repository [" + actualRepositoryName + "] already exists, using repository type [" + rep.GetType().FullName + "]");

						if (readAssemblyAttributes)
						{
							try
							{
								// Look for plugins defined on the assembly
								LoadPlugins(repositoryAssembly, rep);
							}
							catch (Exception ex)
							{
								LogLog.Error(declaringType, "Failed to configure repository [" + actualRepositoryName + "] from assembly attributes.", ex);
							}
						}
					}
					m_assembly2repositoryMap[repositoryAssembly] = rep;
				}
				return rep;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="CreateRepository">
          <declaration><![CDATA[public ILoggerRepository CreateRepository(string repositoryName, Type repositoryType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="361" sc="3" el="431" ec="4">log4net\Core\DefaultRepositorySelector.cs</location>
            <body hash="522d8d20d30d894ff31b040106098c0c"><![CDATA[{
			if (repositoryName == null)
			{
				throw new ArgumentNullException("repositoryName");
			}

			// If the type is not set then use the default type
			if (repositoryType == null)
			{
				repositoryType = m_defaultRepositoryType;
			}

			lock(this)
			{
				ILoggerRepository rep = null;

				// First check that the repository does not exist
				rep = m_name2repositoryMap[repositoryName] as ILoggerRepository;
				if (rep != null)
				{
					throw new LogException("Repository [" + repositoryName + "] is already defined. Repositories cannot be redefined.");
				}
				else
				{
					// Lookup an alias before trying to create the new repository
					ILoggerRepository aliasedRepository = m_alias2repositoryMap[repositoryName] as ILoggerRepository;
					if (aliasedRepository != null)
					{
						// Found an alias

						// Check repository type
						if (aliasedRepository.GetType() == repositoryType)
						{
							// Repository type is compatible
							LogLog.Debug(declaringType, "Aliasing repository [" + repositoryName + "] to existing repository [" + aliasedRepository.Name + "]");
							rep = aliasedRepository;

							// Store in map
							m_name2repositoryMap[repositoryName] = rep;
						}
						else
						{
							// Invalid repository type for alias
							LogLog.Error(declaringType, "Failed to alias repository [" + repositoryName + "] to existing repository ["+aliasedRepository.Name+"]. Requested repository type ["+repositoryType.FullName+"] is not compatible with existing type [" + aliasedRepository.GetType().FullName + "]");

							// We now drop through to create the repository without aliasing
						}
					}

					// If we could not find an alias
					if (rep == null)
					{
						LogLog.Debug(declaringType, "Creating repository [" + repositoryName + "] using type [" + repositoryType + "]");

						// Call the no arg constructor for the repositoryType
						rep = (ILoggerRepository)Activator.CreateInstance(repositoryType);

						// Set the name of the repository
						rep.Name = repositoryName;

						// Store in map
						m_name2repositoryMap[repositoryName] = rep;

						// Notify listeners that the repository has been created
						OnLoggerRepositoryCreatedEvent(rep);
					}
				}

				return rep;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ExistsRepository">
          <declaration><![CDATA[public bool ExistsRepository(string repositoryName)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="446" sc="3" el="451" ec="4">log4net\Core\DefaultRepositorySelector.cs</location>
            <body hash="7ca82b37cc2a01eaa1bddf41d123231f"><![CDATA[{
			lock(this)
			{
				return m_name2repositoryMap.ContainsKey(repositoryName);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="GetAllRepositories">
          <declaration><![CDATA[public ILoggerRepository[] GetAllRepositories()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="463" sc="3" el="471" ec="4">log4net\Core\DefaultRepositorySelector.cs</location>
            <body hash="29b29fda57ff2322ce5f88779802a5e2"><![CDATA[{
			lock(this)
			{
				ICollection reps = m_name2repositoryMap.Values;
				ILoggerRepository[] all = new ILoggerRepository[reps.Count];
				reps.CopyTo(all, 0);
				return all;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="GetInfoForAssembly">
          <declaration><![CDATA[private void GetInfoForAssembly(Assembly assembly, ref string repositoryName, ref Type repositoryType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="572" sc="3" el="641" ec="4">log4net\Core\DefaultRepositorySelector.cs</location>
            <body hash="3150c33fb052f58f86ef1912afdb971d"><![CDATA[{
			if (assembly == null)
			{
				throw new ArgumentNullException("assembly");
			}

			try
			{
				LogLog.Debug(declaringType, "Assembly [" + assembly.FullName + "] Loaded From [" + SystemInfo.AssemblyLocationInfo(assembly) + "]");
			}
			catch
			{
				// Ignore exception from debug call
			}

			try
			{
				// Look for the RepositoryAttribute on the assembly 
#if NETSTANDARD1_3
				object[] repositoryAttributes = assembly.GetCustomAttributes(typeof(log4net.Config.RepositoryAttribute)).ToArray();
#else
				object[] repositoryAttributes = Attribute.GetCustomAttributes(assembly, typeof(log4net.Config.RepositoryAttribute), false);
#endif
				if (repositoryAttributes == null || repositoryAttributes.Length == 0)
				{
					// This is not a problem, but its nice to know what is going on.
					LogLog.Debug(declaringType, "Assembly [" + assembly + "] does not have a RepositoryAttribute specified.");
				}
				else
				{
					if (repositoryAttributes.Length > 1)
					{
						LogLog.Error(declaringType, "Assembly [" + assembly + "] has multiple log4net.Config.RepositoryAttribute assembly attributes. Only using first occurrence.");
					}

					log4net.Config.RepositoryAttribute domAttr = repositoryAttributes[0] as log4net.Config.RepositoryAttribute;

					if (domAttr == null)
					{
						LogLog.Error(declaringType, "Assembly [" + assembly + "] has a RepositoryAttribute but it does not!.");
					}
					else
					{
						// If the Name property is set then override the default
						if (domAttr.Name != null)
						{
							repositoryName = domAttr.Name;
						}

						// If the RepositoryType property is set then override the default
						if (domAttr.RepositoryType != null)
						{
							// Check that the type is a repository
							if (typeof(ILoggerRepository).IsAssignableFrom(domAttr.RepositoryType))
							{
								repositoryType = domAttr.RepositoryType;
							}
							else
							{
								LogLog.Error(declaringType, "DefaultRepositorySelector: Repository Type [" + domAttr.RepositoryType + "] must implement the ILoggerRepository interface.");
							}
						}
					}
				}
			}
			catch (Exception ex)
			{
				LogLog.Error(declaringType, "Unhandled exception in GetInfoForAssembly", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="GetRepository">
          <declaration><![CDATA[public ILoggerRepository GetRepository(Assembly repositoryAssembly)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="138" sc="3" el="144" ec="4">log4net\Core\DefaultRepositorySelector.cs</location>
            <body hash="558dac149754139db9e8a0bb1605ba27"><![CDATA[{
			if (repositoryAssembly == null)
			{
				throw new ArgumentNullException("repositoryAssembly");
			}
			return CreateRepository(repositoryAssembly, m_defaultRepositoryType);
		}]]></body>
          </codeblock>
        </method>
        <method name="GetRepository">
          <declaration><![CDATA[public ILoggerRepository GetRepository(string repositoryName)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="164" sc="3" el="180" ec="4">log4net\Core\DefaultRepositorySelector.cs</location>
            <body hash="7ff93c82555d848e415e558afa70eda1"><![CDATA[{
			if (repositoryName == null)
			{
				throw new ArgumentNullException("repositoryName");
			}

			lock(this)
			{
				// Lookup in map
				ILoggerRepository rep = m_name2repositoryMap[repositoryName] as ILoggerRepository;
				if (rep == null)
				{
					throw new LogException("Repository [" + repositoryName + "] is NOT defined.");
				}
				return rep;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="LoadAliases">
          <declaration><![CDATA[private void LoadAliases(Assembly assembly, ILoggerRepository repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="851" sc="3" el="881" ec="4">log4net\Core\DefaultRepositorySelector.cs</location>
            <body hash="1b280ce443ff73f445ad173010995c0e"><![CDATA[{
			if (assembly == null)
			{
				throw new ArgumentNullException("assembly");
			}
			if (repository == null)
			{
				throw new ArgumentNullException("repository");
			}

			// Look for the AliasRepositoryAttribute on the assembly
#if NETSTANDARD1_3
			object[] configAttributes = assembly.GetCustomAttributes(typeof(log4net.Config.AliasRepositoryAttribute)).ToArray();
#else
			object[] configAttributes = Attribute.GetCustomAttributes(assembly, typeof(log4net.Config.AliasRepositoryAttribute), false);
#endif
			if (configAttributes != null && configAttributes.Length > 0)
			{
				foreach(log4net.Config.AliasRepositoryAttribute configAttr in configAttributes)
				{
					try
					{
						AliasRepository(configAttr.Name, repository);
					}
					catch(Exception ex)
					{
						LogLog.Error(declaringType, "Failed to alias repository [" + configAttr.Name + "]", ex);
					}
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="LoadPlugins">
          <declaration><![CDATA[private void LoadPlugins(Assembly assembly, ILoggerRepository repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="807" sc="3" el="838" ec="4">log4net\Core\DefaultRepositorySelector.cs</location>
            <body hash="d2f49563b99347d7df7b55cc038c4a39"><![CDATA[{
			if (assembly == null)
			{
				throw new ArgumentNullException("assembly");
			}
			if (repository == null)
			{
				throw new ArgumentNullException("repository");
			}

			// Look for the PluginAttribute on the assembly
#if NETSTANDARD1_3
			object[] configAttributes = assembly.GetCustomAttributes(typeof(log4net.Config.PluginAttribute)).ToArray();
#else
			object[] configAttributes = Attribute.GetCustomAttributes(assembly, typeof(log4net.Config.PluginAttribute), false);
#endif
			if (configAttributes != null && configAttributes.Length > 0)
			{
				foreach(log4net.Plugin.IPluginFactory configAttr in configAttributes)
				{
					try
					{
						// Create the plugin and add it to the repository
						repository.PluginMap.Add(configAttr.CreatePlugin());
					}
					catch(Exception ex)
					{
						LogLog.Error(declaringType, "Failed to create plugin. Attribute [" + configAttr.ToString() + "]", ex);
					}
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="OnLoggerRepositoryCreatedEvent">
          <declaration><![CDATA[protected virtual void OnLoggerRepositoryCreatedEvent(ILoggerRepository repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="552" sc="3" el="558" ec="4">log4net\Core\DefaultRepositorySelector.cs</location>
            <body hash="da5f11970c855eb31f7113d4ea07e794"><![CDATA[{
			LoggerRepositoryCreationEventHandler handler = m_loggerRepositoryCreatedEvent;
			if (handler != null) 
			{
				handler(this, new LoggerRepositoryCreationEventArgs(repository));
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="remove_LoggerRepositoryCreatedEvent">
          <declaration><![CDATA[public void remove_LoggerRepositoryCreatedEvent(LoggerRepositoryCreationEventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="72" sc="11" el="72" ec="12">log4net\Core\DefaultRepositorySelector.cs</location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="remove_m_loggerRepositoryCreatedEvent">
          <declaration><![CDATA[private void remove_m_loggerRepositoryCreatedEvent(LoggerRepositoryCreationEventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(DefaultRepositorySelector);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DefaultRepositoryName">
          <declaration><![CDATA[private const string DefaultRepositoryName = "log4net-default-repository";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_alias2repositoryMap">
          <declaration><![CDATA[private readonly Hashtable m_alias2repositoryMap = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_assembly2repositoryMap">
          <declaration><![CDATA[private readonly Hashtable m_assembly2repositoryMap = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_defaultRepositoryType">
          <declaration><![CDATA[private readonly Type m_defaultRepositoryType;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_loggerRepositoryCreatedEvent">
          <declaration><![CDATA[private LoggerRepositoryCreationEventHandler m_loggerRepositoryCreatedEvent;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_name2repositoryMap">
          <declaration><![CDATA[private readonly Hashtable m_name2repositoryMap = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
        <event name="LoggerRepositoryCreatedEvent">
          <declaration><![CDATA[public event LoggerRepositoryCreationEventHandler LoggerRepositoryCreatedEvent]]></declaration>
          <documentation>
          </documentation>
        </event>
        <event name="m_loggerRepositoryCreatedEvent">
          <declaration><![CDATA[private event LoggerRepositoryCreationEventHandler m_loggerRepositoryCreatedEvent;]]></declaration>
          <documentation>
          </documentation>
        </event>
      </events>
    </class>
    <class name="ErrorCode">
      <declaration><![CDATA[public enum ErrorCode]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="AddressParseFailure">
          <declaration><![CDATA[public const ErrorCode AddressParseFailure = 6;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="CloseFailure">
          <declaration><![CDATA[public const ErrorCode CloseFailure = 3;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="FileOpenFailure">
          <declaration><![CDATA[public const ErrorCode FileOpenFailure = 4;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="FlushFailure">
          <declaration><![CDATA[public const ErrorCode FlushFailure = 2;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="GenericFailure">
          <declaration><![CDATA[public const ErrorCode GenericFailure = 0;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="MissingLayout">
          <declaration><![CDATA[public const ErrorCode MissingLayout = 5;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="WriteFailure">
          <declaration><![CDATA[public const ErrorCode WriteFailure = 1;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="ExceptionEvaluator">
      <declaration><![CDATA[public class ExceptionEvaluator : ITriggeringEventEvaluator]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ExceptionEvaluator()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="53" sc="3" el="56" ec="4">log4net\Core\ExceptionEvaluator.cs</location>
            <body hash="c8ee6074e22cd4b4a513c005cf34e541"><![CDATA[public ExceptionEvaluator()
		{
			// empty
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public ExceptionEvaluator(Type exType, bool triggerOnSubClass)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="63" sc="3" el="72" ec="4">log4net\Core\ExceptionEvaluator.cs</location>
            <body hash="3fa67fab56c0efa3cec567c68c3bdcc7"><![CDATA[public ExceptionEvaluator(Type exType, bool triggerOnSubClass)
		{
			if (exType == null)
			{
				throw new ArgumentNullException("exType");
			}

			m_type = exType;
			m_triggerOnSubclass = triggerOnSubClass;
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="IsTriggeringEvent">
          <declaration><![CDATA[public bool IsTriggeringEvent(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="109" sc="3" el="129" ec="4">log4net\Core\ExceptionEvaluator.cs</location>
            <body hash="ab7088a820b218c413c5935ad5d7e4ed"><![CDATA[{
			if (loggingEvent == null)
			{
				throw new ArgumentNullException("loggingEvent");
			}

			if (m_triggerOnSubclass && loggingEvent.ExceptionObject != null)
			{
				// check if loggingEvent.ExceptionObject is of type ExceptionType or subclass of ExceptionType
				Type exceptionObjectType = loggingEvent.ExceptionObject.GetType();
				return exceptionObjectType == m_type || exceptionObjectType.IsSubclassOf(m_type);
			}
			else if (!m_triggerOnSubclass && loggingEvent.ExceptionObject != null)
			{   // check if loggingEvent.ExceptionObject is of type ExceptionType
				return loggingEvent.ExceptionObject.GetType() == m_type;
			}
			else
			{   // loggingEvent.ExceptionObject is null
				return false;
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_triggerOnSubclass">
          <declaration><![CDATA[private bool m_triggerOnSubclass;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_type">
          <declaration><![CDATA[private Type m_type;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="ExceptionType">
          <declaration><![CDATA[public Type ExceptionType]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="TriggerOnSubclass">
          <declaration><![CDATA[public bool TriggerOnSubclass]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="FixFlags">
      <declaration><![CDATA[public enum FixFlags]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="All">
          <declaration><![CDATA[public const FixFlags All = 268435455;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Domain">
          <declaration><![CDATA[public const FixFlags Domain = 64;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Exception">
          <declaration><![CDATA[public const FixFlags Exception = 256;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Identity">
          <declaration><![CDATA[public const FixFlags Identity = 128;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="LocationInfo">
          <declaration><![CDATA[public const FixFlags LocationInfo = 16;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Mdc">
          <deprecation>Replaced by composite Properties</deprecation>
          <declaration><![CDATA[public const FixFlags Mdc = 1;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Message">
          <declaration><![CDATA[public const FixFlags Message = 4;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Ndc">
          <declaration><![CDATA[public const FixFlags Ndc = 2;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="None">
          <declaration><![CDATA[public const FixFlags None = 0;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Partial">
          <declaration><![CDATA[public const FixFlags Partial = 844;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Properties">
          <declaration><![CDATA[public const FixFlags Properties = 512;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ThreadName">
          <declaration><![CDATA[public const FixFlags ThreadName = 8;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="UserName">
          <declaration><![CDATA[public const FixFlags UserName = 32;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="IAppenderAttachable">
      <declaration><![CDATA[public interface IAppenderAttachable]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="AddAppender">
          <declaration><![CDATA[void AddAppender(IAppender appender);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetAppender">
          <declaration><![CDATA[IAppender GetAppender(string name);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="RemoveAllAppenders">
          <declaration><![CDATA[void RemoveAllAppenders();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="RemoveAppender">
          <declaration><![CDATA[IAppender RemoveAppender(IAppender appender);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="RemoveAppender">
          <declaration><![CDATA[IAppender RemoveAppender(string name);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Appenders">
          <declaration><![CDATA[AppenderCollection Appenders]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="IErrorHandler">
      <declaration><![CDATA[public interface IErrorHandler]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="Error">
          <declaration><![CDATA[void Error(string message, Exception e, ErrorCode errorCode);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Error">
          <declaration><![CDATA[void Error(string message, Exception e);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Error">
          <declaration><![CDATA[void Error(string message);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="IFixingRequired">
      <declaration><![CDATA[public interface IFixingRequired]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="GetFixedObject">
          <declaration><![CDATA[object GetFixedObject();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="ILogger">
      <declaration><![CDATA[public interface ILogger]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="IsEnabledFor">
          <declaration><![CDATA[bool IsEnabledFor(Level level);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Log">
          <declaration><![CDATA[void Log(Type callerStackBoundaryDeclaringType, Level level, object message, Exception exception);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Log">
          <declaration><![CDATA[void Log(LoggingEvent logEvent);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Name">
          <declaration><![CDATA[string Name]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Repository">
          <declaration><![CDATA[ILoggerRepository Repository]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ILoggerWrapper">
      <declaration><![CDATA[public interface ILoggerWrapper]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Logger">
          <declaration><![CDATA[ILogger Logger]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="IOptionHandler">
      <declaration><![CDATA[public interface IOptionHandler]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[void ActivateOptions();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="IRepositorySelector">
      <declaration><![CDATA[public interface IRepositorySelector]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="add_LoggerRepositoryCreatedEvent">
          <declaration><![CDATA[void add_LoggerRepositoryCreatedEvent(LoggerRepositoryCreationEventHandler value);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="CreateRepository">
          <declaration><![CDATA[ILoggerRepository CreateRepository(Assembly assembly, Type repositoryType);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="CreateRepository">
          <declaration><![CDATA[ILoggerRepository CreateRepository(string repositoryName, Type repositoryType);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="ExistsRepository">
          <declaration><![CDATA[bool ExistsRepository(string repositoryName);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetAllRepositories">
          <declaration><![CDATA[ILoggerRepository[] GetAllRepositories();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetRepository">
          <declaration><![CDATA[ILoggerRepository GetRepository(Assembly assembly);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetRepository">
          <declaration><![CDATA[ILoggerRepository GetRepository(string repositoryName);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="remove_LoggerRepositoryCreatedEvent">
          <declaration><![CDATA[void remove_LoggerRepositoryCreatedEvent(LoggerRepositoryCreationEventHandler value);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
        <event name="LoggerRepositoryCreatedEvent">
          <declaration><![CDATA[event LoggerRepositoryCreationEventHandler LoggerRepositoryCreatedEvent;]]></declaration>
          <documentation>
          </documentation>
        </event>
      </events>
    </class>
    <class name="ITriggeringEventEvaluator">
      <declaration><![CDATA[public interface ITriggeringEventEvaluator]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="IsTriggeringEvent">
          <declaration><![CDATA[bool IsTriggeringEvent(LoggingEvent loggingEvent);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="Level">
      <declaration><![CDATA[public sealed class Level : IComparable]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public Level(int level, string levelName, string displayName)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="102" sc="3" el="120" ec="4">log4net\Core\Level.cs</location>
            <body hash="07a488fa6d062f0a7bca50c3d9121972"><![CDATA[public Level(int level, string levelName, string displayName) 
		{
			if (levelName == null)
			{
				throw new ArgumentNullException("levelName");
			}
			if (displayName == null)
			{
				throw new ArgumentNullException("displayName");
			}

			m_levelValue = level;
#if NETSTANDARD1_3
			m_levelName = levelName;
#else
			m_levelName = string.Intern(levelName);
#endif
			m_levelDisplayName = displayName;
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public Level(int level, string levelName) : this(level, levelName, levelName)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="133" sc="47" el="135" ec="4">log4net\Core\Level.cs</location>
            <body hash="d9e4d260b3f76daeb5f078f0084269dd"><![CDATA[this(level, levelName, levelName)
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static Level()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="503" sc="3" el="603" ec="69">log4net\Core\Level.cs</location>
            <body hash="d02804d3a046bf79fe2842017946f7e4"><![CDATA[public readonly static Level Off = new Level(int.MaxValue, "OFF");

        /// <summary>
        /// The <see cref="Emergency" /> level designates very severe error events. 
        /// System unusable, emergencies.
        /// </summary>
        public readonly static Level Log4Net_Debug = new Level(120000, "log4net:DEBUG");

		/// <summary>
		/// The <see cref="Emergency" /> level designates very severe error events. 
		/// System unusable, emergencies.
		/// </summary>
		public readonly static Level Emergency = new Level(120000, "EMERGENCY");

		/// <summary>
		/// The <see cref="Fatal" /> level designates very severe error events 
		/// that will presumably lead the application to abort.
		/// </summary>
		public readonly static Level Fatal = new Level(110000, "FATAL");

		/// <summary>
		/// The <see cref="Alert" /> level designates very severe error events. 
		/// Take immediate action, alerts.
		/// </summary>
		public readonly static Level Alert = new Level(100000, "ALERT");

		/// <summary>
		/// The <see cref="Critical" /> level designates very severe error events. 
		/// Critical condition, critical.
		/// </summary>
		public readonly static Level Critical = new Level(90000, "CRITICAL");

		/// <summary>
		/// The <see cref="Severe" /> level designates very severe error events.
		/// </summary>
		public readonly static Level Severe = new Level(80000, "SEVERE");

		/// <summary>
		/// The <see cref="Error" /> level designates error events that might 
		/// still allow the application to continue running.
		/// </summary>
		public readonly static Level Error = new Level(70000, "ERROR");

		/// <summary>
		/// The <see cref="Warn" /> level designates potentially harmful 
		/// situations.
		/// </summary>
		public readonly static Level Warn  = new Level(60000, "WARN");

		/// <summary>
		/// The <see cref="Notice" /> level designates informational messages 
		/// that highlight the progress of the application at the highest level.
		/// </summary>
		public readonly static Level Notice  = new Level(50000, "NOTICE");

		/// <summary>
		/// The <see cref="Info" /> level designates informational messages that 
		/// highlight the progress of the application at coarse-grained level.
		/// </summary>
		public readonly static Level Info  = new Level(40000, "INFO");

		/// <summary>
		/// The <see cref="Debug" /> level designates fine-grained informational 
		/// events that are most useful to debug an application.
		/// </summary>
		public readonly static Level Debug = new Level(30000, "DEBUG");

		/// <summary>
		/// The <see cref="Fine" /> level designates fine-grained informational 
		/// events that are most useful to debug an application.
		/// </summary>
		public readonly static Level Fine = new Level(30000, "FINE");

		/// <summary>
		/// The <see cref="Trace" /> level designates fine-grained informational 
		/// events that are most useful to debug an application.
		/// </summary>
		public readonly static Level Trace = new Level(20000, "TRACE");

		/// <summary>
		/// The <see cref="Finer" /> level designates fine-grained informational 
		/// events that are most useful to debug an application.
		/// </summary>
		public readonly static Level Finer = new Level(20000, "FINER");

		/// <summary>
		/// The <see cref="Verbose" /> level designates fine-grained informational 
		/// events that are most useful to debug an application.
		/// </summary>
		public readonly static Level Verbose = new Level(10000, "VERBOSE");

		/// <summary>
		/// The <see cref="Finest" /> level designates fine-grained informational 
		/// events that are most useful to debug an application.
		/// </summary>
		public readonly static Level Finest = new Level(10000, "FINEST");

		/// <summary>
		/// The <see cref="All" /> level designates the lowest level possible.
		/// </summary>
		public readonly static Level All = new Level(int.MinValue, "ALL");]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Compare">
          <declaration><![CDATA[public static int Compare(Level l, Level r)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="473" sc="3" el="494" ec="4">log4net\Core\Level.cs</location>
            <body hash="add1d2ac88b3a21e109279de3250d03d"><![CDATA[{
			// Reference equals
			if ((object)l == (object)r)
			{
				return 0;
			}

			if (l == null && r == null)
			{
				return 0;
			}
			if (l == null)
			{
				return -1;
			}
			if (r == null)
			{
				return 1;
			}

			return l.m_levelValue.CompareTo(r.m_levelValue);
		}]]></body>
          </codeblock>
        </method>
        <method name="CompareTo">
          <declaration><![CDATA[public int CompareTo(object r)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="296" sc="3" el="303" ec="4">log4net\Core\Level.cs</location>
            <body hash="f05ceb19aa1e7522816c558f941a3508"><![CDATA[{
			Level target = r as Level;
			if (target != null)
			{
				return Compare(this, target);
			}
			throw new ArgumentException("Parameter: r, Value: [" + r + "] is not an instance of Level");
		}]]></body>
          </codeblock>
        </method>
        <method name="Equals">
          <declaration><![CDATA[public override bool Equals(object o)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="223" sc="3" el="233" ec="4">log4net\Core\Level.cs</location>
            <body hash="a931c369c1f49877c2a1dcce3a47eea6"><![CDATA[{
			Level otherLevel = o as Level;
			if (otherLevel != null)
			{
				return m_levelValue == otherLevel.m_levelValue;
			}
			else
			{
				return base.Equals(o);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="GetHashCode">
          <declaration><![CDATA[public override int GetHashCode()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="249" sc="3" el="251" ec="4">log4net\Core\Level.cs</location>
            <body hash="3af91699064df9d9c1ee2a53b96a7f33"><![CDATA[{
			return m_levelValue;
		}]]></body>
          </codeblock>
        </method>
        <method name="op_Equality">
          <declaration><![CDATA[public static bool operator ==(Level l, Level r)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="405" sc="3" el="414" ec="4">log4net\Core\Level.cs</location>
            <body hash="4192e10cecce916adc455faabeb5e1fb"><![CDATA[{
			if (((object)l) != null && ((object)r) != null)
			{
				return l.m_levelValue == r.m_levelValue;
			}
			else
			{
				return ((object) l) == ((object) r);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="op_GreaterThan">
          <declaration><![CDATA[public static bool operator >(Level l, Level r)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="325" sc="3" el="327" ec="4">log4net\Core\Level.cs</location>
            <body hash="d399b59b5da909471448cfa1f24464a4"><![CDATA[{
			return l.m_levelValue > r.m_levelValue;
		}]]></body>
          </codeblock>
        </method>
        <method name="op_GreaterThanOrEqual">
          <declaration><![CDATA[public static bool operator >=(Level l, Level r)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="365" sc="3" el="367" ec="4">log4net\Core\Level.cs</location>
            <body hash="3fb7768345493df17ffcbf008ab88d62"><![CDATA[{
			return l.m_levelValue >= r.m_levelValue;
		}]]></body>
          </codeblock>
        </method>
        <method name="op_Inequality">
          <declaration><![CDATA[public static bool operator !=(Level l, Level r)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="432" sc="3" el="434" ec="4">log4net\Core\Level.cs</location>
            <body hash="bf50b430a24342a319be37f361665a6e"><![CDATA[{
			return !(l==r);
		}]]></body>
          </codeblock>
        </method>
        <method name="op_LessThan">
          <declaration><![CDATA[public static bool operator <(Level l, Level r)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="345" sc="3" el="347" ec="4">log4net\Core\Level.cs</location>
            <body hash="2c6e54136c51f88e46d54399ae5852ee"><![CDATA[{
			return l.m_levelValue < r.m_levelValue;
		}]]></body>
          </codeblock>
        </method>
        <method name="op_LessThanOrEqual">
          <declaration><![CDATA[public static bool operator <=(Level l, Level r)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="385" sc="3" el="387" ec="4">log4net\Core\Level.cs</location>
            <body hash="5cac7cf247071f010f677b38756b9680"><![CDATA[{
			return l.m_levelValue <= r.m_levelValue;
		}]]></body>
          </codeblock>
        </method>
        <method name="ToString">
          <declaration><![CDATA[public override string ToString()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="206" sc="3" el="208" ec="4">log4net\Core\Level.cs</location>
            <body hash="1ae2b2ed9e7b413671bfae47832f1309"><![CDATA[{
			return m_levelName;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="Alert">
          <declaration><![CDATA[public static readonly Level Alert = new Level(100000, "ALERT");]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="All">
          <declaration><![CDATA[public static readonly Level All = new Level(-2147483648, "ALL");]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Critical">
          <declaration><![CDATA[public static readonly Level Critical = new Level(90000, "CRITICAL");]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Debug">
          <declaration><![CDATA[public static readonly Level Debug = new Level(30000, "DEBUG");]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Emergency">
          <declaration><![CDATA[public static readonly Level Emergency = new Level(120000, "EMERGENCY");]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Error">
          <declaration><![CDATA[public static readonly Level Error = new Level(70000, "ERROR");]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Fatal">
          <declaration><![CDATA[public static readonly Level Fatal = new Level(110000, "FATAL");]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Fine">
          <declaration><![CDATA[public static readonly Level Fine = new Level(30000, "FINE");]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Finer">
          <declaration><![CDATA[public static readonly Level Finer = new Level(20000, "FINER");]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Finest">
          <declaration><![CDATA[public static readonly Level Finest = new Level(10000, "FINEST");]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Info">
          <declaration><![CDATA[public static readonly Level Info = new Level(40000, "INFO");]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Log4Net_Debug">
          <declaration><![CDATA[public static readonly Level Log4Net_Debug = new Level(120000, "log4net:DEBUG");]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_levelDisplayName">
          <declaration><![CDATA[private readonly string m_levelDisplayName;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_levelName">
          <declaration><![CDATA[private readonly string m_levelName;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_levelValue">
          <declaration><![CDATA[private readonly int m_levelValue;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Notice">
          <declaration><![CDATA[public static readonly Level Notice = new Level(50000, "NOTICE");]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Off">
          <declaration><![CDATA[public static readonly Level Off = new Level(2147483647, "OFF");]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Severe">
          <declaration><![CDATA[public static readonly Level Severe = new Level(80000, "SEVERE");]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Trace">
          <declaration><![CDATA[public static readonly Level Trace = new Level(20000, "TRACE");]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Verbose">
          <declaration><![CDATA[public static readonly Level Verbose = new Level(10000, "VERBOSE");]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Warn">
          <declaration><![CDATA[public static readonly Level Warn = new Level(60000, "WARN");]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="DisplayName">
          <declaration><![CDATA[public string DisplayName]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Name">
          <declaration><![CDATA[public string Name]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Value">
          <declaration><![CDATA[public int Value]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="LevelCollection">
      <declaration><![CDATA[public class LevelCollection : ICollection, IEnumerable, IList, ICloneable]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_count = 0;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="71" sc="3" el="103" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="740683b710ed9f2d1998248b73405236"><![CDATA[private int m_count = 0;
		private int m_version = 0;

		#endregion
	
		#region Static Wrappers

		/// <summary>
		/// Creates a read-only wrapper for a <c>LevelCollection</c> instance.
		/// </summary>
		/// <param name="list">list to create a readonly wrapper arround</param>
		/// <returns>
		/// A <c>LevelCollection</c> wrapper that is read-only.
		/// </returns>
		public static LevelCollection ReadOnly(LevelCollection list)
		{
			if(list==null) throw new ArgumentNullException("list");

			return new ReadOnlyLevelCollection(list);
		}

		#endregion

		#region Constructors

		/// <summary>
		/// Initializes a new instance of the <c>LevelCollection</c> class
		/// that is empty and has the default initial capacity.
		/// </summary>
		public LevelCollection()
		{
			m_array = new Level[DEFAULT_CAPACITY];
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_count = 0;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="71" sc="3" el="115" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="734c39f9ef1de2213fd280842ce493c4"><![CDATA[private int m_count = 0;
		private int m_version = 0;

		#endregion
	
		#region Static Wrappers

		/// <summary>
		/// Creates a read-only wrapper for a <c>LevelCollection</c> instance.
		/// </summary>
		/// <param name="list">list to create a readonly wrapper arround</param>
		/// <returns>
		/// A <c>LevelCollection</c> wrapper that is read-only.
		/// </returns>
		public static LevelCollection ReadOnly(LevelCollection list)
		{
			if(list==null) throw new ArgumentNullException("list");

			return new ReadOnlyLevelCollection(list);
		}

		#endregion

		#region Constructors

		/// <summary>
		/// Initializes a new instance of the <c>LevelCollection</c> class
		/// that is empty and has the default initial capacity.
		/// </summary>
		public LevelCollection()
		{
			m_array = new Level[DEFAULT_CAPACITY];
		}
		
		/// <summary>
		/// Initializes a new instance of the <c>LevelCollection</c> class
		/// that has the specified initial capacity.
		/// </summary>
		/// <param name="capacity">
		/// The number of elements that the new <c>LevelCollection</c> is initially capable of storing.
		/// </param>
		public LevelCollection(int capacity)
		{
			m_array = new Level[capacity];
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_count = 0;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="71" sc="3" el="126" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="66ff7f971ae041269c50037e71ab44e0"><![CDATA[private int m_count = 0;
		private int m_version = 0;

		#endregion
	
		#region Static Wrappers

		/// <summary>
		/// Creates a read-only wrapper for a <c>LevelCollection</c> instance.
		/// </summary>
		/// <param name="list">list to create a readonly wrapper arround</param>
		/// <returns>
		/// A <c>LevelCollection</c> wrapper that is read-only.
		/// </returns>
		public static LevelCollection ReadOnly(LevelCollection list)
		{
			if(list==null) throw new ArgumentNullException("list");

			return new ReadOnlyLevelCollection(list);
		}

		#endregion

		#region Constructors

		/// <summary>
		/// Initializes a new instance of the <c>LevelCollection</c> class
		/// that is empty and has the default initial capacity.
		/// </summary>
		public LevelCollection()
		{
			m_array = new Level[DEFAULT_CAPACITY];
		}
		
		/// <summary>
		/// Initializes a new instance of the <c>LevelCollection</c> class
		/// that has the specified initial capacity.
		/// </summary>
		/// <param name="capacity">
		/// The number of elements that the new <c>LevelCollection</c> is initially capable of storing.
		/// </param>
		public LevelCollection(int capacity)
		{
			m_array = new Level[capacity];
		}

		/// <summary>
		/// Initializes a new instance of the <c>LevelCollection</c> class
		/// that contains elements copied from the specified <c>LevelCollection</c>.
		/// </summary>
		/// <param name="c">The <c>LevelCollection</c> whose elements are copied to the new collection.</param>
		public LevelCollection(LevelCollection c)
		{
			m_array = new Level[c.Count];
			AddRange(c);
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_count = 0;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="71" sc="3" el="137" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="63e5dd355063ab4ebe2bf11144e3824c"><![CDATA[private int m_count = 0;
		private int m_version = 0;

		#endregion
	
		#region Static Wrappers

		/// <summary>
		/// Creates a read-only wrapper for a <c>LevelCollection</c> instance.
		/// </summary>
		/// <param name="list">list to create a readonly wrapper arround</param>
		/// <returns>
		/// A <c>LevelCollection</c> wrapper that is read-only.
		/// </returns>
		public static LevelCollection ReadOnly(LevelCollection list)
		{
			if(list==null) throw new ArgumentNullException("list");

			return new ReadOnlyLevelCollection(list);
		}

		#endregion

		#region Constructors

		/// <summary>
		/// Initializes a new instance of the <c>LevelCollection</c> class
		/// that is empty and has the default initial capacity.
		/// </summary>
		public LevelCollection()
		{
			m_array = new Level[DEFAULT_CAPACITY];
		}
		
		/// <summary>
		/// Initializes a new instance of the <c>LevelCollection</c> class
		/// that has the specified initial capacity.
		/// </summary>
		/// <param name="capacity">
		/// The number of elements that the new <c>LevelCollection</c> is initially capable of storing.
		/// </param>
		public LevelCollection(int capacity)
		{
			m_array = new Level[capacity];
		}

		/// <summary>
		/// Initializes a new instance of the <c>LevelCollection</c> class
		/// that contains elements copied from the specified <c>LevelCollection</c>.
		/// </summary>
		/// <param name="c">The <c>LevelCollection</c> whose elements are copied to the new collection.</param>
		public LevelCollection(LevelCollection c)
		{
			m_array = new Level[c.Count];
			AddRange(c);
		}

		/// <summary>
		/// Initializes a new instance of the <c>LevelCollection</c> class
		/// that contains elements copied from the specified <see cref="Level"/> array.
		/// </summary>
		/// <param name="a">The <see cref="Level"/> array whose elements are copied to the new list.</param>
		public LevelCollection(Level[] a)
		{
			m_array = new Level[a.Length];
			AddRange(a);
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_count = 0;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="71" sc="3" el="148" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="3fd2bc5921eb28bf8d2553ad001d2788"><![CDATA[private int m_count = 0;
		private int m_version = 0;

		#endregion
	
		#region Static Wrappers

		/// <summary>
		/// Creates a read-only wrapper for a <c>LevelCollection</c> instance.
		/// </summary>
		/// <param name="list">list to create a readonly wrapper arround</param>
		/// <returns>
		/// A <c>LevelCollection</c> wrapper that is read-only.
		/// </returns>
		public static LevelCollection ReadOnly(LevelCollection list)
		{
			if(list==null) throw new ArgumentNullException("list");

			return new ReadOnlyLevelCollection(list);
		}

		#endregion

		#region Constructors

		/// <summary>
		/// Initializes a new instance of the <c>LevelCollection</c> class
		/// that is empty and has the default initial capacity.
		/// </summary>
		public LevelCollection()
		{
			m_array = new Level[DEFAULT_CAPACITY];
		}
		
		/// <summary>
		/// Initializes a new instance of the <c>LevelCollection</c> class
		/// that has the specified initial capacity.
		/// </summary>
		/// <param name="capacity">
		/// The number of elements that the new <c>LevelCollection</c> is initially capable of storing.
		/// </param>
		public LevelCollection(int capacity)
		{
			m_array = new Level[capacity];
		}

		/// <summary>
		/// Initializes a new instance of the <c>LevelCollection</c> class
		/// that contains elements copied from the specified <c>LevelCollection</c>.
		/// </summary>
		/// <param name="c">The <c>LevelCollection</c> whose elements are copied to the new collection.</param>
		public LevelCollection(LevelCollection c)
		{
			m_array = new Level[c.Count];
			AddRange(c);
		}

		/// <summary>
		/// Initializes a new instance of the <c>LevelCollection</c> class
		/// that contains elements copied from the specified <see cref="Level"/> array.
		/// </summary>
		/// <param name="a">The <see cref="Level"/> array whose elements are copied to the new list.</param>
		public LevelCollection(Level[] a)
		{
			m_array = new Level[a.Length];
			AddRange(a);
		}

		/// <summary>
		/// Initializes a new instance of the <c>LevelCollection</c> class
		/// that contains elements copied from the specified <see cref="Level"/> collection.
		/// </summary>
		/// <param name="col">The <see cref="Level"/> collection whose elements are copied to the new list.</param>
		public LevelCollection(ICollection col)
		{
			m_array = new Level[col.Count];
			AddRange(col);
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_count = 0;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="71" sc="3" el="169" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="ab81b90159b5f57d9aac943d04847b90"><![CDATA[private int m_count = 0;
		private int m_version = 0;

		#endregion
	
		#region Static Wrappers

		/// <summary>
		/// Creates a read-only wrapper for a <c>LevelCollection</c> instance.
		/// </summary>
		/// <param name="list">list to create a readonly wrapper arround</param>
		/// <returns>
		/// A <c>LevelCollection</c> wrapper that is read-only.
		/// </returns>
		public static LevelCollection ReadOnly(LevelCollection list)
		{
			if(list==null) throw new ArgumentNullException("list");

			return new ReadOnlyLevelCollection(list);
		}

		#endregion

		#region Constructors

		/// <summary>
		/// Initializes a new instance of the <c>LevelCollection</c> class
		/// that is empty and has the default initial capacity.
		/// </summary>
		public LevelCollection()
		{
			m_array = new Level[DEFAULT_CAPACITY];
		}
		
		/// <summary>
		/// Initializes a new instance of the <c>LevelCollection</c> class
		/// that has the specified initial capacity.
		/// </summary>
		/// <param name="capacity">
		/// The number of elements that the new <c>LevelCollection</c> is initially capable of storing.
		/// </param>
		public LevelCollection(int capacity)
		{
			m_array = new Level[capacity];
		}

		/// <summary>
		/// Initializes a new instance of the <c>LevelCollection</c> class
		/// that contains elements copied from the specified <c>LevelCollection</c>.
		/// </summary>
		/// <param name="c">The <c>LevelCollection</c> whose elements are copied to the new collection.</param>
		public LevelCollection(LevelCollection c)
		{
			m_array = new Level[c.Count];
			AddRange(c);
		}

		/// <summary>
		/// Initializes a new instance of the <c>LevelCollection</c> class
		/// that contains elements copied from the specified <see cref="Level"/> array.
		/// </summary>
		/// <param name="a">The <see cref="Level"/> array whose elements are copied to the new list.</param>
		public LevelCollection(Level[] a)
		{
			m_array = new Level[a.Length];
			AddRange(a);
		}

		/// <summary>
		/// Initializes a new instance of the <c>LevelCollection</c> class
		/// that contains elements copied from the specified <see cref="Level"/> collection.
		/// </summary>
		/// <param name="col">The <see cref="Level"/> collection whose elements are copied to the new list.</param>
		public LevelCollection(ICollection col)
		{
			m_array = new Level[col.Count];
			AddRange(col);
		}
		
		/// <summary>
		/// Type visible only to our subclasses
		/// Used to access protected constructor
		/// </summary>
		protected internal enum Tag 
		{
			/// <summary>
			/// A value
			/// </summary>
			Default
		}

		/// <summary>
		/// Allow subclasses to avoid our default constructors
		/// </summary>
		/// <param name="tag"></param>
		protected internal LevelCollection(Tag tag)
		{
			m_array = null;
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Add">
          <declaration><![CDATA[public virtual int Add(Level item)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="259" sc="3" el="269" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="f295516af989168beb5ba8e0314bc4f2"><![CDATA[{
			if (m_count == m_array.Length)
			{
				EnsureCapacity(m_count + 1);
			}

			m_array[m_count] = item;
			m_version++;

			return m_count++;
		}]]></body>
          </codeblock>
        </method>
        <method name="AddRange">
          <declaration><![CDATA[public virtual int AddRange(LevelCollection x)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="482" sc="3" el="493" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="0d8472a90bea124229797545dba34bc9"><![CDATA[{
			if (m_count + x.Count >= m_array.Length)
			{
				EnsureCapacity(m_count + x.Count);
			}
			
			Array.Copy(x.m_array, 0, m_array, m_count, x.Count);
			m_count += x.Count;
			m_version++;

			return m_count;
		}]]></body>
          </codeblock>
        </method>
        <method name="AddRange">
          <declaration><![CDATA[public virtual int AddRange(Level[] x)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="501" sc="3" el="512" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="afd08b017faf3b66473566896850f9c5"><![CDATA[{
			if (m_count + x.Length >= m_array.Length)
			{
				EnsureCapacity(m_count + x.Length);
			}

			Array.Copy(x, 0, m_array, m_count, x.Length);
			m_count += x.Length;
			m_version++;

			return m_count;
		}]]></body>
          </codeblock>
        </method>
        <method name="AddRange">
          <declaration><![CDATA[public virtual int AddRange(ICollection col)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="520" sc="3" el="532" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="e6ca223c81eee44240838e84306945cf"><![CDATA[{
			if (m_count + col.Count >= m_array.Length)
			{
				EnsureCapacity(m_count + col.Count);
			}

			foreach(object item in col)
			{
				Add((Level)item);
			}

			return m_count;
		}]]></body>
          </codeblock>
        </method>
        <method name="Clear">
          <declaration><![CDATA[public virtual void Clear()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="275" sc="3" el="279" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="8f74d67c60a2cd484d73363fb80d5915"><![CDATA[{
			++m_version;
			m_array = new Level[DEFAULT_CAPACITY];
			m_count = 0;
		}]]></body>
          </codeblock>
        </method>
        <method name="Clone">
          <declaration><![CDATA[public virtual object Clone()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="286" sc="3" el="293" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="c7cb2ecf6f0f432f4b22e5cd0537c0f4"><![CDATA[{
			LevelCollection newCol = new LevelCollection(m_count);
			Array.Copy(m_array, 0, newCol.m_array, 0, m_count);
			newCol.m_count = m_count;
			newCol.m_version = m_version;

			return newCol;
		}]]></body>
          </codeblock>
        </method>
        <method name="Contains">
          <declaration><![CDATA[public virtual bool Contains(Level item)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="301" sc="3" el="310" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="3cb94335e2e358ee489dc1026763b704"><![CDATA[{
			for (int i=0; i != m_count; ++i)
			{
				if (m_array[i].Equals(item))
				{
					return true;
				}
			}
			return false;
		}]]></body>
          </codeblock>
        </method>
        <method name="CopyTo">
          <declaration><![CDATA[public virtual void CopyTo(Level[] array)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="188" sc="3" el="190" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="10b59a8638112a8dbe9bf9a101801af7"><![CDATA[{
			this.CopyTo(array, 0);
		}]]></body>
          </codeblock>
        </method>
        <method name="CopyTo">
          <declaration><![CDATA[public virtual void CopyTo(Level[] array, int start)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="199" sc="3" el="206" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="356909617fc98c0707a2955deb7b7513"><![CDATA[{
			if (m_count > array.GetUpperBound(0) + 1 - start)
			{
				throw new System.ArgumentException("Destination array was not long enough.");
			}
			
			Array.Copy(m_array, 0, array, start, m_count); 
		}]]></body>
          </codeblock>
        </method>
        <method name="EnsureCapacity">
          <declaration><![CDATA[private void EnsureCapacity(int min)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="571" sc="3" el="579" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="36181dd4bfc53e22bb4ca4f382b24b84"><![CDATA[{
			int newCapacity = ((m_array.Length == 0) ? DEFAULT_CAPACITY : m_array.Length * 2);
			if (newCapacity < min)
			{
				newCapacity = min;
			}

			this.Capacity = newCapacity;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetEnumerator">
          <declaration><![CDATA[public virtual LevelCollection.ILevelCollectionEnumerator GetEnumerator()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="436" sc="3" el="438" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="ebbb622c744110f8d1bac0707e083576"><![CDATA[{
			return new Enumerator(this);
		}]]></body>
          </codeblock>
        </method>
        <method name="IndexOf">
          <declaration><![CDATA[public virtual int IndexOf(Level item)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="322" sc="3" el="331" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="4f9aff8712a844ff66b969172807a0f6"><![CDATA[{
			for (int i=0; i != m_count; ++i)
			{
				if (m_array[i].Equals(item))
				{
					return i;
				}
			}
			return -1;
		}]]></body>
          </codeblock>
        </method>
        <method name="Insert">
          <declaration><![CDATA[public virtual void Insert(int index, Level item)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="344" sc="3" el="360" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="096f7827a2ecf8600dd315c69d823234"><![CDATA[{
			ValidateIndex(index, true); // throws
			
			if (m_count == m_array.Length)
			{
				EnsureCapacity(m_count + 1);
			}

			if (index < m_count)
			{
				Array.Copy(m_array, index, m_array, index + 1, m_count - index);
			}

			m_array[index] = item;
			m_count++;
			m_version++;
		}]]></body>
          </codeblock>
        </method>
        <method name="ReadOnly">
          <declaration><![CDATA[public static LevelCollection ReadOnly(LevelCollection list)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="86" sc="3" el="90" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="a834b8257ee93c49c5d3fff8b97b8fcd"><![CDATA[{
			if(list==null) throw new ArgumentNullException("list");

			return new ReadOnlyLevelCollection(list);
		}]]></body>
          </codeblock>
        </method>
        <method name="Remove">
          <declaration><![CDATA[public virtual void Remove(Level item)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="370" sc="3" el="379" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="de949f961937e30af1d8adb206493d69"><![CDATA[{		   
			int i = IndexOf(item);
			if (i < 0)
			{
				throw new System.ArgumentException("Cannot remove the specified item because it was not found in the specified Collection.");
			}
			
			++m_version;
			RemoveAt(i);
		}]]></body>
          </codeblock>
        </method>
        <method name="RemoveAt">
          <declaration><![CDATA[public virtual void RemoveAt(int index)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="391" sc="3" el="407" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="a5e1a6e8809672fd4aec3fc9bf7cbaf2"><![CDATA[{
			ValidateIndex(index); // throws
			
			m_count--;

			if (index < m_count)
			{
				Array.Copy(m_array, index + 1, m_array, index, m_count - index);
			}
			
			// We can't set the deleted entry equal to null, because it might be a value type.
			// Instead, we'll create an empty single-element array of the right type and copy it 
			// over the entry we want to erase.
			Level[] temp = new Level[1];
			Array.Copy(temp, 0, m_array, m_count, 1);
			m_version++;
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.ICollection.CopyTo">
          <declaration><![CDATA[void ICollection.CopyTo(Array array, int start)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="586" sc="3" el="588" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="6aca5568013b8b586ec30ff257dad014"><![CDATA[{
			Array.Copy(m_array, 0, array, start, m_count);
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IEnumerable.GetEnumerator">
          <declaration><![CDATA[IEnumerator IEnumerable.GetEnumerator()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="635" sc="3" el="637" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="7d02d007029b1701aa133378962cdce0"><![CDATA[{
			return (IEnumerator)(this.GetEnumerator());
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IList.Add">
          <declaration><![CDATA[int IList.Add(object x)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="601" sc="3" el="603" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="9ec2e8ef6138d9d15aa1b31581121be8"><![CDATA[{
			return this.Add((Level)x);
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IList.Contains">
          <declaration><![CDATA[bool IList.Contains(object x)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="606" sc="3" el="608" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="48033559c7ef1808594113d5164f9b21"><![CDATA[{
			return this.Contains((Level)x);
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IList.IndexOf">
          <declaration><![CDATA[int IList.IndexOf(object x)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="611" sc="3" el="613" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="f95519a83afc45993b8cea22e95528e3"><![CDATA[{
			return this.IndexOf((Level)x);
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IList.Insert">
          <declaration><![CDATA[void IList.Insert(int pos, object x)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="616" sc="3" el="618" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="e9283ac95a4f9416a031e28b0ecde9ce"><![CDATA[{
			this.Insert(pos, (Level)x);
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IList.Remove">
          <declaration><![CDATA[void IList.Remove(object x)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="621" sc="3" el="623" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="afeb8ae73e1f5d428b046dc2345bf1b7"><![CDATA[{
			this.Remove((Level)x);
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IList.RemoveAt">
          <declaration><![CDATA[void IList.RemoveAt(int pos)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="626" sc="3" el="628" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="e53002e980b10fa2d00afbb5c90a0118"><![CDATA[{
			this.RemoveAt(pos);
		}]]></body>
          </codeblock>
        </method>
        <method name="TrimToSize">
          <declaration><![CDATA[public virtual void TrimToSize()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="538" sc="3" el="540" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="b5df69cc284a1eeb88684b3bf89b1d2d"><![CDATA[{
			this.Capacity = m_count;
		}]]></body>
          </codeblock>
        </method>
        <method name="ValidateIndex">
          <declaration><![CDATA[private void ValidateIndex(int i)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="552" sc="3" el="554" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="7ba51ed3f3d914d29194aeca0387acc8"><![CDATA[{
			ValidateIndex(i, false);
		}]]></body>
          </codeblock>
        </method>
        <method name="ValidateIndex">
          <declaration><![CDATA[private void ValidateIndex(int i, bool allowEqualEnd)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="562" sc="3" el="568" ec="4">log4net\Core\LevelCollection.cs</location>
            <body hash="0dd0b75cfb3e4e5eb58308feb8976830"><![CDATA[{
			int max = (allowEqualEnd) ? (m_count) : (m_count-1);
			if (i < 0 || i > max)
			{
				throw log4net.Util.SystemInfo.CreateArgumentOutOfRangeException("i", (object)i, "Index was out of range. Must be non-negative and less than the size of the collection. [" + (object)i + "] Specified argument was out of the range of valid values.");
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="DEFAULT_CAPACITY">
          <declaration><![CDATA[private const int DEFAULT_CAPACITY = 16;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_array">
          <declaration><![CDATA[private Level[] m_array;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_count">
          <declaration><![CDATA[private int m_count = 0;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_version">
          <declaration><![CDATA[private int m_version = 0;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Capacity">
          <declaration><![CDATA[public virtual int Capacity]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="450" sc="4" el="452" ec="5">log4net\Core\LevelCollection.cs</location>
            <body hash="78cd26a0d2ccca573376c8e22f67dc8a"><![CDATA[{ 
				return m_array.Length; 
			}]]></body>
          </codeblock>
          <codeblock>
            <location sl="454" sc="4" el="473" ec="5">log4net\Core\LevelCollection.cs</location>
            <body hash="63e0d4447bb8e803762bff72a13aa065"><![CDATA[{
				if (value < m_count)
				{
					value = m_count;
				}

				if (value != m_array.Length)
				{
					if (value > 0)
					{
						Level[] temp = new Level[value];
						Array.Copy(m_array, 0, temp, 0, m_count);
						m_array = temp;
					}
					else
					{
						m_array = new Level[DEFAULT_CAPACITY];
					}
				}
			}]]></body>
          </codeblock>
        </property>
        <property name="Count">
          <declaration><![CDATA[public virtual int Count]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IsFixedSize">
          <declaration><![CDATA[public virtual bool IsFixedSize]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IsReadOnly">
          <declaration><![CDATA[public virtual bool IsReadOnly]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IsSynchronized">
          <declaration><![CDATA[public virtual bool IsSynchronized]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Item">
          <declaration><![CDATA[public virtual Level this[int index]]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="241" sc="4" el="244" ec="5">log4net\Core\LevelCollection.cs</location>
            <body hash="8dd2c766f54a28c4d63c86d0a7480385"><![CDATA[{
				ValidateIndex(index); // throws
				return m_array[index]; 
			}]]></body>
          </codeblock>
          <codeblock>
            <location sl="246" sc="4" el="250" ec="5">log4net\Core\LevelCollection.cs</location>
            <body hash="102e9f11d0fb63e58b9453e9181a9a4c"><![CDATA[{
				ValidateIndex(index); // throws
				++m_version; 
				m_array[index] = value; 
			}]]></body>
          </codeblock>
        </property>
        <property name="SyncRoot">
          <declaration><![CDATA[public virtual object SyncRoot]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="System.Collections.IList.Item">
          <declaration><![CDATA[object IList.this[int i]]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="LevelEvaluator">
      <declaration><![CDATA[public class LevelEvaluator : ITriggeringEventEvaluator]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public LevelEvaluator() : this(Level.Off)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="59" sc="29" el="61" ec="4">log4net\Core\LevelEvaluator.cs</location>
            <body hash="74e6a070e0d1055ad2db6f2dc5286134"><![CDATA[this(Level.Off)
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public LevelEvaluator(Level threshold)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="78" sc="3" el="86" ec="4">log4net\Core\LevelEvaluator.cs</location>
            <body hash="fc8efe62dc830a98614bba10dc3eb202"><![CDATA[public LevelEvaluator(Level threshold)
		{
			if (threshold == null)
			{
				throw new ArgumentNullException("threshold");
			}

			m_threshold = threshold;
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="IsTriggeringEvent">
          <declaration><![CDATA[public bool IsTriggeringEvent(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="124" sc="3" el="131" ec="4">log4net\Core\LevelEvaluator.cs</location>
            <body hash="7f15667c575a65ead62a3e1ba36ca0b2"><![CDATA[{
			if (loggingEvent == null)
			{
				throw new ArgumentNullException("loggingEvent");
			}

			return (loggingEvent.Level >= m_threshold); 
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_threshold">
          <declaration><![CDATA[private Level m_threshold;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Threshold">
          <declaration><![CDATA[public Level Threshold]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="LevelMap">
      <declaration><![CDATA[public sealed class LevelMap]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private Hashtable m_mapName2Level = SystemInfo.CreateCaseInsensitiveHashtable();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="47" sc="3" el="61" ec="4">log4net\Core\LevelMap.cs</location>
            <body hash="1cbb7db41eaefcc1f98de027378268aa"><![CDATA[private Hashtable m_mapName2Level = SystemInfo.CreateCaseInsensitiveHashtable();

		#endregion

		/// <summary>
		/// Construct the level map
		/// </summary>
		/// <remarks>
		/// <para>
		/// Construct the level map.
		/// </para>
		/// </remarks>
		public LevelMap()
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Add">
          <declaration><![CDATA[public void Add(string name, int value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="117" sc="3" el="119" ec="4">log4net\Core\LevelMap.cs</location>
            <body hash="c6ae19ac5c8e8ca84b8361b508d3048b"><![CDATA[{
			Add(name, value, null);
		}]]></body>
          </codeblock>
        </method>
        <method name="Add">
          <declaration><![CDATA[public void Add(string name, int value, string displayName)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="133" sc="3" el="149" ec="4">log4net\Core\LevelMap.cs</location>
            <body hash="9ad629de4943b74b95d02d1e8eccdfc5"><![CDATA[{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			if (name.Length == 0)
			{
				throw log4net.Util.SystemInfo.CreateArgumentOutOfRangeException("name", name, "Parameter: name, Value: ["+name+"] out of range. Level name must not be empty");
			}

			if (displayName == null || displayName.Length == 0)
			{
				displayName = name;
			}

			Add(new Level(value, name, displayName));
		}]]></body>
          </codeblock>
        </method>
        <method name="Add">
          <declaration><![CDATA[public void Add(Level level)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="161" sc="3" el="170" ec="4">log4net\Core\LevelMap.cs</location>
            <body hash="c32fbaf50b3b51f547012328247440c0"><![CDATA[{
			if (level == null)
			{
				throw new ArgumentNullException("level");
			}
			lock(this)
			{
				m_mapName2Level[level.Name] = level;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Clear">
          <declaration><![CDATA[public void Clear()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="72" sc="3" el="75" ec="4">log4net\Core\LevelMap.cs</location>
            <body hash="790469188091e4add1d3de5086eaaae4"><![CDATA[{
			// Clear all current levels
			m_mapName2Level.Clear();
		}]]></body>
          </codeblock>
        </method>
        <method name="LookupWithDefault">
          <declaration><![CDATA[public Level LookupWithDefault(Level defaultLevel)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="211" sc="3" el="227" ec="4">log4net\Core\LevelMap.cs</location>
            <body hash="1d3e9bd2915b8dfd28369b5a28ed8279"><![CDATA[{
			if (defaultLevel == null)
			{
				throw new ArgumentNullException("defaultLevel");
			}

			lock(this)
			{
				Level level = (Level)m_mapName2Level[defaultLevel.Name];
				if (level == null)
				{
					m_mapName2Level[defaultLevel.Name] = defaultLevel;
					return defaultLevel;
				}
				return level;
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_mapName2Level">
          <declaration><![CDATA[private Hashtable m_mapName2Level = SystemInfo.CreateCaseInsensitiveHashtable();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="AllLevels">
          <declaration><![CDATA[public LevelCollection AllLevels]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="184" sc="4" el="189" ec="5">log4net\Core\LevelMap.cs</location>
            <body hash="368a0bc63c92d9a6c362abdf027c95a0"><![CDATA[{
				lock(this)
				{
					return new LevelCollection(m_mapName2Level.Values);
				}
			}]]></body>
          </codeblock>
        </property>
        <property name="Item">
          <declaration><![CDATA[public Level this[string name]]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="92" sc="4" el="102" ec="5">log4net\Core\LevelMap.cs</location>
            <body hash="798bc6bd2719812dfb85739479f7abac"><![CDATA[{
				if (name == null)
				{
					throw new ArgumentNullException("name");
				}

				lock(this)
				{
					return (Level)m_mapName2Level[name];
				}
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="LocationInfo">
      <declaration><![CDATA[public class LocationInfo]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public LocationInfo(Type callerStackBoundaryDeclaringType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="77" sc="3" el="160" ec="4">log4net\Core\LocationInfo.cs</location>
            <body hash="b7cfa4553d59bc5b589fbdb64c4f3f18"><![CDATA[public LocationInfo(Type callerStackBoundaryDeclaringType) 
		{
			// Initialize all fields
			m_className = NA;
			m_fileName = NA;
			m_lineNumber = NA;
			m_methodName = NA;
			m_fullInfo = NA;

#if !(NETCF || NETSTANDARD1_3) // StackTrace isn't fully implemented for NETSTANDARD1_3 https://github.com/dotnet/corefx/issues/1797
			if (callerStackBoundaryDeclaringType != null)
			{
				try
				{
					StackTrace st = new StackTrace(true);
					int frameIndex = 0;
																				
					// skip frames not from fqnOfCallingClass
					while (frameIndex < st.FrameCount)
					{
						StackFrame frame = st.GetFrame(frameIndex);
						if (frame != null && frame.GetMethod().DeclaringType == callerStackBoundaryDeclaringType)
						{
							break;
						}
						frameIndex++;
					}

					// skip frames from fqnOfCallingClass
					while (frameIndex < st.FrameCount)
					{
						StackFrame frame = st.GetFrame(frameIndex);
						if (frame != null && frame.GetMethod().DeclaringType != callerStackBoundaryDeclaringType)
						{
							break;
						}
						frameIndex++;
					}

					if (frameIndex < st.FrameCount)
					{
						// take into account the frames we skip above
						int adjustedFrameCount = st.FrameCount - frameIndex;
                        ArrayList stackFramesList = new ArrayList(adjustedFrameCount);
						m_stackFrames = new StackFrameItem[adjustedFrameCount];
						for (int i=frameIndex; i < st.FrameCount; i++) 
						{
							stackFramesList.Add(new StackFrameItem(st.GetFrame(i)));
						}
												
						stackFramesList.CopyTo(m_stackFrames, 0);
						
						// now frameIndex is the first 'user' caller frame
						StackFrame locationFrame = st.GetFrame(frameIndex);

						if (locationFrame != null)
						{
							System.Reflection.MethodBase method = locationFrame.GetMethod();

							if (method != null)
							{
								m_methodName =  method.Name;
								if (method.DeclaringType != null)
								{
									m_className = method.DeclaringType.FullName;
								}
							}
							m_fileName = locationFrame.GetFileName();
							m_lineNumber = locationFrame.GetFileLineNumber().ToString(System.Globalization.NumberFormatInfo.InvariantInfo);

							// Combine all location info
							m_fullInfo =  m_className + '.' + m_methodName + '(' + m_fileName + ':' + m_lineNumber + ')';
						}
					}
				}
				catch(System.Security.SecurityException)
				{
					// This security exception will occur if the caller does not have 
					// some undefined set of SecurityPermission flags.
					LogLog.Debug(declaringType, "Security exception while trying to get caller stack frame. Error Ignored. Location Information Not Available.");
				}
			}
#endif
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public LocationInfo(string className, string methodName, string fileName, string lineNumber)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="175" sc="3" el="183" ec="4">log4net\Core\LocationInfo.cs</location>
            <body hash="d97a6c36fc255611f51af9275216a49f"><![CDATA[public LocationInfo(string className, string methodName, string fileName, string lineNumber)
		{
			m_className = className;
			m_fileName = fileName;
			m_lineNumber = lineNumber;
			m_methodName = methodName;
			m_fullInfo = m_className + '.' + m_methodName + '(' + m_fileName + 
				':' + m_lineNumber + ')';
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static LocationInfo()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="308" sc="6" el="308" ec="72">log4net\Core\LocationInfo.cs</location>
            <body hash="397c931fbd1cee32b6dcb5701f551e3b"><![CDATA[private readonly static Type declaringType = typeof(LocationInfo)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(LocationInfo);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_className">
          <declaration><![CDATA[private readonly string m_className;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_fileName">
          <declaration><![CDATA[private readonly string m_fileName;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_fullInfo">
          <declaration><![CDATA[private readonly string m_fullInfo;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_lineNumber">
          <declaration><![CDATA[private readonly string m_lineNumber;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_methodName">
          <declaration><![CDATA[private readonly string m_methodName;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_stackFrames">
          <declaration><![CDATA[private readonly StackFrameItem[] m_stackFrames;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="NA">
          <declaration><![CDATA[private const string NA = "?";]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="ClassName">
          <declaration><![CDATA[public string ClassName]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="FileName">
          <declaration><![CDATA[public string FileName]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="FullInfo">
          <declaration><![CDATA[public string FullInfo]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="LineNumber">
          <declaration><![CDATA[public string LineNumber]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="MethodName">
          <declaration><![CDATA[public string MethodName]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="StackFrames">
          <declaration><![CDATA[public StackFrameItem[] StackFrames]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="LogException">
      <declaration><![CDATA[public class LogException : ApplicationException]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public LogException()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="58" sc="3" el="60" ec="4">log4net\Core\LogException.cs</location>
            <body hash="b25c506f92e34644ed5e257b32ce86a2"><![CDATA[public LogException()
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public LogException(string message) : base(message)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="72" sc="41" el="74" ec="4">log4net\Core\LogException.cs</location>
            <body hash="e61467aad6c9bdbf17f18adbd74c1180"><![CDATA[base(message) 
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public LogException(string message, Exception innerException) : base(message, innerException)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="87" sc="67" el="89" ec="4">log4net\Core\LogException.cs</location>
            <body hash="adee082fc541698d386a0906598818b0"><![CDATA[base(message, innerException) 
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[protected LogException(SerializationInfo info, StreamingContext context) : base(info, context)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="107" sc="78" el="109" ec="4">log4net\Core\LogException.cs</location>
            <body hash="59699d51c1ad68f31a363ee6e3b56629"><![CDATA[base(info, context) 
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="LoggerManager">
      <declaration><![CDATA[public sealed class LoggerManager]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private LoggerManager()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="66" sc="3" el="68" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="f9c060a27cdeb855a4e8f2c3516660f5"><![CDATA[private LoggerManager() 
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static LoggerManager()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="85" sc="3" el="871" ec="73">log4net\Core\LoggerManager.cs</location>
            <body hash="911d01782929737b4ced5421aa49557e"><![CDATA[{
			try
			{
				// Register the AppDomain events, note we have to do this with a
				// method call rather than directly here because the AppDomain
				// makes a LinkDemand which throws the exception during the JIT phase.
				RegisterAppDomainEvents();
			}
			catch(System.Security.SecurityException)
			{
				LogLog.Debug(declaringType, "Security Exception (ControlAppDomain LinkDemand) while trying "+
					"to register Shutdown handler with the AppDomain. LoggerManager.Shutdown() "+
					"will not be called automatically when the AppDomain exits. It must be called "+
					"programmatically.");
			}

			// Dump out our assembly version into the log if debug is enabled
            LogLog.Debug(declaringType, GetVersionInfo());

			// Set the default repository selector
#if NETCF
			s_repositorySelector = new CompactRepositorySelector(typeof(log4net.Repository.Hierarchy.Hierarchy));
			return;
#elif !NETSTANDARD1_3
			// Look for the RepositorySelector type specified in the AppSettings 'log4net.RepositorySelector'
			string appRepositorySelectorTypeName = SystemInfo.GetAppSetting("log4net.RepositorySelector");
			if (appRepositorySelectorTypeName != null && appRepositorySelectorTypeName.Length > 0)
			{
				// Resolve the config string into a Type
				Type appRepositorySelectorType = null;
				try
				{
					appRepositorySelectorType = SystemInfo.GetTypeFromString(appRepositorySelectorTypeName, false, true);
				}
				catch(Exception ex)
				{
					LogLog.Error(declaringType, "Exception while resolving RepositorySelector Type ["+appRepositorySelectorTypeName+"]", ex);
				}

				if (appRepositorySelectorType != null)
				{
					// Create an instance of the RepositorySelectorType
					object appRepositorySelectorObj = null;
					try
					{
						appRepositorySelectorObj = Activator.CreateInstance(appRepositorySelectorType);
					}
					catch(Exception ex)
					{
						LogLog.Error(declaringType, "Exception while creating RepositorySelector ["+appRepositorySelectorType.FullName+"]", ex);
					}

					if (appRepositorySelectorObj != null && appRepositorySelectorObj is IRepositorySelector)
					{
						s_repositorySelector = (IRepositorySelector)appRepositorySelectorObj;
					}
					else
					{
						LogLog.Error(declaringType, "RepositorySelector Type ["+appRepositorySelectorType.FullName+"] is not an IRepositorySelector");
					}
				}
			}
#endif
			// Create the DefaultRepositorySelector if not configured above 
			if (s_repositorySelector == null)
			{
				s_repositorySelector = new DefaultRepositorySelector(typeof(log4net.Repository.Hierarchy.Hierarchy));
			}
		}

		/// <summary>
		/// Register for ProcessExit and DomainUnload events on the AppDomain
		/// </summary>
		/// <remarks>
		/// <para>
		/// This needs to be in a separate method because the events make
		/// a LinkDemand for the ControlAppDomain SecurityPermission. Because
		/// this is a LinkDemand it is demanded at JIT time. Therefore we cannot
		/// catch the exception in the method itself, we have to catch it in the
		/// caller.
		/// </para>
		/// </remarks>
		private static void RegisterAppDomainEvents()
		{
#if !(NETCF || NETSTANDARD1_3)
			// ProcessExit seems to be fired if we are part of the default domain
			AppDomain.CurrentDomain.ProcessExit += new EventHandler(OnProcessExit);

			// Otherwise DomainUnload is fired
			AppDomain.CurrentDomain.DomainUnload += new EventHandler(OnDomainUnload);
#endif
		}

		#endregion Static Constructor

		#region Public Static Methods

		/// <summary>
		/// Return the default <see cref="ILoggerRepository"/> instance.
		/// </summary>
		/// <param name="repository">the repository to lookup in</param>
		/// <returns>Return the default <see cref="ILoggerRepository"/> instance</returns>
		/// <remarks>
		/// <para>
		/// Gets the <see cref="ILoggerRepository"/> for the repository specified
		/// by the <paramref name="repository"/> argument.
		/// </para>
		/// </remarks>
		[Obsolete("Use GetRepository instead of GetLoggerRepository")]
		public static ILoggerRepository GetLoggerRepository(string repository)
		{
			return GetRepository(repository);
		}

		/// <summary>
		/// Returns the default <see cref="ILoggerRepository"/> instance.
		/// </summary>
		/// <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
		/// <returns>The default <see cref="ILoggerRepository"/> instance.</returns>
		[Obsolete("Use GetRepository instead of GetLoggerRepository")]
		public static ILoggerRepository GetLoggerRepository(Assembly repositoryAssembly)
		{
			return GetRepository(repositoryAssembly);
		}

		/// <summary>
		/// Return the default <see cref="ILoggerRepository"/> instance.
		/// </summary>
		/// <param name="repository">the repository to lookup in</param>
		/// <returns>Return the default <see cref="ILoggerRepository"/> instance</returns>
		/// <remarks>
		/// <para>
		/// Gets the <see cref="ILoggerRepository"/> for the repository specified
		/// by the <paramref name="repository"/> argument.
		/// </para>
		/// </remarks>
		public static ILoggerRepository GetRepository(string repository)
		{
			if (repository == null)
			{
				throw new ArgumentNullException("repository");
			}
			return RepositorySelector.GetRepository(repository);
		}

		/// <summary>
		/// Returns the default <see cref="ILoggerRepository"/> instance.
		/// </summary>
		/// <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
		/// <returns>The default <see cref="ILoggerRepository"/> instance.</returns>
		/// <remarks>
		/// <para>
		/// Returns the default <see cref="ILoggerRepository"/> instance.
		/// </para>
		/// </remarks>
		public static ILoggerRepository GetRepository(Assembly repositoryAssembly)
		{
			if (repositoryAssembly == null)
			{
				throw new ArgumentNullException("repositoryAssembly");
			}
			return RepositorySelector.GetRepository(repositoryAssembly);
		}

		/// <summary>
		/// Returns the named logger if it exists.
		/// </summary>
		/// <param name="repository">The repository to lookup in.</param>
		/// <param name="name">The fully qualified logger name to look for.</param>
		/// <returns>
		/// The logger found, or <c>null</c> if the named logger does not exist in the
		/// specified repository.
		/// </returns>
		/// <remarks>
		/// <para>
		/// If the named logger exists (in the specified repository) then it
		/// returns a reference to the logger, otherwise it returns
		/// <c>null</c>.
		/// </para>
		/// </remarks>
		public static ILogger Exists(string repository, string name) 
		{
			if (repository == null)
			{
				throw new ArgumentNullException("repository");
			}
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			return RepositorySelector.GetRepository(repository).Exists(name);
		}

		/// <summary>
		/// Returns the named logger if it exists.
		/// </summary>
		/// <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
		/// <param name="name">The fully qualified logger name to look for.</param>
		/// <returns>
		/// The logger found, or <c>null</c> if the named logger does not exist in the
		/// specified assembly's repository.
		/// </returns>
		/// <remarks>
		/// <para>
		/// If the named logger exists (in the specified assembly's repository) then it
		/// returns a reference to the logger, otherwise it returns
		/// <c>null</c>.
		/// </para>
		/// </remarks>
		public static ILogger Exists(Assembly repositoryAssembly, string name) 
		{
			if (repositoryAssembly == null)
			{
				throw new ArgumentNullException("repositoryAssembly");
			}
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			return RepositorySelector.GetRepository(repositoryAssembly).Exists(name);
		}

		/// <summary>
		/// Returns all the currently defined loggers in the specified repository.
		/// </summary>
		/// <param name="repository">The repository to lookup in.</param>
		/// <returns>All the defined loggers.</returns>
		/// <remarks>
		/// <para>
		/// The root logger is <b>not</b> included in the returned array.
		/// </para>
		/// </remarks>
		public static ILogger[] GetCurrentLoggers(string repository)
		{
			if (repository == null)
			{
				throw new ArgumentNullException("repository");
			}
			return RepositorySelector.GetRepository(repository).GetCurrentLoggers();
		}

		/// <summary>
		/// Returns all the currently defined loggers in the specified assembly's repository.
		/// </summary>
		/// <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
		/// <returns>All the defined loggers.</returns>
		/// <remarks>
		/// <para>
		/// The root logger is <b>not</b> included in the returned array.
		/// </para>
		/// </remarks>
		public static ILogger[] GetCurrentLoggers(Assembly repositoryAssembly)
		{
			if (repositoryAssembly == null)
			{
				throw new ArgumentNullException("repositoryAssembly");
			}
			return RepositorySelector.GetRepository(repositoryAssembly).GetCurrentLoggers();
		}

		/// <summary>
		/// Retrieves or creates a named logger.
		/// </summary>
		/// <param name="repository">The repository to lookup in.</param>
		/// <param name="name">The name of the logger to retrieve.</param>
		/// <returns>The logger with the name specified.</returns>
		/// <remarks>
		/// <para>
		/// Retrieves a logger named as the <paramref name="name"/>
		/// parameter. If the named logger already exists, then the
		/// existing instance will be returned. Otherwise, a new instance is
		/// created.
		/// </para>
		/// <para>
		/// By default, loggers do not have a set level but inherit
		/// it from the hierarchy. This is one of the central features of
		/// log4net.
		/// </para>
		/// </remarks>
		public static ILogger GetLogger(string repository, string name)
		{
			if (repository == null)
			{
				throw new ArgumentNullException("repository");
			}
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			return RepositorySelector.GetRepository(repository).GetLogger(name);
		}

		/// <summary>
		/// Retrieves or creates a named logger.
		/// </summary>
		/// <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
		/// <param name="name">The name of the logger to retrieve.</param>
		/// <returns>The logger with the name specified.</returns>
		/// <remarks>
		/// <para>
		/// Retrieves a logger named as the <paramref name="name"/>
		/// parameter. If the named logger already exists, then the
		/// existing instance will be returned. Otherwise, a new instance is
		/// created.
		/// </para>
		/// <para>
		/// By default, loggers do not have a set level but inherit
		/// it from the hierarchy. This is one of the central features of
		/// log4net.
		/// </para>
		/// </remarks>
		public static ILogger GetLogger(Assembly repositoryAssembly, string name)
		{
			if (repositoryAssembly == null)
			{
				throw new ArgumentNullException("repositoryAssembly");
			}
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			return RepositorySelector.GetRepository(repositoryAssembly).GetLogger(name);
		}	

		/// <summary>
		/// Shorthand for <see cref="M:LogManager.GetLogger(string)"/>.
		/// </summary>
		/// <param name="repository">The repository to lookup in.</param>
		/// <param name="type">The <paramref name="type"/> of which the fullname will be used as the name of the logger to retrieve.</param>
		/// <returns>The logger with the name specified.</returns>
		/// <remarks>
		/// <para>
		/// Gets the logger for the fully qualified name of the type specified.
		/// </para>
		/// </remarks>
		public static ILogger GetLogger(string repository, Type type) 
		{
			if (repository == null)
			{
				throw new ArgumentNullException("repository");
			}
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			return RepositorySelector.GetRepository(repository).GetLogger(type.FullName);
		}

		/// <summary>
		/// Shorthand for <see cref="M:LogManager.GetLogger(string)"/>.
		/// </summary>
		/// <param name="repositoryAssembly">the assembly to use to lookup the repository</param>
		/// <param name="type">The <paramref name="type"/> of which the fullname will be used as the name of the logger to retrieve.</param>
		/// <returns>The logger with the name specified.</returns>
		/// <remarks>
		/// <para>
		/// Gets the logger for the fully qualified name of the type specified.
		/// </para>
		/// </remarks>
		public static ILogger GetLogger(Assembly repositoryAssembly, Type type) 
		{
			if (repositoryAssembly == null)
			{
				throw new ArgumentNullException("repositoryAssembly");
			}
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			return RepositorySelector.GetRepository(repositoryAssembly).GetLogger(type.FullName);
		}	

		/// <summary>
		/// Shuts down the log4net system.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Calling this method will <b>safely</b> close and remove all
		/// appenders in all the loggers including root contained in all the
		/// default repositories.
		/// </para>
		/// <para>
		/// Some appenders need to be closed before the application exists. 
		/// Otherwise, pending logging events might be lost.
		/// </para>
		/// <para>
		/// The <c>shutdown</c> method is careful to close nested
		/// appenders before closing regular appenders. This is allows
		/// configurations where a regular appender is attached to a logger
		/// and again to a nested appender.
		/// </para>
		/// </remarks>
		public static void Shutdown() 
		{
			foreach(ILoggerRepository repository in GetAllRepositories())
			{
				repository.Shutdown();
			}
		}

		/// <summary>
		/// Shuts down the repository for the repository specified.
		/// </summary>
		/// <param name="repository">The repository to shutdown.</param>
		/// <remarks>
		/// <para>
		/// Calling this method will <b>safely</b> close and remove all
		/// appenders in all the loggers including root contained in the
		/// repository for the <paramref name="repository"/> specified.
		/// </para>
		/// <para>
		/// Some appenders need to be closed before the application exists. 
		/// Otherwise, pending logging events might be lost.
		/// </para>
		/// <para>
		/// The <c>shutdown</c> method is careful to close nested
		/// appenders before closing regular appenders. This is allows
		/// configurations where a regular appender is attached to a logger
		/// and again to a nested appender.
		/// </para>
		/// </remarks>
		public static void ShutdownRepository(string repository) 
		{
			if (repository == null)
			{
				throw new ArgumentNullException("repository");
			}
			RepositorySelector.GetRepository(repository).Shutdown();
		}

		/// <summary>
		/// Shuts down the repository for the repository specified.
		/// </summary>
		/// <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
		/// <remarks>
		/// <para>
		/// Calling this method will <b>safely</b> close and remove all
		/// appenders in all the loggers including root contained in the
		/// repository for the repository. The repository is looked up using
		/// the <paramref name="repositoryAssembly"/> specified.
		/// </para>
		/// <para>
		/// Some appenders need to be closed before the application exists. 
		/// Otherwise, pending logging events might be lost.
		/// </para>
		/// <para>
		/// The <c>shutdown</c> method is careful to close nested
		/// appenders before closing regular appenders. This is allows
		/// configurations where a regular appender is attached to a logger
		/// and again to a nested appender.
		/// </para>
		/// </remarks>
		public static void ShutdownRepository(Assembly repositoryAssembly) 
		{
			if (repositoryAssembly == null)
			{
				throw new ArgumentNullException("repositoryAssembly");
			}
			RepositorySelector.GetRepository(repositoryAssembly).Shutdown();
		}

		/// <summary>
		/// Resets all values contained in this repository instance to their defaults.
		/// </summary>
		/// <param name="repository">The repository to reset.</param>
		/// <remarks>
		/// <para>
		/// Resets all values contained in the repository instance to their
		/// defaults.  This removes all appenders from all loggers, sets
		/// the level of all non-root loggers to <c>null</c>,
		/// sets their additivity flag to <c>true</c> and sets the level
		/// of the root logger to <see cref="Level.Debug"/>. Moreover,
		/// message disabling is set its default "off" value.
		/// </para>		
		/// </remarks>
		public static void ResetConfiguration(string repository) 
		{
			if (repository == null)
			{
				throw new ArgumentNullException("repository");
			}
			RepositorySelector.GetRepository(repository).ResetConfiguration();
		}

		/// <summary>
		/// Resets all values contained in this repository instance to their defaults.
		/// </summary>
		/// <param name="repositoryAssembly">The assembly to use to lookup the repository to reset.</param>
		/// <remarks>
		/// <para>
		/// Resets all values contained in the repository instance to their
		/// defaults.  This removes all appenders from all loggers, sets
		/// the level of all non-root loggers to <c>null</c>,
		/// sets their additivity flag to <c>true</c> and sets the level
		/// of the root logger to <see cref="Level.Debug"/>. Moreover,
		/// message disabling is set its default "off" value.
		/// </para>		
		/// </remarks>
		public static void ResetConfiguration(Assembly repositoryAssembly) 
		{
			if (repositoryAssembly == null)
			{
				throw new ArgumentNullException("repositoryAssembly");
			}
			RepositorySelector.GetRepository(repositoryAssembly).ResetConfiguration();
		}

		/// <summary>
		/// Creates a repository with the specified name.
		/// </summary>
		/// <param name="repository">The name of the repository, this must be unique amongst repositories.</param>
		/// <returns>The <see cref="ILoggerRepository"/> created for the repository.</returns>
		/// <remarks>
		/// <para>
		/// <b>CreateDomain is obsolete. Use CreateRepository instead of CreateDomain.</b>
		/// </para>
		/// <para>
		/// Creates the default type of <see cref="ILoggerRepository"/> which is a
		/// <see cref="log4net.Repository.Hierarchy.Hierarchy"/> object.
		/// </para>
		/// <para>
		/// The <paramref name="repository"/> name must be unique. Repositories cannot be redefined.
		/// An <see cref="Exception"/> will be thrown if the repository already exists.
		/// </para>
		/// </remarks>
		/// <exception cref="LogException">The specified repository already exists.</exception>
		[Obsolete("Use CreateRepository instead of CreateDomain")]
		public static ILoggerRepository CreateDomain(string repository)
		{
			return CreateRepository(repository);
		}

		/// <summary>
		/// Creates a repository with the specified name.
		/// </summary>
		/// <param name="repository">The name of the repository, this must be unique amongst repositories.</param>
		/// <returns>The <see cref="ILoggerRepository"/> created for the repository.</returns>
		/// <remarks>
		/// <para>
		/// Creates the default type of <see cref="ILoggerRepository"/> which is a
		/// <see cref="log4net.Repository.Hierarchy.Hierarchy"/> object.
		/// </para>
		/// <para>
		/// The <paramref name="repository"/> name must be unique. Repositories cannot be redefined.
		/// An <see cref="Exception"/> will be thrown if the repository already exists.
		/// </para>
		/// </remarks>
		/// <exception cref="LogException">The specified repository already exists.</exception>
		public static ILoggerRepository CreateRepository(string repository)
		{
			if (repository == null)
			{
				throw new ArgumentNullException("repository");
			}
			return RepositorySelector.CreateRepository(repository, null);
		}

		/// <summary>
		/// Creates a repository with the specified name and repository type.
		/// </summary>
		/// <param name="repository">The name of the repository, this must be unique to the repository.</param>
		/// <param name="repositoryType">A <see cref="Type"/> that implements <see cref="ILoggerRepository"/>
		/// and has a no arg constructor. An instance of this type will be created to act
		/// as the <see cref="ILoggerRepository"/> for the repository specified.</param>
		/// <returns>The <see cref="ILoggerRepository"/> created for the repository.</returns>
		/// <remarks>
		/// <para>
		/// <b>CreateDomain is obsolete. Use CreateRepository instead of CreateDomain.</b>
		/// </para>
		/// <para>
		/// The <paramref name="repository"/> name must be unique. Repositories cannot be redefined.
		/// An Exception will be thrown if the repository already exists.
		/// </para>
		/// </remarks>
		/// <exception cref="LogException">The specified repository already exists.</exception>
		[Obsolete("Use CreateRepository instead of CreateDomain")]
		public static ILoggerRepository CreateDomain(string repository, Type repositoryType)
		{
			return CreateRepository(repository, repositoryType);
		}

		/// <summary>
		/// Creates a repository with the specified name and repository type.
		/// </summary>
		/// <param name="repository">The name of the repository, this must be unique to the repository.</param>
		/// <param name="repositoryType">A <see cref="Type"/> that implements <see cref="ILoggerRepository"/>
		/// and has a no arg constructor. An instance of this type will be created to act
		/// as the <see cref="ILoggerRepository"/> for the repository specified.</param>
		/// <returns>The <see cref="ILoggerRepository"/> created for the repository.</returns>
		/// <remarks>
		/// <para>
		/// The <paramref name="repository"/> name must be unique. Repositories cannot be redefined.
		/// An Exception will be thrown if the repository already exists.
		/// </para>
		/// </remarks>
		/// <exception cref="LogException">The specified repository already exists.</exception>
		public static ILoggerRepository CreateRepository(string repository, Type repositoryType)
		{
			if (repository == null)
			{
				throw new ArgumentNullException("repository");
			}
			if (repositoryType == null)
			{
				throw new ArgumentNullException("repositoryType");
			}
			return RepositorySelector.CreateRepository(repository, repositoryType);
		}

		/// <summary>
		/// Creates a repository for the specified assembly and repository type.
		/// </summary>
		/// <param name="repositoryAssembly">The assembly to use to get the name of the repository.</param>
		/// <param name="repositoryType">A <see cref="Type"/> that implements <see cref="ILoggerRepository"/>
		/// and has a no arg constructor. An instance of this type will be created to act
		/// as the <see cref="ILoggerRepository"/> for the repository specified.</param>
		/// <returns>The <see cref="ILoggerRepository"/> created for the repository.</returns>
		/// <remarks>
		/// <para>
		/// <b>CreateDomain is obsolete. Use CreateRepository instead of CreateDomain.</b>
		/// </para>
		/// <para>
		/// The <see cref="ILoggerRepository"/> created will be associated with the repository
		/// specified such that a call to <see cref="M:GetRepository(Assembly)"/> with the
		/// same assembly specified will return the same repository instance.
		/// </para>
		/// </remarks>
		[Obsolete("Use CreateRepository instead of CreateDomain")]
		public static ILoggerRepository CreateDomain(Assembly repositoryAssembly, Type repositoryType)
		{
			return CreateRepository(repositoryAssembly, repositoryType);
		}

		/// <summary>
		/// Creates a repository for the specified assembly and repository type.
		/// </summary>
		/// <param name="repositoryAssembly">The assembly to use to get the name of the repository.</param>
		/// <param name="repositoryType">A <see cref="Type"/> that implements <see cref="ILoggerRepository"/>
		/// and has a no arg constructor. An instance of this type will be created to act
		/// as the <see cref="ILoggerRepository"/> for the repository specified.</param>
		/// <returns>The <see cref="ILoggerRepository"/> created for the repository.</returns>
		/// <remarks>
		/// <para>
		/// The <see cref="ILoggerRepository"/> created will be associated with the repository
		/// specified such that a call to <see cref="M:GetRepository(Assembly)"/> with the
		/// same assembly specified will return the same repository instance.
		/// </para>
		/// </remarks>
		public static ILoggerRepository CreateRepository(Assembly repositoryAssembly, Type repositoryType)
		{
			if (repositoryAssembly == null)
			{
				throw new ArgumentNullException("repositoryAssembly");
			}
			if (repositoryType == null)
			{
				throw new ArgumentNullException("repositoryType");
			}
			return RepositorySelector.CreateRepository(repositoryAssembly, repositoryType);
		}

		/// <summary>
		/// Gets an array of all currently defined repositories.
		/// </summary>
		/// <returns>An array of all the known <see cref="ILoggerRepository"/> objects.</returns>
		/// <remarks>
		/// <para>
		/// Gets an array of all currently defined repositories.
		/// </para>
		/// </remarks>
		public static ILoggerRepository[] GetAllRepositories()
		{
			return RepositorySelector.GetAllRepositories();
		}

		/// <summary>
		/// Gets or sets the repository selector used by the <see cref="LogManager" />.
		/// </summary>
		/// <value>
		/// The repository selector used by the <see cref="LogManager" />.
		/// </value>
		/// <remarks>
		/// <para>
		/// The repository selector (<see cref="IRepositorySelector"/>) is used by 
		/// the <see cref="LogManager"/> to create and select repositories 
		/// (<see cref="ILoggerRepository"/>).
		/// </para>
		/// <para>
		/// The caller to <see cref="LogManager"/> supplies either a string name 
		/// or an assembly (if not supplied the assembly is inferred using 
		/// <see cref="M:Assembly.GetCallingAssembly()"/>).
		/// </para>
		/// <para>
		/// This context is used by the selector to lookup a specific repository.
		/// </para>
		/// <para>
		/// For the full .NET Framework, the default repository is <c>DefaultRepositorySelector</c>;
		/// for the .NET Compact Framework <c>CompactRepositorySelector</c> is the default
		/// repository.
		/// </para>
		/// </remarks>
		public static IRepositorySelector RepositorySelector
		{
			get { return s_repositorySelector; }
			set { s_repositorySelector = value; }
		}

		#endregion Public Static Methods

		#region Private Static Methods

		/// <summary>
		/// Internal method to get pertinent version info.
		/// </summary>
		/// <returns>A string of version info.</returns>
		private static string GetVersionInfo()
		{
			System.Text.StringBuilder sb = new System.Text.StringBuilder();

#if NETSTANDARD1_3
			Assembly myAssembly = typeof(LoggerManager).GetTypeInfo().Assembly;
			sb.Append($"log4net assembly [{myAssembly.FullName}]. ");
			//sb.Append($"Loaded from [{myAssembly.Location}]. "); // TODO Assembly.Location available in netstandard1.5
			sb.Append($"(.NET Framework [{RuntimeInformation.FrameworkDescription}] on {RuntimeInformation.OSDescription}");
#else
			Assembly myAssembly = Assembly.GetExecutingAssembly();
			sb.Append("log4net assembly [").Append(myAssembly.FullName).Append("]. ");
			sb.Append("Loaded from [").Append(SystemInfo.AssemblyLocationInfo(myAssembly)).Append("]. ");
			sb.Append("(.NET Runtime [").Append(Environment.Version.ToString()).Append("]");
#if (!SSCLI)
            sb.Append(" on ").Append(Environment.OSVersion.ToString());
#endif
#endif // NETSTANDARD1_3
			sb.Append(")");
			return sb.ToString();
		}

#if (!NETCF)
		/// <summary>
		/// Called when the <see cref="AppDomain.DomainUnload"/> event fires
		/// </summary>
		/// <param name="sender">the <see cref="AppDomain"/> that is exiting</param>
		/// <param name="e">null</param>
		/// <remarks>
		/// <para>
		/// Called when the <see cref="AppDomain.DomainUnload"/> event fires.
		/// </para>
		/// <para>
		/// When the event is triggered the log4net system is <see cref="M:Shutdown()"/>.
		/// </para>
		/// </remarks>
		private static void OnDomainUnload(object sender, EventArgs e)
		{
			Shutdown();
		}

		/// <summary>
		/// Called when the <see cref="AppDomain.ProcessExit"/> event fires
		/// </summary>
		/// <param name="sender">the <see cref="AppDomain"/> that is exiting</param>
		/// <param name="e">null</param>
		/// <remarks>
		/// <para>
		/// Called when the <see cref="AppDomain.ProcessExit"/> event fires.
		/// </para>
		/// <para>
		/// When the event is triggered the log4net system is <see cref="M:Shutdown()"/>.
		/// </para>
		/// </remarks>
		private static void OnProcessExit(object sender, EventArgs e)
		{
			Shutdown();
		}
#endif

		#endregion Private Static Methods

		#region Private Static Fields

	    /// <summary>
	    /// The fully qualified type of the LoggerManager class.
	    /// </summary>
	    /// <remarks>
	    /// Used by the internal logger to record the Type of the
	    /// log message.
	    /// </remarks>
	    private readonly static Type declaringType = typeof(LoggerManager);]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CreateDomain">
          <deprecation>Use CreateRepository instead of CreateDomain</deprecation>
          <declaration><![CDATA[public static ILoggerRepository CreateDomain(string repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="613" sc="3" el="615" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="145f34798d957ae1b188fe754fa9f0fd"><![CDATA[{
			return CreateRepository(repository);
		}]]></body>
          </codeblock>
        </method>
        <method name="CreateDomain">
          <deprecation>Use CreateRepository instead of CreateDomain</deprecation>
          <declaration><![CDATA[public static ILoggerRepository CreateDomain(string repository, Type repositoryType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="662" sc="3" el="664" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="1cd4dc11b8692ad658821eaf113fe018"><![CDATA[{
			return CreateRepository(repository, repositoryType);
		}]]></body>
          </codeblock>
        </method>
        <method name="CreateDomain">
          <deprecation>Use CreateRepository instead of CreateDomain</deprecation>
          <declaration><![CDATA[public static ILoggerRepository CreateDomain(Assembly repositoryAssembly, Type repositoryType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="714" sc="3" el="716" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="ba1da159d3670c6c318c290bd7ead94c"><![CDATA[{
			return CreateRepository(repositoryAssembly, repositoryType);
		}]]></body>
          </codeblock>
        </method>
        <method name="CreateRepository">
          <declaration><![CDATA[public static ILoggerRepository CreateRepository(string repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="634" sc="3" el="640" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="86edddfda098bb3b6e51795a2a901aed"><![CDATA[{
			if (repository == null)
			{
				throw new ArgumentNullException("repository");
			}
			return RepositorySelector.CreateRepository(repository, null);
		}]]></body>
          </codeblock>
        </method>
        <method name="CreateRepository">
          <declaration><![CDATA[public static ILoggerRepository CreateRepository(string repository, Type repositoryType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="682" sc="3" el="692" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="d41d2697204128cf45b17bc50c4c650b"><![CDATA[{
			if (repository == null)
			{
				throw new ArgumentNullException("repository");
			}
			if (repositoryType == null)
			{
				throw new ArgumentNullException("repositoryType");
			}
			return RepositorySelector.CreateRepository(repository, repositoryType);
		}]]></body>
          </codeblock>
        </method>
        <method name="CreateRepository">
          <declaration><![CDATA[public static ILoggerRepository CreateRepository(Assembly repositoryAssembly, Type repositoryType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="734" sc="3" el="744" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="76fec6eb578c16962d2e40c59555fcff"><![CDATA[{
			if (repositoryAssembly == null)
			{
				throw new ArgumentNullException("repositoryAssembly");
			}
			if (repositoryType == null)
			{
				throw new ArgumentNullException("repositoryType");
			}
			return RepositorySelector.CreateRepository(repositoryAssembly, repositoryType);
		}]]></body>
          </codeblock>
        </method>
        <method name="Exists">
          <declaration><![CDATA[public static ILogger Exists(string repository, string name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="266" sc="3" el="276" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="604a291ea465ef4a258b6b64d3a332b5"><![CDATA[{
			if (repository == null)
			{
				throw new ArgumentNullException("repository");
			}
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			return RepositorySelector.GetRepository(repository).Exists(name);
		}]]></body>
          </codeblock>
        </method>
        <method name="Exists">
          <declaration><![CDATA[public static ILogger Exists(Assembly repositoryAssembly, string name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="295" sc="3" el="305" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="ae625e49e706a0171476dd1a7c1946df"><![CDATA[{
			if (repositoryAssembly == null)
			{
				throw new ArgumentNullException("repositoryAssembly");
			}
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			return RepositorySelector.GetRepository(repositoryAssembly).Exists(name);
		}]]></body>
          </codeblock>
        </method>
        <method name="GetAllRepositories">
          <declaration><![CDATA[public static ILoggerRepository[] GetAllRepositories()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="756" sc="3" el="758" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="1b530e963436e528ded9c5db9c8c1102"><![CDATA[{
			return RepositorySelector.GetAllRepositories();
		}]]></body>
          </codeblock>
        </method>
        <method name="GetCurrentLoggers">
          <declaration><![CDATA[public static ILogger[] GetCurrentLoggers(string repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="318" sc="3" el="324" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="0a8f3da02ab7999b5db8dee2630edfbe"><![CDATA[{
			if (repository == null)
			{
				throw new ArgumentNullException("repository");
			}
			return RepositorySelector.GetRepository(repository).GetCurrentLoggers();
		}]]></body>
          </codeblock>
        </method>
        <method name="GetCurrentLoggers">
          <declaration><![CDATA[public static ILogger[] GetCurrentLoggers(Assembly repositoryAssembly)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="337" sc="3" el="343" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="38b4edee97983f3485e0e2bc5930b90a"><![CDATA[{
			if (repositoryAssembly == null)
			{
				throw new ArgumentNullException("repositoryAssembly");
			}
			return RepositorySelector.GetRepository(repositoryAssembly).GetCurrentLoggers();
		}]]></body>
          </codeblock>
        </method>
        <method name="GetLogger">
          <declaration><![CDATA[public static ILogger GetLogger(string repository, string name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="365" sc="3" el="375" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="05ea2a387aad72b276a0f98ff36bfc31"><![CDATA[{
			if (repository == null)
			{
				throw new ArgumentNullException("repository");
			}
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			return RepositorySelector.GetRepository(repository).GetLogger(name);
		}]]></body>
          </codeblock>
        </method>
        <method name="GetLogger">
          <declaration><![CDATA[public static ILogger GetLogger(Assembly repositoryAssembly, string name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="397" sc="3" el="407" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="434be955d59d2235869b1df33b30db9c"><![CDATA[{
			if (repositoryAssembly == null)
			{
				throw new ArgumentNullException("repositoryAssembly");
			}
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			return RepositorySelector.GetRepository(repositoryAssembly).GetLogger(name);
		}]]></body>
          </codeblock>
        </method>
        <method name="GetLogger">
          <declaration><![CDATA[public static ILogger GetLogger(string repository, Type type)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="421" sc="3" el="431" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="bbbe3d0094dd04a57629cfe5b89f389e"><![CDATA[{
			if (repository == null)
			{
				throw new ArgumentNullException("repository");
			}
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			return RepositorySelector.GetRepository(repository).GetLogger(type.FullName);
		}]]></body>
          </codeblock>
        </method>
        <method name="GetLogger">
          <declaration><![CDATA[public static ILogger GetLogger(Assembly repositoryAssembly, Type type)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="445" sc="3" el="455" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="2d9b0aabda9dce13b70fe7771a03b0da"><![CDATA[{
			if (repositoryAssembly == null)
			{
				throw new ArgumentNullException("repositoryAssembly");
			}
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			return RepositorySelector.GetRepository(repositoryAssembly).GetLogger(type.FullName);
		}]]></body>
          </codeblock>
        </method>
        <method name="GetLoggerRepository">
          <deprecation>Use GetRepository instead of GetLoggerRepository</deprecation>
          <declaration><![CDATA[public static ILoggerRepository GetLoggerRepository(string repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="195" sc="3" el="197" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="fd0b53dc25f32f5043b32ea8cf7445bb"><![CDATA[{
			return GetRepository(repository);
		}]]></body>
          </codeblock>
        </method>
        <method name="GetLoggerRepository">
          <deprecation>Use GetRepository instead of GetLoggerRepository</deprecation>
          <declaration><![CDATA[public static ILoggerRepository GetLoggerRepository(Assembly repositoryAssembly)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="206" sc="3" el="208" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="386da14dce1f8add36f5fa0eb2834c22"><![CDATA[{
			return GetRepository(repositoryAssembly);
		}]]></body>
          </codeblock>
        </method>
        <method name="GetRepository">
          <declaration><![CDATA[public static ILoggerRepository GetRepository(string repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="222" sc="3" el="228" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="329028974ae6532feb9f6c68fde9f19c"><![CDATA[{
			if (repository == null)
			{
				throw new ArgumentNullException("repository");
			}
			return RepositorySelector.GetRepository(repository);
		}]]></body>
          </codeblock>
        </method>
        <method name="GetRepository">
          <declaration><![CDATA[public static ILoggerRepository GetRepository(Assembly repositoryAssembly)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="241" sc="3" el="247" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="58e943031b2ec868de0efd473efe69df"><![CDATA[{
			if (repositoryAssembly == null)
			{
				throw new ArgumentNullException("repositoryAssembly");
			}
			return RepositorySelector.GetRepository(repositoryAssembly);
		}]]></body>
          </codeblock>
        </method>
        <method name="GetVersionInfo">
          <declaration><![CDATA[private static string GetVersionInfo()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="801" sc="3" el="820" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="fa78300e672b4cce0a8492287448d3ae"><![CDATA[{
			System.Text.StringBuilder sb = new System.Text.StringBuilder();

#if NETSTANDARD1_3
			Assembly myAssembly = typeof(LoggerManager).GetTypeInfo().Assembly;
			sb.Append($"log4net assembly [{myAssembly.FullName}]. ");
			//sb.Append($"Loaded from [{myAssembly.Location}]. "); // TODO Assembly.Location available in netstandard1.5
			sb.Append($"(.NET Framework [{RuntimeInformation.FrameworkDescription}] on {RuntimeInformation.OSDescription}");
#else
			Assembly myAssembly = Assembly.GetExecutingAssembly();
			sb.Append("log4net assembly [").Append(myAssembly.FullName).Append("]. ");
			sb.Append("Loaded from [").Append(SystemInfo.AssemblyLocationInfo(myAssembly)).Append("]. ");
			sb.Append("(.NET Runtime [").Append(Environment.Version.ToString()).Append("]");
#if (!SSCLI)
            sb.Append(" on ").Append(Environment.OSVersion.ToString());
#endif
#endif // NETSTANDARD1_3
			sb.Append(")");
			return sb.ToString();
		}]]></body>
          </codeblock>
        </method>
        <method name="OnDomainUnload">
          <declaration><![CDATA[private static void OnDomainUnload(object sender, EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="837" sc="3" el="839" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="8a8ebb42a4ed8ffeab0c0f91bdffafe4"><![CDATA[{
			Shutdown();
		}]]></body>
          </codeblock>
        </method>
        <method name="OnProcessExit">
          <declaration><![CDATA[private static void OnProcessExit(object sender, EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="855" sc="3" el="857" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="8a8ebb42a4ed8ffeab0c0f91bdffafe4"><![CDATA[{
			Shutdown();
		}]]></body>
          </codeblock>
        </method>
        <method name="RegisterAppDomainEvents">
          <declaration><![CDATA[private static void RegisterAppDomainEvents()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="168" sc="3" el="176" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="cc4d30c1bd7ff97a43d0132a6a2db8fb"><![CDATA[{
#if !(NETCF || NETSTANDARD1_3)
			// ProcessExit seems to be fired if we are part of the default domain
			AppDomain.CurrentDomain.ProcessExit += new EventHandler(OnProcessExit);

			// Otherwise DomainUnload is fired
			AppDomain.CurrentDomain.DomainUnload += new EventHandler(OnDomainUnload);
#endif
		}]]></body>
          </codeblock>
        </method>
        <method name="ResetConfiguration">
          <declaration><![CDATA[public static void ResetConfiguration(string repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="561" sc="3" el="567" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="ecef81a92d09e8f41b1b902ddd89d9c4"><![CDATA[{
			if (repository == null)
			{
				throw new ArgumentNullException("repository");
			}
			RepositorySelector.GetRepository(repository).ResetConfiguration();
		}]]></body>
          </codeblock>
        </method>
        <method name="ResetConfiguration">
          <declaration><![CDATA[public static void ResetConfiguration(Assembly repositoryAssembly)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="584" sc="3" el="590" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="72584bcc0387e508ef8a7d2bec48b1d9"><![CDATA[{
			if (repositoryAssembly == null)
			{
				throw new ArgumentNullException("repositoryAssembly");
			}
			RepositorySelector.GetRepository(repositoryAssembly).ResetConfiguration();
		}]]></body>
          </codeblock>
        </method>
        <method name="Shutdown">
          <declaration><![CDATA[public static void Shutdown()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="478" sc="3" el="483" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="21eb52488ea1191e67c3d9696f849267"><![CDATA[{
			foreach(ILoggerRepository repository in GetAllRepositories())
			{
				repository.Shutdown();
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ShutdownRepository">
          <declaration><![CDATA[public static void ShutdownRepository(string repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="507" sc="3" el="513" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="ce9f8403bfc89a7dfd1af2fc58140633"><![CDATA[{
			if (repository == null)
			{
				throw new ArgumentNullException("repository");
			}
			RepositorySelector.GetRepository(repository).Shutdown();
		}]]></body>
          </codeblock>
        </method>
        <method name="ShutdownRepository">
          <declaration><![CDATA[public static void ShutdownRepository(Assembly repositoryAssembly)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="538" sc="3" el="544" ec="4">log4net\Core\LoggerManager.cs</location>
            <body hash="51aa49845d4221a639b7186cb63852b7"><![CDATA[{
			if (repositoryAssembly == null)
			{
				throw new ArgumentNullException("repositoryAssembly");
			}
			RepositorySelector.GetRepository(repositoryAssembly).Shutdown();
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="s_repositorySelector">
          <declaration><![CDATA[private static IRepositorySelector s_repositorySelector;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="RepositorySelector">
          <declaration><![CDATA[public static IRepositorySelector RepositorySelector]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="LoggerRepositoryCreationEventArgs">
      <declaration><![CDATA[public class LoggerRepositoryCreationEventArgs : EventArgs]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public LoggerRepositoryCreationEventArgs(ILoggerRepository repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="67" sc="3" el="70" ec="4">log4net\Core\IRepositorySelector.cs</location>
            <body hash="22e5506a421e48a400530c627b7b44d9"><![CDATA[public LoggerRepositoryCreationEventArgs(ILoggerRepository repository)
		{
			m_repository = repository;
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="m_repository">
          <declaration><![CDATA[private ILoggerRepository m_repository;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="LoggerRepository">
          <declaration><![CDATA[public ILoggerRepository LoggerRepository]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="e);">
      <declaration><![CDATA[public delegate void LoggerRepositoryCreationEventHandler(object sender, LoggerRepositoryCreationEventArgs e);]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public extern LoggerRepositoryCreationEventHandler(object @object, IntPtr method);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="BeginInvoke">
          <declaration><![CDATA[public virtual extern IAsyncResult BeginInvoke(object sender, LoggerRepositoryCreationEventArgs e, AsyncCallback callback, object @object);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="EndInvoke">
          <declaration><![CDATA[public virtual extern void EndInvoke(IAsyncResult result);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Invoke">
          <declaration><![CDATA[public virtual extern void Invoke(object sender, LoggerRepositoryCreationEventArgs e);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="LoggerWrapperImpl">
      <declaration><![CDATA[public abstract class LoggerWrapperImpl : ILoggerWrapper]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[protected LoggerWrapperImpl(ILogger logger)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="45" sc="3" el="48" ec="4">log4net\Core\LoggerWrapperImpl.cs</location>
            <body hash="94546de43adce0ae0ead91a232fe60e2"><![CDATA[protected LoggerWrapperImpl(ILogger logger) 
		{
			m_logger = logger;
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="m_logger">
          <declaration><![CDATA[private readonly ILogger m_logger;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Logger">
          <declaration><![CDATA[public virtual ILogger Logger]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="LoggingEvent">
      <declaration><![CDATA[public class LoggingEvent : ISerializable]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private ILoggerRepository m_repository = null;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="359" sc="3" el="1600" ec="40">log4net\Core\LoggingEvent.cs</location>
            <body hash="b3933c38aba5d70667f55698ee07db24"><![CDATA[public LoggingEvent(Type callerStackBoundaryDeclaringType, log4net.Repository.ILoggerRepository repository, string loggerName, Level level, object message, Exception exception) 
		{
			m_callerStackBoundaryDeclaringType = callerStackBoundaryDeclaringType;
			m_message = message;
			m_repository = repository;
			m_thrownException = exception;

			m_data.LoggerName = loggerName;
			m_data.Level = level;

			// Store the event creation time
			m_data.TimeStampUtc = DateTime.UtcNow;
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="LoggingEvent" /> class 
		/// using specific data.
		/// </summary>
		/// <param name="callerStackBoundaryDeclaringType">The declaring type of the method that is
		/// the stack boundary into the logging system for this call.</param>
		/// <param name="repository">The repository this event is logged in.</param>
		/// <param name="data">Data used to initialize the logging event.</param>
		/// <param name="fixedData">The fields in the <paranref name="data"/> struct that have already been fixed.</param>
		/// <remarks>
		/// <para>
		/// This constructor is provided to allow a <see cref="LoggingEvent" />
		/// to be created independently of the log4net framework. This can
		/// be useful if you require a custom serialization scheme.
		/// </para>
		/// <para>
		/// Use the <see cref="M:GetLoggingEventData(FixFlags)"/> method to obtain an 
		/// instance of the <see cref="LoggingEventData"/> class.
		/// </para>
		/// <para>
		/// The <paramref name="fixedData"/> parameter should be used to specify which fields in the
		/// <paramref name="data"/> struct have been preset. Fields not specified in the <paramref name="fixedData"/>
		/// will be captured from the environment if requested or fixed.
		/// </para>
		/// </remarks>
		public LoggingEvent(Type callerStackBoundaryDeclaringType, log4net.Repository.ILoggerRepository repository, LoggingEventData data, FixFlags fixedData) 
		{
			m_callerStackBoundaryDeclaringType = callerStackBoundaryDeclaringType;
			m_repository = repository;

			m_data = data;
			m_fixFlags = fixedData;
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="LoggingEvent" /> class 
		/// using specific data.
		/// </summary>
		/// <param name="callerStackBoundaryDeclaringType">The declaring type of the method that is
		/// the stack boundary into the logging system for this call.</param>
		/// <param name="repository">The repository this event is logged in.</param>
		/// <param name="data">Data used to initialize the logging event.</param>
		/// <remarks>
		/// <para>
		/// This constructor is provided to allow a <see cref="LoggingEvent" />
		/// to be created independently of the log4net framework. This can
		/// be useful if you require a custom serialization scheme.
		/// </para>
		/// <para>
		/// Use the <see cref="M:GetLoggingEventData(FixFlags)"/> method to obtain an 
		/// instance of the <see cref="LoggingEventData"/> class.
		/// </para>
		/// <para>
		/// This constructor sets this objects <see cref="Fix"/> flags to <see cref="FixFlags.All"/>,
		/// this assumes that all the data relating to this event is passed in via the <paramref name="data"/>
		/// parameter and no other data should be captured from the environment.
		/// </para>
		/// </remarks>
		public LoggingEvent(Type callerStackBoundaryDeclaringType, log4net.Repository.ILoggerRepository repository, LoggingEventData data) : this(callerStackBoundaryDeclaringType, repository, data, FixFlags.All)
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="LoggingEvent" /> class 
		/// using specific data.
		/// </summary>
		/// <param name="data">Data used to initialize the logging event.</param>
		/// <remarks>
		/// <para>
		/// This constructor is provided to allow a <see cref="LoggingEvent" />
		/// to be created independently of the log4net framework. This can
		/// be useful if you require a custom serialization scheme.
		/// </para>
		/// <para>
		/// Use the <see cref="M:GetLoggingEventData(FixFlags)"/> method to obtain an 
		/// instance of the <see cref="LoggingEventData"/> class.
		/// </para>
		/// <para>
		/// This constructor sets this objects <see cref="Fix"/> flags to <see cref="FixFlags.All"/>,
		/// this assumes that all the data relating to this event is passed in via the <paramref name="data"/>
		/// parameter and no other data should be captured from the environment.
		/// </para>
		/// </remarks>
		public LoggingEvent(LoggingEventData data) : this(null, null, data)
		{
		}

		#endregion Public Instance Constructors

		#region Protected Instance Constructors

#if !(NETCF || NETSTANDARD1_3)

		/// <summary>
		/// Serialization constructor
		/// </summary>
		/// <param name="info">The <see cref="SerializationInfo" /> that holds the serialized object data.</param>
		/// <param name="context">The <see cref="StreamingContext" /> that contains contextual information about the source or destination.</param>
		/// <remarks>
		/// <para>
		/// Initializes a new instance of the <see cref="LoggingEvent" /> class 
		/// with serialized data.
		/// </para>
		/// </remarks>
		protected LoggingEvent(SerializationInfo info, StreamingContext context) 
		{
			m_data.LoggerName = info.GetString("LoggerName");

			// Note we are deserializing the whole level object. That is the
			// name and the value. This value is correct for the source 
			// hierarchy but may not be for the target hierarchy that this
			// event may be re-logged into. If it is to be re-logged it may
			// be necessary to re-lookup the level based only on the name.
			m_data.Level = (Level)info.GetValue("Level", typeof(Level));

			m_data.Message = info.GetString("Message");
			m_data.ThreadName = info.GetString("ThreadName");
			m_data.TimeStampUtc = info.GetDateTime("TimeStamp").ToUniversalTime();
			m_data.LocationInfo = (LocationInfo) info.GetValue("LocationInfo", typeof(LocationInfo));
			m_data.UserName = info.GetString("UserName");
			m_data.ExceptionString = info.GetString("ExceptionString");
			m_data.Properties = (PropertiesDictionary) info.GetValue("Properties", typeof(PropertiesDictionary));
			m_data.Domain = info.GetString("Domain");
			m_data.Identity = info.GetString("Identity");

			// We have restored all the values of this instance, i.e. all the values are fixed
			// Set the fix flags otherwise the data values may be overwritten from the current environment.
			m_fixFlags = FixFlags.All;
		}

#endif

		#endregion Protected Instance Constructors

		#region Public Instance Properties
	
		/// <summary>
		/// Gets the time when the current process started.
		/// </summary>
		/// <value>
		/// This is the time when this process started.
		/// </value>
		/// <remarks>
		/// <para>
		/// The TimeStamp is stored internally in UTC and converted to the local time zone for this computer.
		/// </para>
		/// <para>
		/// Tries to get the start time for the current process.
		/// Failing that it returns the time of the first call to
		/// this property.
		/// </para>
		/// <para>
		/// Note that AppDomains may be loaded and unloaded within the
		/// same process without the process terminating and therefore
		/// without the process start time being reset.
		/// </para>
		/// </remarks>
		public static DateTime StartTime
		{
			get { return SystemInfo.ProcessStartTimeUtc.ToLocalTime(); }
		}

        /// <summary>
        /// Gets the UTC time when the current process started.
        /// </summary>
        /// <value>
        /// This is the UTC time when this process started.
        /// </value>
        /// <remarks>
        /// <para>
        /// Tries to get the start time for the current process.
        /// Failing that it returns the time of the first call to
        /// this property.
        /// </para>
        /// <para>
        /// Note that AppDomains may be loaded and unloaded within the
        /// same process without the process terminating and therefore
        /// without the process start time being reset.
        /// </para>
        /// </remarks>
        public static DateTime StartTimeUtc
        {
            get { return SystemInfo.ProcessStartTimeUtc; }
		}

		/// <summary>
		/// Gets the <see cref="Level" /> of the logging event.
		/// </summary>
		/// <value>
		/// The <see cref="Level" /> of the logging event.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets the <see cref="Level" /> of the logging event.
		/// </para>
		/// </remarks>
		public Level Level
		{
			get { return m_data.Level; } 
		}

		/// <summary>
		/// Gets the time of the logging event.
		/// </summary>
		/// <value>
		/// The time of the logging event.
		/// </value>
		/// <remarks>
		/// <para>
		/// The TimeStamp is stored in UTC and converted to the local time zone for this computer.
		/// </para>
		/// </remarks>
		public DateTime TimeStamp
		{
			get { return m_data.TimeStampUtc.ToLocalTime(); }
		}

        /// <summary>
        /// Gets UTC the time of the logging event.
        /// </summary>
        /// <value>
        /// The UTC time of the logging event.
        /// </value>
        public DateTime TimeStampUtc
        {
            get { return m_data.TimeStampUtc; }
		}

		/// <summary>
		/// Gets the name of the logger that logged the event.
		/// </summary>
		/// <value>
		/// The name of the logger that logged the event.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets the name of the logger that logged the event.
		/// </para>
		/// </remarks>
		public string LoggerName
		{
			get { return m_data.LoggerName; }
		}

		/// <summary>
		/// Gets the location information for this logging event.
		/// </summary>
		/// <value>
		/// The location information for this logging event.
		/// </value>
		/// <remarks>
		/// <para>
		/// The collected information is cached for future use.
		/// </para>
		/// <para>
		/// See the <see cref="LocationInfo"/> class for more information on
		/// supported frameworks and the different behavior in Debug and
		/// Release builds.
		/// </para>
		/// </remarks>
		public LocationInfo LocationInformation
		{
			get
			{
				if (m_data.LocationInfo == null  && this.m_cacheUpdatable) 
				{
					m_data.LocationInfo = new LocationInfo(m_callerStackBoundaryDeclaringType);
				}
				return m_data.LocationInfo;
			}
		}

		/// <summary>
		/// Gets the message object used to initialize this event.
		/// </summary>
		/// <value>
		/// The message object used to initialize this event.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets the message object used to initialize this event.
		/// Note that this event may not have a valid message object.
		/// If the event is serialized the message object will not 
		/// be transferred. To get the text of the message the
		/// <see cref="RenderedMessage"/> property must be used 
		/// not this property.
		/// </para>
		/// <para>
		/// If there is no defined message object for this event then
		/// null will be returned.
		/// </para>
		/// </remarks>
		public object MessageObject
		{
			get { return m_message; }
		} 

		/// <summary>
		/// Gets the exception object used to initialize this event.
		/// </summary>
		/// <value>
		/// The exception object used to initialize this event.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets the exception object used to initialize this event.
		/// Note that this event may not have a valid exception object.
		/// If the event is serialized the exception object will not 
		/// be transferred. To get the text of the exception the
		/// <see cref="GetExceptionString"/> method must be used 
		/// not this property.
		/// </para>
		/// <para>
		/// If there is no defined exception object for this event then
		/// null will be returned.
		/// </para>
		/// </remarks>
		public Exception ExceptionObject
		{
			get { return m_thrownException; }
		} 

		/// <summary>
		/// The <see cref="ILoggerRepository"/> that this event was created in.
		/// </summary>
		/// <remarks>
		/// <para>
		/// The <see cref="ILoggerRepository"/> that this event was created in.
		/// </para>
		/// </remarks>
		public ILoggerRepository Repository
		{
			get { return m_repository; }
		}

		/// <summary>
		/// Ensure that the repository is set.
		/// </summary>
		/// <param name="repository">the value for the repository</param>
		internal void EnsureRepository(ILoggerRepository repository)
		{
			if (repository != null)
			{
				m_repository = repository;
			}
		}

		/// <summary>
		/// Gets the message, rendered through the <see cref="ILoggerRepository.RendererMap" />.
		/// </summary>
		/// <value>
		/// The message rendered through the <see cref="ILoggerRepository.RendererMap" />.
		/// </value>
		/// <remarks>
		/// <para>
		/// The collected information is cached for future use.
		/// </para>
		/// </remarks>
		public string RenderedMessage
		{
			get 
			{ 
				if (m_data.Message == null && this.m_cacheUpdatable)
				{
					if (m_message == null)
					{
						m_data.Message = "";
					}
					else if (m_message is string)
					{
						m_data.Message = (m_message as string);
					}
					else if (m_repository != null)
					{
						m_data.Message = m_repository.RendererMap.FindAndRender(m_message);
					}
					else
					{
						// Very last resort
						m_data.Message = m_message.ToString();
					}
				}
				return m_data.Message; 
			}
		}

		/// <summary>
		/// Write the rendered message to a TextWriter
		/// </summary>
		/// <param name="writer">the writer to write the message to</param>
		/// <remarks>
		/// <para>
		/// Unlike the <see cref="RenderedMessage"/> property this method
		/// does store the message data in the internal cache. Therefore 
		/// if called only once this method should be faster than the
		/// <see cref="RenderedMessage"/> property, however if the message is
		/// to be accessed multiple times then the property will be more efficient.
		/// </para>
		/// </remarks>
		public void WriteRenderedMessage(TextWriter writer)
		{
			if (m_data.Message != null)
			{
				writer.Write(m_data.Message); 
			}
			else
			{
				if (m_message != null)
				{
					if (m_message is string)
					{
						writer.Write(m_message as string);
					}
					else if (m_repository != null)
					{
						m_repository.RendererMap.FindAndRender(m_message, writer);
					}
					else
					{
						// Very last resort
						writer.Write(m_message.ToString());
					}
				}
			}
		}

		/// <summary>
		/// Gets the name of the current thread.  
		/// </summary>
		/// <value>
		/// The name of the current thread, or the thread ID when 
		/// the name is not available.
		/// </value>
		/// <remarks>
		/// <para>
		/// The collected information is cached for future use.
		/// </para>
		/// </remarks>
		public string ThreadName
		{
			get
			{
				if (m_data.ThreadName == null && this.m_cacheUpdatable)
				{
#if NETCF || NETSTANDARD1_3
					// Get thread ID only
					m_data.ThreadName = SystemInfo.CurrentThreadId.ToString(System.Globalization.NumberFormatInfo.InvariantInfo);
#else
					m_data.ThreadName = System.Threading.Thread.CurrentThread.Name;
					if (m_data.ThreadName == null || m_data.ThreadName.Length == 0)
					{
						// The thread name is not available. Therefore we
						// go the the AppDomain to get the ID of the 
						// current thread. (Why don't Threads know their own ID?)
						try
						{
							m_data.ThreadName = SystemInfo.CurrentThreadId.ToString(System.Globalization.NumberFormatInfo.InvariantInfo);
						}
						catch(System.Security.SecurityException)
						{
							// This security exception will occur if the caller does not have 
							// some undefined set of SecurityPermission flags.
							LogLog.Debug(declaringType, "Security exception while trying to get current thread ID. Error Ignored. Empty thread name.");

							// As a last resort use the hash code of the Thread object
							m_data.ThreadName = System.Threading.Thread.CurrentThread.GetHashCode().ToString(System.Globalization.CultureInfo.InvariantCulture);
						}
					}
#endif
				}
				return m_data.ThreadName;
			}
		}

		/// <summary>
		/// Gets the name of the current user.
		/// </summary>
		/// <value>
		/// The name of the current user, or <c>NOT AVAILABLE</c> when the 
		/// underlying runtime has no support for retrieving the name of the 
		/// current user.
		/// </value>
		/// <remarks>
		/// <para>
		/// Calls <c>WindowsIdentity.GetCurrent().Name</c> to get the name of
		/// the current windows user.
		/// </para>
		/// <para>
		/// To improve performance, we could cache the string representation of 
		/// the name, and reuse that as long as the identity stayed constant.  
		/// Once the identity changed, we would need to re-assign and re-render 
		/// the string.
		/// </para>
		/// <para>
		/// However, the <c>WindowsIdentity.GetCurrent()</c> call seems to 
		/// return different objects every time, so the current implementation 
		/// doesn't do this type of caching.
		/// </para>
		/// <para>
		/// Timing for these operations:
		/// </para>
		/// <list type="table">
		///   <listheader>
		///     <term>Method</term>
		///     <description>Results</description>
		///   </listheader>
		///   <item>
		///	    <term><c>WindowsIdentity.GetCurrent()</c></term>
		///	    <description>10000 loops, 00:00:00.2031250 seconds</description>
		///   </item>
		///   <item>
		///	    <term><c>WindowsIdentity.GetCurrent().Name</c></term>
		///	    <description>10000 loops, 00:00:08.0468750 seconds</description>
		///   </item>
		/// </list>
		/// <para>
		/// This means we could speed things up almost 40 times by caching the 
		/// value of the <c>WindowsIdentity.GetCurrent().Name</c> property, since 
		/// this takes (8.04-0.20) = 7.84375 seconds.
		/// </para>
		/// </remarks>
		public string UserName
		{
			get
			{
				if (m_data.UserName == null  && this.m_cacheUpdatable) 
				{
#if (NETCF || SSCLI || NETSTANDARD1_3) // NETSTANDARD1_3 TODO requires platform-specific code
					// On compact framework there's no notion of current Windows user
					m_data.UserName = SystemInfo.NotAvailableText;
#else
					try
					{
						WindowsIdentity windowsIdentity = WindowsIdentity.GetCurrent();
						if (windowsIdentity != null && windowsIdentity.Name != null)
						{
							m_data.UserName = windowsIdentity.Name;
						}
						else
						{
							m_data.UserName = "";
						}
					}
					catch(System.Security.SecurityException)
					{
						// This security exception will occur if the caller does not have 
						// some undefined set of SecurityPermission flags.
						LogLog.Debug(declaringType, "Security exception while trying to get current windows identity. Error Ignored. Empty user name.");

						m_data.UserName = "";
					}
#endif
				}
				return m_data.UserName;
			}
		}

		/// <summary>
		/// Gets the identity of the current thread principal.
		/// </summary>
		/// <value>
		/// The string name of the identity of the current thread principal.
		/// </value>
		/// <remarks>
		/// <para>
		/// Calls <c>System.Threading.Thread.CurrentPrincipal.Identity.Name</c> to get
		/// the name of the current thread principal.
		/// </para>
		/// </remarks>
		public string Identity
		{
			get
			{
				if (m_data.Identity == null  && this.m_cacheUpdatable)
				{
#if (NETCF || SSCLI || NETSTANDARD1_3)
					// On compact framework there's no notion of current thread principals
					m_data.Identity = SystemInfo.NotAvailableText;
#else
					try
					{
						if (System.Threading.Thread.CurrentPrincipal != null && 
							System.Threading.Thread.CurrentPrincipal.Identity != null &&
							System.Threading.Thread.CurrentPrincipal.Identity.Name != null)
						{
							m_data.Identity = System.Threading.Thread.CurrentPrincipal.Identity.Name;
						}
						else
						{
							m_data.Identity = "";
						}
					}
					catch (ObjectDisposedException)
					{
						// This exception will occur if System.Threading.Thread.CurrentPrincipal.Identity is not null but
						// the getter of the property Name tries to access disposed objects.
						// Seen to happen on IIS 7 or greater with windows authentication.
						LogLog.Debug(declaringType, "Object disposed exception while trying to get current thread principal. Error Ignored. Empty identity name.");

						m_data.Identity = "";
					}
					catch (System.Security.SecurityException)
					{
						// This security exception will occur if the caller does not have 
						// some undefined set of SecurityPermission flags.
						LogLog.Debug(declaringType, "Security exception while trying to get current thread principal. Error Ignored. Empty identity name.");

						m_data.Identity = "";
					}
#endif
				}
				return m_data.Identity;
			}
		}

		/// <summary>
		/// Gets the AppDomain friendly name.
		/// </summary>
		/// <value>
		/// The AppDomain friendly name.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets the AppDomain friendly name.
		/// </para>
		/// </remarks>
		public string Domain
		{
			get 
			{ 
				if (m_data.Domain == null  && this.m_cacheUpdatable)
				{
					m_data.Domain = SystemInfo.ApplicationFriendlyName;
				}
				return m_data.Domain; 
			}
		}

		/// <summary>
		/// Additional event specific properties.
		/// </summary>
		/// <value>
		/// Additional event specific properties.
		/// </value>
		/// <remarks>
		/// <para>
		/// A logger or an appender may attach additional
		/// properties to specific events. These properties
		/// have a string key and an object value.
		/// </para>
		/// <para>
		/// This property is for events that have been added directly to
		/// this event. The aggregate properties (which include these
		/// event properties) can be retrieved using <see cref="LookupProperty"/>
		/// and <see cref="GetProperties"/>.
		/// </para>
		/// <para>
		/// Once the properties have been fixed <see cref="Fix"/> this property
		/// returns the combined cached properties. This ensures that updates to
		/// this property are always reflected in the underlying storage. When
		/// returning the combined properties there may be more keys in the
		/// Dictionary than expected.
		/// </para>
		/// </remarks>
		public PropertiesDictionary Properties
		{
			get 
			{ 
				// If we have cached properties then return that otherwise changes will be lost
				if (m_data.Properties != null)
				{
					return m_data.Properties;
				}

				if (m_eventProperties == null)
				{
					m_eventProperties = new PropertiesDictionary();
				}
				return m_eventProperties; 
			}
		}

		/// <summary>
		/// The fixed fields in this event
		/// </summary>
		/// <value>
		/// The set of fields that are fixed in this event
		/// </value>
		/// <remarks>
		/// <para>
		/// Fields will not be fixed if they have previously been fixed.
		/// It is not possible to 'unfix' a field.
		/// </para>
		/// </remarks>
		public FixFlags Fix
		{
			get { return m_fixFlags; }
			set { this.FixVolatileData(value); }
		}

		#endregion Public Instance Properties

		#region Implementation of ISerializable

#if !NETCF

		/// <summary>
		/// Serializes this object into the <see cref="SerializationInfo" /> provided.
		/// </summary>
		/// <param name="info">The <see cref="SerializationInfo" /> to populate with data.</param>
		/// <param name="context">The destination for this serialization.</param>
		/// <remarks>
		/// <para>
		/// The data in this event must be fixed before it can be serialized.
		/// </para>
		/// <para>
		/// The <see cref="M:FixVolatileData()"/> method must be called during the
		/// <see cref="log4net.Appender.IAppender.DoAppend"/> method call if this event 
		/// is to be used outside that method.
		/// </para>
		/// </remarks>
#if NET_4_0 || MONO_4_0 || NETSTANDARD1_3
        [System.Security.SecurityCritical]
#else
		[System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.Demand, SerializationFormatter=true)]
#endif
		public virtual void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			// The caller must call FixVolatileData before this object
			// can be serialized.

			info.AddValue("LoggerName", m_data.LoggerName);
			info.AddValue("Level", m_data.Level);
			info.AddValue("Message", m_data.Message);
			info.AddValue("ThreadName", m_data.ThreadName);
            // TODO: consider serializing UTC rather than local time.  Not implemented here because it
            // would give an unexpected result if client and server have different versions of this class.
            // info.AddValue("TimeStamp", m_data.TimeStampUtc);
#pragma warning disable 618
			info.AddValue("TimeStamp", m_data.TimeStamp);
#pragma warning restore 618
            info.AddValue("LocationInfo", m_data.LocationInfo);
			info.AddValue("UserName", m_data.UserName);
			info.AddValue("ExceptionString", m_data.ExceptionString);
			info.AddValue("Properties", m_data.Properties);
			info.AddValue("Domain", m_data.Domain);
			info.AddValue("Identity", m_data.Identity);
		}

#endif

		#endregion Implementation of ISerializable

		#region Public Instance Methods

		/// <summary>
		/// Gets the portable data for this <see cref="LoggingEvent" />.
		/// </summary>
		/// <returns>The <see cref="LoggingEventData"/> for this event.</returns>
		/// <remarks>
		/// <para>
		/// A new <see cref="LoggingEvent"/> can be constructed using a
		/// <see cref="LoggingEventData"/> instance.
		/// </para>
		/// <para>
		/// Does a <see cref="FixFlags.Partial"/> fix of the data
		/// in the logging event before returning the event data.
		/// </para>
		/// </remarks>
		public LoggingEventData GetLoggingEventData()
		{
			return GetLoggingEventData(FixFlags.Partial);
		}

		/// <summary>
		/// Gets the portable data for this <see cref="LoggingEvent" />.
		/// </summary>
		/// <param name="fixFlags">The set of data to ensure is fixed in the LoggingEventData</param>
		/// <returns>The <see cref="LoggingEventData"/> for this event.</returns>
		/// <remarks>
		/// <para>
		/// A new <see cref="LoggingEvent"/> can be constructed using a
		/// <see cref="LoggingEventData"/> instance.
		/// </para>
		/// </remarks>
		public LoggingEventData GetLoggingEventData(FixFlags fixFlags)
		{
			Fix = fixFlags;
			return m_data;
		}

		/// <summary>
		/// Returns this event's exception's rendered using the 
		/// <see cref="ILoggerRepository.RendererMap" />.
		/// </summary>
		/// <returns>
		/// This event's exception's rendered using the <see cref="ILoggerRepository.RendererMap" />.
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>Obsolete. Use <see cref="GetExceptionString"/> instead.</b>
		/// </para>
		/// </remarks>
		[Obsolete("Use GetExceptionString instead")]
		public string GetExceptionStrRep() 
		{
			return GetExceptionString();
		}

		/// <summary>
		/// Returns this event's exception's rendered using the 
		/// <see cref="ILoggerRepository.RendererMap" />.
		/// </summary>
		/// <returns>
		/// This event's exception's rendered using the <see cref="ILoggerRepository.RendererMap" />.
		/// </returns>
		/// <remarks>
		/// <para>
		/// Returns this event's exception's rendered using the 
		/// <see cref="ILoggerRepository.RendererMap" />.
		/// </para>
		/// </remarks>
		public string GetExceptionString() 
		{
			if (m_data.ExceptionString == null  && this.m_cacheUpdatable)
			{
				if (m_thrownException != null)
				{
					if (m_repository != null)
					{
						// Render exception using the repositories renderer map
						m_data.ExceptionString = m_repository.RendererMap.FindAndRender(m_thrownException);
					}
					else
					{
						// Very last resort
						m_data.ExceptionString = m_thrownException.ToString();
					}
				}
				else
				{
					m_data.ExceptionString = "";
				}
			}
			return m_data.ExceptionString;
		}

		/// <summary>
		/// Fix instance fields that hold volatile data.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Some of the values in instances of <see cref="LoggingEvent"/>
		/// are considered volatile, that is the values are correct at the
		/// time the event is delivered to appenders, but will not be consistent
		/// at any time afterwards. If an event is to be stored and then processed
		/// at a later time these volatile values must be fixed by calling
		/// <see cref="M:FixVolatileData()"/>. There is a performance penalty
		/// incurred by calling <see cref="M:FixVolatileData()"/> but it
		/// is essential to maintaining data consistency.
		/// </para>
		/// <para>
		/// Calling <see cref="M:FixVolatileData()"/> is equivalent to
		/// calling <see cref="M:FixVolatileData(bool)"/> passing the parameter
		/// <c>false</c>.
		/// </para>
		/// <para>
		/// See <see cref="M:FixVolatileData(bool)"/> for more
		/// information.
		/// </para>
		/// </remarks>
		[Obsolete("Use Fix property")]
		public void FixVolatileData()
		{
			Fix = FixFlags.All;
		}

		/// <summary>
		/// Fixes instance fields that hold volatile data.
		/// </summary>
		/// <param name="fastButLoose">Set to <c>true</c> to not fix data that takes a long time to fix.</param>
		/// <remarks>
		/// <para>
		/// Some of the values in instances of <see cref="LoggingEvent"/>
		/// are considered volatile, that is the values are correct at the
		/// time the event is delivered to appenders, but will not be consistent
		/// at any time afterwards. If an event is to be stored and then processed
		/// at a later time these volatile values must be fixed by calling
		/// <see cref="M:FixVolatileData()"/>. There is a performance penalty
		/// for incurred by calling <see cref="M:FixVolatileData()"/> but it
		/// is essential to maintaining data consistency.
		/// </para>
		/// <para>
		/// The <paramref name="fastButLoose"/> param controls the data that
		/// is fixed. Some of the data that can be fixed takes a long time to 
		/// generate, therefore if you do not require those settings to be fixed
		/// they can be ignored by setting the <paramref name="fastButLoose"/> param
		/// to <c>true</c>. This setting will ignore the <see cref="LocationInformation"/>
		/// and <see cref="UserName"/> settings.
		/// </para>
		/// <para>
		/// Set <paramref name="fastButLoose"/> to <c>false</c> to ensure that all 
		/// settings are fixed.
		/// </para>
		/// </remarks>
		[Obsolete("Use Fix property")]
		public void FixVolatileData(bool fastButLoose)
		{
			if (fastButLoose)
			{
				Fix = FixFlags.Partial;
			}
			else
			{
				Fix = FixFlags.All;
			}
		}

		/// <summary>
		/// Fix the fields specified by the <see cref="FixFlags"/> parameter
		/// </summary>
		/// <param name="flags">the fields to fix</param>
		/// <remarks>
		/// <para>
		/// Only fields specified in the <paramref name="flags"/> will be fixed.
		/// Fields will not be fixed if they have previously been fixed.
		/// It is not possible to 'unfix' a field.
		/// </para>
		/// </remarks>
		protected void FixVolatileData(FixFlags flags)
		{
			object forceCreation = null;

			//Unlock the cache so that new values can be stored
			//This may not be ideal if we are no longer in the correct context
			//and someone calls fix. 
			m_cacheUpdatable=true;

			// determine the flags that we are actually fixing
			FixFlags updateFlags = (FixFlags)((flags ^ m_fixFlags) & flags);

			if (updateFlags > 0) 
			{
				if ((updateFlags & FixFlags.Message) != 0)
				{
					// Force the message to be rendered
					forceCreation = this.RenderedMessage;

					m_fixFlags |= FixFlags.Message;
				}
				if ((updateFlags & FixFlags.ThreadName) != 0)
				{
					// Grab the thread name
					forceCreation = this.ThreadName;

					m_fixFlags |= FixFlags.ThreadName;
				}

				if ((updateFlags & FixFlags.LocationInfo) != 0)
				{
					// Force the location information to be loaded
					forceCreation = this.LocationInformation;

					m_fixFlags |= FixFlags.LocationInfo;
				}
				if ((updateFlags & FixFlags.UserName) != 0)
				{
					// Grab the user name
					forceCreation = this.UserName;

					m_fixFlags |= FixFlags.UserName;
				}
				if ((updateFlags & FixFlags.Domain) != 0)
				{
					// Grab the domain name
					forceCreation = this.Domain;

					m_fixFlags |= FixFlags.Domain;
				}
				if ((updateFlags & FixFlags.Identity) != 0)
				{
					// Grab the identity
					forceCreation = this.Identity;

					m_fixFlags |= FixFlags.Identity;
				}

				if ((updateFlags & FixFlags.Exception) != 0)
				{
					// Force the exception text to be loaded
					forceCreation = GetExceptionString();

					m_fixFlags |= FixFlags.Exception;
				}

				if ((updateFlags & FixFlags.Properties) != 0)
				{
					CacheProperties();

					m_fixFlags |= FixFlags.Properties;
				}
			}

			// avoid warning CS0219
			if (forceCreation != null) 
			{
			}

			//Finaly lock everything we've cached.
			m_cacheUpdatable=false;
		}

		#endregion Public Instance Methods

		#region Protected Instance Methods

		private void CreateCompositeProperties()
		{
			CompositeProperties compositeProperties = new CompositeProperties();

			if (m_eventProperties != null)
			{
				compositeProperties.Add(m_eventProperties);
			}
#if !(NETCF || NETSTANDARD1_3)
			PropertiesDictionary logicalThreadProperties = LogicalThreadContext.Properties.GetProperties(false);
			if (logicalThreadProperties != null)
			{
				compositeProperties.Add(logicalThreadProperties);
			}
#endif
			PropertiesDictionary threadProperties = ThreadContext.Properties.GetProperties(false);
			if (threadProperties != null)
			{
				compositeProperties.Add(threadProperties);
			}

			// TODO: Add Repository Properties

			// event properties
			PropertiesDictionary eventProperties = new PropertiesDictionary();
			eventProperties[UserNameProperty] = UserName;
			eventProperties[IdentityProperty] = Identity;
			compositeProperties.Add(eventProperties);

			compositeProperties.Add(GlobalContext.Properties.GetReadOnlyProperties());
                        m_compositeProperties = compositeProperties;
		}

		private void CacheProperties()
		{
			if (m_data.Properties == null  && this.m_cacheUpdatable)
			{
				if (m_compositeProperties == null)
				{
					CreateCompositeProperties();
				}

				PropertiesDictionary flattenedProperties = m_compositeProperties.Flatten();

				PropertiesDictionary fixedProperties = new PropertiesDictionary();

				// Validate properties
				foreach(DictionaryEntry entry in flattenedProperties)
				{
					string key = entry.Key as string;

					if (key != null)
					{
						object val = entry.Value;

						// Fix any IFixingRequired objects
						IFixingRequired fixingRequired = val as IFixingRequired;
						if (fixingRequired != null)
						{
							val = fixingRequired.GetFixedObject();
						}

						// Strip keys with null values
						if (val != null)
						{
							fixedProperties[key] = val;
						}
					}
				}

				m_data.Properties = fixedProperties;
			}
		}

		/// <summary>
		/// Lookup a composite property in this event
		/// </summary>
		/// <param name="key">the key for the property to lookup</param>
		/// <returns>the value for the property</returns>
		/// <remarks>
		/// <para>
		/// This event has composite properties that combine together properties from
		/// several different contexts in the following order:
		/// <list type="definition">
		///		<item>
		/// 		<term>this events properties</term>
		/// 		<description>
		/// 		This event has <see cref="Properties"/> that can be set. These 
		/// 		properties are specific to this event only.
		/// 		</description>
		/// 	</item>
		/// 	<item>
		/// 		<term>the thread properties</term>
		/// 		<description>
		/// 		The <see cref="ThreadContext.Properties"/> that are set on the current
		/// 		thread. These properties are shared by all events logged on this thread.
		/// 		</description>
		/// 	</item>
		/// 	<item>
		/// 		<term>the global properties</term>
		/// 		<description>
		/// 		The <see cref="GlobalContext.Properties"/> that are set globally. These 
		/// 		properties are shared by all the threads in the AppDomain.
		/// 		</description>
		/// 	</item>
		/// </list>
		/// </para>
		/// </remarks>
		public object LookupProperty(string key)
		{
			if (m_data.Properties != null)
			{
				return m_data.Properties[key];
			}
			if (m_compositeProperties == null)
			{
				CreateCompositeProperties();
			}
			return m_compositeProperties[key];
		}

		/// <summary>
		/// Get all the composite properties in this event
		/// </summary>
		/// <returns>the <see cref="PropertiesDictionary"/> containing all the properties</returns>
		/// <remarks>
		/// <para>
		/// See <see cref="LookupProperty"/> for details of the composite properties 
		/// stored by the event.
		/// </para>
		/// <para>
		/// This method returns a single <see cref="PropertiesDictionary"/> containing all the
		/// properties defined for this event.
		/// </para>
		/// </remarks>
		public PropertiesDictionary GetProperties()
		{
			if (m_data.Properties != null)
			{
				return m_data.Properties;
			}
			if (m_compositeProperties == null)
			{
				CreateCompositeProperties();
			}
			return m_compositeProperties.Flatten();
		}

		#endregion Public Instance Methods

		#region Private Instance Fields

		/// <summary>
		/// The internal logging event data.
		/// </summary>
		private LoggingEventData m_data;

		/// <summary>
		/// The internal logging event data.
		/// </summary>
		private CompositeProperties m_compositeProperties;

		/// <summary>
		/// The internal logging event data.
		/// </summary>
		private PropertiesDictionary m_eventProperties;

		/// <summary>
		/// The fully qualified Type of the calling 
		/// logger class in the stack frame (i.e. the declaring type of the method).
		/// </summary>
		private readonly Type m_callerStackBoundaryDeclaringType;

		/// <summary>
		/// The application supplied message of logging event.
		/// </summary>
		private readonly object m_message;

		/// <summary>
		/// The exception that was thrown.
		/// </summary>
		/// <remarks>
		/// This is not serialized. The string representation
		/// is serialized instead.
		/// </remarks>
		private readonly Exception m_thrownException;

		/// <summary>
		/// The repository that generated the logging event
		/// </summary>
		/// <remarks>
		/// This is not serialized.
		/// </remarks>
		private ILoggerRepository m_repository = null;

		/// <summary>
		/// The fix state for this event
		/// </summary>
		/// <remarks>
		/// These flags indicate which fields have been fixed.
		/// Not serialized.
		/// </remarks>
		private FixFlags m_fixFlags = FixFlags.None;

		/// <summary>
		/// Indicated that the internal cache is updateable (ie not fixed)
		/// </summary>
		/// <remarks>
		/// This is a seperate flag to m_fixFlags as it allows incrementel fixing and simpler
		/// changes in the caching strategy.
		/// </remarks>
		private bool m_cacheUpdatable = true;]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private ILoggerRepository m_repository = null;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="398" sc="3" el="1600" ec="40">log4net\Core\LoggingEvent.cs</location>
            <body hash="b954c4b4909c164ae54d081d53c24c94"><![CDATA[public LoggingEvent(Type callerStackBoundaryDeclaringType, log4net.Repository.ILoggerRepository repository, LoggingEventData data, FixFlags fixedData) 
		{
			m_callerStackBoundaryDeclaringType = callerStackBoundaryDeclaringType;
			m_repository = repository;

			m_data = data;
			m_fixFlags = fixedData;
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="LoggingEvent" /> class 
		/// using specific data.
		/// </summary>
		/// <param name="callerStackBoundaryDeclaringType">The declaring type of the method that is
		/// the stack boundary into the logging system for this call.</param>
		/// <param name="repository">The repository this event is logged in.</param>
		/// <param name="data">Data used to initialize the logging event.</param>
		/// <remarks>
		/// <para>
		/// This constructor is provided to allow a <see cref="LoggingEvent" />
		/// to be created independently of the log4net framework. This can
		/// be useful if you require a custom serialization scheme.
		/// </para>
		/// <para>
		/// Use the <see cref="M:GetLoggingEventData(FixFlags)"/> method to obtain an 
		/// instance of the <see cref="LoggingEventData"/> class.
		/// </para>
		/// <para>
		/// This constructor sets this objects <see cref="Fix"/> flags to <see cref="FixFlags.All"/>,
		/// this assumes that all the data relating to this event is passed in via the <paramref name="data"/>
		/// parameter and no other data should be captured from the environment.
		/// </para>
		/// </remarks>
		public LoggingEvent(Type callerStackBoundaryDeclaringType, log4net.Repository.ILoggerRepository repository, LoggingEventData data) : this(callerStackBoundaryDeclaringType, repository, data, FixFlags.All)
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="LoggingEvent" /> class 
		/// using specific data.
		/// </summary>
		/// <param name="data">Data used to initialize the logging event.</param>
		/// <remarks>
		/// <para>
		/// This constructor is provided to allow a <see cref="LoggingEvent" />
		/// to be created independently of the log4net framework. This can
		/// be useful if you require a custom serialization scheme.
		/// </para>
		/// <para>
		/// Use the <see cref="M:GetLoggingEventData(FixFlags)"/> method to obtain an 
		/// instance of the <see cref="LoggingEventData"/> class.
		/// </para>
		/// <para>
		/// This constructor sets this objects <see cref="Fix"/> flags to <see cref="FixFlags.All"/>,
		/// this assumes that all the data relating to this event is passed in via the <paramref name="data"/>
		/// parameter and no other data should be captured from the environment.
		/// </para>
		/// </remarks>
		public LoggingEvent(LoggingEventData data) : this(null, null, data)
		{
		}

		#endregion Public Instance Constructors

		#region Protected Instance Constructors

#if !(NETCF || NETSTANDARD1_3)

		/// <summary>
		/// Serialization constructor
		/// </summary>
		/// <param name="info">The <see cref="SerializationInfo" /> that holds the serialized object data.</param>
		/// <param name="context">The <see cref="StreamingContext" /> that contains contextual information about the source or destination.</param>
		/// <remarks>
		/// <para>
		/// Initializes a new instance of the <see cref="LoggingEvent" /> class 
		/// with serialized data.
		/// </para>
		/// </remarks>
		protected LoggingEvent(SerializationInfo info, StreamingContext context) 
		{
			m_data.LoggerName = info.GetString("LoggerName");

			// Note we are deserializing the whole level object. That is the
			// name and the value. This value is correct for the source 
			// hierarchy but may not be for the target hierarchy that this
			// event may be re-logged into. If it is to be re-logged it may
			// be necessary to re-lookup the level based only on the name.
			m_data.Level = (Level)info.GetValue("Level", typeof(Level));

			m_data.Message = info.GetString("Message");
			m_data.ThreadName = info.GetString("ThreadName");
			m_data.TimeStampUtc = info.GetDateTime("TimeStamp").ToUniversalTime();
			m_data.LocationInfo = (LocationInfo) info.GetValue("LocationInfo", typeof(LocationInfo));
			m_data.UserName = info.GetString("UserName");
			m_data.ExceptionString = info.GetString("ExceptionString");
			m_data.Properties = (PropertiesDictionary) info.GetValue("Properties", typeof(PropertiesDictionary));
			m_data.Domain = info.GetString("Domain");
			m_data.Identity = info.GetString("Identity");

			// We have restored all the values of this instance, i.e. all the values are fixed
			// Set the fix flags otherwise the data values may be overwritten from the current environment.
			m_fixFlags = FixFlags.All;
		}

#endif

		#endregion Protected Instance Constructors

		#region Public Instance Properties
	
		/// <summary>
		/// Gets the time when the current process started.
		/// </summary>
		/// <value>
		/// This is the time when this process started.
		/// </value>
		/// <remarks>
		/// <para>
		/// The TimeStamp is stored internally in UTC and converted to the local time zone for this computer.
		/// </para>
		/// <para>
		/// Tries to get the start time for the current process.
		/// Failing that it returns the time of the first call to
		/// this property.
		/// </para>
		/// <para>
		/// Note that AppDomains may be loaded and unloaded within the
		/// same process without the process terminating and therefore
		/// without the process start time being reset.
		/// </para>
		/// </remarks>
		public static DateTime StartTime
		{
			get { return SystemInfo.ProcessStartTimeUtc.ToLocalTime(); }
		}

        /// <summary>
        /// Gets the UTC time when the current process started.
        /// </summary>
        /// <value>
        /// This is the UTC time when this process started.
        /// </value>
        /// <remarks>
        /// <para>
        /// Tries to get the start time for the current process.
        /// Failing that it returns the time of the first call to
        /// this property.
        /// </para>
        /// <para>
        /// Note that AppDomains may be loaded and unloaded within the
        /// same process without the process terminating and therefore
        /// without the process start time being reset.
        /// </para>
        /// </remarks>
        public static DateTime StartTimeUtc
        {
            get { return SystemInfo.ProcessStartTimeUtc; }
		}

		/// <summary>
		/// Gets the <see cref="Level" /> of the logging event.
		/// </summary>
		/// <value>
		/// The <see cref="Level" /> of the logging event.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets the <see cref="Level" /> of the logging event.
		/// </para>
		/// </remarks>
		public Level Level
		{
			get { return m_data.Level; } 
		}

		/// <summary>
		/// Gets the time of the logging event.
		/// </summary>
		/// <value>
		/// The time of the logging event.
		/// </value>
		/// <remarks>
		/// <para>
		/// The TimeStamp is stored in UTC and converted to the local time zone for this computer.
		/// </para>
		/// </remarks>
		public DateTime TimeStamp
		{
			get { return m_data.TimeStampUtc.ToLocalTime(); }
		}

        /// <summary>
        /// Gets UTC the time of the logging event.
        /// </summary>
        /// <value>
        /// The UTC time of the logging event.
        /// </value>
        public DateTime TimeStampUtc
        {
            get { return m_data.TimeStampUtc; }
		}

		/// <summary>
		/// Gets the name of the logger that logged the event.
		/// </summary>
		/// <value>
		/// The name of the logger that logged the event.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets the name of the logger that logged the event.
		/// </para>
		/// </remarks>
		public string LoggerName
		{
			get { return m_data.LoggerName; }
		}

		/// <summary>
		/// Gets the location information for this logging event.
		/// </summary>
		/// <value>
		/// The location information for this logging event.
		/// </value>
		/// <remarks>
		/// <para>
		/// The collected information is cached for future use.
		/// </para>
		/// <para>
		/// See the <see cref="LocationInfo"/> class for more information on
		/// supported frameworks and the different behavior in Debug and
		/// Release builds.
		/// </para>
		/// </remarks>
		public LocationInfo LocationInformation
		{
			get
			{
				if (m_data.LocationInfo == null  && this.m_cacheUpdatable) 
				{
					m_data.LocationInfo = new LocationInfo(m_callerStackBoundaryDeclaringType);
				}
				return m_data.LocationInfo;
			}
		}

		/// <summary>
		/// Gets the message object used to initialize this event.
		/// </summary>
		/// <value>
		/// The message object used to initialize this event.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets the message object used to initialize this event.
		/// Note that this event may not have a valid message object.
		/// If the event is serialized the message object will not 
		/// be transferred. To get the text of the message the
		/// <see cref="RenderedMessage"/> property must be used 
		/// not this property.
		/// </para>
		/// <para>
		/// If there is no defined message object for this event then
		/// null will be returned.
		/// </para>
		/// </remarks>
		public object MessageObject
		{
			get { return m_message; }
		} 

		/// <summary>
		/// Gets the exception object used to initialize this event.
		/// </summary>
		/// <value>
		/// The exception object used to initialize this event.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets the exception object used to initialize this event.
		/// Note that this event may not have a valid exception object.
		/// If the event is serialized the exception object will not 
		/// be transferred. To get the text of the exception the
		/// <see cref="GetExceptionString"/> method must be used 
		/// not this property.
		/// </para>
		/// <para>
		/// If there is no defined exception object for this event then
		/// null will be returned.
		/// </para>
		/// </remarks>
		public Exception ExceptionObject
		{
			get { return m_thrownException; }
		} 

		/// <summary>
		/// The <see cref="ILoggerRepository"/> that this event was created in.
		/// </summary>
		/// <remarks>
		/// <para>
		/// The <see cref="ILoggerRepository"/> that this event was created in.
		/// </para>
		/// </remarks>
		public ILoggerRepository Repository
		{
			get { return m_repository; }
		}

		/// <summary>
		/// Ensure that the repository is set.
		/// </summary>
		/// <param name="repository">the value for the repository</param>
		internal void EnsureRepository(ILoggerRepository repository)
		{
			if (repository != null)
			{
				m_repository = repository;
			}
		}

		/// <summary>
		/// Gets the message, rendered through the <see cref="ILoggerRepository.RendererMap" />.
		/// </summary>
		/// <value>
		/// The message rendered through the <see cref="ILoggerRepository.RendererMap" />.
		/// </value>
		/// <remarks>
		/// <para>
		/// The collected information is cached for future use.
		/// </para>
		/// </remarks>
		public string RenderedMessage
		{
			get 
			{ 
				if (m_data.Message == null && this.m_cacheUpdatable)
				{
					if (m_message == null)
					{
						m_data.Message = "";
					}
					else if (m_message is string)
					{
						m_data.Message = (m_message as string);
					}
					else if (m_repository != null)
					{
						m_data.Message = m_repository.RendererMap.FindAndRender(m_message);
					}
					else
					{
						// Very last resort
						m_data.Message = m_message.ToString();
					}
				}
				return m_data.Message; 
			}
		}

		/// <summary>
		/// Write the rendered message to a TextWriter
		/// </summary>
		/// <param name="writer">the writer to write the message to</param>
		/// <remarks>
		/// <para>
		/// Unlike the <see cref="RenderedMessage"/> property this method
		/// does store the message data in the internal cache. Therefore 
		/// if called only once this method should be faster than the
		/// <see cref="RenderedMessage"/> property, however if the message is
		/// to be accessed multiple times then the property will be more efficient.
		/// </para>
		/// </remarks>
		public void WriteRenderedMessage(TextWriter writer)
		{
			if (m_data.Message != null)
			{
				writer.Write(m_data.Message); 
			}
			else
			{
				if (m_message != null)
				{
					if (m_message is string)
					{
						writer.Write(m_message as string);
					}
					else if (m_repository != null)
					{
						m_repository.RendererMap.FindAndRender(m_message, writer);
					}
					else
					{
						// Very last resort
						writer.Write(m_message.ToString());
					}
				}
			}
		}

		/// <summary>
		/// Gets the name of the current thread.  
		/// </summary>
		/// <value>
		/// The name of the current thread, or the thread ID when 
		/// the name is not available.
		/// </value>
		/// <remarks>
		/// <para>
		/// The collected information is cached for future use.
		/// </para>
		/// </remarks>
		public string ThreadName
		{
			get
			{
				if (m_data.ThreadName == null && this.m_cacheUpdatable)
				{
#if NETCF || NETSTANDARD1_3
					// Get thread ID only
					m_data.ThreadName = SystemInfo.CurrentThreadId.ToString(System.Globalization.NumberFormatInfo.InvariantInfo);
#else
					m_data.ThreadName = System.Threading.Thread.CurrentThread.Name;
					if (m_data.ThreadName == null || m_data.ThreadName.Length == 0)
					{
						// The thread name is not available. Therefore we
						// go the the AppDomain to get the ID of the 
						// current thread. (Why don't Threads know their own ID?)
						try
						{
							m_data.ThreadName = SystemInfo.CurrentThreadId.ToString(System.Globalization.NumberFormatInfo.InvariantInfo);
						}
						catch(System.Security.SecurityException)
						{
							// This security exception will occur if the caller does not have 
							// some undefined set of SecurityPermission flags.
							LogLog.Debug(declaringType, "Security exception while trying to get current thread ID. Error Ignored. Empty thread name.");

							// As a last resort use the hash code of the Thread object
							m_data.ThreadName = System.Threading.Thread.CurrentThread.GetHashCode().ToString(System.Globalization.CultureInfo.InvariantCulture);
						}
					}
#endif
				}
				return m_data.ThreadName;
			}
		}

		/// <summary>
		/// Gets the name of the current user.
		/// </summary>
		/// <value>
		/// The name of the current user, or <c>NOT AVAILABLE</c> when the 
		/// underlying runtime has no support for retrieving the name of the 
		/// current user.
		/// </value>
		/// <remarks>
		/// <para>
		/// Calls <c>WindowsIdentity.GetCurrent().Name</c> to get the name of
		/// the current windows user.
		/// </para>
		/// <para>
		/// To improve performance, we could cache the string representation of 
		/// the name, and reuse that as long as the identity stayed constant.  
		/// Once the identity changed, we would need to re-assign and re-render 
		/// the string.
		/// </para>
		/// <para>
		/// However, the <c>WindowsIdentity.GetCurrent()</c> call seems to 
		/// return different objects every time, so the current implementation 
		/// doesn't do this type of caching.
		/// </para>
		/// <para>
		/// Timing for these operations:
		/// </para>
		/// <list type="table">
		///   <listheader>
		///     <term>Method</term>
		///     <description>Results</description>
		///   </listheader>
		///   <item>
		///	    <term><c>WindowsIdentity.GetCurrent()</c></term>
		///	    <description>10000 loops, 00:00:00.2031250 seconds</description>
		///   </item>
		///   <item>
		///	    <term><c>WindowsIdentity.GetCurrent().Name</c></term>
		///	    <description>10000 loops, 00:00:08.0468750 seconds</description>
		///   </item>
		/// </list>
		/// <para>
		/// This means we could speed things up almost 40 times by caching the 
		/// value of the <c>WindowsIdentity.GetCurrent().Name</c> property, since 
		/// this takes (8.04-0.20) = 7.84375 seconds.
		/// </para>
		/// </remarks>
		public string UserName
		{
			get
			{
				if (m_data.UserName == null  && this.m_cacheUpdatable) 
				{
#if (NETCF || SSCLI || NETSTANDARD1_3) // NETSTANDARD1_3 TODO requires platform-specific code
					// On compact framework there's no notion of current Windows user
					m_data.UserName = SystemInfo.NotAvailableText;
#else
					try
					{
						WindowsIdentity windowsIdentity = WindowsIdentity.GetCurrent();
						if (windowsIdentity != null && windowsIdentity.Name != null)
						{
							m_data.UserName = windowsIdentity.Name;
						}
						else
						{
							m_data.UserName = "";
						}
					}
					catch(System.Security.SecurityException)
					{
						// This security exception will occur if the caller does not have 
						// some undefined set of SecurityPermission flags.
						LogLog.Debug(declaringType, "Security exception while trying to get current windows identity. Error Ignored. Empty user name.");

						m_data.UserName = "";
					}
#endif
				}
				return m_data.UserName;
			}
		}

		/// <summary>
		/// Gets the identity of the current thread principal.
		/// </summary>
		/// <value>
		/// The string name of the identity of the current thread principal.
		/// </value>
		/// <remarks>
		/// <para>
		/// Calls <c>System.Threading.Thread.CurrentPrincipal.Identity.Name</c> to get
		/// the name of the current thread principal.
		/// </para>
		/// </remarks>
		public string Identity
		{
			get
			{
				if (m_data.Identity == null  && this.m_cacheUpdatable)
				{
#if (NETCF || SSCLI || NETSTANDARD1_3)
					// On compact framework there's no notion of current thread principals
					m_data.Identity = SystemInfo.NotAvailableText;
#else
					try
					{
						if (System.Threading.Thread.CurrentPrincipal != null && 
							System.Threading.Thread.CurrentPrincipal.Identity != null &&
							System.Threading.Thread.CurrentPrincipal.Identity.Name != null)
						{
							m_data.Identity = System.Threading.Thread.CurrentPrincipal.Identity.Name;
						}
						else
						{
							m_data.Identity = "";
						}
					}
					catch (ObjectDisposedException)
					{
						// This exception will occur if System.Threading.Thread.CurrentPrincipal.Identity is not null but
						// the getter of the property Name tries to access disposed objects.
						// Seen to happen on IIS 7 or greater with windows authentication.
						LogLog.Debug(declaringType, "Object disposed exception while trying to get current thread principal. Error Ignored. Empty identity name.");

						m_data.Identity = "";
					}
					catch (System.Security.SecurityException)
					{
						// This security exception will occur if the caller does not have 
						// some undefined set of SecurityPermission flags.
						LogLog.Debug(declaringType, "Security exception while trying to get current thread principal. Error Ignored. Empty identity name.");

						m_data.Identity = "";
					}
#endif
				}
				return m_data.Identity;
			}
		}

		/// <summary>
		/// Gets the AppDomain friendly name.
		/// </summary>
		/// <value>
		/// The AppDomain friendly name.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets the AppDomain friendly name.
		/// </para>
		/// </remarks>
		public string Domain
		{
			get 
			{ 
				if (m_data.Domain == null  && this.m_cacheUpdatable)
				{
					m_data.Domain = SystemInfo.ApplicationFriendlyName;
				}
				return m_data.Domain; 
			}
		}

		/// <summary>
		/// Additional event specific properties.
		/// </summary>
		/// <value>
		/// Additional event specific properties.
		/// </value>
		/// <remarks>
		/// <para>
		/// A logger or an appender may attach additional
		/// properties to specific events. These properties
		/// have a string key and an object value.
		/// </para>
		/// <para>
		/// This property is for events that have been added directly to
		/// this event. The aggregate properties (which include these
		/// event properties) can be retrieved using <see cref="LookupProperty"/>
		/// and <see cref="GetProperties"/>.
		/// </para>
		/// <para>
		/// Once the properties have been fixed <see cref="Fix"/> this property
		/// returns the combined cached properties. This ensures that updates to
		/// this property are always reflected in the underlying storage. When
		/// returning the combined properties there may be more keys in the
		/// Dictionary than expected.
		/// </para>
		/// </remarks>
		public PropertiesDictionary Properties
		{
			get 
			{ 
				// If we have cached properties then return that otherwise changes will be lost
				if (m_data.Properties != null)
				{
					return m_data.Properties;
				}

				if (m_eventProperties == null)
				{
					m_eventProperties = new PropertiesDictionary();
				}
				return m_eventProperties; 
			}
		}

		/// <summary>
		/// The fixed fields in this event
		/// </summary>
		/// <value>
		/// The set of fields that are fixed in this event
		/// </value>
		/// <remarks>
		/// <para>
		/// Fields will not be fixed if they have previously been fixed.
		/// It is not possible to 'unfix' a field.
		/// </para>
		/// </remarks>
		public FixFlags Fix
		{
			get { return m_fixFlags; }
			set { this.FixVolatileData(value); }
		}

		#endregion Public Instance Properties

		#region Implementation of ISerializable

#if !NETCF

		/// <summary>
		/// Serializes this object into the <see cref="SerializationInfo" /> provided.
		/// </summary>
		/// <param name="info">The <see cref="SerializationInfo" /> to populate with data.</param>
		/// <param name="context">The destination for this serialization.</param>
		/// <remarks>
		/// <para>
		/// The data in this event must be fixed before it can be serialized.
		/// </para>
		/// <para>
		/// The <see cref="M:FixVolatileData()"/> method must be called during the
		/// <see cref="log4net.Appender.IAppender.DoAppend"/> method call if this event 
		/// is to be used outside that method.
		/// </para>
		/// </remarks>
#if NET_4_0 || MONO_4_0 || NETSTANDARD1_3
        [System.Security.SecurityCritical]
#else
		[System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.Demand, SerializationFormatter=true)]
#endif
		public virtual void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			// The caller must call FixVolatileData before this object
			// can be serialized.

			info.AddValue("LoggerName", m_data.LoggerName);
			info.AddValue("Level", m_data.Level);
			info.AddValue("Message", m_data.Message);
			info.AddValue("ThreadName", m_data.ThreadName);
            // TODO: consider serializing UTC rather than local time.  Not implemented here because it
            // would give an unexpected result if client and server have different versions of this class.
            // info.AddValue("TimeStamp", m_data.TimeStampUtc);
#pragma warning disable 618
			info.AddValue("TimeStamp", m_data.TimeStamp);
#pragma warning restore 618
            info.AddValue("LocationInfo", m_data.LocationInfo);
			info.AddValue("UserName", m_data.UserName);
			info.AddValue("ExceptionString", m_data.ExceptionString);
			info.AddValue("Properties", m_data.Properties);
			info.AddValue("Domain", m_data.Domain);
			info.AddValue("Identity", m_data.Identity);
		}

#endif

		#endregion Implementation of ISerializable

		#region Public Instance Methods

		/// <summary>
		/// Gets the portable data for this <see cref="LoggingEvent" />.
		/// </summary>
		/// <returns>The <see cref="LoggingEventData"/> for this event.</returns>
		/// <remarks>
		/// <para>
		/// A new <see cref="LoggingEvent"/> can be constructed using a
		/// <see cref="LoggingEventData"/> instance.
		/// </para>
		/// <para>
		/// Does a <see cref="FixFlags.Partial"/> fix of the data
		/// in the logging event before returning the event data.
		/// </para>
		/// </remarks>
		public LoggingEventData GetLoggingEventData()
		{
			return GetLoggingEventData(FixFlags.Partial);
		}

		/// <summary>
		/// Gets the portable data for this <see cref="LoggingEvent" />.
		/// </summary>
		/// <param name="fixFlags">The set of data to ensure is fixed in the LoggingEventData</param>
		/// <returns>The <see cref="LoggingEventData"/> for this event.</returns>
		/// <remarks>
		/// <para>
		/// A new <see cref="LoggingEvent"/> can be constructed using a
		/// <see cref="LoggingEventData"/> instance.
		/// </para>
		/// </remarks>
		public LoggingEventData GetLoggingEventData(FixFlags fixFlags)
		{
			Fix = fixFlags;
			return m_data;
		}

		/// <summary>
		/// Returns this event's exception's rendered using the 
		/// <see cref="ILoggerRepository.RendererMap" />.
		/// </summary>
		/// <returns>
		/// This event's exception's rendered using the <see cref="ILoggerRepository.RendererMap" />.
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>Obsolete. Use <see cref="GetExceptionString"/> instead.</b>
		/// </para>
		/// </remarks>
		[Obsolete("Use GetExceptionString instead")]
		public string GetExceptionStrRep() 
		{
			return GetExceptionString();
		}

		/// <summary>
		/// Returns this event's exception's rendered using the 
		/// <see cref="ILoggerRepository.RendererMap" />.
		/// </summary>
		/// <returns>
		/// This event's exception's rendered using the <see cref="ILoggerRepository.RendererMap" />.
		/// </returns>
		/// <remarks>
		/// <para>
		/// Returns this event's exception's rendered using the 
		/// <see cref="ILoggerRepository.RendererMap" />.
		/// </para>
		/// </remarks>
		public string GetExceptionString() 
		{
			if (m_data.ExceptionString == null  && this.m_cacheUpdatable)
			{
				if (m_thrownException != null)
				{
					if (m_repository != null)
					{
						// Render exception using the repositories renderer map
						m_data.ExceptionString = m_repository.RendererMap.FindAndRender(m_thrownException);
					}
					else
					{
						// Very last resort
						m_data.ExceptionString = m_thrownException.ToString();
					}
				}
				else
				{
					m_data.ExceptionString = "";
				}
			}
			return m_data.ExceptionString;
		}

		/// <summary>
		/// Fix instance fields that hold volatile data.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Some of the values in instances of <see cref="LoggingEvent"/>
		/// are considered volatile, that is the values are correct at the
		/// time the event is delivered to appenders, but will not be consistent
		/// at any time afterwards. If an event is to be stored and then processed
		/// at a later time these volatile values must be fixed by calling
		/// <see cref="M:FixVolatileData()"/>. There is a performance penalty
		/// incurred by calling <see cref="M:FixVolatileData()"/> but it
		/// is essential to maintaining data consistency.
		/// </para>
		/// <para>
		/// Calling <see cref="M:FixVolatileData()"/> is equivalent to
		/// calling <see cref="M:FixVolatileData(bool)"/> passing the parameter
		/// <c>false</c>.
		/// </para>
		/// <para>
		/// See <see cref="M:FixVolatileData(bool)"/> for more
		/// information.
		/// </para>
		/// </remarks>
		[Obsolete("Use Fix property")]
		public void FixVolatileData()
		{
			Fix = FixFlags.All;
		}

		/// <summary>
		/// Fixes instance fields that hold volatile data.
		/// </summary>
		/// <param name="fastButLoose">Set to <c>true</c> to not fix data that takes a long time to fix.</param>
		/// <remarks>
		/// <para>
		/// Some of the values in instances of <see cref="LoggingEvent"/>
		/// are considered volatile, that is the values are correct at the
		/// time the event is delivered to appenders, but will not be consistent
		/// at any time afterwards. If an event is to be stored and then processed
		/// at a later time these volatile values must be fixed by calling
		/// <see cref="M:FixVolatileData()"/>. There is a performance penalty
		/// for incurred by calling <see cref="M:FixVolatileData()"/> but it
		/// is essential to maintaining data consistency.
		/// </para>
		/// <para>
		/// The <paramref name="fastButLoose"/> param controls the data that
		/// is fixed. Some of the data that can be fixed takes a long time to 
		/// generate, therefore if you do not require those settings to be fixed
		/// they can be ignored by setting the <paramref name="fastButLoose"/> param
		/// to <c>true</c>. This setting will ignore the <see cref="LocationInformation"/>
		/// and <see cref="UserName"/> settings.
		/// </para>
		/// <para>
		/// Set <paramref name="fastButLoose"/> to <c>false</c> to ensure that all 
		/// settings are fixed.
		/// </para>
		/// </remarks>
		[Obsolete("Use Fix property")]
		public void FixVolatileData(bool fastButLoose)
		{
			if (fastButLoose)
			{
				Fix = FixFlags.Partial;
			}
			else
			{
				Fix = FixFlags.All;
			}
		}

		/// <summary>
		/// Fix the fields specified by the <see cref="FixFlags"/> parameter
		/// </summary>
		/// <param name="flags">the fields to fix</param>
		/// <remarks>
		/// <para>
		/// Only fields specified in the <paramref name="flags"/> will be fixed.
		/// Fields will not be fixed if they have previously been fixed.
		/// It is not possible to 'unfix' a field.
		/// </para>
		/// </remarks>
		protected void FixVolatileData(FixFlags flags)
		{
			object forceCreation = null;

			//Unlock the cache so that new values can be stored
			//This may not be ideal if we are no longer in the correct context
			//and someone calls fix. 
			m_cacheUpdatable=true;

			// determine the flags that we are actually fixing
			FixFlags updateFlags = (FixFlags)((flags ^ m_fixFlags) & flags);

			if (updateFlags > 0) 
			{
				if ((updateFlags & FixFlags.Message) != 0)
				{
					// Force the message to be rendered
					forceCreation = this.RenderedMessage;

					m_fixFlags |= FixFlags.Message;
				}
				if ((updateFlags & FixFlags.ThreadName) != 0)
				{
					// Grab the thread name
					forceCreation = this.ThreadName;

					m_fixFlags |= FixFlags.ThreadName;
				}

				if ((updateFlags & FixFlags.LocationInfo) != 0)
				{
					// Force the location information to be loaded
					forceCreation = this.LocationInformation;

					m_fixFlags |= FixFlags.LocationInfo;
				}
				if ((updateFlags & FixFlags.UserName) != 0)
				{
					// Grab the user name
					forceCreation = this.UserName;

					m_fixFlags |= FixFlags.UserName;
				}
				if ((updateFlags & FixFlags.Domain) != 0)
				{
					// Grab the domain name
					forceCreation = this.Domain;

					m_fixFlags |= FixFlags.Domain;
				}
				if ((updateFlags & FixFlags.Identity) != 0)
				{
					// Grab the identity
					forceCreation = this.Identity;

					m_fixFlags |= FixFlags.Identity;
				}

				if ((updateFlags & FixFlags.Exception) != 0)
				{
					// Force the exception text to be loaded
					forceCreation = GetExceptionString();

					m_fixFlags |= FixFlags.Exception;
				}

				if ((updateFlags & FixFlags.Properties) != 0)
				{
					CacheProperties();

					m_fixFlags |= FixFlags.Properties;
				}
			}

			// avoid warning CS0219
			if (forceCreation != null) 
			{
			}

			//Finaly lock everything we've cached.
			m_cacheUpdatable=false;
		}

		#endregion Public Instance Methods

		#region Protected Instance Methods

		private void CreateCompositeProperties()
		{
			CompositeProperties compositeProperties = new CompositeProperties();

			if (m_eventProperties != null)
			{
				compositeProperties.Add(m_eventProperties);
			}
#if !(NETCF || NETSTANDARD1_3)
			PropertiesDictionary logicalThreadProperties = LogicalThreadContext.Properties.GetProperties(false);
			if (logicalThreadProperties != null)
			{
				compositeProperties.Add(logicalThreadProperties);
			}
#endif
			PropertiesDictionary threadProperties = ThreadContext.Properties.GetProperties(false);
			if (threadProperties != null)
			{
				compositeProperties.Add(threadProperties);
			}

			// TODO: Add Repository Properties

			// event properties
			PropertiesDictionary eventProperties = new PropertiesDictionary();
			eventProperties[UserNameProperty] = UserName;
			eventProperties[IdentityProperty] = Identity;
			compositeProperties.Add(eventProperties);

			compositeProperties.Add(GlobalContext.Properties.GetReadOnlyProperties());
                        m_compositeProperties = compositeProperties;
		}

		private void CacheProperties()
		{
			if (m_data.Properties == null  && this.m_cacheUpdatable)
			{
				if (m_compositeProperties == null)
				{
					CreateCompositeProperties();
				}

				PropertiesDictionary flattenedProperties = m_compositeProperties.Flatten();

				PropertiesDictionary fixedProperties = new PropertiesDictionary();

				// Validate properties
				foreach(DictionaryEntry entry in flattenedProperties)
				{
					string key = entry.Key as string;

					if (key != null)
					{
						object val = entry.Value;

						// Fix any IFixingRequired objects
						IFixingRequired fixingRequired = val as IFixingRequired;
						if (fixingRequired != null)
						{
							val = fixingRequired.GetFixedObject();
						}

						// Strip keys with null values
						if (val != null)
						{
							fixedProperties[key] = val;
						}
					}
				}

				m_data.Properties = fixedProperties;
			}
		}

		/// <summary>
		/// Lookup a composite property in this event
		/// </summary>
		/// <param name="key">the key for the property to lookup</param>
		/// <returns>the value for the property</returns>
		/// <remarks>
		/// <para>
		/// This event has composite properties that combine together properties from
		/// several different contexts in the following order:
		/// <list type="definition">
		///		<item>
		/// 		<term>this events properties</term>
		/// 		<description>
		/// 		This event has <see cref="Properties"/> that can be set. These 
		/// 		properties are specific to this event only.
		/// 		</description>
		/// 	</item>
		/// 	<item>
		/// 		<term>the thread properties</term>
		/// 		<description>
		/// 		The <see cref="ThreadContext.Properties"/> that are set on the current
		/// 		thread. These properties are shared by all events logged on this thread.
		/// 		</description>
		/// 	</item>
		/// 	<item>
		/// 		<term>the global properties</term>
		/// 		<description>
		/// 		The <see cref="GlobalContext.Properties"/> that are set globally. These 
		/// 		properties are shared by all the threads in the AppDomain.
		/// 		</description>
		/// 	</item>
		/// </list>
		/// </para>
		/// </remarks>
		public object LookupProperty(string key)
		{
			if (m_data.Properties != null)
			{
				return m_data.Properties[key];
			}
			if (m_compositeProperties == null)
			{
				CreateCompositeProperties();
			}
			return m_compositeProperties[key];
		}

		/// <summary>
		/// Get all the composite properties in this event
		/// </summary>
		/// <returns>the <see cref="PropertiesDictionary"/> containing all the properties</returns>
		/// <remarks>
		/// <para>
		/// See <see cref="LookupProperty"/> for details of the composite properties 
		/// stored by the event.
		/// </para>
		/// <para>
		/// This method returns a single <see cref="PropertiesDictionary"/> containing all the
		/// properties defined for this event.
		/// </para>
		/// </remarks>
		public PropertiesDictionary GetProperties()
		{
			if (m_data.Properties != null)
			{
				return m_data.Properties;
			}
			if (m_compositeProperties == null)
			{
				CreateCompositeProperties();
			}
			return m_compositeProperties.Flatten();
		}

		#endregion Public Instance Methods

		#region Private Instance Fields

		/// <summary>
		/// The internal logging event data.
		/// </summary>
		private LoggingEventData m_data;

		/// <summary>
		/// The internal logging event data.
		/// </summary>
		private CompositeProperties m_compositeProperties;

		/// <summary>
		/// The internal logging event data.
		/// </summary>
		private PropertiesDictionary m_eventProperties;

		/// <summary>
		/// The fully qualified Type of the calling 
		/// logger class in the stack frame (i.e. the declaring type of the method).
		/// </summary>
		private readonly Type m_callerStackBoundaryDeclaringType;

		/// <summary>
		/// The application supplied message of logging event.
		/// </summary>
		private readonly object m_message;

		/// <summary>
		/// The exception that was thrown.
		/// </summary>
		/// <remarks>
		/// This is not serialized. The string representation
		/// is serialized instead.
		/// </remarks>
		private readonly Exception m_thrownException;

		/// <summary>
		/// The repository that generated the logging event
		/// </summary>
		/// <remarks>
		/// This is not serialized.
		/// </remarks>
		private ILoggerRepository m_repository = null;

		/// <summary>
		/// The fix state for this event
		/// </summary>
		/// <remarks>
		/// These flags indicate which fields have been fixed.
		/// Not serialized.
		/// </remarks>
		private FixFlags m_fixFlags = FixFlags.None;

		/// <summary>
		/// Indicated that the internal cache is updateable (ie not fixed)
		/// </summary>
		/// <remarks>
		/// This is a seperate flag to m_fixFlags as it allows incrementel fixing and simpler
		/// changes in the caching strategy.
		/// </remarks>
		private bool m_cacheUpdatable = true;]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public LoggingEvent(Type callerStackBoundaryDeclaringType, ILoggerRepository repository, LoggingEventData data) : this(callerStackBoundaryDeclaringType, repository, data, FixFlags.All)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="431" sc="136" el="433" ec="4">log4net\Core\LoggingEvent.cs</location>
            <body hash="a0ec49ded2ab641deb7767ca2e6cacef"><![CDATA[this(callerStackBoundaryDeclaringType, repository, data, FixFlags.All)
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public LoggingEvent(LoggingEventData data) : this(null, null, data)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="456" sc="48" el="458" ec="4">log4net\Core\LoggingEvent.cs</location>
            <body hash="c1a0bc5a4dbc9961fb75784d1a41a4fc"><![CDATA[this(null, null, data)
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private ILoggerRepository m_repository = null;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="477" sc="3" el="1600" ec="40">log4net\Core\LoggingEvent.cs</location>
            <body hash="3319a3182969f0f6315bc793575c99b1"><![CDATA[protected LoggingEvent(SerializationInfo info, StreamingContext context) 
		{
			m_data.LoggerName = info.GetString("LoggerName");

			// Note we are deserializing the whole level object. That is the
			// name and the value. This value is correct for the source 
			// hierarchy but may not be for the target hierarchy that this
			// event may be re-logged into. If it is to be re-logged it may
			// be necessary to re-lookup the level based only on the name.
			m_data.Level = (Level)info.GetValue("Level", typeof(Level));

			m_data.Message = info.GetString("Message");
			m_data.ThreadName = info.GetString("ThreadName");
			m_data.TimeStampUtc = info.GetDateTime("TimeStamp").ToUniversalTime();
			m_data.LocationInfo = (LocationInfo) info.GetValue("LocationInfo", typeof(LocationInfo));
			m_data.UserName = info.GetString("UserName");
			m_data.ExceptionString = info.GetString("ExceptionString");
			m_data.Properties = (PropertiesDictionary) info.GetValue("Properties", typeof(PropertiesDictionary));
			m_data.Domain = info.GetString("Domain");
			m_data.Identity = info.GetString("Identity");

			// We have restored all the values of this instance, i.e. all the values are fixed
			// Set the fix flags otherwise the data values may be overwritten from the current environment.
			m_fixFlags = FixFlags.All;
		}

#endif

		#endregion Protected Instance Constructors

		#region Public Instance Properties
	
		/// <summary>
		/// Gets the time when the current process started.
		/// </summary>
		/// <value>
		/// This is the time when this process started.
		/// </value>
		/// <remarks>
		/// <para>
		/// The TimeStamp is stored internally in UTC and converted to the local time zone for this computer.
		/// </para>
		/// <para>
		/// Tries to get the start time for the current process.
		/// Failing that it returns the time of the first call to
		/// this property.
		/// </para>
		/// <para>
		/// Note that AppDomains may be loaded and unloaded within the
		/// same process without the process terminating and therefore
		/// without the process start time being reset.
		/// </para>
		/// </remarks>
		public static DateTime StartTime
		{
			get { return SystemInfo.ProcessStartTimeUtc.ToLocalTime(); }
		}

        /// <summary>
        /// Gets the UTC time when the current process started.
        /// </summary>
        /// <value>
        /// This is the UTC time when this process started.
        /// </value>
        /// <remarks>
        /// <para>
        /// Tries to get the start time for the current process.
        /// Failing that it returns the time of the first call to
        /// this property.
        /// </para>
        /// <para>
        /// Note that AppDomains may be loaded and unloaded within the
        /// same process without the process terminating and therefore
        /// without the process start time being reset.
        /// </para>
        /// </remarks>
        public static DateTime StartTimeUtc
        {
            get { return SystemInfo.ProcessStartTimeUtc; }
		}

		/// <summary>
		/// Gets the <see cref="Level" /> of the logging event.
		/// </summary>
		/// <value>
		/// The <see cref="Level" /> of the logging event.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets the <see cref="Level" /> of the logging event.
		/// </para>
		/// </remarks>
		public Level Level
		{
			get { return m_data.Level; } 
		}

		/// <summary>
		/// Gets the time of the logging event.
		/// </summary>
		/// <value>
		/// The time of the logging event.
		/// </value>
		/// <remarks>
		/// <para>
		/// The TimeStamp is stored in UTC and converted to the local time zone for this computer.
		/// </para>
		/// </remarks>
		public DateTime TimeStamp
		{
			get { return m_data.TimeStampUtc.ToLocalTime(); }
		}

        /// <summary>
        /// Gets UTC the time of the logging event.
        /// </summary>
        /// <value>
        /// The UTC time of the logging event.
        /// </value>
        public DateTime TimeStampUtc
        {
            get { return m_data.TimeStampUtc; }
		}

		/// <summary>
		/// Gets the name of the logger that logged the event.
		/// </summary>
		/// <value>
		/// The name of the logger that logged the event.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets the name of the logger that logged the event.
		/// </para>
		/// </remarks>
		public string LoggerName
		{
			get { return m_data.LoggerName; }
		}

		/// <summary>
		/// Gets the location information for this logging event.
		/// </summary>
		/// <value>
		/// The location information for this logging event.
		/// </value>
		/// <remarks>
		/// <para>
		/// The collected information is cached for future use.
		/// </para>
		/// <para>
		/// See the <see cref="LocationInfo"/> class for more information on
		/// supported frameworks and the different behavior in Debug and
		/// Release builds.
		/// </para>
		/// </remarks>
		public LocationInfo LocationInformation
		{
			get
			{
				if (m_data.LocationInfo == null  && this.m_cacheUpdatable) 
				{
					m_data.LocationInfo = new LocationInfo(m_callerStackBoundaryDeclaringType);
				}
				return m_data.LocationInfo;
			}
		}

		/// <summary>
		/// Gets the message object used to initialize this event.
		/// </summary>
		/// <value>
		/// The message object used to initialize this event.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets the message object used to initialize this event.
		/// Note that this event may not have a valid message object.
		/// If the event is serialized the message object will not 
		/// be transferred. To get the text of the message the
		/// <see cref="RenderedMessage"/> property must be used 
		/// not this property.
		/// </para>
		/// <para>
		/// If there is no defined message object for this event then
		/// null will be returned.
		/// </para>
		/// </remarks>
		public object MessageObject
		{
			get { return m_message; }
		} 

		/// <summary>
		/// Gets the exception object used to initialize this event.
		/// </summary>
		/// <value>
		/// The exception object used to initialize this event.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets the exception object used to initialize this event.
		/// Note that this event may not have a valid exception object.
		/// If the event is serialized the exception object will not 
		/// be transferred. To get the text of the exception the
		/// <see cref="GetExceptionString"/> method must be used 
		/// not this property.
		/// </para>
		/// <para>
		/// If there is no defined exception object for this event then
		/// null will be returned.
		/// </para>
		/// </remarks>
		public Exception ExceptionObject
		{
			get { return m_thrownException; }
		} 

		/// <summary>
		/// The <see cref="ILoggerRepository"/> that this event was created in.
		/// </summary>
		/// <remarks>
		/// <para>
		/// The <see cref="ILoggerRepository"/> that this event was created in.
		/// </para>
		/// </remarks>
		public ILoggerRepository Repository
		{
			get { return m_repository; }
		}

		/// <summary>
		/// Ensure that the repository is set.
		/// </summary>
		/// <param name="repository">the value for the repository</param>
		internal void EnsureRepository(ILoggerRepository repository)
		{
			if (repository != null)
			{
				m_repository = repository;
			}
		}

		/// <summary>
		/// Gets the message, rendered through the <see cref="ILoggerRepository.RendererMap" />.
		/// </summary>
		/// <value>
		/// The message rendered through the <see cref="ILoggerRepository.RendererMap" />.
		/// </value>
		/// <remarks>
		/// <para>
		/// The collected information is cached for future use.
		/// </para>
		/// </remarks>
		public string RenderedMessage
		{
			get 
			{ 
				if (m_data.Message == null && this.m_cacheUpdatable)
				{
					if (m_message == null)
					{
						m_data.Message = "";
					}
					else if (m_message is string)
					{
						m_data.Message = (m_message as string);
					}
					else if (m_repository != null)
					{
						m_data.Message = m_repository.RendererMap.FindAndRender(m_message);
					}
					else
					{
						// Very last resort
						m_data.Message = m_message.ToString();
					}
				}
				return m_data.Message; 
			}
		}

		/// <summary>
		/// Write the rendered message to a TextWriter
		/// </summary>
		/// <param name="writer">the writer to write the message to</param>
		/// <remarks>
		/// <para>
		/// Unlike the <see cref="RenderedMessage"/> property this method
		/// does store the message data in the internal cache. Therefore 
		/// if called only once this method should be faster than the
		/// <see cref="RenderedMessage"/> property, however if the message is
		/// to be accessed multiple times then the property will be more efficient.
		/// </para>
		/// </remarks>
		public void WriteRenderedMessage(TextWriter writer)
		{
			if (m_data.Message != null)
			{
				writer.Write(m_data.Message); 
			}
			else
			{
				if (m_message != null)
				{
					if (m_message is string)
					{
						writer.Write(m_message as string);
					}
					else if (m_repository != null)
					{
						m_repository.RendererMap.FindAndRender(m_message, writer);
					}
					else
					{
						// Very last resort
						writer.Write(m_message.ToString());
					}
				}
			}
		}

		/// <summary>
		/// Gets the name of the current thread.  
		/// </summary>
		/// <value>
		/// The name of the current thread, or the thread ID when 
		/// the name is not available.
		/// </value>
		/// <remarks>
		/// <para>
		/// The collected information is cached for future use.
		/// </para>
		/// </remarks>
		public string ThreadName
		{
			get
			{
				if (m_data.ThreadName == null && this.m_cacheUpdatable)
				{
#if NETCF || NETSTANDARD1_3
					// Get thread ID only
					m_data.ThreadName = SystemInfo.CurrentThreadId.ToString(System.Globalization.NumberFormatInfo.InvariantInfo);
#else
					m_data.ThreadName = System.Threading.Thread.CurrentThread.Name;
					if (m_data.ThreadName == null || m_data.ThreadName.Length == 0)
					{
						// The thread name is not available. Therefore we
						// go the the AppDomain to get the ID of the 
						// current thread. (Why don't Threads know their own ID?)
						try
						{
							m_data.ThreadName = SystemInfo.CurrentThreadId.ToString(System.Globalization.NumberFormatInfo.InvariantInfo);
						}
						catch(System.Security.SecurityException)
						{
							// This security exception will occur if the caller does not have 
							// some undefined set of SecurityPermission flags.
							LogLog.Debug(declaringType, "Security exception while trying to get current thread ID. Error Ignored. Empty thread name.");

							// As a last resort use the hash code of the Thread object
							m_data.ThreadName = System.Threading.Thread.CurrentThread.GetHashCode().ToString(System.Globalization.CultureInfo.InvariantCulture);
						}
					}
#endif
				}
				return m_data.ThreadName;
			}
		}

		/// <summary>
		/// Gets the name of the current user.
		/// </summary>
		/// <value>
		/// The name of the current user, or <c>NOT AVAILABLE</c> when the 
		/// underlying runtime has no support for retrieving the name of the 
		/// current user.
		/// </value>
		/// <remarks>
		/// <para>
		/// Calls <c>WindowsIdentity.GetCurrent().Name</c> to get the name of
		/// the current windows user.
		/// </para>
		/// <para>
		/// To improve performance, we could cache the string representation of 
		/// the name, and reuse that as long as the identity stayed constant.  
		/// Once the identity changed, we would need to re-assign and re-render 
		/// the string.
		/// </para>
		/// <para>
		/// However, the <c>WindowsIdentity.GetCurrent()</c> call seems to 
		/// return different objects every time, so the current implementation 
		/// doesn't do this type of caching.
		/// </para>
		/// <para>
		/// Timing for these operations:
		/// </para>
		/// <list type="table">
		///   <listheader>
		///     <term>Method</term>
		///     <description>Results</description>
		///   </listheader>
		///   <item>
		///	    <term><c>WindowsIdentity.GetCurrent()</c></term>
		///	    <description>10000 loops, 00:00:00.2031250 seconds</description>
		///   </item>
		///   <item>
		///	    <term><c>WindowsIdentity.GetCurrent().Name</c></term>
		///	    <description>10000 loops, 00:00:08.0468750 seconds</description>
		///   </item>
		/// </list>
		/// <para>
		/// This means we could speed things up almost 40 times by caching the 
		/// value of the <c>WindowsIdentity.GetCurrent().Name</c> property, since 
		/// this takes (8.04-0.20) = 7.84375 seconds.
		/// </para>
		/// </remarks>
		public string UserName
		{
			get
			{
				if (m_data.UserName == null  && this.m_cacheUpdatable) 
				{
#if (NETCF || SSCLI || NETSTANDARD1_3) // NETSTANDARD1_3 TODO requires platform-specific code
					// On compact framework there's no notion of current Windows user
					m_data.UserName = SystemInfo.NotAvailableText;
#else
					try
					{
						WindowsIdentity windowsIdentity = WindowsIdentity.GetCurrent();
						if (windowsIdentity != null && windowsIdentity.Name != null)
						{
							m_data.UserName = windowsIdentity.Name;
						}
						else
						{
							m_data.UserName = "";
						}
					}
					catch(System.Security.SecurityException)
					{
						// This security exception will occur if the caller does not have 
						// some undefined set of SecurityPermission flags.
						LogLog.Debug(declaringType, "Security exception while trying to get current windows identity. Error Ignored. Empty user name.");

						m_data.UserName = "";
					}
#endif
				}
				return m_data.UserName;
			}
		}

		/// <summary>
		/// Gets the identity of the current thread principal.
		/// </summary>
		/// <value>
		/// The string name of the identity of the current thread principal.
		/// </value>
		/// <remarks>
		/// <para>
		/// Calls <c>System.Threading.Thread.CurrentPrincipal.Identity.Name</c> to get
		/// the name of the current thread principal.
		/// </para>
		/// </remarks>
		public string Identity
		{
			get
			{
				if (m_data.Identity == null  && this.m_cacheUpdatable)
				{
#if (NETCF || SSCLI || NETSTANDARD1_3)
					// On compact framework there's no notion of current thread principals
					m_data.Identity = SystemInfo.NotAvailableText;
#else
					try
					{
						if (System.Threading.Thread.CurrentPrincipal != null && 
							System.Threading.Thread.CurrentPrincipal.Identity != null &&
							System.Threading.Thread.CurrentPrincipal.Identity.Name != null)
						{
							m_data.Identity = System.Threading.Thread.CurrentPrincipal.Identity.Name;
						}
						else
						{
							m_data.Identity = "";
						}
					}
					catch (ObjectDisposedException)
					{
						// This exception will occur if System.Threading.Thread.CurrentPrincipal.Identity is not null but
						// the getter of the property Name tries to access disposed objects.
						// Seen to happen on IIS 7 or greater with windows authentication.
						LogLog.Debug(declaringType, "Object disposed exception while trying to get current thread principal. Error Ignored. Empty identity name.");

						m_data.Identity = "";
					}
					catch (System.Security.SecurityException)
					{
						// This security exception will occur if the caller does not have 
						// some undefined set of SecurityPermission flags.
						LogLog.Debug(declaringType, "Security exception while trying to get current thread principal. Error Ignored. Empty identity name.");

						m_data.Identity = "";
					}
#endif
				}
				return m_data.Identity;
			}
		}

		/// <summary>
		/// Gets the AppDomain friendly name.
		/// </summary>
		/// <value>
		/// The AppDomain friendly name.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets the AppDomain friendly name.
		/// </para>
		/// </remarks>
		public string Domain
		{
			get 
			{ 
				if (m_data.Domain == null  && this.m_cacheUpdatable)
				{
					m_data.Domain = SystemInfo.ApplicationFriendlyName;
				}
				return m_data.Domain; 
			}
		}

		/// <summary>
		/// Additional event specific properties.
		/// </summary>
		/// <value>
		/// Additional event specific properties.
		/// </value>
		/// <remarks>
		/// <para>
		/// A logger or an appender may attach additional
		/// properties to specific events. These properties
		/// have a string key and an object value.
		/// </para>
		/// <para>
		/// This property is for events that have been added directly to
		/// this event. The aggregate properties (which include these
		/// event properties) can be retrieved using <see cref="LookupProperty"/>
		/// and <see cref="GetProperties"/>.
		/// </para>
		/// <para>
		/// Once the properties have been fixed <see cref="Fix"/> this property
		/// returns the combined cached properties. This ensures that updates to
		/// this property are always reflected in the underlying storage. When
		/// returning the combined properties there may be more keys in the
		/// Dictionary than expected.
		/// </para>
		/// </remarks>
		public PropertiesDictionary Properties
		{
			get 
			{ 
				// If we have cached properties then return that otherwise changes will be lost
				if (m_data.Properties != null)
				{
					return m_data.Properties;
				}

				if (m_eventProperties == null)
				{
					m_eventProperties = new PropertiesDictionary();
				}
				return m_eventProperties; 
			}
		}

		/// <summary>
		/// The fixed fields in this event
		/// </summary>
		/// <value>
		/// The set of fields that are fixed in this event
		/// </value>
		/// <remarks>
		/// <para>
		/// Fields will not be fixed if they have previously been fixed.
		/// It is not possible to 'unfix' a field.
		/// </para>
		/// </remarks>
		public FixFlags Fix
		{
			get { return m_fixFlags; }
			set { this.FixVolatileData(value); }
		}

		#endregion Public Instance Properties

		#region Implementation of ISerializable

#if !NETCF

		/// <summary>
		/// Serializes this object into the <see cref="SerializationInfo" /> provided.
		/// </summary>
		/// <param name="info">The <see cref="SerializationInfo" /> to populate with data.</param>
		/// <param name="context">The destination for this serialization.</param>
		/// <remarks>
		/// <para>
		/// The data in this event must be fixed before it can be serialized.
		/// </para>
		/// <para>
		/// The <see cref="M:FixVolatileData()"/> method must be called during the
		/// <see cref="log4net.Appender.IAppender.DoAppend"/> method call if this event 
		/// is to be used outside that method.
		/// </para>
		/// </remarks>
#if NET_4_0 || MONO_4_0 || NETSTANDARD1_3
        [System.Security.SecurityCritical]
#else
		[System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.Demand, SerializationFormatter=true)]
#endif
		public virtual void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			// The caller must call FixVolatileData before this object
			// can be serialized.

			info.AddValue("LoggerName", m_data.LoggerName);
			info.AddValue("Level", m_data.Level);
			info.AddValue("Message", m_data.Message);
			info.AddValue("ThreadName", m_data.ThreadName);
            // TODO: consider serializing UTC rather than local time.  Not implemented here because it
            // would give an unexpected result if client and server have different versions of this class.
            // info.AddValue("TimeStamp", m_data.TimeStampUtc);
#pragma warning disable 618
			info.AddValue("TimeStamp", m_data.TimeStamp);
#pragma warning restore 618
            info.AddValue("LocationInfo", m_data.LocationInfo);
			info.AddValue("UserName", m_data.UserName);
			info.AddValue("ExceptionString", m_data.ExceptionString);
			info.AddValue("Properties", m_data.Properties);
			info.AddValue("Domain", m_data.Domain);
			info.AddValue("Identity", m_data.Identity);
		}

#endif

		#endregion Implementation of ISerializable

		#region Public Instance Methods

		/// <summary>
		/// Gets the portable data for this <see cref="LoggingEvent" />.
		/// </summary>
		/// <returns>The <see cref="LoggingEventData"/> for this event.</returns>
		/// <remarks>
		/// <para>
		/// A new <see cref="LoggingEvent"/> can be constructed using a
		/// <see cref="LoggingEventData"/> instance.
		/// </para>
		/// <para>
		/// Does a <see cref="FixFlags.Partial"/> fix of the data
		/// in the logging event before returning the event data.
		/// </para>
		/// </remarks>
		public LoggingEventData GetLoggingEventData()
		{
			return GetLoggingEventData(FixFlags.Partial);
		}

		/// <summary>
		/// Gets the portable data for this <see cref="LoggingEvent" />.
		/// </summary>
		/// <param name="fixFlags">The set of data to ensure is fixed in the LoggingEventData</param>
		/// <returns>The <see cref="LoggingEventData"/> for this event.</returns>
		/// <remarks>
		/// <para>
		/// A new <see cref="LoggingEvent"/> can be constructed using a
		/// <see cref="LoggingEventData"/> instance.
		/// </para>
		/// </remarks>
		public LoggingEventData GetLoggingEventData(FixFlags fixFlags)
		{
			Fix = fixFlags;
			return m_data;
		}

		/// <summary>
		/// Returns this event's exception's rendered using the 
		/// <see cref="ILoggerRepository.RendererMap" />.
		/// </summary>
		/// <returns>
		/// This event's exception's rendered using the <see cref="ILoggerRepository.RendererMap" />.
		/// </returns>
		/// <remarks>
		/// <para>
		/// <b>Obsolete. Use <see cref="GetExceptionString"/> instead.</b>
		/// </para>
		/// </remarks>
		[Obsolete("Use GetExceptionString instead")]
		public string GetExceptionStrRep() 
		{
			return GetExceptionString();
		}

		/// <summary>
		/// Returns this event's exception's rendered using the 
		/// <see cref="ILoggerRepository.RendererMap" />.
		/// </summary>
		/// <returns>
		/// This event's exception's rendered using the <see cref="ILoggerRepository.RendererMap" />.
		/// </returns>
		/// <remarks>
		/// <para>
		/// Returns this event's exception's rendered using the 
		/// <see cref="ILoggerRepository.RendererMap" />.
		/// </para>
		/// </remarks>
		public string GetExceptionString() 
		{
			if (m_data.ExceptionString == null  && this.m_cacheUpdatable)
			{
				if (m_thrownException != null)
				{
					if (m_repository != null)
					{
						// Render exception using the repositories renderer map
						m_data.ExceptionString = m_repository.RendererMap.FindAndRender(m_thrownException);
					}
					else
					{
						// Very last resort
						m_data.ExceptionString = m_thrownException.ToString();
					}
				}
				else
				{
					m_data.ExceptionString = "";
				}
			}
			return m_data.ExceptionString;
		}

		/// <summary>
		/// Fix instance fields that hold volatile data.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Some of the values in instances of <see cref="LoggingEvent"/>
		/// are considered volatile, that is the values are correct at the
		/// time the event is delivered to appenders, but will not be consistent
		/// at any time afterwards. If an event is to be stored and then processed
		/// at a later time these volatile values must be fixed by calling
		/// <see cref="M:FixVolatileData()"/>. There is a performance penalty
		/// incurred by calling <see cref="M:FixVolatileData()"/> but it
		/// is essential to maintaining data consistency.
		/// </para>
		/// <para>
		/// Calling <see cref="M:FixVolatileData()"/> is equivalent to
		/// calling <see cref="M:FixVolatileData(bool)"/> passing the parameter
		/// <c>false</c>.
		/// </para>
		/// <para>
		/// See <see cref="M:FixVolatileData(bool)"/> for more
		/// information.
		/// </para>
		/// </remarks>
		[Obsolete("Use Fix property")]
		public void FixVolatileData()
		{
			Fix = FixFlags.All;
		}

		/// <summary>
		/// Fixes instance fields that hold volatile data.
		/// </summary>
		/// <param name="fastButLoose">Set to <c>true</c> to not fix data that takes a long time to fix.</param>
		/// <remarks>
		/// <para>
		/// Some of the values in instances of <see cref="LoggingEvent"/>
		/// are considered volatile, that is the values are correct at the
		/// time the event is delivered to appenders, but will not be consistent
		/// at any time afterwards. If an event is to be stored and then processed
		/// at a later time these volatile values must be fixed by calling
		/// <see cref="M:FixVolatileData()"/>. There is a performance penalty
		/// for incurred by calling <see cref="M:FixVolatileData()"/> but it
		/// is essential to maintaining data consistency.
		/// </para>
		/// <para>
		/// The <paramref name="fastButLoose"/> param controls the data that
		/// is fixed. Some of the data that can be fixed takes a long time to 
		/// generate, therefore if you do not require those settings to be fixed
		/// they can be ignored by setting the <paramref name="fastButLoose"/> param
		/// to <c>true</c>. This setting will ignore the <see cref="LocationInformation"/>
		/// and <see cref="UserName"/> settings.
		/// </para>
		/// <para>
		/// Set <paramref name="fastButLoose"/> to <c>false</c> to ensure that all 
		/// settings are fixed.
		/// </para>
		/// </remarks>
		[Obsolete("Use Fix property")]
		public void FixVolatileData(bool fastButLoose)
		{
			if (fastButLoose)
			{
				Fix = FixFlags.Partial;
			}
			else
			{
				Fix = FixFlags.All;
			}
		}

		/// <summary>
		/// Fix the fields specified by the <see cref="FixFlags"/> parameter
		/// </summary>
		/// <param name="flags">the fields to fix</param>
		/// <remarks>
		/// <para>
		/// Only fields specified in the <paramref name="flags"/> will be fixed.
		/// Fields will not be fixed if they have previously been fixed.
		/// It is not possible to 'unfix' a field.
		/// </para>
		/// </remarks>
		protected void FixVolatileData(FixFlags flags)
		{
			object forceCreation = null;

			//Unlock the cache so that new values can be stored
			//This may not be ideal if we are no longer in the correct context
			//and someone calls fix. 
			m_cacheUpdatable=true;

			// determine the flags that we are actually fixing
			FixFlags updateFlags = (FixFlags)((flags ^ m_fixFlags) & flags);

			if (updateFlags > 0) 
			{
				if ((updateFlags & FixFlags.Message) != 0)
				{
					// Force the message to be rendered
					forceCreation = this.RenderedMessage;

					m_fixFlags |= FixFlags.Message;
				}
				if ((updateFlags & FixFlags.ThreadName) != 0)
				{
					// Grab the thread name
					forceCreation = this.ThreadName;

					m_fixFlags |= FixFlags.ThreadName;
				}

				if ((updateFlags & FixFlags.LocationInfo) != 0)
				{
					// Force the location information to be loaded
					forceCreation = this.LocationInformation;

					m_fixFlags |= FixFlags.LocationInfo;
				}
				if ((updateFlags & FixFlags.UserName) != 0)
				{
					// Grab the user name
					forceCreation = this.UserName;

					m_fixFlags |= FixFlags.UserName;
				}
				if ((updateFlags & FixFlags.Domain) != 0)
				{
					// Grab the domain name
					forceCreation = this.Domain;

					m_fixFlags |= FixFlags.Domain;
				}
				if ((updateFlags & FixFlags.Identity) != 0)
				{
					// Grab the identity
					forceCreation = this.Identity;

					m_fixFlags |= FixFlags.Identity;
				}

				if ((updateFlags & FixFlags.Exception) != 0)
				{
					// Force the exception text to be loaded
					forceCreation = GetExceptionString();

					m_fixFlags |= FixFlags.Exception;
				}

				if ((updateFlags & FixFlags.Properties) != 0)
				{
					CacheProperties();

					m_fixFlags |= FixFlags.Properties;
				}
			}

			// avoid warning CS0219
			if (forceCreation != null) 
			{
			}

			//Finaly lock everything we've cached.
			m_cacheUpdatable=false;
		}

		#endregion Public Instance Methods

		#region Protected Instance Methods

		private void CreateCompositeProperties()
		{
			CompositeProperties compositeProperties = new CompositeProperties();

			if (m_eventProperties != null)
			{
				compositeProperties.Add(m_eventProperties);
			}
#if !(NETCF || NETSTANDARD1_3)
			PropertiesDictionary logicalThreadProperties = LogicalThreadContext.Properties.GetProperties(false);
			if (logicalThreadProperties != null)
			{
				compositeProperties.Add(logicalThreadProperties);
			}
#endif
			PropertiesDictionary threadProperties = ThreadContext.Properties.GetProperties(false);
			if (threadProperties != null)
			{
				compositeProperties.Add(threadProperties);
			}

			// TODO: Add Repository Properties

			// event properties
			PropertiesDictionary eventProperties = new PropertiesDictionary();
			eventProperties[UserNameProperty] = UserName;
			eventProperties[IdentityProperty] = Identity;
			compositeProperties.Add(eventProperties);

			compositeProperties.Add(GlobalContext.Properties.GetReadOnlyProperties());
                        m_compositeProperties = compositeProperties;
		}

		private void CacheProperties()
		{
			if (m_data.Properties == null  && this.m_cacheUpdatable)
			{
				if (m_compositeProperties == null)
				{
					CreateCompositeProperties();
				}

				PropertiesDictionary flattenedProperties = m_compositeProperties.Flatten();

				PropertiesDictionary fixedProperties = new PropertiesDictionary();

				// Validate properties
				foreach(DictionaryEntry entry in flattenedProperties)
				{
					string key = entry.Key as string;

					if (key != null)
					{
						object val = entry.Value;

						// Fix any IFixingRequired objects
						IFixingRequired fixingRequired = val as IFixingRequired;
						if (fixingRequired != null)
						{
							val = fixingRequired.GetFixedObject();
						}

						// Strip keys with null values
						if (val != null)
						{
							fixedProperties[key] = val;
						}
					}
				}

				m_data.Properties = fixedProperties;
			}
		}

		/// <summary>
		/// Lookup a composite property in this event
		/// </summary>
		/// <param name="key">the key for the property to lookup</param>
		/// <returns>the value for the property</returns>
		/// <remarks>
		/// <para>
		/// This event has composite properties that combine together properties from
		/// several different contexts in the following order:
		/// <list type="definition">
		///		<item>
		/// 		<term>this events properties</term>
		/// 		<description>
		/// 		This event has <see cref="Properties"/> that can be set. These 
		/// 		properties are specific to this event only.
		/// 		</description>
		/// 	</item>
		/// 	<item>
		/// 		<term>the thread properties</term>
		/// 		<description>
		/// 		The <see cref="ThreadContext.Properties"/> that are set on the current
		/// 		thread. These properties are shared by all events logged on this thread.
		/// 		</description>
		/// 	</item>
		/// 	<item>
		/// 		<term>the global properties</term>
		/// 		<description>
		/// 		The <see cref="GlobalContext.Properties"/> that are set globally. These 
		/// 		properties are shared by all the threads in the AppDomain.
		/// 		</description>
		/// 	</item>
		/// </list>
		/// </para>
		/// </remarks>
		public object LookupProperty(string key)
		{
			if (m_data.Properties != null)
			{
				return m_data.Properties[key];
			}
			if (m_compositeProperties == null)
			{
				CreateCompositeProperties();
			}
			return m_compositeProperties[key];
		}

		/// <summary>
		/// Get all the composite properties in this event
		/// </summary>
		/// <returns>the <see cref="PropertiesDictionary"/> containing all the properties</returns>
		/// <remarks>
		/// <para>
		/// See <see cref="LookupProperty"/> for details of the composite properties 
		/// stored by the event.
		/// </para>
		/// <para>
		/// This method returns a single <see cref="PropertiesDictionary"/> containing all the
		/// properties defined for this event.
		/// </para>
		/// </remarks>
		public PropertiesDictionary GetProperties()
		{
			if (m_data.Properties != null)
			{
				return m_data.Properties;
			}
			if (m_compositeProperties == null)
			{
				CreateCompositeProperties();
			}
			return m_compositeProperties.Flatten();
		}

		#endregion Public Instance Methods

		#region Private Instance Fields

		/// <summary>
		/// The internal logging event data.
		/// </summary>
		private LoggingEventData m_data;

		/// <summary>
		/// The internal logging event data.
		/// </summary>
		private CompositeProperties m_compositeProperties;

		/// <summary>
		/// The internal logging event data.
		/// </summary>
		private PropertiesDictionary m_eventProperties;

		/// <summary>
		/// The fully qualified Type of the calling 
		/// logger class in the stack frame (i.e. the declaring type of the method).
		/// </summary>
		private readonly Type m_callerStackBoundaryDeclaringType;

		/// <summary>
		/// The application supplied message of logging event.
		/// </summary>
		private readonly object m_message;

		/// <summary>
		/// The exception that was thrown.
		/// </summary>
		/// <remarks>
		/// This is not serialized. The string representation
		/// is serialized instead.
		/// </remarks>
		private readonly Exception m_thrownException;

		/// <summary>
		/// The repository that generated the logging event
		/// </summary>
		/// <remarks>
		/// This is not serialized.
		/// </remarks>
		private ILoggerRepository m_repository = null;

		/// <summary>
		/// The fix state for this event
		/// </summary>
		/// <remarks>
		/// These flags indicate which fields have been fixed.
		/// Not serialized.
		/// </remarks>
		private FixFlags m_fixFlags = FixFlags.None;

		/// <summary>
		/// Indicated that the internal cache is updateable (ie not fixed)
		/// </summary>
		/// <remarks>
		/// This is a seperate flag to m_fixFlags as it allows incrementel fixing and simpler
		/// changes in the caching strategy.
		/// </remarks>
		private bool m_cacheUpdatable = true;]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static LoggingEvent()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="333" sc="6" el="333" ec="72">log4net\Core\LoggingEvent.cs</location>
            <body hash="f24fc53fa01a77a5221d6de94cd98438"><![CDATA[private readonly static Type declaringType = typeof(LoggingEvent)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CacheProperties">
          <declaration><![CDATA[private void CacheProperties()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1423" sc="3" el="1461" ec="4">log4net\Core\LoggingEvent.cs</location>
            <body hash="e8dddb0e97d0a08aa05bc2f0e809e18f"><![CDATA[{
			if (m_data.Properties == null  && this.m_cacheUpdatable)
			{
				if (m_compositeProperties == null)
				{
					CreateCompositeProperties();
				}

				PropertiesDictionary flattenedProperties = m_compositeProperties.Flatten();

				PropertiesDictionary fixedProperties = new PropertiesDictionary();

				// Validate properties
				foreach(DictionaryEntry entry in flattenedProperties)
				{
					string key = entry.Key as string;

					if (key != null)
					{
						object val = entry.Value;

						// Fix any IFixingRequired objects
						IFixingRequired fixingRequired = val as IFixingRequired;
						if (fixingRequired != null)
						{
							val = fixingRequired.GetFixedObject();
						}

						// Strip keys with null values
						if (val != null)
						{
							fixedProperties[key] = val;
						}
					}
				}

				m_data.Properties = fixedProperties;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="CreateCompositeProperties">
          <declaration><![CDATA[private void CreateCompositeProperties()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1390" sc="3" el="1420" ec="4">log4net\Core\LoggingEvent.cs</location>
            <body hash="5f19dc9573ece30f8d663a8c9ee30a58"><![CDATA[{
			CompositeProperties compositeProperties = new CompositeProperties();

			if (m_eventProperties != null)
			{
				compositeProperties.Add(m_eventProperties);
			}
#if !(NETCF || NETSTANDARD1_3)
			PropertiesDictionary logicalThreadProperties = LogicalThreadContext.Properties.GetProperties(false);
			if (logicalThreadProperties != null)
			{
				compositeProperties.Add(logicalThreadProperties);
			}
#endif
			PropertiesDictionary threadProperties = ThreadContext.Properties.GetProperties(false);
			if (threadProperties != null)
			{
				compositeProperties.Add(threadProperties);
			}

			// TODO: Add Repository Properties

			// event properties
			PropertiesDictionary eventProperties = new PropertiesDictionary();
			eventProperties[UserNameProperty] = UserName;
			eventProperties[IdentityProperty] = Identity;
			compositeProperties.Add(eventProperties);

			compositeProperties.Add(GlobalContext.Properties.GetReadOnlyProperties());
                        m_compositeProperties = compositeProperties;
		}]]></body>
          </codeblock>
        </method>
        <method name="EnsureRepository">
          <declaration><![CDATA[internal void EnsureRepository(ILoggerRepository repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="713" sc="3" el="718" ec="4">log4net\Core\LoggingEvent.cs</location>
            <body hash="8d93c08f0d0005c4f90e68cd1afdc83d"><![CDATA[{
			if (repository != null)
			{
				m_repository = repository;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="FixVolatileData">
          <deprecation>Use Fix property</deprecation>
          <declaration><![CDATA[public void FixVolatileData()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1246" sc="3" el="1248" ec="4">log4net\Core\LoggingEvent.cs</location>
            <body hash="30e6cb49b4734562e1b1dbee1b05f5be"><![CDATA[{
			Fix = FixFlags.All;
		}]]></body>
          </codeblock>
        </method>
        <method name="FixVolatileData">
          <deprecation>Use Fix property</deprecation>
          <declaration><![CDATA[public void FixVolatileData(bool fastButLoose)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1280" sc="3" el="1289" ec="4">log4net\Core\LoggingEvent.cs</location>
            <body hash="58fe21d694d37cb3f3c945baa6b4e1f4"><![CDATA[{
			if (fastButLoose)
			{
				Fix = FixFlags.Partial;
			}
			else
			{
				Fix = FixFlags.All;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="FixVolatileData">
          <declaration><![CDATA[protected void FixVolatileData(FixFlags flags)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1303" sc="3" el="1383" ec="4">log4net\Core\LoggingEvent.cs</location>
            <body hash="3b2e0db98c40d86897a49ef7e3de5215"><![CDATA[{
			object forceCreation = null;

			//Unlock the cache so that new values can be stored
			//This may not be ideal if we are no longer in the correct context
			//and someone calls fix. 
			m_cacheUpdatable=true;

			// determine the flags that we are actually fixing
			FixFlags updateFlags = (FixFlags)((flags ^ m_fixFlags) & flags);

			if (updateFlags > 0) 
			{
				if ((updateFlags & FixFlags.Message) != 0)
				{
					// Force the message to be rendered
					forceCreation = this.RenderedMessage;

					m_fixFlags |= FixFlags.Message;
				}
				if ((updateFlags & FixFlags.ThreadName) != 0)
				{
					// Grab the thread name
					forceCreation = this.ThreadName;

					m_fixFlags |= FixFlags.ThreadName;
				}

				if ((updateFlags & FixFlags.LocationInfo) != 0)
				{
					// Force the location information to be loaded
					forceCreation = this.LocationInformation;

					m_fixFlags |= FixFlags.LocationInfo;
				}
				if ((updateFlags & FixFlags.UserName) != 0)
				{
					// Grab the user name
					forceCreation = this.UserName;

					m_fixFlags |= FixFlags.UserName;
				}
				if ((updateFlags & FixFlags.Domain) != 0)
				{
					// Grab the domain name
					forceCreation = this.Domain;

					m_fixFlags |= FixFlags.Domain;
				}
				if ((updateFlags & FixFlags.Identity) != 0)
				{
					// Grab the identity
					forceCreation = this.Identity;

					m_fixFlags |= FixFlags.Identity;
				}

				if ((updateFlags & FixFlags.Exception) != 0)
				{
					// Force the exception text to be loaded
					forceCreation = GetExceptionString();

					m_fixFlags |= FixFlags.Exception;
				}

				if ((updateFlags & FixFlags.Properties) != 0)
				{
					CacheProperties();

					m_fixFlags |= FixFlags.Properties;
				}
			}

			// avoid warning CS0219
			if (forceCreation != null) 
			{
			}

			//Finaly lock everything we've cached.
			m_cacheUpdatable=false;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetExceptionString">
          <declaration><![CDATA[public string GetExceptionString()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1196" sc="3" el="1218" ec="4">log4net\Core\LoggingEvent.cs</location>
            <body hash="89c370f900ceea9221004706de8c2618"><![CDATA[{
			if (m_data.ExceptionString == null  && this.m_cacheUpdatable)
			{
				if (m_thrownException != null)
				{
					if (m_repository != null)
					{
						// Render exception using the repositories renderer map
						m_data.ExceptionString = m_repository.RendererMap.FindAndRender(m_thrownException);
					}
					else
					{
						// Very last resort
						m_data.ExceptionString = m_thrownException.ToString();
					}
				}
				else
				{
					m_data.ExceptionString = "";
				}
			}
			return m_data.ExceptionString;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetExceptionStrRep">
          <deprecation>Use GetExceptionString instead</deprecation>
          <declaration><![CDATA[public string GetExceptionStrRep()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1178" sc="3" el="1180" ec="4">log4net\Core\LoggingEvent.cs</location>
            <body hash="d4b76161d9794062e469725c1d6ce702"><![CDATA[{
			return GetExceptionString();
		}]]></body>
          </codeblock>
        </method>
        <method name="GetLoggingEventData">
          <declaration><![CDATA[public LoggingEventData GetLoggingEventData()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1143" sc="3" el="1145" ec="4">log4net\Core\LoggingEvent.cs</location>
            <body hash="447a03eb9c7071ec6db53a21bd7fff1c"><![CDATA[{
			return GetLoggingEventData(FixFlags.Partial);
		}]]></body>
          </codeblock>
        </method>
        <method name="GetLoggingEventData">
          <declaration><![CDATA[public LoggingEventData GetLoggingEventData(FixFlags fixFlags)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1159" sc="3" el="1162" ec="4">log4net\Core\LoggingEvent.cs</location>
            <body hash="7945f3cf3ba677624d1ba298812250a8"><![CDATA[{
			Fix = fixFlags;
			return m_data;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetObjectData">
          <declaration><![CDATA[public virtual void GetObjectData(SerializationInfo info, StreamingContext context)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1100" sc="3" el="1120" ec="4">log4net\Core\LoggingEvent.cs</location>
            <body hash="f6b3023fc7b5dc2accac4df901a7f40b"><![CDATA[{
			// The caller must call FixVolatileData before this object
			// can be serialized.

			info.AddValue("LoggerName", m_data.LoggerName);
			info.AddValue("Level", m_data.Level);
			info.AddValue("Message", m_data.Message);
			info.AddValue("ThreadName", m_data.ThreadName);
            // TODO: consider serializing UTC rather than local time.  Not implemented here because it
            // would give an unexpected result if client and server have different versions of this class.
            // info.AddValue("TimeStamp", m_data.TimeStampUtc);
#pragma warning disable 618
			info.AddValue("TimeStamp", m_data.TimeStamp);
#pragma warning restore 618
            info.AddValue("LocationInfo", m_data.LocationInfo);
			info.AddValue("UserName", m_data.UserName);
			info.AddValue("ExceptionString", m_data.ExceptionString);
			info.AddValue("Properties", m_data.Properties);
			info.AddValue("Domain", m_data.Domain);
			info.AddValue("Identity", m_data.Identity);
		}]]></body>
          </codeblock>
        </method>
        <method name="GetProperties">
          <declaration><![CDATA[public PropertiesDictionary GetProperties()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1525" sc="3" el="1535" ec="4">log4net\Core\LoggingEvent.cs</location>
            <body hash="58be91c0676818ed6014e3981d938632"><![CDATA[{
			if (m_data.Properties != null)
			{
				return m_data.Properties;
			}
			if (m_compositeProperties == null)
			{
				CreateCompositeProperties();
			}
			return m_compositeProperties.Flatten();
		}]]></body>
          </codeblock>
        </method>
        <method name="LookupProperty">
          <declaration><![CDATA[public object LookupProperty(string key)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1498" sc="3" el="1508" ec="4">log4net\Core\LoggingEvent.cs</location>
            <body hash="40ab444c6fcc46b957d08b12a93734ca"><![CDATA[{
			if (m_data.Properties != null)
			{
				return m_data.Properties[key];
			}
			if (m_compositeProperties == null)
			{
				CreateCompositeProperties();
			}
			return m_compositeProperties[key];
		}]]></body>
          </codeblock>
        </method>
        <method name="WriteRenderedMessage">
          <declaration><![CDATA[public void WriteRenderedMessage(TextWriter writer)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="773" sc="3" el="797" ec="4">log4net\Core\LoggingEvent.cs</location>
            <body hash="732ba1cfd6b3335e23b5f1de62cd5b4a"><![CDATA[{
			if (m_data.Message != null)
			{
				writer.Write(m_data.Message); 
			}
			else
			{
				if (m_message != null)
				{
					if (m_message is string)
					{
						writer.Write(m_message as string);
					}
					else if (m_repository != null)
					{
						m_repository.RendererMap.FindAndRender(m_message, writer);
					}
					else
					{
						// Very last resort
						writer.Write(m_message.ToString());
					}
				}
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(LoggingEvent);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="HostNameProperty">
          <declaration><![CDATA[public const string HostNameProperty = "log4net:HostName";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="IdentityProperty">
          <declaration><![CDATA[public const string IdentityProperty = "log4net:Identity";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_cacheUpdatable">
          <declaration><![CDATA[private bool m_cacheUpdatable = true;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_callerStackBoundaryDeclaringType">
          <declaration><![CDATA[private readonly Type m_callerStackBoundaryDeclaringType;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_compositeProperties">
          <declaration><![CDATA[private CompositeProperties m_compositeProperties;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_data">
          <declaration><![CDATA[private LoggingEventData m_data;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_eventProperties">
          <declaration><![CDATA[private PropertiesDictionary m_eventProperties;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_fixFlags">
          <declaration><![CDATA[private FixFlags m_fixFlags = FixFlags.None;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_message">
          <declaration><![CDATA[private readonly object m_message;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_repository">
          <declaration><![CDATA[private ILoggerRepository m_repository = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_thrownException">
          <declaration><![CDATA[private readonly Exception m_thrownException;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="UserNameProperty">
          <declaration><![CDATA[public const string UserNameProperty = "log4net:UserName";]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Domain">
          <declaration><![CDATA[public string Domain]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1002" sc="4" el="1008" ec="5">log4net\Core\LoggingEvent.cs</location>
            <body hash="8b9cfb7af4dc471e597f16b5cfc05148"><![CDATA[{ 
				if (m_data.Domain == null  && this.m_cacheUpdatable)
				{
					m_data.Domain = SystemInfo.ApplicationFriendlyName;
				}
				return m_data.Domain; 
			}]]></body>
          </codeblock>
        </property>
        <property name="ExceptionObject">
          <declaration><![CDATA[public Exception ExceptionObject]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Fix">
          <declaration><![CDATA[public FixFlags Fix]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Identity">
          <declaration><![CDATA[public string Identity]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="945" sc="4" el="985" ec="5">log4net\Core\LoggingEvent.cs</location>
            <body hash="bbb6f4ee61517e2f9ba27ae64af5c04b"><![CDATA[{
				if (m_data.Identity == null  && this.m_cacheUpdatable)
				{
#if (NETCF || SSCLI || NETSTANDARD1_3)
					// On compact framework there's no notion of current thread principals
					m_data.Identity = SystemInfo.NotAvailableText;
#else
					try
					{
						if (System.Threading.Thread.CurrentPrincipal != null && 
							System.Threading.Thread.CurrentPrincipal.Identity != null &&
							System.Threading.Thread.CurrentPrincipal.Identity.Name != null)
						{
							m_data.Identity = System.Threading.Thread.CurrentPrincipal.Identity.Name;
						}
						else
						{
							m_data.Identity = "";
						}
					}
					catch (ObjectDisposedException)
					{
						// This exception will occur if System.Threading.Thread.CurrentPrincipal.Identity is not null but
						// the getter of the property Name tries to access disposed objects.
						// Seen to happen on IIS 7 or greater with windows authentication.
						LogLog.Debug(declaringType, "Object disposed exception while trying to get current thread principal. Error Ignored. Empty identity name.");

						m_data.Identity = "";
					}
					catch (System.Security.SecurityException)
					{
						// This security exception will occur if the caller does not have 
						// some undefined set of SecurityPermission flags.
						LogLog.Debug(declaringType, "Security exception while trying to get current thread principal. Error Ignored. Empty identity name.");

						m_data.Identity = "";
					}
#endif
				}
				return m_data.Identity;
			}]]></body>
          </codeblock>
        </property>
        <property name="Level">
          <declaration><![CDATA[public Level Level]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="LocationInformation">
          <declaration><![CDATA[public LocationInfo LocationInformation]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="636" sc="4" el="642" ec="5">log4net\Core\LoggingEvent.cs</location>
            <body hash="99e9f83373143488eac3ab38bff26aa1"><![CDATA[{
				if (m_data.LocationInfo == null  && this.m_cacheUpdatable) 
				{
					m_data.LocationInfo = new LocationInfo(m_callerStackBoundaryDeclaringType);
				}
				return m_data.LocationInfo;
			}]]></body>
          </codeblock>
        </property>
        <property name="LoggerName">
          <declaration><![CDATA[public string LoggerName]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="MessageObject">
          <declaration><![CDATA[public object MessageObject]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Properties">
          <declaration><![CDATA[public PropertiesDictionary Properties]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1040" sc="4" el="1052" ec="5">log4net\Core\LoggingEvent.cs</location>
            <body hash="de14a1fc946162132436513820032421"><![CDATA[{ 
				// If we have cached properties then return that otherwise changes will be lost
				if (m_data.Properties != null)
				{
					return m_data.Properties;
				}

				if (m_eventProperties == null)
				{
					m_eventProperties = new PropertiesDictionary();
				}
				return m_eventProperties; 
			}]]></body>
          </codeblock>
        </property>
        <property name="RenderedMessage">
          <declaration><![CDATA[public string RenderedMessage]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="734" sc="4" el="756" ec="5">log4net\Core\LoggingEvent.cs</location>
            <body hash="512b3c9f7c1d0cf9daf358db829c70be"><![CDATA[{ 
				if (m_data.Message == null && this.m_cacheUpdatable)
				{
					if (m_message == null)
					{
						m_data.Message = "";
					}
					else if (m_message is string)
					{
						m_data.Message = (m_message as string);
					}
					else if (m_repository != null)
					{
						m_data.Message = m_repository.RendererMap.FindAndRender(m_message);
					}
					else
					{
						// Very last resort
						m_data.Message = m_message.ToString();
					}
				}
				return m_data.Message; 
			}]]></body>
          </codeblock>
        </property>
        <property name="Repository">
          <declaration><![CDATA[public ILoggerRepository Repository]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="StartTime">
          <declaration><![CDATA[public static DateTime StartTime]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="StartTimeUtc">
          <declaration><![CDATA[public static DateTime StartTimeUtc]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="ThreadName">
          <declaration><![CDATA[public string ThreadName]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="814" sc="4" el="844" ec="5">log4net\Core\LoggingEvent.cs</location>
            <body hash="a921e275bea32d25b5ffe35400df34db"><![CDATA[{
				if (m_data.ThreadName == null && this.m_cacheUpdatable)
				{
#if NETCF || NETSTANDARD1_3
					// Get thread ID only
					m_data.ThreadName = SystemInfo.CurrentThreadId.ToString(System.Globalization.NumberFormatInfo.InvariantInfo);
#else
					m_data.ThreadName = System.Threading.Thread.CurrentThread.Name;
					if (m_data.ThreadName == null || m_data.ThreadName.Length == 0)
					{
						// The thread name is not available. Therefore we
						// go the the AppDomain to get the ID of the 
						// current thread. (Why don't Threads know their own ID?)
						try
						{
							m_data.ThreadName = SystemInfo.CurrentThreadId.ToString(System.Globalization.NumberFormatInfo.InvariantInfo);
						}
						catch(System.Security.SecurityException)
						{
							// This security exception will occur if the caller does not have 
							// some undefined set of SecurityPermission flags.
							LogLog.Debug(declaringType, "Security exception while trying to get current thread ID. Error Ignored. Empty thread name.");

							// As a last resort use the hash code of the Thread object
							m_data.ThreadName = System.Threading.Thread.CurrentThread.GetHashCode().ToString(System.Globalization.CultureInfo.InvariantCulture);
						}
					}
#endif
				}
				return m_data.ThreadName;
			}]]></body>
          </codeblock>
        </property>
        <property name="TimeStamp">
          <declaration><![CDATA[public DateTime TimeStamp]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="TimeStampUtc">
          <declaration><![CDATA[public DateTime TimeStampUtc]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="UserName">
          <declaration><![CDATA[public string UserName]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="897" sc="4" el="927" ec="5">log4net\Core\LoggingEvent.cs</location>
            <body hash="be7359eb2035ee98c3d6241b198c021f"><![CDATA[{
				if (m_data.UserName == null  && this.m_cacheUpdatable) 
				{
#if (NETCF || SSCLI || NETSTANDARD1_3) // NETSTANDARD1_3 TODO requires platform-specific code
					// On compact framework there's no notion of current Windows user
					m_data.UserName = SystemInfo.NotAvailableText;
#else
					try
					{
						WindowsIdentity windowsIdentity = WindowsIdentity.GetCurrent();
						if (windowsIdentity != null && windowsIdentity.Name != null)
						{
							m_data.UserName = windowsIdentity.Name;
						}
						else
						{
							m_data.UserName = "";
						}
					}
					catch(System.Security.SecurityException)
					{
						// This security exception will occur if the caller does not have 
						// some undefined set of SecurityPermission flags.
						LogLog.Debug(declaringType, "Security exception while trying to get current windows identity. Error Ignored. Empty user name.");

						m_data.UserName = "";
					}
#endif
				}
				return m_data.UserName;
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="LoggingEventData">
      <declaration><![CDATA[public struct LoggingEventData]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="_timeStampUtc">
          <declaration><![CDATA[private DateTime _timeStampUtc;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Domain">
          <declaration><![CDATA[public string Domain;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ExceptionString">
          <declaration><![CDATA[public string ExceptionString;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Identity">
          <declaration><![CDATA[public string Identity;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Level">
          <declaration><![CDATA[public Level Level;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="LocationInfo">
          <declaration><![CDATA[public LocationInfo LocationInfo;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="LoggerName">
          <declaration><![CDATA[public string LoggerName;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Message">
          <declaration><![CDATA[public string Message;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Properties">
          <declaration><![CDATA[public PropertiesDictionary Properties;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ThreadName">
          <declaration><![CDATA[public string ThreadName;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="TimeStamp">
          <deprecation>Prefer using TimeStampUtc, since local time can be ambiguous in time zones with daylight savings time.</deprecation>
          <declaration><![CDATA[public DateTime TimeStamp;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="UserName">
          <declaration><![CDATA[public string UserName;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="TimeStampUtc">
          <declaration><![CDATA[public DateTime TimeStampUtc]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="113" sc="13" el="122" ec="14">log4net\Core\LoggingEvent.cs</location>
            <body hash="7465f2e33ff59ff5056a8ad7ac745fcc"><![CDATA[{
                if (TimeStamp != default(DateTime) && 
                    _timeStampUtc == default(DateTime))
                {
                    // TimeStamp field has been set explicitly but TimeStampUtc hasn't
                    // => use TimeStamp
                    return TimeStamp.ToUniversalTime();
                }
                return _timeStampUtc;
            }]]></body>
          </codeblock>
          <codeblock>
            <location sl="124" sc="13" el="128" ec="14">log4net\Core\LoggingEvent.cs</location>
            <body hash="926356a5c5cd9f3a73bb1bee9b315a01"><![CDATA[{
                _timeStampUtc = value;
                // For backwards compatibility
                TimeStamp = _timeStampUtc.ToLocalTime();
            }]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="LogImpl">
      <declaration><![CDATA[public class LogImpl : LoggerWrapperImpl, ILog, ILoggerWrapper]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public LogImpl(ILogger logger) : base(logger)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="112" sc="36" el="119" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="f45ab623eb7bb5fbb749e395a42d2c31"><![CDATA[base(logger)
		{
			// Listen for changes to the repository
			logger.Repository.ConfigurationChanged += new LoggerRepositoryConfigurationChangedEventHandler(LoggerRepositoryConfigurationChanged);

			// load the current levels
			ReloadLevels(logger.Repository);
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static LogImpl()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1282" sc="3" el="1282" ec="68">log4net\Core\LogImpl.cs</location>
            <body hash="af5ae259f57596dd6369d9d6c58219ab"><![CDATA[private readonly static Type ThisDeclaringType = typeof(LogImpl)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Debug">
          <declaration><![CDATA[public virtual void Debug(object message)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="169" sc="3" el="171" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="fd0098a293ab72c3630939d01a3bce5f"><![CDATA[{
			Logger.Log(ThisDeclaringType, m_levelDebug, message, null);
		}]]></body>
          </codeblock>
        </method>
        <method name="Debug">
          <declaration><![CDATA[public virtual void Debug(object message, Exception exception)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="190" sc="3" el="192" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="73c766c9f594fb7c07147398f8864376"><![CDATA[{
			Logger.Log(ThisDeclaringType, m_levelDebug, message, exception);
		}]]></body>
          </codeblock>
        </method>
        <method name="DebugFormat">
          <declaration><![CDATA[public virtual void DebugFormat(string format, params object[] args)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="217" sc="3" el="222" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="c59d785e9bc2784a2fdd148c5eb15d4b"><![CDATA[{
			if (IsDebugEnabled)
			{
				Logger.Log(ThisDeclaringType, m_levelDebug, new SystemStringFormat(CultureInfo.InvariantCulture, format, args), null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="DebugFormat">
          <declaration><![CDATA[public virtual void DebugFormat(string format, object arg0)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="247" sc="3" el="252" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="8824feb27b676e27ca9e73e3fdd856bc"><![CDATA[{
			if (IsDebugEnabled)
			{
				Logger.Log(ThisDeclaringType, m_levelDebug, new SystemStringFormat(CultureInfo.InvariantCulture, format, new object[] { arg0 }), null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="DebugFormat">
          <declaration><![CDATA[public virtual void DebugFormat(string format, object arg0, object arg1)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="278" sc="3" el="283" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="1845f98779dea8b70435bd3a22b323b0"><![CDATA[{
			if (IsDebugEnabled)
			{
				Logger.Log(ThisDeclaringType, m_levelDebug, new SystemStringFormat(CultureInfo.InvariantCulture, format, new object[] { arg0, arg1 }), null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="DebugFormat">
          <declaration><![CDATA[public virtual void DebugFormat(string format, object arg0, object arg1, object arg2)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="310" sc="3" el="315" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="b3557fcc104d6d6c9c464bbe2e409a27"><![CDATA[{
			if (IsDebugEnabled)
			{
				Logger.Log(ThisDeclaringType, m_levelDebug, new SystemStringFormat(CultureInfo.InvariantCulture, format, new object[] { arg0, arg1, arg2 }), null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="DebugFormat">
          <declaration><![CDATA[public virtual void DebugFormat(IFormatProvider provider, string format, params object[] args)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="336" sc="3" el="341" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="c445247de8580da7b1bdab237ddbb325"><![CDATA[{
			if (IsDebugEnabled)
			{
				Logger.Log(ThisDeclaringType, m_levelDebug, new SystemStringFormat(provider, format, args), null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Error">
          <declaration><![CDATA[public virtual void Error(object message)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="763" sc="3" el="765" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="ea803fa97336881f8b9f62e5d2d24bce"><![CDATA[{
			Logger.Log(ThisDeclaringType, m_levelError, message, null);
		}]]></body>
          </codeblock>
        </method>
        <method name="Error">
          <declaration><![CDATA[public virtual void Error(object message, Exception exception)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="784" sc="3" el="786" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="54c12a1de0d4090c48e3cb99fa1789c9"><![CDATA[{
			Logger.Log(ThisDeclaringType, m_levelError, message, exception);
		}]]></body>
          </codeblock>
        </method>
        <method name="ErrorFormat">
          <declaration><![CDATA[public virtual void ErrorFormat(string format, params object[] args)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="811" sc="3" el="816" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="858681aa2d0360447d069e5575677438"><![CDATA[{
			if (IsErrorEnabled)
			{
				Logger.Log(ThisDeclaringType, m_levelError, new SystemStringFormat(CultureInfo.InvariantCulture, format, args), null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ErrorFormat">
          <declaration><![CDATA[public virtual void ErrorFormat(string format, object arg0)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="841" sc="3" el="846" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="950c77d8d6841029001ce0976fe25f48"><![CDATA[{
			if (IsErrorEnabled)
			{
				Logger.Log(ThisDeclaringType, m_levelError, new SystemStringFormat(CultureInfo.InvariantCulture, format, new object[] { arg0 }), null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ErrorFormat">
          <declaration><![CDATA[public virtual void ErrorFormat(string format, object arg0, object arg1)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="872" sc="3" el="877" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="5b109e1afdd60163358fac17ce096688"><![CDATA[{
			if (IsErrorEnabled)
			{
				Logger.Log(ThisDeclaringType, m_levelError, new SystemStringFormat(CultureInfo.InvariantCulture, format, new object[] { arg0, arg1 }), null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ErrorFormat">
          <declaration><![CDATA[public virtual void ErrorFormat(string format, object arg0, object arg1, object arg2)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="904" sc="3" el="909" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="1ce50698ee2be58059e8c4546c888ff9"><![CDATA[{
			if (IsErrorEnabled)
			{
				Logger.Log(ThisDeclaringType, m_levelError, new SystemStringFormat(CultureInfo.InvariantCulture, format, new object[] { arg0, arg1, arg2 }), null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ErrorFormat">
          <declaration><![CDATA[public virtual void ErrorFormat(IFormatProvider provider, string format, params object[] args)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="930" sc="3" el="935" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="702734643a3472134cefa86b0e910b2b"><![CDATA[{
			if (IsErrorEnabled)
			{
				Logger.Log(ThisDeclaringType, m_levelError, new SystemStringFormat(provider, format, args), null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Fatal">
          <declaration><![CDATA[public virtual void Fatal(object message)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="961" sc="3" el="963" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="c45a73a6ef8ccc8970bf00ec932b640a"><![CDATA[{
			Logger.Log(ThisDeclaringType, m_levelFatal, message, null);
		}]]></body>
          </codeblock>
        </method>
        <method name="Fatal">
          <declaration><![CDATA[public virtual void Fatal(object message, Exception exception)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="982" sc="3" el="984" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="2845e5247b00bfdfcfbba1c6f81dd55f"><![CDATA[{
			Logger.Log(ThisDeclaringType, m_levelFatal, message, exception);
		}]]></body>
          </codeblock>
        </method>
        <method name="FatalFormat">
          <declaration><![CDATA[public virtual void FatalFormat(string format, params object[] args)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1009" sc="3" el="1014" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="b2799850fb29e930bd2561437ec7ba50"><![CDATA[{
			if (IsFatalEnabled)
			{
				Logger.Log(ThisDeclaringType, m_levelFatal, new SystemStringFormat(CultureInfo.InvariantCulture, format, args), null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="FatalFormat">
          <declaration><![CDATA[public virtual void FatalFormat(string format, object arg0)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1039" sc="3" el="1044" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="8cc5d11b6b3e7e61b4693de9f62a40db"><![CDATA[{
			if (IsFatalEnabled)
			{
				Logger.Log(ThisDeclaringType, m_levelFatal, new SystemStringFormat(CultureInfo.InvariantCulture, format, new object[] { arg0 }), null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="FatalFormat">
          <declaration><![CDATA[public virtual void FatalFormat(string format, object arg0, object arg1)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1070" sc="3" el="1075" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="051dbe07518aa352960a9d13d5918014"><![CDATA[{
			if (IsFatalEnabled)
			{
				Logger.Log(ThisDeclaringType, m_levelFatal, new SystemStringFormat(CultureInfo.InvariantCulture, format, new object[] { arg0, arg1 }), null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="FatalFormat">
          <declaration><![CDATA[public virtual void FatalFormat(string format, object arg0, object arg1, object arg2)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1102" sc="3" el="1107" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="89616a5f19316430b5fec49541b609a8"><![CDATA[{
			if (IsFatalEnabled)
			{
				Logger.Log(ThisDeclaringType, m_levelFatal, new SystemStringFormat(CultureInfo.InvariantCulture, format, new object[] { arg0, arg1, arg2 }), null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="FatalFormat">
          <declaration><![CDATA[public virtual void FatalFormat(IFormatProvider provider, string format, params object[] args)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1128" sc="3" el="1133" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="10f72117f731a7795b29c9aa7c11e2c4"><![CDATA[{
			if (IsFatalEnabled)
			{
				Logger.Log(ThisDeclaringType, m_levelFatal, new SystemStringFormat(provider, format, args), null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Info">
          <declaration><![CDATA[public virtual void Info(object message)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="367" sc="3" el="369" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="e8a5c89315361d6857948a88acb1f3f4"><![CDATA[{
			Logger.Log(ThisDeclaringType, m_levelInfo, message, null);
		}]]></body>
          </codeblock>
        </method>
        <method name="Info">
          <declaration><![CDATA[public virtual void Info(object message, Exception exception)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="388" sc="3" el="390" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="6076a00fafd40dbc28c536a43da0ab76"><![CDATA[{
			Logger.Log(ThisDeclaringType, m_levelInfo, message, exception);
		}]]></body>
          </codeblock>
        </method>
        <method name="InfoFormat">
          <declaration><![CDATA[public virtual void InfoFormat(string format, params object[] args)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="415" sc="3" el="420" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="f9090a343b742f554529fd335ec69576"><![CDATA[{
			if (IsInfoEnabled)
			{
				Logger.Log(ThisDeclaringType, m_levelInfo, new SystemStringFormat(CultureInfo.InvariantCulture, format, args), null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="InfoFormat">
          <declaration><![CDATA[public virtual void InfoFormat(string format, object arg0)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="445" sc="3" el="450" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="a8719313edee74d3f858fa60aef990fe"><![CDATA[{
			if (IsInfoEnabled)
			{
				Logger.Log(ThisDeclaringType, m_levelInfo, new SystemStringFormat(CultureInfo.InvariantCulture, format, new object[] { arg0 }), null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="InfoFormat">
          <declaration><![CDATA[public virtual void InfoFormat(string format, object arg0, object arg1)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="476" sc="3" el="481" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="f2fba46c03a09aee892ccbd32058290f"><![CDATA[{
			if (IsInfoEnabled)
			{
				Logger.Log(ThisDeclaringType, m_levelInfo, new SystemStringFormat(CultureInfo.InvariantCulture, format, new object[] { arg0, arg1 }), null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="InfoFormat">
          <declaration><![CDATA[public virtual void InfoFormat(string format, object arg0, object arg1, object arg2)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="508" sc="3" el="513" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="0b8f42716044a5d56b9c0059f894c885"><![CDATA[{
			if (IsInfoEnabled)
			{
				Logger.Log(ThisDeclaringType, m_levelInfo, new SystemStringFormat(CultureInfo.InvariantCulture, format, new object[] { arg0, arg1, arg2 }), null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="InfoFormat">
          <declaration><![CDATA[public virtual void InfoFormat(IFormatProvider provider, string format, params object[] args)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="534" sc="3" el="539" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="4bf515ccbb8f7e01aee582bb4f555f92"><![CDATA[{
			if (IsInfoEnabled)
			{
				Logger.Log(ThisDeclaringType, m_levelInfo, new SystemStringFormat(provider, format, args), null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="LoggerRepositoryConfigurationChanged">
          <declaration><![CDATA[private void LoggerRepositoryConfigurationChanged(object sender, EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1267" sc="3" el="1273" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="8c0ad6947eec7ab17b2de5e33fb5a187"><![CDATA[{
			ILoggerRepository repository = sender as ILoggerRepository;
			if (repository != null)
			{
				ReloadLevels(repository);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ReloadLevels">
          <declaration><![CDATA[protected virtual void ReloadLevels(ILoggerRepository repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="133" sc="3" el="141" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="9db212855d97591e88b1706667b1ccae"><![CDATA[{
			LevelMap levelMap = repository.LevelMap;

			m_levelDebug = levelMap.LookupWithDefault(Level.Debug);
			m_levelInfo = levelMap.LookupWithDefault(Level.Info);
			m_levelWarn = levelMap.LookupWithDefault(Level.Warn);
			m_levelError = levelMap.LookupWithDefault(Level.Error);
			m_levelFatal = levelMap.LookupWithDefault(Level.Fatal);
		}]]></body>
          </codeblock>
        </method>
        <method name="Warn">
          <declaration><![CDATA[public virtual void Warn(object message)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="565" sc="3" el="567" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="e7276464262eb9b4535278212bb3c66f"><![CDATA[{
			Logger.Log(ThisDeclaringType, m_levelWarn, message, null);
		}]]></body>
          </codeblock>
        </method>
        <method name="Warn">
          <declaration><![CDATA[public virtual void Warn(object message, Exception exception)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="586" sc="3" el="588" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="78e1f20ef16bdaa8ea61ebff15412dfc"><![CDATA[{
			Logger.Log(ThisDeclaringType, m_levelWarn, message, exception);
		}]]></body>
          </codeblock>
        </method>
        <method name="WarnFormat">
          <declaration><![CDATA[public virtual void WarnFormat(string format, params object[] args)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="613" sc="3" el="618" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="e2442d677edf2ef173bcbc325a9bed92"><![CDATA[{
			if (IsWarnEnabled)
			{
				Logger.Log(ThisDeclaringType, m_levelWarn, new SystemStringFormat(CultureInfo.InvariantCulture, format, args), null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="WarnFormat">
          <declaration><![CDATA[public virtual void WarnFormat(string format, object arg0)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="643" sc="3" el="648" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="0daf6ef997b357985db72518a0a9498c"><![CDATA[{
			if (IsWarnEnabled)
			{
				Logger.Log(ThisDeclaringType, m_levelWarn, new SystemStringFormat(CultureInfo.InvariantCulture, format, new object[] { arg0 }), null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="WarnFormat">
          <declaration><![CDATA[public virtual void WarnFormat(string format, object arg0, object arg1)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="674" sc="3" el="679" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="d20ec051726747a113d416f4c5ee1eb4"><![CDATA[{
			if (IsWarnEnabled)
			{
				Logger.Log(ThisDeclaringType, m_levelWarn, new SystemStringFormat(CultureInfo.InvariantCulture, format, new object[] { arg0, arg1 }), null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="WarnFormat">
          <declaration><![CDATA[public virtual void WarnFormat(string format, object arg0, object arg1, object arg2)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="706" sc="3" el="711" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="31706a90c1b72019fe5982e83bc2bd0f"><![CDATA[{
			if (IsWarnEnabled)
			{
				Logger.Log(ThisDeclaringType, m_levelWarn, new SystemStringFormat(CultureInfo.InvariantCulture, format, new object[] { arg0, arg1, arg2 }), null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="WarnFormat">
          <declaration><![CDATA[public virtual void WarnFormat(IFormatProvider provider, string format, params object[] args)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="732" sc="3" el="737" ec="4">log4net\Core\LogImpl.cs</location>
            <body hash="d2d6828e7263e7d61b706ec5d266116d"><![CDATA[{
			if (IsWarnEnabled)
			{
				Logger.Log(ThisDeclaringType, m_levelWarn, new SystemStringFormat(provider, format, args), null);
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_levelDebug">
          <declaration><![CDATA[private Level m_levelDebug;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_levelError">
          <declaration><![CDATA[private Level m_levelError;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_levelFatal">
          <declaration><![CDATA[private Level m_levelFatal;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_levelInfo">
          <declaration><![CDATA[private Level m_levelInfo;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_levelWarn">
          <declaration><![CDATA[private Level m_levelWarn;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ThisDeclaringType">
          <declaration><![CDATA[private static readonly Type ThisDeclaringType = typeof(LogImpl);]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="IsDebugEnabled">
          <declaration><![CDATA[public virtual bool IsDebugEnabled]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IsErrorEnabled">
          <declaration><![CDATA[public virtual bool IsErrorEnabled]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IsFatalEnabled">
          <declaration><![CDATA[public virtual bool IsFatalEnabled]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IsInfoEnabled">
          <declaration><![CDATA[public virtual bool IsInfoEnabled]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IsWarnEnabled">
          <declaration><![CDATA[public virtual bool IsWarnEnabled]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="MethodItem">
      <declaration><![CDATA[public class MethodItem]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public MethodItem()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="42" sc="3" el="46" ec="4">log4net\Core\MethodItem.cs</location>
            <body hash="c7e730098e1d48530c5ded017b82eadc"><![CDATA[public MethodItem()
		{
			m_name = NA;
			m_parameters = new string[0];
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public MethodItem(string name) : this()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="53" sc="6" el="56" ec="4">log4net\Core\MethodItem.cs</location>
            <body hash="d3efc84e9dbb6fd58bca07e52eda0124"><![CDATA[this()
		{
			m_name = name;
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public MethodItem(string name, string[] parameters) : this(name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="64" sc="6" el="67" ec="4">log4net\Core\MethodItem.cs</location>
            <body hash="057f762a4567172eb3338081b24fed0d"><![CDATA[this(name)
		{
			m_parameters = parameters;
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public MethodItem(MethodBase methodBase) : this(methodBase.Name, MethodItem.GetMethodParameterNames(methodBase))]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="74" sc="6" el="76" ec="4">log4net\Core\MethodItem.cs</location>
            <body hash="b8564e830ef6c9c8ced2514a9577cec0"><![CDATA[this(methodBase.Name, GetMethodParameterNames(methodBase))
        {
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static MethodItem()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="160" sc="3" el="160" ec="67">log4net\Core\MethodItem.cs</location>
            <body hash="6923d13599dbe85223783605708246e3"><![CDATA[private readonly static Type declaringType = typeof(MethodItem)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="GetMethodParameterNames">
          <declaration><![CDATA[private static string[] GetMethodParameterNames(MethodBase methodBase)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="81" sc="3" el="100" ec="4">log4net\Core\MethodItem.cs</location>
            <body hash="b2a3a0d22f7fb00ccc09ff5dbf07f043"><![CDATA[{
			ArrayList methodParameterNames = new ArrayList();
			try
			{
				System.Reflection.ParameterInfo[] methodBaseGetParameters = methodBase.GetParameters();

				int methodBaseGetParametersCount = methodBaseGetParameters.GetUpperBound(0);

				for (int i = 0; i <= methodBaseGetParametersCount; i++)
				{
					methodParameterNames.Add(methodBaseGetParameters[i].ParameterType + " " + methodBaseGetParameters[i].Name);
				}
			}
			catch (Exception ex)
			{
				LogLog.Error(declaringType, "An exception ocurred while retreiving method parameters.", ex);
			}

			return (string[])methodParameterNames.ToArray(typeof(string));
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(MethodItem);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_name">
          <declaration><![CDATA[private readonly string m_name;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_parameters">
          <declaration><![CDATA[private readonly string[] m_parameters;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="NA">
          <declaration><![CDATA[private const string NA = "?";]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Name">
          <declaration><![CDATA[public string Name]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Parameters">
          <declaration><![CDATA[public string[] Parameters]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="SecurityContext">
      <declaration><![CDATA[public abstract class SecurityContext]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[protected SecurityContext()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Impersonate">
          <declaration><![CDATA[public abstract IDisposable Impersonate(object state);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="SecurityContextProvider">
      <declaration><![CDATA[public class SecurityContextProvider]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[protected SecurityContextProvider()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="101" sc="3" el="103" ec="4">log4net\Core\SecurityContextProvider.cs</location>
            <body hash="60077f90a7f16504860973a9e0474508"><![CDATA[protected SecurityContextProvider()
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static SecurityContextProvider()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="63" sc="3" el="63" ec="92">log4net\Core\SecurityContextProvider.cs</location>
            <body hash="19cbd1d8a69822158a25d2115554bdcb"><![CDATA[private static SecurityContextProvider s_defaultProvider = new SecurityContextProvider()]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CreateSecurityContext">
          <declaration><![CDATA[public virtual SecurityContext CreateSecurityContext(object consumer)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="120" sc="3" el="122" ec="4">log4net\Core\SecurityContextProvider.cs</location>
            <body hash="b21bdcc3ea891197588ecb32bcf018de"><![CDATA[{
			return NullSecurityContext.Instance;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="s_defaultProvider">
          <declaration><![CDATA[private static SecurityContextProvider s_defaultProvider = new SecurityContextProvider();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="DefaultProvider">
          <declaration><![CDATA[public static SecurityContextProvider DefaultProvider]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="StackFrameItem">
      <declaration><![CDATA[public class StackFrameItem]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public StackFrameItem(StackFrame frame)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="43" sc="9" el="72" ec="10">log4net\Core\StackFrameItem.cs</location>
            <body hash="b37f466cab284fc5f82535929d3c9ee5"><![CDATA[public StackFrameItem(StackFrame frame)
        {
            // set default values
            m_lineNumber = NA;
            m_fileName = NA;
            m_method = new MethodItem();
            m_className = NA;

			try
			{
				// get frame values
				m_lineNumber = frame.GetFileLineNumber().ToString(System.Globalization.NumberFormatInfo.InvariantInfo);
				m_fileName = frame.GetFileName();
				// get method values
				MethodBase method = frame.GetMethod();
				if (method != null)
				{
					if(method.DeclaringType != null)
						m_className = method.DeclaringType.FullName;
					m_method = new MethodItem(method);
				}
			}
			catch (Exception ex)
			{
				LogLog.Error(declaringType, "An exception ocurred while retreiving stack frame information.", ex);
			}

            // set full info
            m_fullInfo = m_className + '.' + m_method.Name + '(' + m_fileName + ':' + m_lineNumber + ')';
        }]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static StackFrameItem()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="184" sc="9" el="184" ec="77">log4net\Core\StackFrameItem.cs</location>
            <body hash="a4d9c3e7a62d316741c5e417a4915130"><![CDATA[private readonly static Type declaringType = typeof(StackFrameItem)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(StackFrameItem);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_className">
          <declaration><![CDATA[private readonly string m_className;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_fileName">
          <declaration><![CDATA[private readonly string m_fileName;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_fullInfo">
          <declaration><![CDATA[private readonly string m_fullInfo;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_lineNumber">
          <declaration><![CDATA[private readonly string m_lineNumber;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_method">
          <declaration><![CDATA[private readonly MethodItem m_method;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="NA">
          <declaration><![CDATA[private const string NA = "?";]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="ClassName">
          <declaration><![CDATA[public string ClassName]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="FileName">
          <declaration><![CDATA[public string FileName]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="FullInfo">
          <declaration><![CDATA[public string FullInfo]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="LineNumber">
          <declaration><![CDATA[public string LineNumber]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Method">
          <declaration><![CDATA[public MethodItem Method]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="TimeEvaluator">
      <declaration><![CDATA[public class TimeEvaluator : ITriggeringEventEvaluator]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public TimeEvaluator() : this(0)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="64" sc="15" el="66" ec="10">log4net\Core\TimeEvaluator.cs</location>
            <body hash="0540dde4b1ab90d8773023fce4319e03"><![CDATA[this(DEFAULT_INTERVAL)
        {
        }]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public TimeEvaluator(int interval)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="84" sc="9" el="88" ec="10">log4net\Core\TimeEvaluator.cs</location>
            <body hash="a330cd912920df4b324975b93bb4e198"><![CDATA[public TimeEvaluator(int interval)
        {
            m_interval = interval;
            m_lastTimeUtc = DateTime.UtcNow;
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="IsTriggeringEvent">
          <declaration><![CDATA[public bool IsTriggeringEvent(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="123" sc="9" el="146" ec="10">log4net\Core\TimeEvaluator.cs</location>
            <body hash="183329ed69d00c7a3276cc8f87471b33"><![CDATA[{
            if (loggingEvent == null)
            {
                throw new ArgumentNullException("loggingEvent");
            }

            // disable the evaluator if threshold is zero
            if (m_interval == 0) return false;

            lock (this) // avoid triggering multiple times
            {
                TimeSpan passed = DateTime.UtcNow.Subtract(m_lastTimeUtc);

                if (passed.TotalSeconds > m_interval)
                {
                    m_lastTimeUtc = DateTime.UtcNow;
                    return true;
                }
                else
                {
                    return false;
                }
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="DEFAULT_INTERVAL">
          <declaration><![CDATA[private const int DEFAULT_INTERVAL = 0;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_interval">
          <declaration><![CDATA[private int m_interval;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_lastTimeUtc">
          <declaration><![CDATA[private DateTime m_lastTimeUtc;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Interval">
          <declaration><![CDATA[public int Interval]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="logger);">
      <declaration><![CDATA[public delegate ILoggerWrapper WrapperCreationHandler(ILogger logger);]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public extern WrapperCreationHandler(object @object, IntPtr method);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="BeginInvoke">
          <declaration><![CDATA[public virtual extern IAsyncResult BeginInvoke(ILogger logger, AsyncCallback callback, object @object);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="EndInvoke">
          <declaration><![CDATA[public virtual extern ILoggerWrapper EndInvoke(IAsyncResult result);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Invoke">
          <declaration><![CDATA[public virtual extern ILoggerWrapper Invoke(ILogger logger);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="WrapperMap">
      <declaration><![CDATA[public class WrapperMap]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private readonly Hashtable m_repositories = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="81" sc="3" el="245" ec="63">log4net\Core\WrapperMap.cs</location>
            <body hash="62871fad1e509bb2e1718358de30cf38"><![CDATA[public WrapperMap(WrapperCreationHandler createWrapperHandler) 
		{
			m_createWrapperHandler = createWrapperHandler;

			// Create the delegates for the event callbacks
			m_shutdownHandler = new LoggerRepositoryShutdownEventHandler(ILoggerRepository_Shutdown);
		}

		#endregion Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Gets the wrapper object for the specified logger.
		/// </summary>
		/// <returns>The wrapper object for the specified logger</returns>
		/// <remarks>
		/// <para>
		/// If the logger is null then the corresponding wrapper is null.
		/// </para>
		/// <para>
		/// Looks up the wrapper it it has previously been requested and
		/// returns it. If the wrapper has never been requested before then
		/// the <see cref="CreateNewWrapperObject"/> virtual method is
		/// called.
		/// </para>
		/// </remarks>
		virtual public ILoggerWrapper GetWrapper(ILogger logger)
		{
			// If the logger is null then the corresponding wrapper is null
			if (logger == null)
			{
				return null;
			}

			lock(this)
			{
				// Lookup hierarchy in map.
				Hashtable wrappersMap = (Hashtable)m_repositories[logger.Repository];

				if (wrappersMap == null)
				{
					// Hierarchy does not exist in map.
					// Must register with hierarchy

					wrappersMap = new Hashtable();
					m_repositories[logger.Repository] = wrappersMap;

					// Register for config reset & shutdown on repository
					logger.Repository.ShutdownEvent += m_shutdownHandler;
				}

				// Look for the wrapper object in the map
				ILoggerWrapper wrapperObject = wrappersMap[logger] as ILoggerWrapper;

				if (wrapperObject == null)
				{
					// No wrapper object exists for the specified logger

					// Create a new wrapper wrapping the logger
					wrapperObject = CreateNewWrapperObject(logger);
					
					// Store wrapper logger in map
					wrappersMap[logger] = wrapperObject;
				}

				return wrapperObject;
			}
		}

		#endregion Public Instance Properties

		#region Protected Instance Properties

		/// <summary>
		/// Gets the map of logger repositories.
		/// </summary>
		/// <value>
		/// Map of logger repositories.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets the hashtable that is keyed on <see cref="ILoggerRepository"/>. The
		/// values are hashtables keyed on <see cref="ILogger"/> with the
		/// value being the corresponding <see cref="ILoggerWrapper"/>.
		/// </para>
		/// </remarks>
		protected Hashtable Repositories 
		{
			get { return this.m_repositories; }
		}

		#endregion Protected Instance Properties

		#region Protected Instance Methods

		/// <summary>
		/// Creates the wrapper object for the specified logger.
		/// </summary>
		/// <param name="logger">The logger to wrap in a wrapper.</param>
		/// <returns>The wrapper object for the logger.</returns>
		/// <remarks>
		/// <para>
		/// This implementation uses the <see cref="WrapperCreationHandler"/>
		/// passed to the constructor to create the wrapper. This method
		/// can be overridden in a subclass.
		/// </para>
		/// </remarks>
		virtual protected ILoggerWrapper CreateNewWrapperObject(ILogger logger)
		{
			if (m_createWrapperHandler != null)
			{
				return m_createWrapperHandler(logger);
			}
			return null;
		}

		/// <summary>
		/// Called when a monitored repository shutdown event is received.
		/// </summary>
		/// <param name="repository">The <see cref="ILoggerRepository"/> that is shutting down</param>
		/// <remarks>
		/// <para>
		/// This method is called when a <see cref="ILoggerRepository"/> that this
		/// <see cref="WrapperMap"/> is holding loggers for has signaled its shutdown
		/// event <see cref="ILoggerRepository.ShutdownEvent"/>. The default
		/// behavior of this method is to release the references to the loggers
		/// and their wrappers generated for this repository.
		/// </para>
		/// </remarks>
		virtual protected void RepositoryShutdown(ILoggerRepository repository)
		{
			lock(this)
			{
				// Remove the repository from map
				m_repositories.Remove(repository);

				// Unhook events from the repository
				repository.ShutdownEvent -= m_shutdownHandler;
			}
		}

		/// <summary>
		/// Event handler for repository shutdown event.
		/// </summary>
		/// <param name="sender">The sender of the event.</param>
		/// <param name="e">The event args.</param>
		private void ILoggerRepository_Shutdown(object sender, EventArgs e)
		{
			ILoggerRepository repository = sender as ILoggerRepository;
			if (repository != null)
			{
				// Remove all repository from map
				RepositoryShutdown(repository);
			}
		}

		#endregion Protected Instance Methods

		#region Private Instance Variables

		/// <summary>
		/// Map of logger repositories to hashtables of ILogger to ILoggerWrapper mappings
		/// </summary>
		private readonly Hashtable m_repositories = new Hashtable();]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CreateNewWrapperObject">
          <declaration><![CDATA[protected virtual ILoggerWrapper CreateNewWrapperObject(ILogger logger)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="190" sc="3" el="196" ec="4">log4net\Core\WrapperMap.cs</location>
            <body hash="ee178bfc23ddd2ae1e187b47991b2c3c"><![CDATA[{
			if (m_createWrapperHandler != null)
			{
				return m_createWrapperHandler(logger);
			}
			return null;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetWrapper">
          <declaration><![CDATA[public virtual ILoggerWrapper GetWrapper(ILogger logger)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="109" sc="3" el="149" ec="4">log4net\Core\WrapperMap.cs</location>
            <body hash="17bdc407b593f89888b59387d0a0e0b5"><![CDATA[{
			// If the logger is null then the corresponding wrapper is null
			if (logger == null)
			{
				return null;
			}

			lock(this)
			{
				// Lookup hierarchy in map.
				Hashtable wrappersMap = (Hashtable)m_repositories[logger.Repository];

				if (wrappersMap == null)
				{
					// Hierarchy does not exist in map.
					// Must register with hierarchy

					wrappersMap = new Hashtable();
					m_repositories[logger.Repository] = wrappersMap;

					// Register for config reset & shutdown on repository
					logger.Repository.ShutdownEvent += m_shutdownHandler;
				}

				// Look for the wrapper object in the map
				ILoggerWrapper wrapperObject = wrappersMap[logger] as ILoggerWrapper;

				if (wrapperObject == null)
				{
					// No wrapper object exists for the specified logger

					// Create a new wrapper wrapping the logger
					wrapperObject = CreateNewWrapperObject(logger);
					
					// Store wrapper logger in map
					wrappersMap[logger] = wrapperObject;
				}

				return wrapperObject;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ILoggerRepository_Shutdown">
          <declaration><![CDATA[private void ILoggerRepository_Shutdown(object sender, EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="229" sc="3" el="236" ec="4">log4net\Core\WrapperMap.cs</location>
            <body hash="6f8cd23d699d1b7fc27aec57d19c859c"><![CDATA[{
			ILoggerRepository repository = sender as ILoggerRepository;
			if (repository != null)
			{
				// Remove all repository from map
				RepositoryShutdown(repository);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="RepositoryShutdown">
          <declaration><![CDATA[protected virtual void RepositoryShutdown(ILoggerRepository repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="212" sc="3" el="221" ec="4">log4net\Core\WrapperMap.cs</location>
            <body hash="713b3d0dd1f661d46e02ca9a10d3f227"><![CDATA[{
			lock(this)
			{
				// Remove the repository from map
				m_repositories.Remove(repository);

				// Unhook events from the repository
				repository.ShutdownEvent -= m_shutdownHandler;
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_createWrapperHandler">
          <declaration><![CDATA[private readonly WrapperCreationHandler m_createWrapperHandler;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_repositories">
          <declaration><![CDATA[private readonly Hashtable m_repositories = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_shutdownHandler">
          <declaration><![CDATA[private readonly LoggerRepositoryShutdownEventHandler m_shutdownHandler;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Repositories">
          <declaration><![CDATA[protected Hashtable Repositories]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="log4net.DateFormatter">
    <class name="AbsoluteTimeDateFormatter">
      <declaration><![CDATA[public class AbsoluteTimeDateFormatter : IDateFormatter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public AbsoluteTimeDateFormatter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static AbsoluteTimeDateFormatter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="197" sc="3" el="209" ec="64">log4net\DateFormatter\AbsoluteTimeDateFormatter.cs</location>
            <body hash="578213e8de9d966b88f26f88d593ed5a"><![CDATA[private static long s_lastTimeToTheSecond = 0;

		/// <summary>
		/// Last stored time with precision up to the second, formatted
		/// as a string.
		/// </summary>
		private static StringBuilder s_lastTimeBuf = new StringBuilder();

		/// <summary>
		/// Last stored time with precision up to the second, formatted
		/// as a string.
		/// </summary>
		private static Hashtable s_lastTimeStrings = new Hashtable();]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="FormatDate">
          <declaration><![CDATA[public virtual void FormatDate(DateTime dateToFormat, TextWriter writer)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="103" sc="3" el="169" ec="4">log4net\DateFormatter\AbsoluteTimeDateFormatter.cs</location>
            <body hash="ca584d6a393653c19ebe64cf91b50637"><![CDATA[{
                    lock (s_lastTimeStrings)
		    {
			// Calculate the current time precise only to the second
			long currentTimeToTheSecond = (dateToFormat.Ticks - (dateToFormat.Ticks % TimeSpan.TicksPerSecond));

                        string timeString = null;
			// Compare this time with the stored last time
			// If we are in the same second then append
			// the previously calculated time string
                        if (s_lastTimeToTheSecond != currentTimeToTheSecond)
                        {
                            s_lastTimeStrings.Clear();
                        }
                        else
                        {
                            timeString = (string) s_lastTimeStrings[GetType()];
                        }

                        if (timeString == null)
                        {
				// lock so that only one thread can use the buffer and
				// update the s_lastTimeToTheSecond and s_lastTimeStrings

				// PERF: Try removing this lock and using a new StringBuilder each time
				lock(s_lastTimeBuf)
				{
                                        timeString = (string) s_lastTimeStrings[GetType()];

                                        if (timeString == null)
                                        {
						// We are in a new second.
						s_lastTimeBuf.Length = 0;

						// Calculate the new string for this second
						FormatDateWithoutMillis(dateToFormat, s_lastTimeBuf);

						// Render the string buffer to a string
                                                timeString = s_lastTimeBuf.ToString();

#if NET_1_1
						// Ensure that the above string is written into the variable NOW on all threads.
						// This is only required on multiprocessor machines with weak memeory models
						System.Threading.Thread.MemoryBarrier();
#endif
						// Store the time as a string (we only have to do this once per second)
                                                s_lastTimeStrings[GetType()] = timeString;
						s_lastTimeToTheSecond = currentTimeToTheSecond;
					}
				}
			}
			writer.Write(timeString);
	
			// Append the current millisecond info
			writer.Write(',');
			int millis = dateToFormat.Millisecond;
			if (millis < 100) 
			{
				writer.Write('0');
			}
			if (millis < 10) 
			{
				writer.Write('0');
			}
			writer.Write(millis);
                    }
		}]]></body>
          </codeblock>
        </method>
        <method name="FormatDateWithoutMillis">
          <declaration><![CDATA[protected virtual void FormatDateWithoutMillis(DateTime dateToFormat, StringBuilder buffer)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="55" sc="3" el="78" ec="4">log4net\DateFormatter\AbsoluteTimeDateFormatter.cs</location>
            <body hash="efc25373b1d4c2c392fd67a249b781a3"><![CDATA[{
			int hour = dateToFormat.Hour;
			if (hour < 10) 
			{
				buffer.Append('0');
			}
			buffer.Append(hour);
			buffer.Append(':');

			int mins = dateToFormat.Minute;
			if (mins < 10) 
			{
				buffer.Append('0');
			}
			buffer.Append(mins);
			buffer.Append(':');
	
			int secs = dateToFormat.Second;
			if (secs < 10) 
			{
				buffer.Append('0');
			}
			buffer.Append(secs);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="AbsoluteTimeDateFormat">
          <declaration><![CDATA[public const string AbsoluteTimeDateFormat = "ABSOLUTE";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DateAndTimeDateFormat">
          <declaration><![CDATA[public const string DateAndTimeDateFormat = "DATE";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Iso8601TimeDateFormat">
          <declaration><![CDATA[public const string Iso8601TimeDateFormat = "ISO8601";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="s_lastTimeBuf">
          <declaration><![CDATA[private static StringBuilder s_lastTimeBuf = new StringBuilder();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="s_lastTimeStrings">
          <declaration><![CDATA[private static Hashtable s_lastTimeStrings = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="s_lastTimeToTheSecond">
          <declaration><![CDATA[private static long s_lastTimeToTheSecond = 0L;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="DateTimeDateFormatter">
      <declaration><![CDATA[public class DateTimeDateFormatter : AbsoluteTimeDateFormatter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public DateTimeDateFormatter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="51" sc="3" el="54" ec="4">log4net\DateFormatter\DateTimeDateFormatter.cs</location>
            <body hash="6152339e610ecda59628f9baaa5c47c0"><![CDATA[public DateTimeDateFormatter()
		{
			m_dateTimeFormatInfo = DateTimeFormatInfo.InvariantInfo;
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="FormatDateWithoutMillis">
          <declaration><![CDATA[protected override void FormatDateWithoutMillis(DateTime dateToFormat, StringBuilder buffer)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="76" sc="3" el="93" ec="4">log4net\DateFormatter\DateTimeDateFormatter.cs</location>
            <body hash="d13b58c70f86e4270556789c989e74c9"><![CDATA[{
			int day = dateToFormat.Day;
			if (day < 10) 
			{
				buffer.Append('0');
			}
			buffer.Append(day);
			buffer.Append(' ');		

			buffer.Append(m_dateTimeFormatInfo.GetAbbreviatedMonthName(dateToFormat.Month));
			buffer.Append(' ');	

			buffer.Append(dateToFormat.Year);
			buffer.Append(' ');

			// Append the 'HH:mm:ss'
			base.FormatDateWithoutMillis(dateToFormat, buffer);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_dateTimeFormatInfo">
          <declaration><![CDATA[private readonly DateTimeFormatInfo m_dateTimeFormatInfo;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="IDateFormatter">
      <declaration><![CDATA[public interface IDateFormatter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="FormatDate">
          <declaration><![CDATA[void FormatDate(DateTime dateToFormat, TextWriter writer);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="Iso8601DateFormatter">
      <declaration><![CDATA[public class Iso8601DateFormatter : AbsoluteTimeDateFormatter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public Iso8601DateFormatter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="47" sc="3" el="49" ec="4">log4net\DateFormatter\Iso8601DateFormatter.cs</location>
            <body hash="17249281bcb6cbf456959cbbab809ed0"><![CDATA[public Iso8601DateFormatter()
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="FormatDateWithoutMillis">
          <declaration><![CDATA[protected override void FormatDateWithoutMillis(DateTime dateToFormat, StringBuilder buffer)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="70" sc="3" el="92" ec="4">log4net\DateFormatter\Iso8601DateFormatter.cs</location>
            <body hash="ecfdaa82e1198f4816976ae1437195d8"><![CDATA[{
			buffer.Append(dateToFormat.Year);

			buffer.Append('-');
			int month = dateToFormat.Month;
			if (month < 10)
			{
				buffer.Append('0');
			}
			buffer.Append(month);
			buffer.Append('-');

			int day = dateToFormat.Day;
			if (day < 10) 
			{
				buffer.Append('0');
			}
			buffer.Append(day);
			buffer.Append(' ');

			// Append the 'HH:mm:ss'
			base.FormatDateWithoutMillis(dateToFormat, buffer);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="SimpleDateFormatter">
      <declaration><![CDATA[public class SimpleDateFormatter : IDateFormatter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public SimpleDateFormatter(string format)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="53" sc="3" el="56" ec="4">log4net\DateFormatter\SimpleDateFormatter.cs</location>
            <body hash="31ab8d48560fef0cee7e82b7af037564"><![CDATA[public SimpleDateFormatter(string format)
		{
			m_formatString = format;
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="FormatDate">
          <declaration><![CDATA[public virtual void FormatDate(DateTime dateToFormat, TextWriter writer)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="74" sc="3" el="76" ec="4">log4net\DateFormatter\SimpleDateFormatter.cs</location>
            <body hash="bdf0a49001bcf6410663bb2567c02094"><![CDATA[{
			writer.Write(dateToFormat.ToString(m_formatString, System.Globalization.DateTimeFormatInfo.InvariantInfo));
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_formatString">
          <declaration><![CDATA[private readonly string m_formatString;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="log4net.Filter">
    <class name="DenyAllFilter">
      <declaration><![CDATA[public sealed class DenyAllFilter : FilterSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public DenyAllFilter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="46" sc="3" el="48" ec="4">log4net\Filter\DenyAllFilter.cs</location>
            <body hash="d0c26fe300ff1404123ec06ab013bbdf"><![CDATA[public DenyAllFilter()
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Decide">
          <declaration><![CDATA[public override FilterDecision Decide(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="69" sc="3" el="71" ec="4">log4net\Filter\DenyAllFilter.cs</location>
            <body hash="24b220c3163db42fd9d3b932cc502a00"><![CDATA[{
			return FilterDecision.Deny;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="FilterDecision">
      <declaration><![CDATA[public enum FilterDecision]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="Accept">
          <declaration><![CDATA[public const FilterDecision Accept = 1;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Deny">
          <declaration><![CDATA[public const FilterDecision Deny = -1;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Neutral">
          <declaration><![CDATA[public const FilterDecision Neutral = 0;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="FilterSkeleton">
      <declaration><![CDATA[public abstract class FilterSkeleton : IFilter, IOptionHandler]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[protected FilterSkeleton()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public virtual void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="108" sc="3" el="109" ec="4">log4net\Filter\FilterSkeleton.cs</location>
            <body hash="d2c65ffc45d1c7103cabbde916faf7e7"><![CDATA[{
		}]]></body>
          </codeblock>
        </method>
        <method name="Decide">
          <declaration><![CDATA[public abstract FilterDecision Decide(LoggingEvent loggingEvent);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_next">
          <declaration><![CDATA[private IFilter m_next;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Next">
          <declaration><![CDATA[public IFilter Next]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="IFilter">
      <declaration><![CDATA[public interface IFilter : IOptionHandler]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="Decide">
          <declaration><![CDATA[FilterDecision Decide(LoggingEvent loggingEvent);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Next">
          <declaration><![CDATA[IFilter Next]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="LevelMatchFilter">
      <declaration><![CDATA[public class LevelMatchFilter : FilterSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private bool m_acceptOnMatch = true;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="52" sc="3" el="68" ec="4">log4net\Filter\LevelMatchFilter.cs</location>
            <body hash="b497498301333f00a52e964788c29811"><![CDATA[private bool m_acceptOnMatch = true;

		/// <summary>
		/// the <see cref="Level"/> to match against
		/// </summary>
		private Level m_levelToMatch;

		#endregion

		#region Constructors

		/// <summary>
		/// Default constructor
		/// </summary>
		public LevelMatchFilter()
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Decide">
          <declaration><![CDATA[public override FilterDecision Decide(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="126" sc="3" el="138" ec="4">log4net\Filter\LevelMatchFilter.cs</location>
            <body hash="3fe970b55b528fc23299c9f953a8df1a"><![CDATA[{
			if (loggingEvent == null)
			{
				throw new ArgumentNullException("loggingEvent");
			}

			if (m_levelToMatch != null && m_levelToMatch == loggingEvent.Level) 
			{
				// Found match
				return m_acceptOnMatch ? FilterDecision.Accept : FilterDecision.Deny;
			}
			return FilterDecision.Neutral;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_acceptOnMatch">
          <declaration><![CDATA[private bool m_acceptOnMatch = true;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_levelToMatch">
          <declaration><![CDATA[private Level m_levelToMatch;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="AcceptOnMatch">
          <declaration><![CDATA[public bool AcceptOnMatch]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="LevelToMatch">
          <declaration><![CDATA[public Level LevelToMatch]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="LevelRangeFilter">
      <declaration><![CDATA[public class LevelRangeFilter : FilterSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private bool m_acceptOnMatch = true;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="51" sc="3" el="72" ec="4">log4net\Filter\LevelRangeFilter.cs</location>
            <body hash="00836e63415f4c1d735b9b1d7797a101"><![CDATA[private bool m_acceptOnMatch = true;

		/// <summary>
		/// the minimum <see cref="Level"/> value to match
		/// </summary>
		private Level m_levelMin;

		/// <summary>
		/// the maximum <see cref="Level"/> value to match
		/// </summary>
		private Level m_levelMax;

		#endregion

		#region Constructors

		/// <summary>
		/// Default constructor
		/// </summary>
		public LevelRangeFilter()
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Decide">
          <declaration><![CDATA[public override FilterDecision Decide(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="146" sc="3" el="181" ec="4">log4net\Filter\LevelRangeFilter.cs</location>
            <body hash="39124ebfa13ca280584710a7d7f9af43"><![CDATA[{
			if (loggingEvent == null)
			{
				throw new ArgumentNullException("loggingEvent");
			}

			if (m_levelMin != null) 
			{
				if (loggingEvent.Level < m_levelMin) 
				{
					// level of event is less than minimum
					return FilterDecision.Deny;
				}
			}

			if (m_levelMax != null) 
			{
				if (loggingEvent.Level > m_levelMax) 
				{
					// level of event is greater than maximum
					return FilterDecision.Deny;
				}
			}

			if (m_acceptOnMatch) 
			{
				// this filter set up to bypass later filters and always return
				// accept if level in range
				return FilterDecision.Accept;
			}
			else 
			{
				// event is ok for this filter; allow later filters to have a look..
				return FilterDecision.Neutral;
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_acceptOnMatch">
          <declaration><![CDATA[private bool m_acceptOnMatch = true;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_levelMax">
          <declaration><![CDATA[private Level m_levelMax;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_levelMin">
          <declaration><![CDATA[private Level m_levelMin;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="AcceptOnMatch">
          <declaration><![CDATA[public bool AcceptOnMatch]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="LevelMax">
          <declaration><![CDATA[public Level LevelMax]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="LevelMin">
          <declaration><![CDATA[public Level LevelMin]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="LoggerMatchFilter">
      <declaration><![CDATA[public class LoggerMatchFilter : FilterSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private bool m_acceptOnMatch = true;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="50" sc="3" el="66" ec="4">log4net\Filter\LoggerMatchFilter.cs</location>
            <body hash="d5d9485f7c4e614383cb1b6d9e1d527d"><![CDATA[private bool m_acceptOnMatch = true;

		/// <summary>
		/// The logger name string to substring match against the event
		/// </summary>
		private string m_loggerToMatch;

		#endregion

		#region Constructors

		/// <summary>
		/// Default constructor
		/// </summary>
		public LoggerMatchFilter()
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Decide">
          <declaration><![CDATA[public override FilterDecision Decide(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="133" sc="3" el="156" ec="4">log4net\Filter\LoggerMatchFilter.cs</location>
            <body hash="3b2f80c7ca0dfc2d3e5b601ef251e413"><![CDATA[{
			if (loggingEvent == null)
			{
				throw new ArgumentNullException("loggingEvent");
			}

			// Check if we have been setup to filter
			if ((m_loggerToMatch != null && m_loggerToMatch.Length != 0) && 
				loggingEvent.LoggerName.StartsWith(m_loggerToMatch))
			{
				// we've got a match
				if (m_acceptOnMatch) 
				{
					return FilterDecision.Accept;
				} 
				return FilterDecision.Deny;
			}
			else
			{
				// We cannot filter so allow the filter chain
				// to continue processing
				return FilterDecision.Neutral;
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_acceptOnMatch">
          <declaration><![CDATA[private bool m_acceptOnMatch = true;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_loggerToMatch">
          <declaration><![CDATA[private string m_loggerToMatch;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="AcceptOnMatch">
          <declaration><![CDATA[public bool AcceptOnMatch]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="LoggerToMatch">
          <declaration><![CDATA[public string LoggerToMatch]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="MdcFilter">
      <declaration><![CDATA[public class MdcFilter : PropertyFilter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public MdcFilter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="NdcFilter">
      <declaration><![CDATA[public class NdcFilter : PropertyFilter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public NdcFilter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="55" sc="3" el="58" ec="4">log4net\Filter\NdcFilter.cs</location>
            <body hash="695185eab189d691db49e7019dd98d6a"><![CDATA[public NdcFilter()
		{
			base.Key = "NDC";
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="PropertyFilter">
      <declaration><![CDATA[public class PropertyFilter : StringMatchFilter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public PropertyFilter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="55" sc="3" el="57" ec="4">log4net\Filter\PropertyFilter.cs</location>
            <body hash="571d77fe1acf62f9adae8be4560e3773"><![CDATA[public PropertyFilter()
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Decide">
          <declaration><![CDATA[public override FilterDecision Decide(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="98" sc="3" el="161" ec="4">log4net\Filter\PropertyFilter.cs</location>
            <body hash="15790f418d7de3605087850f74fab7a4"><![CDATA[{
			if (loggingEvent == null)
			{
				throw new ArgumentNullException("loggingEvent");
			}

			// Check if we have a key to lookup the event property value with
			if (m_key == null)
			{
				// We cannot filter so allow the filter chain
				// to continue processing
				return FilterDecision.Neutral;
			}

			// Lookup the string to match in from the properties using 
			// the key specified.
			object msgObj = loggingEvent.LookupProperty(m_key);

			// Use an ObjectRenderer to convert the property value to a string
			string msg = loggingEvent.Repository.RendererMap.FindAndRender(msgObj);

			// Check if we have been setup to filter
			if (msg == null || (m_stringToMatch == null && m_regexToMatch == null))
			{
				// We cannot filter so allow the filter chain
				// to continue processing
				return FilterDecision.Neutral;
			}
    
			// Firstly check if we are matching using a regex
			if (m_regexToMatch != null)
			{
				// Check the regex
				if (m_regexToMatch.Match(msg).Success == false)
				{
					// No match, continue processing
					return FilterDecision.Neutral;
				} 

				// we've got a match
				if (m_acceptOnMatch) 
				{
					return FilterDecision.Accept;
				} 
				return FilterDecision.Deny;
			}
			else if (m_stringToMatch != null)
			{
				// Check substring match
				if (msg.IndexOf(m_stringToMatch) == -1) 
				{
					// No match, continue processing
					return FilterDecision.Neutral;
				} 

				// we've got a match
				if (m_acceptOnMatch) 
				{
					return FilterDecision.Accept;
				} 
				return FilterDecision.Deny;
			}
			return FilterDecision.Neutral;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_key">
          <declaration><![CDATA[private string m_key;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Key">
          <declaration><![CDATA[public string Key]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="StringMatchFilter">
      <declaration><![CDATA[public class StringMatchFilter : FilterSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[protected bool m_acceptOnMatch = true;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="46" sc="3" el="72" ec="4">log4net\Filter\StringMatchFilter.cs</location>
            <body hash="d00f1dbc9640ffdcd4eccf56b3ef6325"><![CDATA[protected bool m_acceptOnMatch = true;

		/// <summary>
		/// The string to substring match against the message
		/// </summary>
		protected string m_stringToMatch;

		/// <summary>
		/// A string regex to match
		/// </summary>
		protected string m_stringRegexToMatch;

		/// <summary>
		/// A regex object to match (generated from m_stringRegexToMatch)
		/// </summary>
		protected Regex m_regexToMatch;

		#endregion

		#region Constructors

		/// <summary>
		/// Default constructor
		/// </summary>
		public StringMatchFilter()
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public override void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="95" sc="3" el="104" ec="4">log4net\Filter\StringMatchFilter.cs</location>
            <body hash="57081e51c2c5bc6ad218b7253a7dcaa1"><![CDATA[{
			if (m_stringRegexToMatch != null)
			{
#if NETSTANDARD1_3
				m_regexToMatch = new Regex(m_stringRegexToMatch);
#else
				m_regexToMatch = new Regex(m_stringRegexToMatch, RegexOptions.Compiled);
#endif
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Decide">
          <declaration><![CDATA[public override FilterDecision Decide(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="190" sc="3" el="241" ec="4">log4net\Filter\StringMatchFilter.cs</location>
            <body hash="4cba69ce61e4fb5348033097632c1178"><![CDATA[{
			if (loggingEvent == null)
			{
				throw new ArgumentNullException("loggingEvent");
			}

			string msg = loggingEvent.RenderedMessage;

			// Check if we have been setup to filter
			if (msg == null || (m_stringToMatch == null && m_regexToMatch == null))
			{
				// We cannot filter so allow the filter chain
				// to continue processing
				return FilterDecision.Neutral;
			}
    
			// Firstly check if we are matching using a regex
			if (m_regexToMatch != null)
			{
				// Check the regex
				if (m_regexToMatch.Match(msg).Success == false)
				{
					// No match, continue processing
					return FilterDecision.Neutral;
				} 

				// we've got a match
				if (m_acceptOnMatch) 
				{
					return FilterDecision.Accept;
				} 
				return FilterDecision.Deny;
			}
			else if (m_stringToMatch != null)
			{
				// Check substring match
				if (msg.IndexOf(m_stringToMatch) == -1) 
				{
					// No match, continue processing
					return FilterDecision.Neutral;
				} 

				// we've got a match
				if (m_acceptOnMatch) 
				{
					return FilterDecision.Accept;
				} 
				return FilterDecision.Deny;
			}
			return FilterDecision.Neutral;

		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_acceptOnMatch">
          <declaration><![CDATA[protected bool m_acceptOnMatch = true;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_regexToMatch">
          <declaration><![CDATA[protected Regex m_regexToMatch;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_stringRegexToMatch">
          <declaration><![CDATA[protected string m_stringRegexToMatch;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_stringToMatch">
          <declaration><![CDATA[protected string m_stringToMatch;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="AcceptOnMatch">
          <declaration><![CDATA[public bool AcceptOnMatch]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="RegexToMatch">
          <declaration><![CDATA[public string RegexToMatch]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="StringToMatch">
          <declaration><![CDATA[public string StringToMatch]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="log4net.Layout">
    <class name="DynamicPatternLayout">
      <declaration><![CDATA[public class DynamicPatternLayout : PatternLayout]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private PatternString m_headerPatternString = new PatternString("");]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="59" sc="3" el="79" ec="4">log4net\Layout\DynamicPatternLayout.cs</location>
            <body hash="37783580c97bb89603225e8d1ffeb6c0"><![CDATA[private PatternString m_headerPatternString = new PatternString("");

		/// <summary>
		/// The footer PatternString
		/// </summary>
		private PatternString m_footerPatternString  = new PatternString("");
		#endregion

		#region Constructors
		/// <summary>
		/// Constructs a DynamicPatternLayout using the DefaultConversionPattern
		/// </summary>
		/// <remarks>
		/// <para>
		/// The default pattern just produces the application supplied message.
		/// </para>
		/// </remarks>
		public DynamicPatternLayout()
			: base()
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private PatternString m_headerPatternString = new PatternString("");]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="59" sc="3" el="90" ec="4">log4net\Layout\DynamicPatternLayout.cs</location>
            <body hash="ba811ab58a7ccb6db9ad29c12ad7ece4"><![CDATA[private PatternString m_headerPatternString = new PatternString("");

		/// <summary>
		/// The footer PatternString
		/// </summary>
		private PatternString m_footerPatternString  = new PatternString("");
		#endregion

		#region Constructors
		/// <summary>
		/// Constructs a DynamicPatternLayout using the DefaultConversionPattern
		/// </summary>
		/// <remarks>
		/// <para>
		/// The default pattern just produces the application supplied message.
		/// </para>
		/// </remarks>
		public DynamicPatternLayout()
			: base()
		{
		}

		/// <summary>
		/// Constructs a DynamicPatternLayout using the supplied conversion pattern
		/// </summary>
		/// <param name="pattern">the pattern to use</param>
		/// <remarks>
		/// </remarks>
		public DynamicPatternLayout (string pattern) 
			: base(pattern)
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="m_footerPatternString">
          <declaration><![CDATA[private PatternString m_footerPatternString = new PatternString("");]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_headerPatternString">
          <declaration><![CDATA[private PatternString m_headerPatternString = new PatternString("");]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Footer">
          <declaration><![CDATA[public override string Footer]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="132" sc="4" el="134" ec="5">log4net\Layout\DynamicPatternLayout.cs</location>
            <body hash="34ec64a4006d714bd21e3b0cc830459b"><![CDATA[{
				return m_footerPatternString.Format();
			}]]></body>
          </codeblock>
          <codeblock>
            <location sl="136" sc="4" el="139" ec="5">log4net\Layout\DynamicPatternLayout.cs</location>
            <body hash="ceb6c39b3ece95880438d06a04ab5140"><![CDATA[{
				base.Footer = value;
				m_footerPatternString = new PatternString(value);
			}]]></body>
          </codeblock>
        </property>
        <property name="Header">
          <declaration><![CDATA[public override string Header]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="108" sc="4" el="110" ec="5">log4net\Layout\DynamicPatternLayout.cs</location>
            <body hash="fe4a8c9d1111f5fb13fe03c8e07dd29c"><![CDATA[{
				return m_headerPatternString.Format();
			}]]></body>
          </codeblock>
          <codeblock>
            <location sl="112" sc="4" el="115" ec="5">log4net\Layout\DynamicPatternLayout.cs</location>
            <body hash="dfe282a0cd9520a006c170855eadd7a7"><![CDATA[{
				base.Header = value;
				m_headerPatternString = new PatternString(value);
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ExceptionLayout">
      <declaration><![CDATA[public class ExceptionLayout : LayoutSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ExceptionLayout()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="55" sc="3" el="58" ec="4">log4net\Layout\ExceptionLayout.cs</location>
            <body hash="3d79d391cb6f818eb8009ccf0f593df4"><![CDATA[public ExceptionLayout()
		{
			this.IgnoresException = false;
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public override void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="77" sc="3" el="79" ec="4">log4net\Layout\ExceptionLayout.cs</location>
            <body hash="1f0663468aa8a3b69b307028d8b86ee3"><![CDATA[{
			// nothing to do.
		}]]></body>
          </codeblock>
        </method>
        <method name="Format">
          <declaration><![CDATA[public override void Format(TextWriter writer, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="97" sc="3" el="104" ec="4">log4net\Layout\ExceptionLayout.cs</location>
            <body hash="494f1bef25a872ba41e0511678d773f0"><![CDATA[{
			if (loggingEvent == null)
			{
				throw new ArgumentNullException("loggingEvent");
			}

			writer.Write(loggingEvent.GetExceptionString());
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="ILayout">
      <declaration><![CDATA[public interface ILayout]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="Format">
          <declaration><![CDATA[void Format(TextWriter writer, LoggingEvent loggingEvent);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="ContentType">
          <declaration><![CDATA[string ContentType]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Footer">
          <declaration><![CDATA[string Footer]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Header">
          <declaration><![CDATA[string Header]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IgnoresException">
          <declaration><![CDATA[bool IgnoresException]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="IRawLayout">
      <declaration><![CDATA[public interface IRawLayout]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="Format">
          <declaration><![CDATA[object Format(LoggingEvent loggingEvent);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="Layout2RawLayoutAdapter">
      <declaration><![CDATA[public class Layout2RawLayoutAdapter : IRawLayout]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public Layout2RawLayoutAdapter(ILayout layout)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="61" sc="3" el="64" ec="4">log4net\Layout\Layout2RawLayoutAdapter.cs</location>
            <body hash="c87b9b8e6a45fdc0e1d7ad5641699714"><![CDATA[public Layout2RawLayoutAdapter(ILayout layout)
		{
			m_layout = layout;
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Format">
          <declaration><![CDATA[public virtual object Format(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="85" sc="3" el="89" ec="4">log4net\Layout\Layout2RawLayoutAdapter.cs</location>
            <body hash="58d2e492465acf4283a84ebafc96a8cb"><![CDATA[{
			StringWriter writer = new StringWriter(System.Globalization.CultureInfo.InvariantCulture);
			m_layout.Format(writer, loggingEvent);
			return writer.ToString();
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_layout">
          <declaration><![CDATA[private ILayout m_layout;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="LayoutSkeleton">
      <declaration><![CDATA[public abstract class LayoutSkeleton : ILayout, IOptionHandler]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private string m_header = null;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="63" sc="3" el="99" ec="4">log4net\Layout\LayoutSkeleton.cs</location>
            <body hash="c76617ad726b22f4ceb2e250f24bbc22"><![CDATA[private string m_header = null;

		/// <summary>
		/// The footer text
		/// </summary>
		/// <remarks>
		/// <para>
		/// See <see cref="Footer"/> for more information.
		/// </para>
		/// </remarks>
		private string m_footer = null;

		/// <summary>
		/// Flag indicating if this layout handles exceptions
		/// </summary>
		/// <remarks>
		/// <para>
		/// <c>false</c> if this layout handles exceptions
		/// </para>
		/// </remarks>
		private bool m_ignoresException = true;

		#endregion

		#region Constructors

		/// <summary>
		/// Empty default constructor
		/// </summary>
		/// <remarks>
		/// <para>
		/// Empty default constructor
		/// </para>
		/// </remarks>
		protected LayoutSkeleton()
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public abstract void ActivateOptions();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Format">
          <declaration><![CDATA[public abstract void Format(TextWriter writer, LoggingEvent loggingEvent);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Format">
          <declaration><![CDATA[public string Format(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="151" sc="9" el="155" ec="10">log4net\Layout\LayoutSkeleton.cs</location>
            <body hash="8aa61a3217f1778d8bd39096603daf2d"><![CDATA[{
            StringWriter writer = new StringWriter(System.Globalization.CultureInfo.InvariantCulture);
            Format(writer, loggingEvent);
            return writer.ToString();
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_footer">
          <declaration><![CDATA[private string m_footer = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_header">
          <declaration><![CDATA[private string m_header = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_ignoresException">
          <declaration><![CDATA[private bool m_ignoresException = true;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="ContentType">
          <declaration><![CDATA[public virtual string ContentType]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Footer">
          <declaration><![CDATA[public virtual string Footer]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Header">
          <declaration><![CDATA[public virtual string Header]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IgnoresException">
          <declaration><![CDATA[public virtual bool IgnoresException]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="PatternLayout">
      <declaration><![CDATA[public class PatternLayout : LayoutSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".cctor">
          <declaration><![CDATA[static PatternLayout()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="858" sc="3" el="939" ec="4">log4net\Layout\PatternLayout.cs</location>
            <body hash="566655453be01fbf5ba30c54619acba3"><![CDATA[{
			s_globalRulesRegistry = new Hashtable(45);

			s_globalRulesRegistry.Add("literal", typeof(LiteralPatternConverter));
			s_globalRulesRegistry.Add("newline", typeof(NewLinePatternConverter));
			s_globalRulesRegistry.Add("n", typeof(NewLinePatternConverter));

// .NET Compact Framework 1.0 has no support for ASP.NET
// SSCLI 1.0 has no support for ASP.NET
#if !NETCF && !SSCLI && !CLIENT_PROFILE && !NETSTANDARD1_3
			s_globalRulesRegistry.Add("aspnet-cache", typeof(AspNetCachePatternConverter));
			s_globalRulesRegistry.Add("aspnet-context", typeof(AspNetContextPatternConverter));
			s_globalRulesRegistry.Add("aspnet-request", typeof(AspNetRequestPatternConverter));
			s_globalRulesRegistry.Add("aspnet-session", typeof(AspNetSessionPatternConverter));
#endif

			s_globalRulesRegistry.Add("c", typeof(LoggerPatternConverter));
			s_globalRulesRegistry.Add("logger", typeof(LoggerPatternConverter));

			s_globalRulesRegistry.Add("C", typeof(TypeNamePatternConverter));
			s_globalRulesRegistry.Add("class", typeof(TypeNamePatternConverter));
			s_globalRulesRegistry.Add("type", typeof(TypeNamePatternConverter));

			s_globalRulesRegistry.Add("d", typeof(DatePatternConverter));
			s_globalRulesRegistry.Add("date", typeof(DatePatternConverter));

			s_globalRulesRegistry.Add("exception", typeof(ExceptionPatternConverter));

			s_globalRulesRegistry.Add("F", typeof(FileLocationPatternConverter));
			s_globalRulesRegistry.Add("file", typeof(FileLocationPatternConverter));

			s_globalRulesRegistry.Add("l", typeof(FullLocationPatternConverter));
			s_globalRulesRegistry.Add("location", typeof(FullLocationPatternConverter));

			s_globalRulesRegistry.Add("L", typeof(LineLocationPatternConverter));
			s_globalRulesRegistry.Add("line", typeof(LineLocationPatternConverter));

			s_globalRulesRegistry.Add("m", typeof(MessagePatternConverter));
			s_globalRulesRegistry.Add("message", typeof(MessagePatternConverter));

			s_globalRulesRegistry.Add("M", typeof(MethodLocationPatternConverter));
			s_globalRulesRegistry.Add("method", typeof(MethodLocationPatternConverter));

			s_globalRulesRegistry.Add("p", typeof(LevelPatternConverter));
			s_globalRulesRegistry.Add("level", typeof(LevelPatternConverter));

			s_globalRulesRegistry.Add("P", typeof(PropertyPatternConverter));
			s_globalRulesRegistry.Add("property", typeof(PropertyPatternConverter));
			s_globalRulesRegistry.Add("properties", typeof(PropertyPatternConverter));

			s_globalRulesRegistry.Add("r", typeof(RelativeTimePatternConverter));
			s_globalRulesRegistry.Add("timestamp", typeof(RelativeTimePatternConverter));
			
#if !(NETCF || NETSTANDARD1_3)
			s_globalRulesRegistry.Add("stacktrace", typeof(StackTracePatternConverter));
            s_globalRulesRegistry.Add("stacktracedetail", typeof(StackTraceDetailPatternConverter));
#endif

			s_globalRulesRegistry.Add("t", typeof(ThreadPatternConverter));
			s_globalRulesRegistry.Add("thread", typeof(ThreadPatternConverter));

			// For backwards compatibility the NDC patterns
			s_globalRulesRegistry.Add("x", typeof(NdcPatternConverter));
			s_globalRulesRegistry.Add("ndc", typeof(NdcPatternConverter));

			// For backwards compatibility the MDC patterns just do a property lookup
			s_globalRulesRegistry.Add("X", typeof(PropertyPatternConverter));
			s_globalRulesRegistry.Add("mdc", typeof(PropertyPatternConverter));

			s_globalRulesRegistry.Add("a", typeof(AppDomainPatternConverter));
			s_globalRulesRegistry.Add("appdomain", typeof(AppDomainPatternConverter));

			s_globalRulesRegistry.Add("u", typeof(IdentityPatternConverter));
			s_globalRulesRegistry.Add("identity", typeof(IdentityPatternConverter));

			s_globalRulesRegistry.Add("utcdate", typeof(UtcDatePatternConverter));
			s_globalRulesRegistry.Add("utcDate", typeof(UtcDatePatternConverter));
			s_globalRulesRegistry.Add("UtcDate", typeof(UtcDatePatternConverter));

			s_globalRulesRegistry.Add("w", typeof(UserNamePatternConverter));
			s_globalRulesRegistry.Add("username", typeof(UserNamePatternConverter));
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public PatternLayout() : this("%message%newline")]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="963" sc="28" el="965" ec="4">log4net\Layout\PatternLayout.cs</location>
            <body hash="87ed63aaf1d53ec606f0a353b4d456f9"><![CDATA[this(DefaultConversionPattern)
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private Hashtable m_instanceRulesRegistry = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="843" sc="3" el="994" ec="4">log4net\Layout\PatternLayout.cs</location>
            <body hash="4b3514a0d7f786c7b2989f552f18f070"><![CDATA[private Hashtable m_instanceRulesRegistry = new Hashtable();

		#endregion

		#region Static Constructor

		/// <summary>
		/// Initialize the global registry
		/// </summary>
		/// <remarks>
		/// <para>
		/// Defines the builtin global rules.
		/// </para>
		/// </remarks>
		static PatternLayout()
		{
			s_globalRulesRegistry = new Hashtable(45);

			s_globalRulesRegistry.Add("literal", typeof(LiteralPatternConverter));
			s_globalRulesRegistry.Add("newline", typeof(NewLinePatternConverter));
			s_globalRulesRegistry.Add("n", typeof(NewLinePatternConverter));

// .NET Compact Framework 1.0 has no support for ASP.NET
// SSCLI 1.0 has no support for ASP.NET
#if !NETCF && !SSCLI && !CLIENT_PROFILE && !NETSTANDARD1_3
			s_globalRulesRegistry.Add("aspnet-cache", typeof(AspNetCachePatternConverter));
			s_globalRulesRegistry.Add("aspnet-context", typeof(AspNetContextPatternConverter));
			s_globalRulesRegistry.Add("aspnet-request", typeof(AspNetRequestPatternConverter));
			s_globalRulesRegistry.Add("aspnet-session", typeof(AspNetSessionPatternConverter));
#endif

			s_globalRulesRegistry.Add("c", typeof(LoggerPatternConverter));
			s_globalRulesRegistry.Add("logger", typeof(LoggerPatternConverter));

			s_globalRulesRegistry.Add("C", typeof(TypeNamePatternConverter));
			s_globalRulesRegistry.Add("class", typeof(TypeNamePatternConverter));
			s_globalRulesRegistry.Add("type", typeof(TypeNamePatternConverter));

			s_globalRulesRegistry.Add("d", typeof(DatePatternConverter));
			s_globalRulesRegistry.Add("date", typeof(DatePatternConverter));

			s_globalRulesRegistry.Add("exception", typeof(ExceptionPatternConverter));

			s_globalRulesRegistry.Add("F", typeof(FileLocationPatternConverter));
			s_globalRulesRegistry.Add("file", typeof(FileLocationPatternConverter));

			s_globalRulesRegistry.Add("l", typeof(FullLocationPatternConverter));
			s_globalRulesRegistry.Add("location", typeof(FullLocationPatternConverter));

			s_globalRulesRegistry.Add("L", typeof(LineLocationPatternConverter));
			s_globalRulesRegistry.Add("line", typeof(LineLocationPatternConverter));

			s_globalRulesRegistry.Add("m", typeof(MessagePatternConverter));
			s_globalRulesRegistry.Add("message", typeof(MessagePatternConverter));

			s_globalRulesRegistry.Add("M", typeof(MethodLocationPatternConverter));
			s_globalRulesRegistry.Add("method", typeof(MethodLocationPatternConverter));

			s_globalRulesRegistry.Add("p", typeof(LevelPatternConverter));
			s_globalRulesRegistry.Add("level", typeof(LevelPatternConverter));

			s_globalRulesRegistry.Add("P", typeof(PropertyPatternConverter));
			s_globalRulesRegistry.Add("property", typeof(PropertyPatternConverter));
			s_globalRulesRegistry.Add("properties", typeof(PropertyPatternConverter));

			s_globalRulesRegistry.Add("r", typeof(RelativeTimePatternConverter));
			s_globalRulesRegistry.Add("timestamp", typeof(RelativeTimePatternConverter));
			
#if !(NETCF || NETSTANDARD1_3)
			s_globalRulesRegistry.Add("stacktrace", typeof(StackTracePatternConverter));
            s_globalRulesRegistry.Add("stacktracedetail", typeof(StackTraceDetailPatternConverter));
#endif

			s_globalRulesRegistry.Add("t", typeof(ThreadPatternConverter));
			s_globalRulesRegistry.Add("thread", typeof(ThreadPatternConverter));

			// For backwards compatibility the NDC patterns
			s_globalRulesRegistry.Add("x", typeof(NdcPatternConverter));
			s_globalRulesRegistry.Add("ndc", typeof(NdcPatternConverter));

			// For backwards compatibility the MDC patterns just do a property lookup
			s_globalRulesRegistry.Add("X", typeof(PropertyPatternConverter));
			s_globalRulesRegistry.Add("mdc", typeof(PropertyPatternConverter));

			s_globalRulesRegistry.Add("a", typeof(AppDomainPatternConverter));
			s_globalRulesRegistry.Add("appdomain", typeof(AppDomainPatternConverter));

			s_globalRulesRegistry.Add("u", typeof(IdentityPatternConverter));
			s_globalRulesRegistry.Add("identity", typeof(IdentityPatternConverter));

			s_globalRulesRegistry.Add("utcdate", typeof(UtcDatePatternConverter));
			s_globalRulesRegistry.Add("utcDate", typeof(UtcDatePatternConverter));
			s_globalRulesRegistry.Add("UtcDate", typeof(UtcDatePatternConverter));

			s_globalRulesRegistry.Add("w", typeof(UserNamePatternConverter));
			s_globalRulesRegistry.Add("username", typeof(UserNamePatternConverter));
		}

		#endregion Static Constructor

		#region Constructors

		/// <summary>
		/// Constructs a PatternLayout using the DefaultConversionPattern
		/// </summary>
		/// <remarks>
		/// <para>
		/// The default pattern just produces the application supplied message.
		/// </para>
		/// <para>
		/// Note to Inheritors: This constructor calls the virtual method
		/// <see cref="CreatePatternParser"/>. If you override this method be
		/// aware that it will be called before your is called constructor.
		/// </para>
		/// <para>
		/// As per the <see cref="IOptionHandler"/> contract the <see cref="ActivateOptions"/>
		/// method must be called after the properties on this object have been
		/// configured.
		/// </para>
		/// </remarks>
		public PatternLayout() : this(DefaultConversionPattern)
		{
		}

		/// <summary>
		/// Constructs a PatternLayout using the supplied conversion pattern
		/// </summary>
		/// <param name="pattern">the pattern to use</param>
		/// <remarks>
		/// <para>
		/// Note to Inheritors: This constructor calls the virtual method
		/// <see cref="CreatePatternParser"/>. If you override this method be
		/// aware that it will be called before your is called constructor.
		/// </para>
		/// <para>
		/// When using this constructor the <see cref="ActivateOptions"/> method 
		/// need not be called. This may not be the case when using a subclass.
		/// </para>
		/// </remarks>
		public PatternLayout(string pattern) 
		{
			// By default we do not process the exception
			IgnoresException = true;

			m_pattern = pattern;
			if (m_pattern == null)
			{
				m_pattern = DefaultConversionPattern;
			}

			ActivateOptions();
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public override void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1065" sc="3" el="1084" ec="4">log4net\Layout\PatternLayout.cs</location>
            <body hash="598f13061fe30dd60bba8c239cf8a966"><![CDATA[{
			m_head = CreatePatternParser(m_pattern).Parse();

			PatternConverter curConverter = m_head;
			while(curConverter != null)
			{
				PatternLayoutConverter layoutConverter = curConverter as PatternLayoutConverter;
				if (layoutConverter != null)
				{
					if (!layoutConverter.IgnoresException)
					{
						// Found converter that handles the exception
						this.IgnoresException = false;

						break;
					}
				}
				curConverter = curConverter.Next;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="AddConverter">
          <declaration><![CDATA[public void AddConverter(ConverterInfo converterInfo)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1135" sc="3" el="1143" ec="4">log4net\Layout\PatternLayout.cs</location>
            <body hash="4d78c06f487d26bab6bbddd286a771c4"><![CDATA[{
            if (converterInfo == null) throw new ArgumentNullException("converterInfo");

            if (!typeof(PatternConverter).IsAssignableFrom(converterInfo.Type))
            {
                throw new ArgumentException("The converter type specified [" + converterInfo.Type + "] must be a subclass of log4net.Util.PatternConverter", "converterInfo");
            }
            m_instanceRulesRegistry[converterInfo.Name] = converterInfo;
		}]]></body>
          </codeblock>
        </method>
        <method name="AddConverter">
          <declaration><![CDATA[public void AddConverter(string name, Type type)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1162" sc="3" el="1171" ec="4">log4net\Layout\PatternLayout.cs</location>
            <body hash="676607c8d58d7a4863a1cb1f2f155d2a"><![CDATA[{
            if (name == null) throw new ArgumentNullException("name");
            if (type == null) throw new ArgumentNullException("type");

            ConverterInfo converterInfo = new ConverterInfo();
            converterInfo.Name = name;
            converterInfo.Type = type;

            AddConverter(converterInfo);
		}]]></body>
          </codeblock>
        </method>
        <method name="CreatePatternParser">
          <declaration><![CDATA[protected virtual PatternParser CreatePatternParser(string pattern)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1026" sc="3" el="1044" ec="4">log4net\Layout\PatternLayout.cs</location>
            <body hash="1603e8c35534098068d362c73818a42c"><![CDATA[{
			PatternParser patternParser = new PatternParser(pattern);

			// Add all the builtin patterns
			foreach(DictionaryEntry entry in s_globalRulesRegistry)
			{
                ConverterInfo converterInfo = new ConverterInfo();
                converterInfo.Name = (string)entry.Key;
                converterInfo.Type = (Type)entry.Value;
                patternParser.PatternConverters[entry.Key] = converterInfo;
			}
			// Add the instance patterns
			foreach(DictionaryEntry entry in m_instanceRulesRegistry)
			{
				patternParser.PatternConverters[entry.Key] = entry.Value;
			}

			return patternParser;
		}]]></body>
          </codeblock>
        </method>
        <method name="Format">
          <declaration><![CDATA[public override void Format(TextWriter writer, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1102" sc="3" el="1120" ec="4">log4net\Layout\PatternLayout.cs</location>
            <body hash="0399432df9374edd37ddb8cc8e3b73c7"><![CDATA[{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			if (loggingEvent == null)
			{
				throw new ArgumentNullException("loggingEvent");
			}

			PatternConverter c = m_head;

			// loop through the chain of pattern converters
			while(c != null) 
			{
				c.Format(writer, loggingEvent);
				c = c.Next;
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="DefaultConversionPattern">
          <declaration><![CDATA[public const string DefaultConversionPattern = "%message%newline";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DetailConversionPattern">
          <declaration><![CDATA[public const string DetailConversionPattern = "%timestamp [%thread] %level %logger %ndc - %message%newline";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_head">
          <declaration><![CDATA[private PatternConverter m_head;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_instanceRulesRegistry">
          <declaration><![CDATA[private Hashtable m_instanceRulesRegistry = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_pattern">
          <declaration><![CDATA[private string m_pattern;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="s_globalRulesRegistry">
          <declaration><![CDATA[private static Hashtable s_globalRulesRegistry;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="ConversionPattern">
          <declaration><![CDATA[public string ConversionPattern]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="RawLayoutConverter">
      <declaration><![CDATA[public class RawLayoutConverter : IConvertFrom]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public RawLayoutConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CanConvertFrom">
          <declaration><![CDATA[public bool CanConvertFrom(Type sourceType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="60" sc="3" el="63" ec="4">log4net\Layout\RawLayoutConverter.cs</location>
            <body hash="2af3dfd3ab3f4d593e1efcfe1ceac426"><![CDATA[{
			// Accept an ILayout object
			return (typeof(ILayout).IsAssignableFrom(sourceType));
		}]]></body>
          </codeblock>
        </method>
        <method name="ConvertFrom">
          <declaration><![CDATA[public object ConvertFrom(object source)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="80" sc="3" el="87" ec="4">log4net\Layout\RawLayoutConverter.cs</location>
            <body hash="0109acfaafa37264518da99d3b872829"><![CDATA[{
			ILayout layout = source as ILayout;
			if (layout != null) 
			{
				return new Layout2RawLayoutAdapter(layout);
			}
			throw ConversionNotSupportedException.Create(typeof(IRawLayout), source);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="RawPropertyLayout">
      <declaration><![CDATA[public class RawPropertyLayout : IRawLayout]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public RawPropertyLayout()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="44" sc="3" el="46" ec="4">log4net\Layout\RawPropertyLayout.cs</location>
            <body hash="be71fde206420d19462aa25440b5cb71"><![CDATA[public RawPropertyLayout()
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Format">
          <declaration><![CDATA[public virtual object Format(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="84" sc="3" el="86" ec="4">log4net\Layout\RawPropertyLayout.cs</location>
            <body hash="15310e985dab8f17c346738e97dd4089"><![CDATA[{
			return loggingEvent.LookupProperty(m_key);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_key">
          <declaration><![CDATA[private string m_key;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Key">
          <declaration><![CDATA[public string Key]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="RawTimeStampLayout">
      <declaration><![CDATA[public class RawTimeStampLayout : IRawLayout]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public RawTimeStampLayout()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="45" sc="3" el="47" ec="4">log4net\Layout\RawTimeStampLayout.cs</location>
            <body hash="c69a62f35287e167139412478d9f9486"><![CDATA[public RawTimeStampLayout()
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Format">
          <declaration><![CDATA[public virtual object Format(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="68" sc="3" el="70" ec="4">log4net\Layout\RawTimeStampLayout.cs</location>
            <body hash="42b105a67598de214bbbdf44f9aede1d"><![CDATA[{
			return loggingEvent.TimeStamp;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="RawUtcTimeStampLayout">
      <declaration><![CDATA[public class RawUtcTimeStampLayout : IRawLayout]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public RawUtcTimeStampLayout()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="45" sc="3" el="47" ec="4">log4net\Layout\RawUtcTimeStampLayout.cs</location>
            <body hash="34787e7a41172a1cd9053903530b7efc"><![CDATA[public RawUtcTimeStampLayout()
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Format">
          <declaration><![CDATA[public virtual object Format(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="68" sc="3" el="70" ec="4">log4net\Layout\RawUtcTimeStampLayout.cs</location>
            <body hash="361bf3da3595ce53117d160f283f421d"><![CDATA[{
			return loggingEvent.TimeStampUtc;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="SimpleLayout">
      <declaration><![CDATA[public class SimpleLayout : LayoutSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public SimpleLayout()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="50" sc="3" el="53" ec="4">log4net\Layout\SimpleLayout.cs</location>
            <body hash="74ac01596ed9cf2408c748165887fcc2"><![CDATA[public SimpleLayout()
		{
			IgnoresException = true;
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public override void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="76" sc="3" el="78" ec="4">log4net\Layout\SimpleLayout.cs</location>
            <body hash="1f0663468aa8a3b69b307028d8b86ee3"><![CDATA[{
			// nothing to do.
		}]]></body>
          </codeblock>
        </method>
        <method name="Format">
          <declaration><![CDATA[public override void Format(TextWriter writer, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="97" sc="3" el="107" ec="4">log4net\Layout\SimpleLayout.cs</location>
            <body hash="2f2847bf499bbe35278cfd501aa105bf"><![CDATA[{
			if (loggingEvent == null)
			{
				throw new ArgumentNullException("loggingEvent");
			}

			writer.Write(loggingEvent.Level.DisplayName);
			writer.Write(" - ");
			loggingEvent.WriteRenderedMessage(writer);
			writer.WriteLine();
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="XmlLayout">
      <declaration><![CDATA[public class XmlLayout : XmlLayoutBase]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private string m_prefix = "log4net";]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="79" sc="24" el="329" ec="41">log4net\Layout\XmlLayout.cs</location>
            <body hash="a20eda6add53aaaf35751f4285cf552b"><![CDATA[base()
		{
		}

		/// <summary>
		/// Constructs an XmlLayout.
		/// </summary>
		/// <remarks>
		/// <para>
		/// The <b>LocationInfo</b> option takes a boolean value. By
		/// default, it is set to false which means there will be no location
		/// information output by this layout. If the the option is set to
		/// true, then the file name and line number of the statement
		/// at the origin of the log statement will be output. 
		/// </para>
		/// <para>
		/// If you are embedding this layout within an SmtpAppender
		/// then make sure to set the <b>LocationInfo</b> option of that 
		/// appender as well.
		/// </para>
		/// </remarks>
		public XmlLayout(bool locationInfo) :  base(locationInfo)
		{
		}

		#endregion Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// The prefix to use for all element names
		/// </summary>
		/// <remarks>
		/// <para>
		/// The default prefix is <b>log4net</b>. Set this property
		/// to change the prefix. If the prefix is set to an empty string
		/// then no prefix will be written.
		/// </para>
		/// </remarks>
		public string Prefix
		{
			get { return m_prefix; }
			set { m_prefix = value; }
		}

		
		/// <summary>
		/// Set whether or not to base64 encode the message.
		/// </summary>
		/// <remarks>
		/// <para>
		/// By default the log message will be written as text to the xml
		/// output. This can cause problems when the message contains binary
		/// data. By setting this to true the contents of the message will be
		/// base64 encoded. If this is set then invalid character replacement
		/// (see <see cref="XmlLayoutBase.InvalidCharReplacement"/>) will not be performed
		/// on the log message.
		/// </para>
		/// </remarks>
		public bool Base64EncodeMessage
		{
			get {return m_base64Message;}
			set {m_base64Message=value;}
		}

		/// <summary>
		/// Set whether or not to base64 encode the property values.
		/// </summary>
		/// <remarks>
		/// <para>
		/// By default the properties will be written as text to the xml
		/// output. This can cause problems when one or more properties contain
		/// binary data. By setting this to true the values of the properties
		/// will be base64 encoded. If this is set then invalid character replacement
		/// (see <see cref="XmlLayoutBase.InvalidCharReplacement"/>) will not be performed
		/// on the property values.
		/// </para>
		/// </remarks>
		public bool Base64EncodeProperties
		{
			get {return m_base64Properties;}
			set {m_base64Properties=value;}
		}


		#endregion Public Instance Properties

		#region Implementation of IOptionHandler

		/// <summary>
		/// Initialize layout options
		/// </summary>
		/// <remarks>
		/// <para>
		/// This is part of the <see cref="IOptionHandler"/> delayed object
		/// activation scheme. The <see cref="ActivateOptions"/> method must 
		/// be called on this object after the configuration properties have
		/// been set. Until <see cref="ActivateOptions"/> is called this
		/// object is in an undefined state and must not be used. 
		/// </para>
		/// <para>
		/// If any of the configuration properties are modified then 
		/// <see cref="ActivateOptions"/> must be called again.
		/// </para>
		/// <para>
		/// Builds a cache of the element names
		/// </para>
		/// </remarks>
		override public void ActivateOptions() 
		{
			base.ActivateOptions();

			// Cache the full element names including the prefix
			if (m_prefix != null && m_prefix.Length > 0)
			{
				m_elmEvent = m_prefix + ":" + ELM_EVENT;
				m_elmMessage = m_prefix + ":" + ELM_MESSAGE;
				m_elmProperties = m_prefix + ":" + ELM_PROPERTIES;
				m_elmData = m_prefix + ":" + ELM_DATA;
				m_elmException = m_prefix + ":" + ELM_EXCEPTION;
				m_elmLocation = m_prefix + ":" + ELM_LOCATION;
			}
		}

		#endregion Implementation of IOptionHandler

		#region Override implementation of XMLLayoutBase

		/// <summary>
		/// Does the actual writing of the XML.
		/// </summary>
		/// <param name="writer">The writer to use to output the event to.</param>
		/// <param name="loggingEvent">The event to write.</param>
		/// <remarks>
		/// <para>
		/// Override the base class <see cref="XmlLayoutBase.FormatXml"/> method
		/// to write the <see cref="LoggingEvent"/> to the <see cref="XmlWriter"/>.
		/// </para>
		/// </remarks>
		override protected void FormatXml(XmlWriter writer, LoggingEvent loggingEvent)
		{
			writer.WriteStartElement(m_elmEvent);
			writer.WriteAttributeString(ATTR_LOGGER, loggingEvent.LoggerName);

#if NET_2_0 || NETCF_2_0 || MONO_2_0 || NETSTANDARD1_3
			writer.WriteAttributeString(ATTR_TIMESTAMP, XmlConvert.ToString(loggingEvent.TimeStamp, XmlDateTimeSerializationMode.Local));
#else
			writer.WriteAttributeString(ATTR_TIMESTAMP, XmlConvert.ToString(loggingEvent.TimeStamp));
#endif

			writer.WriteAttributeString(ATTR_LEVEL, loggingEvent.Level.DisplayName);
			writer.WriteAttributeString(ATTR_THREAD, loggingEvent.ThreadName);

			if (loggingEvent.Domain != null && loggingEvent.Domain.Length > 0)
			{
				writer.WriteAttributeString(ATTR_DOMAIN, loggingEvent.Domain);
			}
			if (loggingEvent.Identity != null && loggingEvent.Identity.Length > 0)
			{
				writer.WriteAttributeString(ATTR_IDENTITY, loggingEvent.Identity);
			}
			if (loggingEvent.UserName != null && loggingEvent.UserName.Length > 0)
			{
				writer.WriteAttributeString(ATTR_USERNAME, loggingEvent.UserName);
			}
    
			// Append the message text
			writer.WriteStartElement(m_elmMessage);
			if (!this.Base64EncodeMessage)
			{
				Transform.WriteEscapedXmlString(writer, loggingEvent.RenderedMessage, this.InvalidCharReplacement);
			}
			else
			{
				byte[] messageBytes = Encoding.UTF8.GetBytes(loggingEvent.RenderedMessage);
				string base64Message = Convert.ToBase64String(messageBytes, 0, messageBytes.Length);
				Transform.WriteEscapedXmlString(writer, base64Message,this.InvalidCharReplacement);
			}
			writer.WriteEndElement();

			PropertiesDictionary properties = loggingEvent.GetProperties();

			// Append the properties text
			if (properties.Count > 0)
			{
				writer.WriteStartElement(m_elmProperties);
				foreach(System.Collections.DictionaryEntry entry in properties)
				{
					writer.WriteStartElement(m_elmData);
					writer.WriteAttributeString(ATTR_NAME, Transform.MaskXmlInvalidCharacters((string)entry.Key,this.InvalidCharReplacement));

					// Use an ObjectRenderer to convert the object to a string
					string valueStr =null;
					if (!this.Base64EncodeProperties)
					{
						valueStr = Transform.MaskXmlInvalidCharacters(loggingEvent.Repository.RendererMap.FindAndRender(entry.Value),this.InvalidCharReplacement);
					}
					else
					{
						byte[] propertyValueBytes = Encoding.UTF8.GetBytes(loggingEvent.Repository.RendererMap.FindAndRender(entry.Value));
						valueStr = Convert.ToBase64String(propertyValueBytes, 0, propertyValueBytes.Length);
					}
					writer.WriteAttributeString(ATTR_VALUE, valueStr);

					writer.WriteEndElement();
				}
				writer.WriteEndElement();
			}

			string exceptionStr = loggingEvent.GetExceptionString();
			if (exceptionStr != null && exceptionStr.Length > 0)
			{
				// Append the stack trace line
				writer.WriteStartElement(m_elmException);
				Transform.WriteEscapedXmlString(writer, exceptionStr,this.InvalidCharReplacement);
				writer.WriteEndElement();
			}

			if (LocationInfo)
			{ 
				LocationInfo locationInfo = loggingEvent.LocationInformation;

				writer.WriteStartElement(m_elmLocation);
				writer.WriteAttributeString(ATTR_CLASS, locationInfo.ClassName);
				writer.WriteAttributeString(ATTR_METHOD, locationInfo.MethodName);
				writer.WriteAttributeString(ATTR_FILE, locationInfo.FileName);
				writer.WriteAttributeString(ATTR_LINE, locationInfo.LineNumber);
				writer.WriteEndElement();
			}

			writer.WriteEndElement();
		}

		#endregion Override implementation of XMLLayoutBase

		#region Private Instance Fields
  
		/// <summary>
		/// The prefix to use for all generated element names
		/// </summary>
		private string m_prefix = PREFIX;

		private string m_elmEvent = ELM_EVENT;
		private string m_elmMessage = ELM_MESSAGE;
		private string m_elmData = ELM_DATA;
		private string m_elmProperties = ELM_PROPERTIES;
		private string m_elmException = ELM_EXCEPTION;
		private string m_elmLocation = ELM_LOCATION;

		private bool m_base64Message=false;
		private bool m_base64Properties=false;]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private string m_prefix = "log4net";]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="100" sc="42" el="329" ec="41">log4net\Layout\XmlLayout.cs</location>
            <body hash="ffe4445692a772c78e8bfb05e9d84ed4"><![CDATA[base(locationInfo)
		{
		}

		#endregion Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// The prefix to use for all element names
		/// </summary>
		/// <remarks>
		/// <para>
		/// The default prefix is <b>log4net</b>. Set this property
		/// to change the prefix. If the prefix is set to an empty string
		/// then no prefix will be written.
		/// </para>
		/// </remarks>
		public string Prefix
		{
			get { return m_prefix; }
			set { m_prefix = value; }
		}

		
		/// <summary>
		/// Set whether or not to base64 encode the message.
		/// </summary>
		/// <remarks>
		/// <para>
		/// By default the log message will be written as text to the xml
		/// output. This can cause problems when the message contains binary
		/// data. By setting this to true the contents of the message will be
		/// base64 encoded. If this is set then invalid character replacement
		/// (see <see cref="XmlLayoutBase.InvalidCharReplacement"/>) will not be performed
		/// on the log message.
		/// </para>
		/// </remarks>
		public bool Base64EncodeMessage
		{
			get {return m_base64Message;}
			set {m_base64Message=value;}
		}

		/// <summary>
		/// Set whether or not to base64 encode the property values.
		/// </summary>
		/// <remarks>
		/// <para>
		/// By default the properties will be written as text to the xml
		/// output. This can cause problems when one or more properties contain
		/// binary data. By setting this to true the values of the properties
		/// will be base64 encoded. If this is set then invalid character replacement
		/// (see <see cref="XmlLayoutBase.InvalidCharReplacement"/>) will not be performed
		/// on the property values.
		/// </para>
		/// </remarks>
		public bool Base64EncodeProperties
		{
			get {return m_base64Properties;}
			set {m_base64Properties=value;}
		}


		#endregion Public Instance Properties

		#region Implementation of IOptionHandler

		/// <summary>
		/// Initialize layout options
		/// </summary>
		/// <remarks>
		/// <para>
		/// This is part of the <see cref="IOptionHandler"/> delayed object
		/// activation scheme. The <see cref="ActivateOptions"/> method must 
		/// be called on this object after the configuration properties have
		/// been set. Until <see cref="ActivateOptions"/> is called this
		/// object is in an undefined state and must not be used. 
		/// </para>
		/// <para>
		/// If any of the configuration properties are modified then 
		/// <see cref="ActivateOptions"/> must be called again.
		/// </para>
		/// <para>
		/// Builds a cache of the element names
		/// </para>
		/// </remarks>
		override public void ActivateOptions() 
		{
			base.ActivateOptions();

			// Cache the full element names including the prefix
			if (m_prefix != null && m_prefix.Length > 0)
			{
				m_elmEvent = m_prefix + ":" + ELM_EVENT;
				m_elmMessage = m_prefix + ":" + ELM_MESSAGE;
				m_elmProperties = m_prefix + ":" + ELM_PROPERTIES;
				m_elmData = m_prefix + ":" + ELM_DATA;
				m_elmException = m_prefix + ":" + ELM_EXCEPTION;
				m_elmLocation = m_prefix + ":" + ELM_LOCATION;
			}
		}

		#endregion Implementation of IOptionHandler

		#region Override implementation of XMLLayoutBase

		/// <summary>
		/// Does the actual writing of the XML.
		/// </summary>
		/// <param name="writer">The writer to use to output the event to.</param>
		/// <param name="loggingEvent">The event to write.</param>
		/// <remarks>
		/// <para>
		/// Override the base class <see cref="XmlLayoutBase.FormatXml"/> method
		/// to write the <see cref="LoggingEvent"/> to the <see cref="XmlWriter"/>.
		/// </para>
		/// </remarks>
		override protected void FormatXml(XmlWriter writer, LoggingEvent loggingEvent)
		{
			writer.WriteStartElement(m_elmEvent);
			writer.WriteAttributeString(ATTR_LOGGER, loggingEvent.LoggerName);

#if NET_2_0 || NETCF_2_0 || MONO_2_0 || NETSTANDARD1_3
			writer.WriteAttributeString(ATTR_TIMESTAMP, XmlConvert.ToString(loggingEvent.TimeStamp, XmlDateTimeSerializationMode.Local));
#else
			writer.WriteAttributeString(ATTR_TIMESTAMP, XmlConvert.ToString(loggingEvent.TimeStamp));
#endif

			writer.WriteAttributeString(ATTR_LEVEL, loggingEvent.Level.DisplayName);
			writer.WriteAttributeString(ATTR_THREAD, loggingEvent.ThreadName);

			if (loggingEvent.Domain != null && loggingEvent.Domain.Length > 0)
			{
				writer.WriteAttributeString(ATTR_DOMAIN, loggingEvent.Domain);
			}
			if (loggingEvent.Identity != null && loggingEvent.Identity.Length > 0)
			{
				writer.WriteAttributeString(ATTR_IDENTITY, loggingEvent.Identity);
			}
			if (loggingEvent.UserName != null && loggingEvent.UserName.Length > 0)
			{
				writer.WriteAttributeString(ATTR_USERNAME, loggingEvent.UserName);
			}
    
			// Append the message text
			writer.WriteStartElement(m_elmMessage);
			if (!this.Base64EncodeMessage)
			{
				Transform.WriteEscapedXmlString(writer, loggingEvent.RenderedMessage, this.InvalidCharReplacement);
			}
			else
			{
				byte[] messageBytes = Encoding.UTF8.GetBytes(loggingEvent.RenderedMessage);
				string base64Message = Convert.ToBase64String(messageBytes, 0, messageBytes.Length);
				Transform.WriteEscapedXmlString(writer, base64Message,this.InvalidCharReplacement);
			}
			writer.WriteEndElement();

			PropertiesDictionary properties = loggingEvent.GetProperties();

			// Append the properties text
			if (properties.Count > 0)
			{
				writer.WriteStartElement(m_elmProperties);
				foreach(System.Collections.DictionaryEntry entry in properties)
				{
					writer.WriteStartElement(m_elmData);
					writer.WriteAttributeString(ATTR_NAME, Transform.MaskXmlInvalidCharacters((string)entry.Key,this.InvalidCharReplacement));

					// Use an ObjectRenderer to convert the object to a string
					string valueStr =null;
					if (!this.Base64EncodeProperties)
					{
						valueStr = Transform.MaskXmlInvalidCharacters(loggingEvent.Repository.RendererMap.FindAndRender(entry.Value),this.InvalidCharReplacement);
					}
					else
					{
						byte[] propertyValueBytes = Encoding.UTF8.GetBytes(loggingEvent.Repository.RendererMap.FindAndRender(entry.Value));
						valueStr = Convert.ToBase64String(propertyValueBytes, 0, propertyValueBytes.Length);
					}
					writer.WriteAttributeString(ATTR_VALUE, valueStr);

					writer.WriteEndElement();
				}
				writer.WriteEndElement();
			}

			string exceptionStr = loggingEvent.GetExceptionString();
			if (exceptionStr != null && exceptionStr.Length > 0)
			{
				// Append the stack trace line
				writer.WriteStartElement(m_elmException);
				Transform.WriteEscapedXmlString(writer, exceptionStr,this.InvalidCharReplacement);
				writer.WriteEndElement();
			}

			if (LocationInfo)
			{ 
				LocationInfo locationInfo = loggingEvent.LocationInformation;

				writer.WriteStartElement(m_elmLocation);
				writer.WriteAttributeString(ATTR_CLASS, locationInfo.ClassName);
				writer.WriteAttributeString(ATTR_METHOD, locationInfo.MethodName);
				writer.WriteAttributeString(ATTR_FILE, locationInfo.FileName);
				writer.WriteAttributeString(ATTR_LINE, locationInfo.LineNumber);
				writer.WriteEndElement();
			}

			writer.WriteEndElement();
		}

		#endregion Override implementation of XMLLayoutBase

		#region Private Instance Fields
  
		/// <summary>
		/// The prefix to use for all generated element names
		/// </summary>
		private string m_prefix = PREFIX;

		private string m_elmEvent = ELM_EVENT;
		private string m_elmMessage = ELM_MESSAGE;
		private string m_elmData = ELM_DATA;
		private string m_elmProperties = ELM_PROPERTIES;
		private string m_elmException = ELM_EXCEPTION;
		private string m_elmLocation = ELM_LOCATION;

		private bool m_base64Message=false;
		private bool m_base64Properties=false;]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public override void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="188" sc="3" el="201" ec="4">log4net\Layout\XmlLayout.cs</location>
            <body hash="f052521283fc4b58017bb5d93dcb417d"><![CDATA[{
			base.ActivateOptions();

			// Cache the full element names including the prefix
			if (m_prefix != null && m_prefix.Length > 0)
			{
				m_elmEvent = m_prefix + ":" + ELM_EVENT;
				m_elmMessage = m_prefix + ":" + ELM_MESSAGE;
				m_elmProperties = m_prefix + ":" + ELM_PROPERTIES;
				m_elmData = m_prefix + ":" + ELM_DATA;
				m_elmException = m_prefix + ":" + ELM_EXCEPTION;
				m_elmLocation = m_prefix + ":" + ELM_LOCATION;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="FormatXml">
          <declaration><![CDATA[protected override void FormatXml(XmlWriter writer, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="219" sc="3" el="310" ec="4">log4net\Layout\XmlLayout.cs</location>
            <body hash="2a84d69e6fd7084053aacbb20caaf854"><![CDATA[{
			writer.WriteStartElement(m_elmEvent);
			writer.WriteAttributeString(ATTR_LOGGER, loggingEvent.LoggerName);

#if NET_2_0 || NETCF_2_0 || MONO_2_0 || NETSTANDARD1_3
			writer.WriteAttributeString(ATTR_TIMESTAMP, XmlConvert.ToString(loggingEvent.TimeStamp, XmlDateTimeSerializationMode.Local));
#else
			writer.WriteAttributeString(ATTR_TIMESTAMP, XmlConvert.ToString(loggingEvent.TimeStamp));
#endif

			writer.WriteAttributeString(ATTR_LEVEL, loggingEvent.Level.DisplayName);
			writer.WriteAttributeString(ATTR_THREAD, loggingEvent.ThreadName);

			if (loggingEvent.Domain != null && loggingEvent.Domain.Length > 0)
			{
				writer.WriteAttributeString(ATTR_DOMAIN, loggingEvent.Domain);
			}
			if (loggingEvent.Identity != null && loggingEvent.Identity.Length > 0)
			{
				writer.WriteAttributeString(ATTR_IDENTITY, loggingEvent.Identity);
			}
			if (loggingEvent.UserName != null && loggingEvent.UserName.Length > 0)
			{
				writer.WriteAttributeString(ATTR_USERNAME, loggingEvent.UserName);
			}
    
			// Append the message text
			writer.WriteStartElement(m_elmMessage);
			if (!this.Base64EncodeMessage)
			{
				Transform.WriteEscapedXmlString(writer, loggingEvent.RenderedMessage, this.InvalidCharReplacement);
			}
			else
			{
				byte[] messageBytes = Encoding.UTF8.GetBytes(loggingEvent.RenderedMessage);
				string base64Message = Convert.ToBase64String(messageBytes, 0, messageBytes.Length);
				Transform.WriteEscapedXmlString(writer, base64Message,this.InvalidCharReplacement);
			}
			writer.WriteEndElement();

			PropertiesDictionary properties = loggingEvent.GetProperties();

			// Append the properties text
			if (properties.Count > 0)
			{
				writer.WriteStartElement(m_elmProperties);
				foreach(System.Collections.DictionaryEntry entry in properties)
				{
					writer.WriteStartElement(m_elmData);
					writer.WriteAttributeString(ATTR_NAME, Transform.MaskXmlInvalidCharacters((string)entry.Key,this.InvalidCharReplacement));

					// Use an ObjectRenderer to convert the object to a string
					string valueStr =null;
					if (!this.Base64EncodeProperties)
					{
						valueStr = Transform.MaskXmlInvalidCharacters(loggingEvent.Repository.RendererMap.FindAndRender(entry.Value),this.InvalidCharReplacement);
					}
					else
					{
						byte[] propertyValueBytes = Encoding.UTF8.GetBytes(loggingEvent.Repository.RendererMap.FindAndRender(entry.Value));
						valueStr = Convert.ToBase64String(propertyValueBytes, 0, propertyValueBytes.Length);
					}
					writer.WriteAttributeString(ATTR_VALUE, valueStr);

					writer.WriteEndElement();
				}
				writer.WriteEndElement();
			}

			string exceptionStr = loggingEvent.GetExceptionString();
			if (exceptionStr != null && exceptionStr.Length > 0)
			{
				// Append the stack trace line
				writer.WriteStartElement(m_elmException);
				Transform.WriteEscapedXmlString(writer, exceptionStr,this.InvalidCharReplacement);
				writer.WriteEndElement();
			}

			if (LocationInfo)
			{ 
				LocationInfo locationInfo = loggingEvent.LocationInformation;

				writer.WriteStartElement(m_elmLocation);
				writer.WriteAttributeString(ATTR_CLASS, locationInfo.ClassName);
				writer.WriteAttributeString(ATTR_METHOD, locationInfo.MethodName);
				writer.WriteAttributeString(ATTR_FILE, locationInfo.FileName);
				writer.WriteAttributeString(ATTR_LINE, locationInfo.LineNumber);
				writer.WriteEndElement();
			}

			writer.WriteEndElement();
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="ATTR_CLASS">
          <declaration><![CDATA[private const string ATTR_CLASS = "class";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ATTR_DOMAIN">
          <declaration><![CDATA[private const string ATTR_DOMAIN = "domain";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ATTR_FILE">
          <declaration><![CDATA[private const string ATTR_FILE = "file";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ATTR_IDENTITY">
          <declaration><![CDATA[private const string ATTR_IDENTITY = "identity";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ATTR_LEVEL">
          <declaration><![CDATA[private const string ATTR_LEVEL = "level";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ATTR_LINE">
          <declaration><![CDATA[private const string ATTR_LINE = "line";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ATTR_LOGGER">
          <declaration><![CDATA[private const string ATTR_LOGGER = "logger";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ATTR_METHOD">
          <declaration><![CDATA[private const string ATTR_METHOD = "method";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ATTR_NAME">
          <declaration><![CDATA[private const string ATTR_NAME = "name";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ATTR_THREAD">
          <declaration><![CDATA[private const string ATTR_THREAD = "thread";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ATTR_TIMESTAMP">
          <declaration><![CDATA[private const string ATTR_TIMESTAMP = "timestamp";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ATTR_USERNAME">
          <declaration><![CDATA[private const string ATTR_USERNAME = "username";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ATTR_VALUE">
          <declaration><![CDATA[private const string ATTR_VALUE = "value";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ELM_DATA">
          <declaration><![CDATA[private const string ELM_DATA = "data";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ELM_EVENT">
          <declaration><![CDATA[private const string ELM_EVENT = "event";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ELM_EXCEPTION">
          <declaration><![CDATA[private const string ELM_EXCEPTION = "exception";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ELM_GLOBAL_PROPERTIES">
          <declaration><![CDATA[private const string ELM_GLOBAL_PROPERTIES = "global-properties";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ELM_LOCATION">
          <declaration><![CDATA[private const string ELM_LOCATION = "locationInfo";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ELM_MESSAGE">
          <declaration><![CDATA[private const string ELM_MESSAGE = "message";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ELM_PROPERTIES">
          <declaration><![CDATA[private const string ELM_PROPERTIES = "properties";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_base64Message">
          <declaration><![CDATA[private bool m_base64Message = false;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_base64Properties">
          <declaration><![CDATA[private bool m_base64Properties = false;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_elmData">
          <declaration><![CDATA[private string m_elmData = "data";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_elmEvent">
          <declaration><![CDATA[private string m_elmEvent = "event";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_elmException">
          <declaration><![CDATA[private string m_elmException = "exception";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_elmLocation">
          <declaration><![CDATA[private string m_elmLocation = "locationInfo";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_elmMessage">
          <declaration><![CDATA[private string m_elmMessage = "message";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_elmProperties">
          <declaration><![CDATA[private string m_elmProperties = "properties";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_prefix">
          <declaration><![CDATA[private string m_prefix = "log4net";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="PREFIX">
          <declaration><![CDATA[private const string PREFIX = "log4net";]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Base64EncodeMessage">
          <declaration><![CDATA[public bool Base64EncodeMessage]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Base64EncodeProperties">
          <declaration><![CDATA[public bool Base64EncodeProperties]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Prefix">
          <declaration><![CDATA[public string Prefix]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="XmlLayoutBase">
      <declaration><![CDATA[public abstract class XmlLayoutBase : LayoutSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[protected XmlLayoutBase() : this(false)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="57" sc="31" el="60" ec="4">log4net\Layout\XmlLayoutBase.cs</location>
            <body hash="0de31fdec9ffba72140c0a01cd2afc2e"><![CDATA[this(false)
		{
			IgnoresException = false;
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private bool m_locationInfo = false;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="79" sc="3" el="251" ec="47">log4net\Layout\XmlLayoutBase.cs</location>
            <body hash="45b20b547f556ccc33d3c02f82529182"><![CDATA[protected XmlLayoutBase(bool locationInfo)
		{
			IgnoresException = false;
			m_locationInfo = locationInfo;
		}

		#endregion Protected Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Gets a value indicating whether to include location information in 
		/// the XML events.
		/// </summary>
		/// <value>
		/// <c>true</c> if location information should be included in the XML 
		/// events; otherwise, <c>false</c>.
		/// </value>
		/// <remarks>
		/// <para>
		/// If <see cref="LocationInfo" /> is set to <c>true</c>, then the file 
		/// name and line number of the statement at the origin of the log 
		/// statement will be output. 
		/// </para>
		/// <para>
		/// If you are embedding this layout within an <c>SMTPAppender</c>
		/// then make sure to set the <b>LocationInfo</b> option of that 
		/// appender as well.
		/// </para>
		/// </remarks>
		public bool LocationInfo
		{
			get { return m_locationInfo; }
			set { m_locationInfo = value; }
		}
		/// <summary>
		/// The string to replace characters that can not be expressed in XML with.
		/// <remarks>
		/// <para>
		/// Not all characters may be expressed in XML. This property contains the
		/// string to replace those that can not with. This defaults to a ?. Set it
		/// to the empty string to simply remove offending characters. For more
		/// details on the allowed character ranges see http://www.w3.org/TR/REC-xml/#charsets
		/// Character replacement will occur in  the log message, the property names 
		/// and the property values.
		/// </para>
		/// </remarks>
		/// </summary>
		public string InvalidCharReplacement
		{
			get {return m_invalidCharReplacement;}
			set {m_invalidCharReplacement=value;}
		}
		#endregion

		#region Implementation of IOptionHandler

		/// <summary>
		/// Initialize layout options
		/// </summary>
		/// <remarks>
		/// <para>
		/// This is part of the <see cref="IOptionHandler"/> delayed object
		/// activation scheme. The <see cref="ActivateOptions"/> method must 
		/// be called on this object after the configuration properties have
		/// been set. Until <see cref="ActivateOptions"/> is called this
		/// object is in an undefined state and must not be used. 
		/// </para>
		/// <para>
		/// If any of the configuration properties are modified then 
		/// <see cref="ActivateOptions"/> must be called again.
		/// </para>
		/// </remarks>
		override public void ActivateOptions() 
		{
			// nothing to do
		}

		#endregion Implementation of IOptionHandler

		#region Override implementation of LayoutSkeleton

		/// <summary>
		/// Gets the content type output by this layout. 
		/// </summary>
		/// <value>
		/// As this is the XML layout, the value is always <c>"text/xml"</c>.
		/// </value>
		/// <remarks>
		/// <para>
		/// As this is the XML layout, the value is always <c>"text/xml"</c>.
		/// </para>
		/// </remarks>
		override public string ContentType
		{
			get { return "text/xml"; }
		}

		/// <summary>
		/// Produces a formatted string.
		/// </summary>
		/// <param name="loggingEvent">The event being logged.</param>
		/// <param name="writer">The TextWriter to write the formatted event to</param>
		/// <remarks>
		/// <para>
		/// Format the <see cref="LoggingEvent"/> and write it to the <see cref="TextWriter"/>.
		/// </para>
		/// <para>
		/// This method creates an <see cref="XmlTextWriter"/> that writes to the
		/// <paramref name="writer"/>. The <see cref="XmlTextWriter"/> is passed 
		/// to the <see cref="FormatXml"/> method. Subclasses should override the
		/// <see cref="FormatXml"/> method rather than this method.
		/// </para>
		/// </remarks>
		override public void Format(TextWriter writer, LoggingEvent loggingEvent) 
		{
			if (loggingEvent == null)
			{
				throw new ArgumentNullException("loggingEvent");
			}
#if NETSTANDARD1_3
			var settings = new XmlWriterSettings
			{
				Indent = false,
				OmitXmlDeclaration = true
			};
			var xmlWriter = XmlWriter.Create(new ProtectCloseTextWriter(writer), settings);
#else
			XmlTextWriter xmlWriter = new XmlTextWriter(new ProtectCloseTextWriter(writer));
			xmlWriter.Formatting = Formatting.None;
			xmlWriter.Namespaces = false;
#endif
			// Write the event to the writer
			FormatXml(xmlWriter, loggingEvent);

			xmlWriter.WriteWhitespace(SystemInfo.NewLine);

			// Close on xmlWriter will ensure xml is flushed
			// the protected writer will ignore the actual close
			xmlWriter.Close();
		}

		#endregion Override implementation of LayoutSkeleton

		#region Protected Instance Methods

		/// <summary>
		/// Does the actual writing of the XML.
		/// </summary>
		/// <param name="writer">The writer to use to output the event to.</param>
		/// <param name="loggingEvent">The event to write.</param>
		/// <remarks>
		/// <para>
		/// Subclasses should override this method to format
		/// the <see cref="LoggingEvent"/> as XML.
		/// </para>
		/// </remarks>
		abstract protected void FormatXml(XmlWriter writer, LoggingEvent loggingEvent);

		#endregion Protected Instance Methods

		#region Private Instance Fields
  
		/// <summary>
		/// Flag to indicate if location information should be included in
		/// the XML events.
		/// </summary>
		private bool m_locationInfo = false;

		/// <summary>
		/// The string to replace invalid chars with
		/// </summary>
		private string m_invalidCharReplacement="?";]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public override void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="153" sc="3" el="155" ec="4">log4net\Layout\XmlLayoutBase.cs</location>
            <body hash="1fe439dc6d5eea62d3537ec9e25d989f"><![CDATA[{
			// nothing to do
		}]]></body>
          </codeblock>
        </method>
        <method name="Format">
          <declaration><![CDATA[public override void Format(TextWriter writer, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="194" sc="3" el="219" ec="4">log4net\Layout\XmlLayoutBase.cs</location>
            <body hash="0480408f778ac0670eb6a29b14639729"><![CDATA[{
			if (loggingEvent == null)
			{
				throw new ArgumentNullException("loggingEvent");
			}
#if NETSTANDARD1_3
			var settings = new XmlWriterSettings
			{
				Indent = false,
				OmitXmlDeclaration = true
			};
			var xmlWriter = XmlWriter.Create(new ProtectCloseTextWriter(writer), settings);
#else
			XmlTextWriter xmlWriter = new XmlTextWriter(new ProtectCloseTextWriter(writer));
			xmlWriter.Formatting = Formatting.None;
			xmlWriter.Namespaces = false;
#endif
			// Write the event to the writer
			FormatXml(xmlWriter, loggingEvent);

			xmlWriter.WriteWhitespace(SystemInfo.NewLine);

			// Close on xmlWriter will ensure xml is flushed
			// the protected writer will ignore the actual close
			xmlWriter.Close();
		}]]></body>
          </codeblock>
        </method>
        <method name="FormatXml">
          <declaration><![CDATA[protected abstract void FormatXml(XmlWriter writer, LoggingEvent loggingEvent);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_invalidCharReplacement">
          <declaration><![CDATA[private string m_invalidCharReplacement = "?";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_locationInfo">
          <declaration><![CDATA[private bool m_locationInfo = false;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="ContentType">
          <declaration><![CDATA[public override string ContentType]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="InvalidCharReplacement">
          <declaration><![CDATA[public string InvalidCharReplacement]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="LocationInfo">
          <declaration><![CDATA[public bool LocationInfo]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="XmlLayoutSchemaLog4j">
      <declaration><![CDATA[public class XmlLayoutSchemaLog4j : XmlLayoutBase]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public XmlLayoutSchemaLog4j()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="55" sc="35" el="57" ec="4">log4net\Layout\XmlLayoutSchemaLog4j.cs</location>
            <body hash="f89283f9c37548ffdc754964dc9b26fe"><![CDATA[base()
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public XmlLayoutSchemaLog4j(bool locationInfo) : base(locationInfo)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="76" sc="53" el="78" ec="4">log4net\Layout\XmlLayoutSchemaLog4j.cs</location>
            <body hash="0b820dbdc99704a468b14a8eccf74310"><![CDATA[base(locationInfo)
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static XmlLayoutSchemaLog4j()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="46" sc="3" el="46" ec="74">log4net\Layout\XmlLayoutSchemaLog4j.cs</location>
            <body hash="00e078b289c0769642e6c966f5a61e41"><![CDATA[private static readonly DateTime s_date1970 = new DateTime(1970, 1, 1)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="FormatXml">
          <declaration><![CDATA[protected override void FormatXml(XmlWriter writer, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="140" sc="3" el="249" ec="4">log4net\Layout\XmlLayoutSchemaLog4j.cs</location>
            <body hash="5611916a235e35abb2b7207247ff884a"><![CDATA[{
			// Translate logging events for log4j

			// Translate hostname property
			if (loggingEvent.LookupProperty(LoggingEvent.HostNameProperty) != null && 
				loggingEvent.LookupProperty("log4jmachinename") == null)
			{
				loggingEvent.GetProperties()["log4jmachinename"] = loggingEvent.LookupProperty(LoggingEvent.HostNameProperty);
			}

			// translate appdomain name
			if (loggingEvent.LookupProperty("log4japp") == null && 
				loggingEvent.Domain != null && 
				loggingEvent.Domain.Length > 0)
			{
				loggingEvent.GetProperties()["log4japp"] = loggingEvent.Domain;
			}

			// translate identity name
			if (loggingEvent.Identity != null && 
				loggingEvent.Identity.Length > 0 && 
				loggingEvent.LookupProperty(LoggingEvent.IdentityProperty) == null)
			{
				loggingEvent.GetProperties()[LoggingEvent.IdentityProperty] = loggingEvent.Identity;
			}

			// translate user name
			if (loggingEvent.UserName != null && 
				loggingEvent.UserName.Length > 0 && 
				loggingEvent.LookupProperty(LoggingEvent.UserNameProperty) == null)
			{
				loggingEvent.GetProperties()[LoggingEvent.UserNameProperty] = loggingEvent.UserName;
			}

			// Write the start element
			writer.WriteStartElement("log4j:event");
			writer.WriteAttributeString("logger", loggingEvent.LoggerName);

			// Calculate the timestamp as the number of milliseconds since january 1970
			// 
			// We must convert the TimeStamp to UTC before performing any mathematical
			// operations. This allows use to take into account discontinuities
			// caused by daylight savings time transitions.
			TimeSpan timeSince1970 = loggingEvent.TimeStampUtc - s_date1970;

			writer.WriteAttributeString("timestamp", XmlConvert.ToString((long)timeSince1970.TotalMilliseconds));
			writer.WriteAttributeString("level", loggingEvent.Level.DisplayName);
			writer.WriteAttributeString("thread", loggingEvent.ThreadName);
    
			// Append the message text
			writer.WriteStartElement("log4j:message");
			Transform.WriteEscapedXmlString(writer, loggingEvent.RenderedMessage,this.InvalidCharReplacement);
			writer.WriteEndElement();

			object ndcObj = loggingEvent.LookupProperty("NDC");
			if (ndcObj != null)
			{
				string valueStr = loggingEvent.Repository.RendererMap.FindAndRender(ndcObj);

				if (valueStr != null && valueStr.Length > 0)
				{
					// Append the NDC text
					writer.WriteStartElement("log4j:NDC");
					Transform.WriteEscapedXmlString(writer, valueStr,this.InvalidCharReplacement);
					writer.WriteEndElement();
				}
			}

			// Append the properties text
			PropertiesDictionary properties = loggingEvent.GetProperties();
			if (properties.Count > 0)
			{
				writer.WriteStartElement("log4j:properties");
				foreach(System.Collections.DictionaryEntry entry in properties)
				{
					writer.WriteStartElement("log4j:data");
					writer.WriteAttributeString("name", (string)entry.Key);

					// Use an ObjectRenderer to convert the object to a string
					string valueStr = loggingEvent.Repository.RendererMap.FindAndRender(entry.Value);
					writer.WriteAttributeString("value", valueStr);

					writer.WriteEndElement();
				}
				writer.WriteEndElement();
			}

			string exceptionStr = loggingEvent.GetExceptionString();
			if (exceptionStr != null && exceptionStr.Length > 0)
			{
				// Append the stack trace line
				writer.WriteStartElement("log4j:throwable");
				Transform.WriteEscapedXmlString(writer, exceptionStr,this.InvalidCharReplacement);
				writer.WriteEndElement();
			}

			if (LocationInfo)
			{ 
				LocationInfo locationInfo = loggingEvent.LocationInformation;

				writer.WriteStartElement("log4j:locationInfo");
				writer.WriteAttributeString("class", locationInfo.ClassName);
				writer.WriteAttributeString("method", locationInfo.MethodName);
				writer.WriteAttributeString("file", locationInfo.FileName);
				writer.WriteAttributeString("line", locationInfo.LineNumber);
				writer.WriteEndElement();
			}

			writer.WriteEndElement();
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="s_date1970">
          <declaration><![CDATA[private static readonly DateTime s_date1970 = new DateTime(1970, 1, 1);]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Version">
          <declaration><![CDATA[public string Version]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="96" sc="4" el="101" ec="5">log4net\Layout\XmlLayoutSchemaLog4j.cs</location>
            <body hash="28090dea347b947a9616294e9aac6b38"><![CDATA[{ 
				if (value != "1.2")
				{
					throw new ArgumentException("Only version 1.2 of the log4j schema is currently supported");
				}
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="log4net.Layout.Pattern">
    <class name="AppDomainPatternConverter">
      <declaration><![CDATA[internal sealed class AppDomainPatternConverter : PatternLayoutConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public AppDomainPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="51" sc="3" el="53" ec="4">log4net\Layout\Pattern\AppDomainPatternConverter.cs</location>
            <body hash="03557b642236e89b7e1edc094c4e7850"><![CDATA[{
			writer.Write(loggingEvent.Domain);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="AspNetCachePatternConverter">
      <declaration><![CDATA[internal sealed class AspNetCachePatternConverter : AspNetPatternLayoutConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public AspNetCachePatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, LoggingEvent loggingEvent, HttpContext httpContext)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="57" sc="3" el="73" ec="4">log4net\Layout\Pattern\AspNetCachePatternConverter.cs</location>
            <body hash="a925f2dded1e952d0ebb36b6f3a87ce3"><![CDATA[{
			if (HttpRuntime.Cache != null)
			{
				if (Option != null)
				{
					WriteObject(writer, loggingEvent.Repository, HttpRuntime.Cache[Option]);
				}
				else
				{
					WriteObject(writer, loggingEvent.Repository, HttpRuntime.Cache.GetEnumerator());
				}
			}
			else
			{
				writer.Write(SystemInfo.NotAvailableText);
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="AspNetContextPatternConverter">
      <declaration><![CDATA[internal sealed class AspNetContextPatternConverter : AspNetPatternLayoutConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public AspNetContextPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, LoggingEvent loggingEvent, HttpContext httpContext)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="55" sc="3" el="64" ec="4">log4net\Layout\Pattern\AspNetContextPatternConverter.cs</location>
            <body hash="9c0848a7a77e8697c931e28c68ff0365"><![CDATA[{
			if (Option != null)
			{
				WriteObject(writer, loggingEvent.Repository, httpContext.Items[Option]);
			}
			else
			{
				WriteObject(writer, loggingEvent.Repository, httpContext.Items);
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="AspNetPatternLayoutConverter">
      <declaration><![CDATA[internal abstract class AspNetPatternLayoutConverter : PatternLayoutConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[protected AspNetPatternLayoutConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="43" sc="3" el="52" ec="4">log4net\Layout\Pattern\AspNetPatternConverter.cs</location>
            <body hash="23dd4d6a33f4c22c205bf9f7b9a4323b"><![CDATA[{
			if (HttpContext.Current == null)
			{
				writer.Write(SystemInfo.NotAvailableText);
			}
			else
			{
				Convert(writer, loggingEvent, HttpContext.Current);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Convert">
          <declaration><![CDATA[protected abstract void Convert(TextWriter writer, LoggingEvent loggingEvent, HttpContext httpContext);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="AspNetRequestPatternConverter">
      <declaration><![CDATA[internal sealed class AspNetRequestPatternConverter : AspNetPatternLayoutConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public AspNetRequestPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, LoggingEvent loggingEvent, HttpContext httpContext)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="56" sc="3" el="82" ec="4">log4net\Layout\Pattern\AspNetRequestPatternConverter.cs</location>
            <body hash="188e23eb0e20ee18712837a0bee2344a"><![CDATA[{
		    HttpRequest request = null;
		    try {
			request = httpContext.Request;
		    } catch (HttpException) {
			// likely a case of running in IIS integrated mode
			// when inside an Application_Start event.
			// treat it like a case of the Request
			// property returning null
		    }

			if (request != null)
			{
				if (Option != null)
				{
					WriteObject(writer, loggingEvent.Repository, httpContext.Request.Params[Option]);
				}
				else
				{
					WriteObject(writer, loggingEvent.Repository, httpContext.Request.Params);
				}
			}
			else
			{
				writer.Write(SystemInfo.NotAvailableText);
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="AspNetSessionPatternConverter">
      <declaration><![CDATA[internal sealed class AspNetSessionPatternConverter : AspNetPatternLayoutConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public AspNetSessionPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, LoggingEvent loggingEvent, HttpContext httpContext)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="57" sc="3" el="73" ec="4">log4net\Layout\Pattern\AspNetSessionPatternConverter.cs</location>
            <body hash="3b55d521eb59a1dc3188ecbd4a69d87c"><![CDATA[{
			if (httpContext.Session != null)
			{
				if (Option != null)
				{
					WriteObject(writer, loggingEvent.Repository, httpContext.Session.Contents[Option]);
				}
				else
				{
					WriteObject(writer, loggingEvent.Repository, httpContext.Session);
				}
			}
			else
			{
				writer.Write(SystemInfo.NotAvailableText);
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="DatePatternConverter">
      <declaration><![CDATA[internal class DatePatternConverter : PatternLayoutConverter, IOptionHandler]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public DatePatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static DatePatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="185" sc="6" el="185" ec="80">log4net\Layout\Pattern\DatePatternConverter.cs</location>
            <body hash="0c90379b107c4db7b94a89608b151459"><![CDATA[private readonly static Type declaringType = typeof(DatePatternConverter)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="115" sc="3" el="146" ec="4">log4net\Layout\Pattern\DatePatternConverter.cs</location>
            <body hash="771b42c2b96ff9811c516b86c44f5a71"><![CDATA[{
			string dateFormatStr = Option;
			if (dateFormatStr == null)
			{
				dateFormatStr = AbsoluteTimeDateFormatter.Iso8601TimeDateFormat;
			}

			if (SystemInfo.EqualsIgnoringCase(dateFormatStr, AbsoluteTimeDateFormatter.Iso8601TimeDateFormat))
			{
				m_dateFormatter = new Iso8601DateFormatter();
			}
			else if (SystemInfo.EqualsIgnoringCase(dateFormatStr, AbsoluteTimeDateFormatter.AbsoluteTimeDateFormat))
			{
				m_dateFormatter = new AbsoluteTimeDateFormatter();
			}
			else if (SystemInfo.EqualsIgnoringCase(dateFormatStr, AbsoluteTimeDateFormatter.DateAndTimeDateFormat))
			{
				m_dateFormatter = new DateTimeDateFormatter();
			}
			else
			{
				try 
				{
					m_dateFormatter = new SimpleDateFormatter(dateFormatStr);
				}
				catch (Exception e) 
				{
					LogLog.Error(declaringType, "Could not instantiate SimpleDateFormatter with ["+dateFormatStr+"]", e);
					m_dateFormatter = new Iso8601DateFormatter();
				}	
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="165" sc="3" el="174" ec="4">log4net\Layout\Pattern\DatePatternConverter.cs</location>
            <body hash="3642e9c50a008fb3faca851fe1ea3175"><![CDATA[{
			try 
			{
				m_dateFormatter.FormatDate(loggingEvent.TimeStamp, writer);
			}
			catch (Exception ex) 
			{
				LogLog.Error(declaringType, "Error occurred while converting date.", ex);
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(DatePatternConverter);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_dateFormatter">
          <declaration><![CDATA[protected IDateFormatter m_dateFormatter;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="ExceptionPatternConverter">
      <declaration><![CDATA[internal sealed class ExceptionPatternConverter : PatternLayoutConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ExceptionPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="48" sc="3" el="52" ec="4">log4net\Layout\Pattern\ExceptionPatternConverter.cs</location>
            <body hash="8a35857cea06a673ef7d1d29a3e33a5f"><![CDATA[public ExceptionPatternConverter()
		{
			// This converter handles the exception
			IgnoresException = false;
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="94" sc="3" el="135" ec="4">log4net\Layout\Pattern\ExceptionPatternConverter.cs</location>
            <body hash="0c8ec42a1aba6d4f3661f433707404bc"><![CDATA[{
			if (loggingEvent.ExceptionObject != null && Option != null && Option.Length > 0)
			{
				switch (Option.ToLower())
				{
					case "message":
						WriteObject(writer, loggingEvent.Repository, loggingEvent.ExceptionObject.Message);
						break;
#if !NETCF						
					case "source":
						WriteObject(writer, loggingEvent.Repository, loggingEvent.ExceptionObject.Source);
						break;
					case "stacktrace":
						WriteObject(writer, loggingEvent.Repository, loggingEvent.ExceptionObject.StackTrace);
						break;
#if !NETSTANDARD1_3
					case "targetsite":
						WriteObject(writer, loggingEvent.Repository, loggingEvent.ExceptionObject.TargetSite);
						break;
#endif
					case "helplink":
						WriteObject(writer, loggingEvent.Repository, loggingEvent.ExceptionObject.HelpLink);
						break;
#endif						
					default:
						// do not output SystemInfo.NotAvailableText
						break;
				}
			}
			else
			{
				string exceptionString = loggingEvent.GetExceptionString();
				if (exceptionString != null && exceptionString.Length > 0) 
				{
					writer.WriteLine(exceptionString);
				}
				else
				{
					// do not output SystemInfo.NotAvailableText
				}
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="FileLocationPatternConverter">
      <declaration><![CDATA[internal sealed class FileLocationPatternConverter : PatternLayoutConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public FileLocationPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="52" sc="3" el="54" ec="4">log4net\Layout\Pattern\FileLocationPatternConverter.cs</location>
            <body hash="9e04b5ed9bfe7eb4558b478dc813fed3"><![CDATA[{
			writer.Write(loggingEvent.LocationInformation.FileName);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="FullLocationPatternConverter">
      <declaration><![CDATA[internal sealed class FullLocationPatternConverter : PatternLayoutConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public FullLocationPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="50" sc="3" el="52" ec="4">log4net\Layout\Pattern\FullLocationPatternConverter.cs</location>
            <body hash="f8dd5d336bba1c4260958f5ac6b2a051"><![CDATA[{
			writer.Write( loggingEvent.LocationInformation.FullInfo );
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="IdentityPatternConverter">
      <declaration><![CDATA[internal sealed class IdentityPatternConverter : PatternLayoutConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public IdentityPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="54" sc="3" el="56" ec="4">log4net\Layout\Pattern\IdentityPatternConverter.cs</location>
            <body hash="202cd9184b27a08b29b8d04b3d950b58"><![CDATA[{
			writer.Write(loggingEvent.Identity);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="LevelPatternConverter">
      <declaration><![CDATA[internal sealed class LevelPatternConverter : PatternLayoutConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public LevelPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="52" sc="3" el="54" ec="4">log4net\Layout\Pattern\LevelPatternConverter.cs</location>
            <body hash="2b75ac90690e7ff7fdd61ee1137b20bb"><![CDATA[{
			writer.Write( loggingEvent.Level.DisplayName );
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="LineLocationPatternConverter">
      <declaration><![CDATA[internal sealed class LineLocationPatternConverter : PatternLayoutConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public LineLocationPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="52" sc="3" el="54" ec="4">log4net\Layout\Pattern\LineLocationPatternConverter.cs</location>
            <body hash="11db1e5f97ba73853d07c7167418f808"><![CDATA[{
			writer.Write(loggingEvent.LocationInformation.LineNumber);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="LoggerPatternConverter">
      <declaration><![CDATA[internal sealed class LoggerPatternConverter : NamedPatternConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public LoggerPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="GetFullyQualifiedName">
          <declaration><![CDATA[protected override string GetFullyQualifiedName(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="50" sc="3" el="52" ec="4">log4net\Layout\Pattern\LoggerPatternConverter.cs</location>
            <body hash="214fcdb28b1eca5945aea1500a2dfb38"><![CDATA[{
			return loggingEvent.LoggerName;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="MessagePatternConverter">
      <declaration><![CDATA[internal sealed class MessagePatternConverter : PatternLayoutConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public MessagePatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="52" sc="3" el="54" ec="4">log4net\Layout\Pattern\MessagePatternConverter.cs</location>
            <body hash="44be18bc2ebc8a21e3ee0e3c11d4975a"><![CDATA[{
			loggingEvent.WriteRenderedMessage(writer);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="MethodLocationPatternConverter">
      <declaration><![CDATA[internal sealed class MethodLocationPatternConverter : PatternLayoutConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public MethodLocationPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="52" sc="3" el="54" ec="4">log4net\Layout\Pattern\MethodLocationPatternConverter.cs</location>
            <body hash="5c7ae54a061438175e70efd2635c7997"><![CDATA[{
			writer.Write(loggingEvent.LocationInformation.MethodName);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="NamedPatternConverter">
      <declaration><![CDATA[public abstract class NamedPatternConverter : PatternLayoutConverter, IOptionHandler]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_precision = 0;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="47" sc="3" el="47" ec="31">log4net\Layout\Pattern\NamedPatternConverter.cs</location>
            <body hash="fabfece5b6438cb4a5ad4ca5b8c78ebc"><![CDATA[private int m_precision = 0]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static NamedPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="166" sc="6" el="166" ec="81">log4net\Layout\Pattern\NamedPatternConverter.cs</location>
            <body hash="003204dddb7bec986217e03a3c2815b3"><![CDATA[private readonly static Type declaringType = typeof(NamedPatternConverter)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="68" sc="3" el="94" ec="4">log4net\Layout\Pattern\NamedPatternConverter.cs</location>
            <body hash="9fecafcdedb615d9aa8b3747a1acef9a"><![CDATA[{
			m_precision = 0;

			if (Option != null) 
			{
				string optStr = Option.Trim();
				if (optStr.Length > 0)
				{
					int precisionVal;
					if (SystemInfo.TryParse(optStr, out precisionVal))
					{
						if (precisionVal <= 0) 
						{
							LogLog.Error(declaringType, "NamedPatternConverter: Precision option (" + optStr + ") isn't a positive integer.");
						}
						else
						{
							m_precision = precisionVal;
						}
					} 
					else
					{
						LogLog.Error(declaringType, "NamedPatternConverter: Precision option \"" + optStr + "\" not a decimal integer.");
					}
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Convert">
          <declaration><![CDATA[protected sealed override void Convert(TextWriter writer, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="124" sc="3" el="155" ec="4">log4net\Layout\Pattern\NamedPatternConverter.cs</location>
            <body hash="cb9dd29a1dbce223b8f02f5fec6b9371"><![CDATA[{
			string name = GetFullyQualifiedName(loggingEvent);
			if (m_precision <= 0 || name == null || name.Length < 2)
			{
				writer.Write(name);
			}
			else 
			{
				int len = name.Length;
                string trailingDot = string.Empty;
                if (name.EndsWith(DOT))
                {
                    trailingDot = DOT;
                    name = name.Substring(0, len - 1);
                    len--;
                }

                int end = name.LastIndexOf(DOT);
				for(int i = 1; end > 0 && i < m_precision; i++) 
				{
                    end = name.LastIndexOf('.', end - 1);
                }
                if (end == -1)
                {
                    writer.Write(name + trailingDot);
                }
                else
                {
                    writer.Write(name.Substring(end + 1, len - end - 1) + trailingDot);
                }
			}	  
		}]]></body>
          </codeblock>
        </method>
        <method name="GetFullyQualifiedName">
          <declaration><![CDATA[protected abstract string GetFullyQualifiedName(LoggingEvent loggingEvent);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(NamedPatternConverter);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DOT">
          <declaration><![CDATA[private const string DOT = ".";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_precision">
          <declaration><![CDATA[private int m_precision = 0;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="NdcPatternConverter">
      <declaration><![CDATA[internal sealed class NdcPatternConverter : PatternLayoutConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public NdcPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="57" sc="3" el="60" ec="4">log4net\Layout\Pattern\NdcPatternConverter.cs</location>
            <body hash="dd641297e0bde717a8394ceb0e68f844"><![CDATA[{
			// Write the value for the specified key
			WriteObject(writer, loggingEvent.Repository, loggingEvent.LookupProperty("NDC"));
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="PatternLayoutConverter">
      <declaration><![CDATA[public abstract class PatternLayoutConverter : PatternConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private bool m_ignoresException = true;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="48" sc="3" el="121" ec="42">log4net\Layout\Pattern\PatternLayoutConverter.cs</location>
            <body hash="f309988302e5b82078ea1489610d482f"><![CDATA[protected PatternLayoutConverter() 
		{  
		}

		#endregion Protected Instance Constructors

		#region Public Properties

		/// <summary>
		/// Flag indicating if this converter handles the logging event exception
		/// </summary>
		/// <value><c>false</c> if this converter handles the logging event exception</value>
		/// <remarks>
		/// <para>
		/// If this converter handles the exception object contained within
		/// <see cref="LoggingEvent"/>, then this property should be set to
		/// <c>false</c>. Otherwise, if the layout ignores the exception
		/// object, then the property should be set to <c>true</c>.
		/// </para>
		/// <para>
		/// Set this value to override a this default setting. The default
		/// value is <c>true</c>, this converter does not handle the exception.
		/// </para>
		/// </remarks>
		virtual public bool IgnoresException 
		{ 
			get { return m_ignoresException; }
			set { m_ignoresException = value; }
		}

		#endregion Public Properties

		#region Protected Abstract Methods

		/// <summary>
		/// Derived pattern converters must override this method in order to
		/// convert conversion specifiers in the correct way.
		/// </summary>
		/// <param name="writer"><see cref="TextWriter" /> that will receive the formatted result.</param>
		/// <param name="loggingEvent">The <see cref="LoggingEvent" /> on which the pattern converter should be executed.</param>
		abstract protected void Convert(TextWriter writer, LoggingEvent loggingEvent);

		#endregion Protected Abstract Methods

		#region Protected Methods

		/// <summary>
		/// Derived pattern converters must override this method in order to
		/// convert conversion specifiers in the correct way.
		/// </summary>
		/// <param name="writer"><see cref="TextWriter" /> that will receive the formatted result.</param>
		/// <param name="state">The state object on which the pattern converter should be executed.</param>
		override protected void Convert(TextWriter writer, object state)
		{
			LoggingEvent loggingEvent = state as LoggingEvent;
			if (loggingEvent != null)
			{
				Convert(writer, loggingEvent);
			}
			else
			{
				throw new ArgumentException("state must be of type ["+typeof(LoggingEvent).FullName+"]", "state");
			}
		}

		#endregion Protected Methods

		/// <summary>
		/// Flag indicating if this converter handles exceptions
		/// </summary>
		/// <remarks>
		/// <c>false</c> if this converter handles exceptions
		/// </remarks>
		private bool m_ignoresException = true;]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected abstract void Convert(TextWriter writer, LoggingEvent loggingEvent);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, object state)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="101" sc="3" el="111" ec="4">log4net\Layout\Pattern\PatternLayoutConverter.cs</location>
            <body hash="978c2d62e6976760ca68d4493fbf31e9"><![CDATA[{
			LoggingEvent loggingEvent = state as LoggingEvent;
			if (loggingEvent != null)
			{
				Convert(writer, loggingEvent);
			}
			else
			{
				throw new ArgumentException("state must be of type ["+typeof(LoggingEvent).FullName+"]", "state");
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_ignoresException">
          <declaration><![CDATA[private bool m_ignoresException = true;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="IgnoresException">
          <declaration><![CDATA[public virtual bool IgnoresException]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="PropertyPatternConverter">
      <declaration><![CDATA[internal sealed class PropertyPatternConverter : PatternLayoutConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public PropertyPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="64" sc="3" el="75" ec="4">log4net\Layout\Pattern\PropertyPatternConverter.cs</location>
            <body hash="9836b74e50ed8d78b1ca304cf6d218c7"><![CDATA[{
			if (Option != null)
			{
				// Write the value for the specified key
				WriteObject(writer, loggingEvent.Repository, loggingEvent.LookupProperty(Option));
			}
			else
			{
				// Write all the key value pairs
				WriteDictionary(writer, loggingEvent.Repository, loggingEvent.GetProperties());
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="RelativeTimePatternConverter">
      <declaration><![CDATA[internal sealed class RelativeTimePatternConverter : PatternLayoutConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public RelativeTimePatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="52" sc="3" el="54" ec="4">log4net\Layout\Pattern\RelativeTimePatternConverter.cs</location>
            <body hash="afef4b33b9dad13d7697888c29b5e101"><![CDATA[{
			writer.Write( TimeDifferenceInMillis(LoggingEvent.StartTimeUtc, loggingEvent.TimeStampUtc).ToString(System.Globalization.NumberFormatInfo.InvariantInfo) );
		}]]></body>
          </codeblock>
        </method>
        <method name="TimeDifferenceInMillis">
          <declaration><![CDATA[private static long TimeDifferenceInMillis(DateTime start, DateTime end)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="63" sc="3" el="68" ec="4">log4net\Layout\Pattern\RelativeTimePatternConverter.cs</location>
            <body hash="50d4e9dbe1397f04b2e665da85666690"><![CDATA[{
			// We must convert all times to UTC before performing any mathematical
			// operations on them. This allows use to take into account discontinuities
			// caused by daylight savings time transitions.
			return (long)(end.ToUniversalTime() - start.ToUniversalTime()).TotalMilliseconds;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="StackTraceDetailPatternConverter">
      <declaration><![CDATA[internal class StackTraceDetailPatternConverter : StackTracePatternConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public StackTraceDetailPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static StackTraceDetailPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="86" sc="9" el="86" ec="89">log4net\Layout\Pattern\StackTraceDetailPatternConverter.cs</location>
            <body hash="4acb7caf2dc6bda31e08cca563500136"><![CDATA[private readonly static Type declaringType = typeof(StackTracePatternConverter)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="GetMethodInformation">
          <declaration><![CDATA[internal override string GetMethodInformation(MethodItem method)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="45" sc="9" el="75" ec="10">log4net\Layout\Pattern\StackTraceDetailPatternConverter.cs</location>
            <body hash="ec21ec1dc302f521122933ae588d81fd"><![CDATA[{
            string returnValue="";

            try
            {
                string param = "";
                string[] names = method.Parameters;
                StringBuilder sb = new StringBuilder();
                if (names != null && names.GetUpperBound(0) > 0)
                {
                    for (int i = 0; i <= names.GetUpperBound(0); i++)
                    {
                        sb.AppendFormat("{0}, ", names[i]);
                    }
                }

                if (sb.Length > 0)
                {
                    sb.Remove(sb.Length - 2, 2);
                    param = sb.ToString();
                }

                returnValue=base.GetMethodInformation(method) + "(" + param + ")";
            }
            catch (Exception ex)
            {
                LogLog.Error(declaringType, "An exception ocurred while retreiving method information.", ex);
            }

            return returnValue;
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(StackTracePatternConverter);]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="StackTracePatternConverter">
      <declaration><![CDATA[internal class StackTracePatternConverter : PatternLayoutConverter, IOptionHandler]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_stackFrameLevel = 1;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="41" sc="3" el="41" ec="37">log4net\Layout\Pattern\StackTracePatternConverter.cs</location>
            <body hash="b225c6c157227f49d53a8066970b776f"><![CDATA[private int m_stackFrameLevel = 1]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static StackTracePatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="145" sc="6" el="145" ec="86">log4net\Layout\Pattern\StackTracePatternConverter.cs</location>
            <body hash="4acb7caf2dc6bda31e08cca563500136"><![CDATA[private readonly static Type declaringType = typeof(StackTracePatternConverter)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="60" sc="3" el="84" ec="4">log4net\Layout\Pattern\StackTracePatternConverter.cs</location>
            <body hash="9b9f51521c7fb3814e7bb0a0bdcfc160"><![CDATA[{
			if (Option == null)
				return;
			
			string optStr = Option.Trim();
			if (optStr.Length != 0)
			{
				int stackLevelVal;
				if (SystemInfo.TryParse(optStr, out stackLevelVal))
				{
					if (stackLevelVal <= 0) 
					{
						LogLog.Error(declaringType, "StackTracePatternConverter: StackeFrameLevel option (" + optStr + ") isn't a positive integer.");
					}
					else
					{
						m_stackFrameLevel = stackLevelVal;
					}
				} 
				else
				{
					LogLog.Error(declaringType, "StackTracePatternConverter: StackFrameLevel option \"" + optStr + "\" not a decimal integer.");
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="97" sc="3" el="123" ec="4">log4net\Layout\Pattern\StackTracePatternConverter.cs</location>
            <body hash="63fe28ccfdb8b347457c436027dc23d5"><![CDATA[{
			StackFrameItem[] stackframes = loggingEvent.LocationInformation.StackFrames;
			if ((stackframes == null) || (stackframes.Length <= 0))
			{
				LogLog.Error(declaringType, "loggingEvent.LocationInformation.StackFrames was null or empty.");
				return;
			}
			
			int stackFrameIndex = m_stackFrameLevel - 1;
			while (stackFrameIndex >= 0)
			{
				if (stackFrameIndex >= stackframes.Length)
				{
					stackFrameIndex--;
					continue;
				}
				
				StackFrameItem stackFrame = stackframes[stackFrameIndex];
                writer.Write("{0}.{1}", stackFrame.ClassName, GetMethodInformation(stackFrame.Method));
				if (stackFrameIndex > 0)
				{
                    // TODO: make this user settable?
					writer.Write(" > ");
				}
				stackFrameIndex--;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="GetMethodInformation">
          <declaration><![CDATA[internal virtual string GetMethodInformation(MethodItem method)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="132" sc="9" el="134" ec="10">log4net\Layout\Pattern\StackTracePatternConverter.cs</location>
            <body hash="144a848bea768b66edf990d6bdab55cc"><![CDATA[{
            return method.Name;
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(StackTracePatternConverter);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_stackFrameLevel">
          <declaration><![CDATA[private int m_stackFrameLevel = 1;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="ThreadPatternConverter">
      <declaration><![CDATA[internal sealed class ThreadPatternConverter : PatternLayoutConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ThreadPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="50" sc="3" el="52" ec="4">log4net\Layout\Pattern\ThreadPatternConverter.cs</location>
            <body hash="00876151ae5ef24f9ac968e17c81b667"><![CDATA[{
			writer.Write(loggingEvent.ThreadName);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="TypeNamePatternConverter">
      <declaration><![CDATA[internal sealed class TypeNamePatternConverter : NamedPatternConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public TypeNamePatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="GetFullyQualifiedName">
          <declaration><![CDATA[protected override string GetFullyQualifiedName(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="50" sc="3" el="52" ec="4">log4net\Layout\Pattern\TypeNamePatternConverter.cs</location>
            <body hash="7b5f8955dc96bcb83a2921ca03585da7"><![CDATA[{
			return loggingEvent.LocationInformation.ClassName;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="UserNamePatternConverter">
      <declaration><![CDATA[internal sealed class UserNamePatternConverter : PatternLayoutConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public UserNamePatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="41" sc="3" el="43" ec="4">log4net\Layout\Pattern\UserNamePatternConverter.cs</location>
            <body hash="88c1c8faad6bf466b2b722470fc9963e"><![CDATA[{
			writer.Write( loggingEvent.UserName );
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="UtcDatePatternConverter">
      <declaration><![CDATA[internal class UtcDatePatternConverter : DatePatternConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public UtcDatePatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static UtcDatePatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="87" sc="6" el="87" ec="83">log4net\Layout\Pattern\UtcDatePatternConverter.cs</location>
            <body hash="e6142569c1e175afd5b75dc61c839d62"><![CDATA[private readonly static Type declaringType = typeof(UtcDatePatternConverter)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="67" sc="3" el="76" ec="4">log4net\Layout\Pattern\UtcDatePatternConverter.cs</location>
            <body hash="46b1223b046f6ae5c084aef8c7687a75"><![CDATA[{
			try 
			{
				m_dateFormatter.FormatDate(loggingEvent.TimeStampUtc, writer);
			}
			catch (Exception ex) 
			{
				LogLog.Error(declaringType, "Error occurred while converting date.", ex);
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(UtcDatePatternConverter);]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="log4net.ObjectRenderer">
    <class name="DefaultRenderer">
      <declaration><![CDATA[public sealed class DefaultRenderer : IObjectRenderer]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public DefaultRenderer()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="54" sc="3" el="56" ec="4">log4net\ObjectRenderer\DefaultRenderer.cs</location>
            <body hash="a5d9e51b3cfbd6eb7d50760b32b1afcc"><![CDATA[public DefaultRenderer()
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="RenderArray">
          <declaration><![CDATA[private void RenderArray(RendererMap rendererMap, Array array, TextWriter writer)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="236" sc="3" el="257" ec="4">log4net\ObjectRenderer\DefaultRenderer.cs</location>
            <body hash="7cef9555b73f9f74897fc817197da091"><![CDATA[{
			if (array.Rank != 1)
			{
				writer.Write(array.ToString());
			}
			else
			{
				writer.Write(array.GetType().Name + " {");
				int len = array.Length;

				if (len > 0)
				{
					rendererMap.FindAndRender(array.GetValue(0), writer);
					for(int i=1; i<len; i++)
					{
						writer.Write(", ");
						rendererMap.FindAndRender(array.GetValue(i), writer);
					}
				}
				writer.Write("}");
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="RenderDictionaryEntry">
          <declaration><![CDATA[private void RenderDictionaryEntry(RendererMap rendererMap, DictionaryEntry entry, TextWriter writer)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="304" sc="3" el="308" ec="4">log4net\ObjectRenderer\DefaultRenderer.cs</location>
            <body hash="4e4f7ded4f4f6d68f4e8ddb0d79665be"><![CDATA[{
			rendererMap.FindAndRender(entry.Key, writer);
			writer.Write("=");
			rendererMap.FindAndRender(entry.Value, writer);
		}]]></body>
          </codeblock>
        </method>
        <method name="RenderEnumerator">
          <declaration><![CDATA[private void RenderEnumerator(RendererMap rendererMap, IEnumerator enumerator, TextWriter writer)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="274" sc="3" el="289" ec="4">log4net\ObjectRenderer\DefaultRenderer.cs</location>
            <body hash="3f6704d9b177d3ad55f16587a6f5da5f"><![CDATA[{
			writer.Write("{");

			if (enumerator != null && enumerator.MoveNext())
			{
				rendererMap.FindAndRender(enumerator.Current, writer);

				while (enumerator.MoveNext())
				{
					writer.Write(", ");
					rendererMap.FindAndRender(enumerator.Current, writer);
				}
			}

			writer.Write("}");
		}]]></body>
          </codeblock>
        </method>
        <method name="RenderObject">
          <declaration><![CDATA[public void RenderObject(RendererMap rendererMap, object obj, TextWriter writer)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="149" sc="3" el="212" ec="4">log4net\ObjectRenderer\DefaultRenderer.cs</location>
            <body hash="9db24c0cb084db8eadd68394f2ffa229"><![CDATA[{
			if (rendererMap == null)
			{
				throw new ArgumentNullException("rendererMap");
			}

			if (obj == null)
			{
				writer.Write(SystemInfo.NullText);
				return;
			}
			
			Array objArray = obj as Array;
			if (objArray != null)
			{
				RenderArray(rendererMap, objArray, writer);
				return;
			}

			// Test if we are dealing with some form of collection object
			IEnumerable objEnumerable = obj as IEnumerable;
			if (objEnumerable != null)
			{
				// Get a collection interface if we can as its .Count property may be more
				// performant than getting the IEnumerator object and trying to advance it.
				ICollection objCollection = obj as ICollection;
				if (objCollection != null && objCollection.Count == 0)
				{
					writer.Write("{}");
					return;
				}
				
				// This is a special check to allow us to get the enumerator from the IDictionary
				// interface as this guarantees us DictionaryEntry objects. Note that in .NET 2.0
				// the generic IDictionary<> interface enumerates KeyValuePair objects rather than
				// DictionaryEntry ones. However the implementation of the plain IDictionary 
				// interface on the generic Dictionary<> still returns DictionaryEntry objects.
				IDictionary objDictionary = obj as IDictionary;
				if (objDictionary != null)
				{
					RenderEnumerator(rendererMap, objDictionary.GetEnumerator(), writer);
					return;
				}

				RenderEnumerator(rendererMap, objEnumerable.GetEnumerator(), writer);
				return;
			}

			IEnumerator objEnumerator = obj as IEnumerator;
			if (objEnumerator != null)
			{
				RenderEnumerator(rendererMap, objEnumerator, writer);
				return;
			}
			
			if (obj is DictionaryEntry)
			{
				RenderDictionaryEntry(rendererMap, (DictionaryEntry)obj, writer);
				return;
			}

			string str = obj.ToString();
			writer.Write( (str==null) ? SystemInfo.NullText : str );
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="IObjectRenderer">
      <declaration><![CDATA[public interface IObjectRenderer]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="RenderObject">
          <declaration><![CDATA[void RenderObject(RendererMap rendererMap, object obj, TextWriter writer);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="RendererMap">
      <declaration><![CDATA[public class RendererMap]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private Hashtable m_cache = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="53" sc="3" el="72" ec="4">log4net\ObjectRenderer\RendererMap.cs</location>
            <body hash="a36373da782ff4f9f680f59bb156d9c1"><![CDATA[private System.Collections.Hashtable m_cache = new System.Collections.Hashtable();

		private static IObjectRenderer s_defaultRenderer = new DefaultRenderer();

		#endregion

		#region Constructors

		/// <summary>
		/// Default Constructor
		/// </summary>
		/// <remarks>
		/// <para>
		/// Default constructor.
		/// </para>
		/// </remarks>
		public RendererMap() 
		{
			m_map = System.Collections.Hashtable.Synchronized(new System.Collections.Hashtable());
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static RendererMap()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="48" sc="9" el="55" ec="76">log4net\ObjectRenderer\RendererMap.cs</location>
            <body hash="8b0fac7f3b39dcb7ae6f1decaba77cb7"><![CDATA[private readonly static Type declaringType = typeof(RendererMap);

		#region Member Variables

		private System.Collections.Hashtable m_map;
		private System.Collections.Hashtable m_cache = new System.Collections.Hashtable();

		private static IObjectRenderer s_defaultRenderer = new DefaultRenderer();]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Clear">
          <declaration><![CDATA[public void Clear()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="301" sc="3" el="304" ec="4">log4net\ObjectRenderer\RendererMap.cs</location>
            <body hash="aba636683d375cc2a8167a1446e6b33d"><![CDATA[{
			m_map.Clear();
			m_cache.Clear();
		}]]></body>
          </codeblock>
        </method>
        <method name="FindAndRender">
          <declaration><![CDATA[public string FindAndRender(object obj)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="89" sc="3" el="100" ec="4">log4net\ObjectRenderer\RendererMap.cs</location>
            <body hash="8dbeecdd8d6cac88542234f77a1d0706"><![CDATA[{
			// Optimisation for strings
			string strData = obj as String;
			if (strData != null)
			{
				return strData;
			}

			StringWriter stringWriter = new StringWriter(System.Globalization.CultureInfo.InvariantCulture);
			FindAndRender(obj, stringWriter);
			return stringWriter.ToString();
		}]]></body>
          </codeblock>
        </method>
        <method name="FindAndRender">
          <declaration><![CDATA[public void FindAndRender(object obj, TextWriter writer)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="117" sc="3" el="169" ec="4">log4net\ObjectRenderer\RendererMap.cs</location>
            <body hash="a98c4e735eb10e361d0d7f160e358a0e"><![CDATA[{
			if (obj == null)
			{
				writer.Write(SystemInfo.NullText);
			}
			else 
			{
				// Optimisation for strings
				string str = obj as string;
				if (str != null)
				{
					writer.Write(str);
				}
				else
				{
					// Lookup the renderer for the specific type
					try
					{
						Get(obj.GetType()).RenderObject(this, obj, writer);
					}
					catch(Exception ex)
					{
						// Exception rendering the object
						log4net.Util.LogLog.Error(declaringType, "Exception while rendering object of type ["+obj.GetType().FullName+"]", ex);

						// return default message
						string objectTypeName = "";
						if (obj != null && obj.GetType() != null)
						{
							objectTypeName = obj.GetType().FullName;
						}

						writer.Write("<log4net.Error>Exception rendering object type ["+objectTypeName+"]");
						if (ex != null)
						{
							string exceptionText = null;

							try
							{
								exceptionText = ex.ToString();
							}
							catch
							{
								// Ignore exception
							}

							writer.Write("<stackTrace>" + exceptionText + "</stackTrace>");
						}
						writer.Write("</log4net.Error>");
					}
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Get">
          <declaration><![CDATA[public IObjectRenderer Get(object obj)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="186" sc="3" el="195" ec="4">log4net\ObjectRenderer\RendererMap.cs</location>
            <body hash="7025d838285046056512e4370b95bcac"><![CDATA[{
			if (obj == null) 
			{
				return null;
			}
			else
			{
				return Get(obj.GetType());
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Get">
          <declaration><![CDATA[public IObjectRenderer Get(Type type)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="210" sc="3" el="248" ec="4">log4net\ObjectRenderer\RendererMap.cs</location>
            <body hash="53f1bb243a5cb52b1098da784e53e1b1"><![CDATA[{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}

			IObjectRenderer result = null;

			// Check cache
			result = (IObjectRenderer)m_cache[type];

			if (result == null)
			{
#if NETSTANDARD1_3
				for (Type cur = type; cur != null; cur = cur.GetTypeInfo().BaseType)
#else
				for(Type cur = type; cur != null; cur = cur.BaseType)
#endif
				{
					// Search the type's interfaces
					result = SearchTypeAndInterfaces(cur);
					if (result != null)
					{
						break;
					}
				}

				// if not set then use the default renderer
				if (result == null)
				{
					result = s_defaultRenderer;
				}

				// Add to cache
				m_cache[type] = result;
			}

			return result;
		}]]></body>
          </codeblock>
        </method>
        <method name="Put">
          <declaration><![CDATA[public void Put(Type typeToRender, IObjectRenderer renderer)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="319" sc="3" el="332" ec="4">log4net\ObjectRenderer\RendererMap.cs</location>
            <body hash="e604bde6b985372b23f75c8a840991fe"><![CDATA[{
			m_cache.Clear();

			if (typeToRender == null)
			{
				throw new ArgumentNullException("typeToRender");
			}
			if (renderer == null)
			{
				throw new ArgumentNullException("renderer");
			}

			m_map[typeToRender] = renderer;
		}]]></body>
          </codeblock>
        </method>
        <method name="SearchTypeAndInterfaces">
          <declaration><![CDATA[private IObjectRenderer SearchTypeAndInterfaces(Type type)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="256" sc="3" el="274" ec="4">log4net\ObjectRenderer\RendererMap.cs</location>
            <body hash="95fa4b2182bbb7b736bd4834bf996524"><![CDATA[{
			IObjectRenderer r = (IObjectRenderer)m_map[type];
			if (r != null) 
			{
				return r;
			} 
			else 
			{
				foreach(Type t in type.GetInterfaces())
				{
					r = SearchTypeAndInterfaces(t);
					if (r != null)
					{
						return r; 
					}
				}
			}
			return null;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(RendererMap);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_cache">
          <declaration><![CDATA[private Hashtable m_cache = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_map">
          <declaration><![CDATA[private Hashtable m_map;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="s_defaultRenderer">
          <declaration><![CDATA[private static IObjectRenderer s_defaultRenderer = new DefaultRenderer();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="DefaultRenderer">
          <declaration><![CDATA[public IObjectRenderer DefaultRenderer]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="log4net.Plugin">
    <class name="IPlugin">
      <declaration><![CDATA[public interface IPlugin]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="Attach">
          <declaration><![CDATA[void Attach(ILoggerRepository repository);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Shutdown">
          <declaration><![CDATA[void Shutdown();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Name">
          <declaration><![CDATA[string Name]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="IPluginFactory">
      <declaration><![CDATA[public interface IPluginFactory]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="CreatePlugin">
          <declaration><![CDATA[IPlugin CreatePlugin();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="PluginCollection">
      <declaration><![CDATA[public class PluginCollection : ICollection, IEnumerable, IList, ICloneable]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_count = 0;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="72" sc="3" el="104" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="19fc390d72f774ca40372fe1c1bf6dc0"><![CDATA[private int m_count = 0;
		private int m_version = 0;

		#endregion Implementation (data)
	
		#region Static Wrappers

		/// <summary>
		///	Creates a read-only wrapper for a <c>PluginCollection</c> instance.
		/// </summary>
		/// <param name="list">list to create a readonly wrapper arround</param>
		/// <returns>
		/// A <c>PluginCollection</c> wrapper that is read-only.
		/// </returns>
		public static PluginCollection ReadOnly(PluginCollection list)
		{
			if(list == null) throw new ArgumentNullException("list");

			return new ReadOnlyPluginCollection(list);
		}

		#endregion

		#region Constructors

		/// <summary>
		///	Initializes a new instance of the <c>PluginCollection</c> class
		///	that is empty and has the default initial capacity.
		/// </summary>
		public PluginCollection()
		{
			m_array = new IPlugin[DEFAULT_CAPACITY];
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_count = 0;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="72" sc="3" el="116" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="7a9e09a3c12c50c8cc71514048a81673"><![CDATA[private int m_count = 0;
		private int m_version = 0;

		#endregion Implementation (data)
	
		#region Static Wrappers

		/// <summary>
		///	Creates a read-only wrapper for a <c>PluginCollection</c> instance.
		/// </summary>
		/// <param name="list">list to create a readonly wrapper arround</param>
		/// <returns>
		/// A <c>PluginCollection</c> wrapper that is read-only.
		/// </returns>
		public static PluginCollection ReadOnly(PluginCollection list)
		{
			if(list == null) throw new ArgumentNullException("list");

			return new ReadOnlyPluginCollection(list);
		}

		#endregion

		#region Constructors

		/// <summary>
		///	Initializes a new instance of the <c>PluginCollection</c> class
		///	that is empty and has the default initial capacity.
		/// </summary>
		public PluginCollection()
		{
			m_array = new IPlugin[DEFAULT_CAPACITY];
		}
		
		/// <summary>
		/// Initializes a new instance of the <c>PluginCollection</c> class
		/// that has the specified initial capacity.
		/// </summary>
		/// <param name="capacity">
		/// The number of elements that the new <c>PluginCollection</c> is initially capable of storing.
		/// </param>
		public PluginCollection(int capacity)
		{
			m_array = new IPlugin[capacity];
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_count = 0;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="72" sc="3" el="127" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="d162aa4e00098462d1b733d6d927311d"><![CDATA[private int m_count = 0;
		private int m_version = 0;

		#endregion Implementation (data)
	
		#region Static Wrappers

		/// <summary>
		///	Creates a read-only wrapper for a <c>PluginCollection</c> instance.
		/// </summary>
		/// <param name="list">list to create a readonly wrapper arround</param>
		/// <returns>
		/// A <c>PluginCollection</c> wrapper that is read-only.
		/// </returns>
		public static PluginCollection ReadOnly(PluginCollection list)
		{
			if(list == null) throw new ArgumentNullException("list");

			return new ReadOnlyPluginCollection(list);
		}

		#endregion

		#region Constructors

		/// <summary>
		///	Initializes a new instance of the <c>PluginCollection</c> class
		///	that is empty and has the default initial capacity.
		/// </summary>
		public PluginCollection()
		{
			m_array = new IPlugin[DEFAULT_CAPACITY];
		}
		
		/// <summary>
		/// Initializes a new instance of the <c>PluginCollection</c> class
		/// that has the specified initial capacity.
		/// </summary>
		/// <param name="capacity">
		/// The number of elements that the new <c>PluginCollection</c> is initially capable of storing.
		/// </param>
		public PluginCollection(int capacity)
		{
			m_array = new IPlugin[capacity];
		}

		/// <summary>
		/// Initializes a new instance of the <c>PluginCollection</c> class
		/// that contains elements copied from the specified <c>PluginCollection</c>.
		/// </summary>
		/// <param name="c">The <c>PluginCollection</c> whose elements are copied to the new collection.</param>
		public PluginCollection(PluginCollection c)
		{
			m_array = new IPlugin[c.Count];
			AddRange(c);
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_count = 0;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="72" sc="3" el="138" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="6a98d617c7c625c46ba9c88dfddb8f39"><![CDATA[private int m_count = 0;
		private int m_version = 0;

		#endregion Implementation (data)
	
		#region Static Wrappers

		/// <summary>
		///	Creates a read-only wrapper for a <c>PluginCollection</c> instance.
		/// </summary>
		/// <param name="list">list to create a readonly wrapper arround</param>
		/// <returns>
		/// A <c>PluginCollection</c> wrapper that is read-only.
		/// </returns>
		public static PluginCollection ReadOnly(PluginCollection list)
		{
			if(list == null) throw new ArgumentNullException("list");

			return new ReadOnlyPluginCollection(list);
		}

		#endregion

		#region Constructors

		/// <summary>
		///	Initializes a new instance of the <c>PluginCollection</c> class
		///	that is empty and has the default initial capacity.
		/// </summary>
		public PluginCollection()
		{
			m_array = new IPlugin[DEFAULT_CAPACITY];
		}
		
		/// <summary>
		/// Initializes a new instance of the <c>PluginCollection</c> class
		/// that has the specified initial capacity.
		/// </summary>
		/// <param name="capacity">
		/// The number of elements that the new <c>PluginCollection</c> is initially capable of storing.
		/// </param>
		public PluginCollection(int capacity)
		{
			m_array = new IPlugin[capacity];
		}

		/// <summary>
		/// Initializes a new instance of the <c>PluginCollection</c> class
		/// that contains elements copied from the specified <c>PluginCollection</c>.
		/// </summary>
		/// <param name="c">The <c>PluginCollection</c> whose elements are copied to the new collection.</param>
		public PluginCollection(PluginCollection c)
		{
			m_array = new IPlugin[c.Count];
			AddRange(c);
		}

		/// <summary>
		/// Initializes a new instance of the <c>PluginCollection</c> class
		/// that contains elements copied from the specified <see cref="IPlugin"/> array.
		/// </summary>
		/// <param name="a">The <see cref="IPlugin"/> array whose elements are copied to the new list.</param>
		public PluginCollection(IPlugin[] a)
		{
			m_array = new IPlugin[a.Length];
			AddRange(a);
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_count = 0;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="72" sc="3" el="149" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="6c1bc54bd1db373b8842fced020c2191"><![CDATA[private int m_count = 0;
		private int m_version = 0;

		#endregion Implementation (data)
	
		#region Static Wrappers

		/// <summary>
		///	Creates a read-only wrapper for a <c>PluginCollection</c> instance.
		/// </summary>
		/// <param name="list">list to create a readonly wrapper arround</param>
		/// <returns>
		/// A <c>PluginCollection</c> wrapper that is read-only.
		/// </returns>
		public static PluginCollection ReadOnly(PluginCollection list)
		{
			if(list == null) throw new ArgumentNullException("list");

			return new ReadOnlyPluginCollection(list);
		}

		#endregion

		#region Constructors

		/// <summary>
		///	Initializes a new instance of the <c>PluginCollection</c> class
		///	that is empty and has the default initial capacity.
		/// </summary>
		public PluginCollection()
		{
			m_array = new IPlugin[DEFAULT_CAPACITY];
		}
		
		/// <summary>
		/// Initializes a new instance of the <c>PluginCollection</c> class
		/// that has the specified initial capacity.
		/// </summary>
		/// <param name="capacity">
		/// The number of elements that the new <c>PluginCollection</c> is initially capable of storing.
		/// </param>
		public PluginCollection(int capacity)
		{
			m_array = new IPlugin[capacity];
		}

		/// <summary>
		/// Initializes a new instance of the <c>PluginCollection</c> class
		/// that contains elements copied from the specified <c>PluginCollection</c>.
		/// </summary>
		/// <param name="c">The <c>PluginCollection</c> whose elements are copied to the new collection.</param>
		public PluginCollection(PluginCollection c)
		{
			m_array = new IPlugin[c.Count];
			AddRange(c);
		}

		/// <summary>
		/// Initializes a new instance of the <c>PluginCollection</c> class
		/// that contains elements copied from the specified <see cref="IPlugin"/> array.
		/// </summary>
		/// <param name="a">The <see cref="IPlugin"/> array whose elements are copied to the new list.</param>
		public PluginCollection(IPlugin[] a)
		{
			m_array = new IPlugin[a.Length];
			AddRange(a);
		}
		
		/// <summary>
		/// Initializes a new instance of the <c>PluginCollection</c> class
		/// that contains elements copied from the specified <see cref="IPlugin"/> collection.
		/// </summary>
		/// <param name="col">The <see cref="IPlugin"/> collection whose elements are copied to the new list.</param>
		public PluginCollection(ICollection col)
		{
			m_array = new IPlugin[col.Count];
			AddRange(col);
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_count = 0;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="72" sc="3" el="172" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="26bd018f5f9c033768d5039adddb88e0"><![CDATA[private int m_count = 0;
		private int m_version = 0;

		#endregion Implementation (data)
	
		#region Static Wrappers

		/// <summary>
		///	Creates a read-only wrapper for a <c>PluginCollection</c> instance.
		/// </summary>
		/// <param name="list">list to create a readonly wrapper arround</param>
		/// <returns>
		/// A <c>PluginCollection</c> wrapper that is read-only.
		/// </returns>
		public static PluginCollection ReadOnly(PluginCollection list)
		{
			if(list == null) throw new ArgumentNullException("list");

			return new ReadOnlyPluginCollection(list);
		}

		#endregion

		#region Constructors

		/// <summary>
		///	Initializes a new instance of the <c>PluginCollection</c> class
		///	that is empty and has the default initial capacity.
		/// </summary>
		public PluginCollection()
		{
			m_array = new IPlugin[DEFAULT_CAPACITY];
		}
		
		/// <summary>
		/// Initializes a new instance of the <c>PluginCollection</c> class
		/// that has the specified initial capacity.
		/// </summary>
		/// <param name="capacity">
		/// The number of elements that the new <c>PluginCollection</c> is initially capable of storing.
		/// </param>
		public PluginCollection(int capacity)
		{
			m_array = new IPlugin[capacity];
		}

		/// <summary>
		/// Initializes a new instance of the <c>PluginCollection</c> class
		/// that contains elements copied from the specified <c>PluginCollection</c>.
		/// </summary>
		/// <param name="c">The <c>PluginCollection</c> whose elements are copied to the new collection.</param>
		public PluginCollection(PluginCollection c)
		{
			m_array = new IPlugin[c.Count];
			AddRange(c);
		}

		/// <summary>
		/// Initializes a new instance of the <c>PluginCollection</c> class
		/// that contains elements copied from the specified <see cref="IPlugin"/> array.
		/// </summary>
		/// <param name="a">The <see cref="IPlugin"/> array whose elements are copied to the new list.</param>
		public PluginCollection(IPlugin[] a)
		{
			m_array = new IPlugin[a.Length];
			AddRange(a);
		}
		
		/// <summary>
		/// Initializes a new instance of the <c>PluginCollection</c> class
		/// that contains elements copied from the specified <see cref="IPlugin"/> collection.
		/// </summary>
		/// <param name="col">The <see cref="IPlugin"/> collection whose elements are copied to the new list.</param>
		public PluginCollection(ICollection col)
		{
			m_array = new IPlugin[col.Count];
			AddRange(col);
		}

		/// <summary>
		/// Type visible only to our subclasses
		/// Used to access protected constructor
		/// </summary>
		/// <exclude/>
		protected internal enum Tag 
		{
			/// <summary>
			/// A value
			/// </summary>
			Default
		}

		/// <summary>
		/// Allow subclasses to avoid our default constructors
		/// </summary>
		/// <param name="tag"></param>
		/// <exclude/>
		protected internal PluginCollection(Tag tag)
		{
			m_array = null;
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Add">
          <declaration><![CDATA[public virtual int Add(IPlugin item)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="269" sc="3" el="279" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="f295516af989168beb5ba8e0314bc4f2"><![CDATA[{
			if (m_count == m_array.Length)
			{
				EnsureCapacity(m_count + 1);
			}

			m_array[m_count] = item;
			m_version++;

			return m_count++;
		}]]></body>
          </codeblock>
        </method>
        <method name="AddRange">
          <declaration><![CDATA[public virtual int AddRange(PluginCollection x)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="494" sc="3" el="505" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="0d8472a90bea124229797545dba34bc9"><![CDATA[{
			if (m_count + x.Count >= m_array.Length)
			{
				EnsureCapacity(m_count + x.Count);
			}
			
			Array.Copy(x.m_array, 0, m_array, m_count, x.Count);
			m_count += x.Count;
			m_version++;

			return m_count;
		}]]></body>
          </codeblock>
        </method>
        <method name="AddRange">
          <declaration><![CDATA[public virtual int AddRange(IPlugin[] x)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="513" sc="3" el="524" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="afd08b017faf3b66473566896850f9c5"><![CDATA[{
			if (m_count + x.Length >= m_array.Length)
			{
				EnsureCapacity(m_count + x.Length);
			}

			Array.Copy(x, 0, m_array, m_count, x.Length);
			m_count += x.Length;
			m_version++;

			return m_count;
		}]]></body>
          </codeblock>
        </method>
        <method name="AddRange">
          <declaration><![CDATA[public virtual int AddRange(ICollection col)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="532" sc="3" el="544" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="90d2a6ea80ee4f4d646424dd74efbbb2"><![CDATA[{
			if (m_count + col.Count >= m_array.Length)
			{
				EnsureCapacity(m_count + col.Count);
			}

			foreach(object item in col)
			{
				Add((IPlugin)item);
			}

			return m_count;
		}]]></body>
          </codeblock>
        </method>
        <method name="Clear">
          <declaration><![CDATA[public virtual void Clear()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="285" sc="3" el="289" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="80021dbf0d3ec1dbe9cc4d4418286221"><![CDATA[{
			++m_version;
			m_array = new IPlugin[DEFAULT_CAPACITY];
			m_count = 0;
		}]]></body>
          </codeblock>
        </method>
        <method name="Clone">
          <declaration><![CDATA[public virtual object Clone()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="296" sc="3" el="303" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="5eb6b0c22ed977737771e3a445dc3db5"><![CDATA[{
			PluginCollection newCol = new PluginCollection(m_count);
			Array.Copy(m_array, 0, newCol.m_array, 0, m_count);
			newCol.m_count = m_count;
			newCol.m_version = m_version;

			return newCol;
		}]]></body>
          </codeblock>
        </method>
        <method name="Contains">
          <declaration><![CDATA[public virtual bool Contains(IPlugin item)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="311" sc="3" el="320" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="3cb94335e2e358ee489dc1026763b704"><![CDATA[{
			for (int i=0; i != m_count; ++i)
			{
				if (m_array[i].Equals(item))
				{
					return true;
				}
			}
			return false;
		}]]></body>
          </codeblock>
        </method>
        <method name="CopyTo">
          <declaration><![CDATA[public virtual void CopyTo(IPlugin[] array)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="192" sc="3" el="194" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="10b59a8638112a8dbe9bf9a101801af7"><![CDATA[{
			this.CopyTo(array, 0);
		}]]></body>
          </codeblock>
        </method>
        <method name="CopyTo">
          <declaration><![CDATA[public virtual void CopyTo(IPlugin[] array, int start)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="203" sc="3" el="210" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="356909617fc98c0707a2955deb7b7513"><![CDATA[{
			if (m_count > array.GetUpperBound(0) + 1 - start)
			{
				throw new System.ArgumentException("Destination array was not long enough.");
			}
			
			Array.Copy(m_array, 0, array, start, m_count); 
		}]]></body>
          </codeblock>
        </method>
        <method name="EnsureCapacity">
          <declaration><![CDATA[private void EnsureCapacity(int min)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="583" sc="3" el="591" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="36181dd4bfc53e22bb4ca4f382b24b84"><![CDATA[{
			int newCapacity = ((m_array.Length == 0) ? DEFAULT_CAPACITY : m_array.Length * 2);
			if (newCapacity < min)
			{
				newCapacity = min;
			}

			this.Capacity = newCapacity;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetEnumerator">
          <declaration><![CDATA[public virtual PluginCollection.IPluginCollectionEnumerator GetEnumerator()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="445" sc="3" el="447" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="ebbb622c744110f8d1bac0707e083576"><![CDATA[{
			return new Enumerator(this);
		}]]></body>
          </codeblock>
        </method>
        <method name="IndexOf">
          <declaration><![CDATA[public virtual int IndexOf(IPlugin item)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="332" sc="3" el="341" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="4f9aff8712a844ff66b969172807a0f6"><![CDATA[{
			for (int i=0; i != m_count; ++i)
			{
				if (m_array[i].Equals(item))
				{
					return i;
				}
			}
			return -1;
		}]]></body>
          </codeblock>
        </method>
        <method name="Insert">
          <declaration><![CDATA[public virtual void Insert(int index, IPlugin item)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="354" sc="3" el="370" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="096f7827a2ecf8600dd315c69d823234"><![CDATA[{
			ValidateIndex(index, true); // throws
			
			if (m_count == m_array.Length)
			{
				EnsureCapacity(m_count + 1);
			}

			if (index < m_count)
			{
				Array.Copy(m_array, index, m_array, index + 1, m_count - index);
			}

			m_array[index] = item;
			m_count++;
			m_version++;
		}]]></body>
          </codeblock>
        </method>
        <method name="ReadOnly">
          <declaration><![CDATA[public static PluginCollection ReadOnly(PluginCollection list)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="87" sc="3" el="91" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="c6806f211dab713563983308858dfdc7"><![CDATA[{
			if(list == null) throw new ArgumentNullException("list");

			return new ReadOnlyPluginCollection(list);
		}]]></body>
          </codeblock>
        </method>
        <method name="Remove">
          <declaration><![CDATA[public virtual void Remove(IPlugin item)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="380" sc="3" el="388" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="0951720d3af35e1577a1114d53f7a225"><![CDATA[{		   
			int i = IndexOf(item);
			if (i < 0)
			{
				throw new System.ArgumentException("Cannot remove the specified item because it was not found in the specified Collection.");
			}
			++m_version;
			RemoveAt(i);
		}]]></body>
          </codeblock>
        </method>
        <method name="RemoveAt">
          <declaration><![CDATA[public virtual void RemoveAt(int index)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="400" sc="3" el="416" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="15cb8879297ffc3ead9509a8802ed8de"><![CDATA[{
			ValidateIndex(index); // throws
			
			m_count--;

			if (index < m_count)
			{
				Array.Copy(m_array, index + 1, m_array, index, m_count - index);
			}
			
			// We can't set the deleted entry equal to null, because it might be a value type.
			// Instead, we'll create an empty single-element array of the right type and copy it 
			// over the entry we want to erase.
			IPlugin[] temp = new IPlugin[1];
			Array.Copy(temp, 0, m_array, m_count, 1);
			m_version++;
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.ICollection.CopyTo">
          <declaration><![CDATA[void ICollection.CopyTo(Array array, int start)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="598" sc="3" el="600" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="6aca5568013b8b586ec30ff257dad014"><![CDATA[{
			Array.Copy(m_array, 0, array, start, m_count);
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IEnumerable.GetEnumerator">
          <declaration><![CDATA[IEnumerator IEnumerable.GetEnumerator()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="647" sc="3" el="649" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="7d02d007029b1701aa133378962cdce0"><![CDATA[{
			return (IEnumerator)(this.GetEnumerator());
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IList.Add">
          <declaration><![CDATA[int IList.Add(object x)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="613" sc="3" el="615" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="78270804db655b4831d183b3271a5a27"><![CDATA[{
			return this.Add((IPlugin)x);
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IList.Contains">
          <declaration><![CDATA[bool IList.Contains(object x)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="618" sc="3" el="620" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="d71a988411c42db9b5a3382a04bb3f85"><![CDATA[{
			return this.Contains((IPlugin)x);
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IList.IndexOf">
          <declaration><![CDATA[int IList.IndexOf(object x)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="623" sc="3" el="625" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="d8c89397587ada56c9eab921b3289b59"><![CDATA[{
			return this.IndexOf((IPlugin)x);
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IList.Insert">
          <declaration><![CDATA[void IList.Insert(int pos, object x)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="628" sc="3" el="630" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="1e2aaf552e45b400d0ab7a42138a76d0"><![CDATA[{
			this.Insert(pos, (IPlugin)x);
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IList.Remove">
          <declaration><![CDATA[void IList.Remove(object x)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="633" sc="3" el="635" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="b8ef2b2ba22328f85ad0810f6db53d5c"><![CDATA[{
			this.Remove((IPlugin)x);
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IList.RemoveAt">
          <declaration><![CDATA[void IList.RemoveAt(int pos)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="638" sc="3" el="640" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="e53002e980b10fa2d00afbb5c90a0118"><![CDATA[{
			this.RemoveAt(pos);
		}]]></body>
          </codeblock>
        </method>
        <method name="TrimToSize">
          <declaration><![CDATA[public virtual void TrimToSize()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="550" sc="3" el="552" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="b5df69cc284a1eeb88684b3bf89b1d2d"><![CDATA[{
			this.Capacity = m_count;
		}]]></body>
          </codeblock>
        </method>
        <method name="ValidateIndex">
          <declaration><![CDATA[private void ValidateIndex(int i)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="564" sc="3" el="566" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="7ba51ed3f3d914d29194aeca0387acc8"><![CDATA[{
			ValidateIndex(i, false);
		}]]></body>
          </codeblock>
        </method>
        <method name="ValidateIndex">
          <declaration><![CDATA[private void ValidateIndex(int i, bool allowEqualEnd)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="574" sc="3" el="580" ec="4">log4net\Plugin\PluginCollection.cs</location>
            <body hash="0dd0b75cfb3e4e5eb58308feb8976830"><![CDATA[{
			int max = (allowEqualEnd) ? (m_count) : (m_count-1);
			if (i < 0 || i > max)
			{
				throw log4net.Util.SystemInfo.CreateArgumentOutOfRangeException("i", (object)i, "Index was out of range. Must be non-negative and less than the size of the collection. [" + (object)i + "] Specified argument was out of the range of valid values.");
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="DEFAULT_CAPACITY">
          <declaration><![CDATA[private const int DEFAULT_CAPACITY = 16;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_array">
          <declaration><![CDATA[private IPlugin[] m_array;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_count">
          <declaration><![CDATA[private int m_count = 0;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_version">
          <declaration><![CDATA[private int m_version = 0;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Capacity">
          <declaration><![CDATA[public virtual int Capacity]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="462" sc="4" el="464" ec="5">log4net\Plugin\PluginCollection.cs</location>
            <body hash="78cd26a0d2ccca573376c8e22f67dc8a"><![CDATA[{ 
				return m_array.Length; 
			}]]></body>
          </codeblock>
          <codeblock>
            <location sl="466" sc="4" el="485" ec="5">log4net\Plugin\PluginCollection.cs</location>
            <body hash="870278c2caab2b9dfa5da740c3a9f159"><![CDATA[{
				if (value < m_count)
				{
					value = m_count;
				}

				if (value != m_array.Length)
				{
					if (value > 0)
					{
						IPlugin[] temp = new IPlugin[value];
						Array.Copy(m_array, 0, temp, 0, m_count);
						m_array = temp;
					}
					else
					{
						m_array = new IPlugin[DEFAULT_CAPACITY];
					}
				}
			}]]></body>
          </codeblock>
        </property>
        <property name="Count">
          <declaration><![CDATA[public virtual int Count]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IsFixedSize">
          <declaration><![CDATA[public virtual bool IsFixedSize]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IsReadOnly">
          <declaration><![CDATA[public virtual bool IsReadOnly]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IsSynchronized">
          <declaration><![CDATA[public virtual bool IsSynchronized]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Item">
          <declaration><![CDATA[public virtual IPlugin this[int index]]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="251" sc="4" el="254" ec="5">log4net\Plugin\PluginCollection.cs</location>
            <body hash="8dd2c766f54a28c4d63c86d0a7480385"><![CDATA[{
				ValidateIndex(index); // throws
				return m_array[index]; 
			}]]></body>
          </codeblock>
          <codeblock>
            <location sl="256" sc="4" el="260" ec="5">log4net\Plugin\PluginCollection.cs</location>
            <body hash="102e9f11d0fb63e58b9453e9181a9a4c"><![CDATA[{
				ValidateIndex(index); // throws
				++m_version; 
				m_array[index] = value; 
			}]]></body>
          </codeblock>
        </property>
        <property name="SyncRoot">
          <declaration><![CDATA[public virtual object SyncRoot]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="System.Collections.IList.Item">
          <declaration><![CDATA[object IList.this[int i]]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="PluginMap">
      <declaration><![CDATA[public sealed class PluginMap]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private readonly Hashtable m_mapName2Plugin = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="53" sc="3" el="184" ec="65">log4net\Plugin\PluginMap.cs</location>
            <body hash="e113fd8a35a3eb768043092d0baf3172"><![CDATA[public PluginMap(ILoggerRepository repository)
		{
			m_repository = repository;
		}

		#endregion Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Gets a <see cref="IPlugin" /> by name.
		/// </summary>
		/// <param name="name">The name of the <see cref="IPlugin" /> to lookup.</param>
		/// <returns>
		/// The <see cref="IPlugin" /> from the map with the name specified, or 
		/// <c>null</c> if no plugin is found.
		/// </returns>
		/// <remarks>
		/// <para>
		/// Lookup a plugin by name. If the plugin is not found <c>null</c>
		/// will be returned.
		/// </para>
		/// </remarks>
		public IPlugin this[string name]
		{
			get
			{
				if (name == null)
				{
					throw new ArgumentNullException("name");
				}

				lock(this)
				{
					return (IPlugin)m_mapName2Plugin[name];
				}
			}
		}

		/// <summary>
		/// Gets all possible plugins as a list of <see cref="IPlugin" /> objects.
		/// </summary>
		/// <value>All possible plugins as a list of <see cref="IPlugin" /> objects.</value>
		/// <remarks>
		/// <para>
		/// Get a collection of all the plugins defined in this map.
		/// </para>
		/// </remarks>
		public PluginCollection AllPlugins
		{
			get
			{
				lock(this)
				{
					return new PluginCollection(m_mapName2Plugin.Values);
				}
			}
		}
		
		#endregion Public Instance Properties

		#region Public Instance Methods

		/// <summary>
		/// Adds a <see cref="IPlugin" /> to the map.
		/// </summary>
		/// <param name="plugin">The <see cref="IPlugin" /> to add to the map.</param>
		/// <remarks>
		/// <para>
		/// The <see cref="IPlugin" /> will be attached to the repository when added.
		/// </para>
		/// <para>
		/// If there already exists a plugin with the same name 
		/// attached to the repository then the old plugin will
		/// be <see cref="IPlugin.Shutdown"/> and replaced with
		/// the new plugin.
		/// </para>
		/// </remarks>
		public void Add(IPlugin plugin)
		{
			if (plugin == null)
			{
				throw new ArgumentNullException("plugin");
			}

			IPlugin curPlugin = null;

			lock(this)
			{
				// Get the current plugin if it exists
				curPlugin = m_mapName2Plugin[plugin.Name] as IPlugin;

				// Store new plugin
				m_mapName2Plugin[plugin.Name] = plugin;
			}

			// Shutdown existing plugin with same name
			if (curPlugin != null)
			{
				curPlugin.Shutdown();
			}

			// Attach new plugin to repository
			plugin.Attach(m_repository);
		}

		/// <summary>
		/// Removes a <see cref="IPlugin" /> from the map.
		/// </summary>
		/// <param name="plugin">The <see cref="IPlugin" /> to remove from the map.</param>
		/// <remarks>
		/// <para>
		/// Remove a specific plugin from this map.
		/// </para>
		/// </remarks>
		public void Remove(IPlugin plugin)
		{
			if (plugin == null)
			{
				throw new ArgumentNullException("plugin");
			}
			lock(this)
			{
				m_mapName2Plugin.Remove(plugin.Name);
			}
		}

		#endregion Public Instance Methods

		#region Private Instance Fields

		private readonly Hashtable m_mapName2Plugin = new Hashtable();]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Add">
          <declaration><![CDATA[public void Add(IPlugin plugin)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="132" sc="3" el="157" ec="4">log4net\Plugin\PluginMap.cs</location>
            <body hash="70e39efb723abafd8e708413182df2c0"><![CDATA[{
			if (plugin == null)
			{
				throw new ArgumentNullException("plugin");
			}

			IPlugin curPlugin = null;

			lock(this)
			{
				// Get the current plugin if it exists
				curPlugin = m_mapName2Plugin[plugin.Name] as IPlugin;

				// Store new plugin
				m_mapName2Plugin[plugin.Name] = plugin;
			}

			// Shutdown existing plugin with same name
			if (curPlugin != null)
			{
				curPlugin.Shutdown();
			}

			// Attach new plugin to repository
			plugin.Attach(m_repository);
		}]]></body>
          </codeblock>
        </method>
        <method name="Remove">
          <declaration><![CDATA[public void Remove(IPlugin plugin)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="169" sc="3" el="178" ec="4">log4net\Plugin\PluginMap.cs</location>
            <body hash="5cd26a7ff2d6f5489ac968dbc9c6a4d3"><![CDATA[{
			if (plugin == null)
			{
				throw new ArgumentNullException("plugin");
			}
			lock(this)
			{
				m_mapName2Plugin.Remove(plugin.Name);
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_mapName2Plugin">
          <declaration><![CDATA[private readonly Hashtable m_mapName2Plugin = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_repository">
          <declaration><![CDATA[private readonly ILoggerRepository m_repository;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="AllPlugins">
          <declaration><![CDATA[public PluginCollection AllPlugins]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="104" sc="4" el="109" ec="5">log4net\Plugin\PluginMap.cs</location>
            <body hash="98c91a82f07fbc4554111d9562266e05"><![CDATA[{
				lock(this)
				{
					return new PluginCollection(m_mapName2Plugin.Values);
				}
			}]]></body>
          </codeblock>
        </property>
        <property name="Item">
          <declaration><![CDATA[public IPlugin this[string name]]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="79" sc="4" el="89" ec="5">log4net\Plugin\PluginMap.cs</location>
            <body hash="ca570c25f5b921af6f1242e1ece5ab89"><![CDATA[{
				if (name == null)
				{
					throw new ArgumentNullException("name");
				}

				lock(this)
				{
					return (IPlugin)m_mapName2Plugin[name];
				}
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="PluginSkeleton">
      <declaration><![CDATA[public abstract class PluginSkeleton : IPlugin]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[protected PluginSkeleton(string name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="47" sc="3" el="50" ec="4">log4net\Plugin\PluginSkeleton.cs</location>
            <body hash="b7c74ef08fa7a45d48efc94e1d282a13"><![CDATA[protected PluginSkeleton(string name)
		{
			m_name = name;
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Attach">
          <declaration><![CDATA[public virtual void Attach(ILoggerRepository repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="92" sc="3" el="94" ec="4">log4net\Plugin\PluginSkeleton.cs</location>
            <body hash="5941861150d5fed2e11e11592a283d03"><![CDATA[{
			m_repository = repository;
		}]]></body>
          </codeblock>
        </method>
        <method name="Shutdown">
          <declaration><![CDATA[public virtual void Shutdown()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="107" sc="3" el="108" ec="4">log4net\Plugin\PluginSkeleton.cs</location>
            <body hash="d2c65ffc45d1c7103cabbde916faf7e7"><![CDATA[{
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_name">
          <declaration><![CDATA[private string m_name;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_repository">
          <declaration><![CDATA[private ILoggerRepository m_repository;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="LoggerRepository">
          <declaration><![CDATA[protected virtual ILoggerRepository LoggerRepository]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Name">
          <declaration><![CDATA[public virtual string Name]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="RemoteLoggingServerPlugin">
      <declaration><![CDATA[public class RemoteLoggingServerPlugin : PluginSkeleton]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public RemoteLoggingServerPlugin() : base("RemoteLoggingServerPlugin:Unset URI")]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="64" sc="40" el="66" ec="4">log4net\Plugin\RemoteLoggingServerPlugin.cs</location>
            <body hash="468ea2fce34f33e02171016aca188212"><![CDATA[base("RemoteLoggingServerPlugin:Unset URI")
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public RemoteLoggingServerPlugin(string sinkUri) : base("RemoteLoggingServerPlugin:" + sinkUri)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="79" sc="54" el="82" ec="4">log4net\Plugin\RemoteLoggingServerPlugin.cs</location>
            <body hash="3db4d1af20172e35252d997724868534"><![CDATA[base("RemoteLoggingServerPlugin:"+sinkUri)
		{
			m_sinkUri = sinkUri;
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static RemoteLoggingServerPlugin()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="181" sc="6" el="181" ec="85">log4net\Plugin\RemoteLoggingServerPlugin.cs</location>
            <body hash="89f6cc83bfc410ac806301b702eb59c5"><![CDATA[private readonly static Type declaringType = typeof(RemoteLoggingServerPlugin)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Attach">
          <declaration><![CDATA[public override void Attach(ILoggerRepository repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="126" sc="3" el="140" ec="4">log4net\Plugin\RemoteLoggingServerPlugin.cs</location>
            <body hash="116414ae3a750973d9d12a34dee26c78"><![CDATA[{
			base.Attach(repository);

			// Create the sink and marshal it
			m_sink = new RemoteLoggingSinkImpl(repository); 

			try
			{
				RemotingServices.Marshal(m_sink, m_sinkUri, typeof(IRemoteLoggingSink));		
			}
			catch(Exception ex)
			{
				LogLog.Error(declaringType, "Failed to Marshal remoting sink", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Shutdown">
          <declaration><![CDATA[public override void Shutdown()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="155" sc="3" el="161" ec="4">log4net\Plugin\RemoteLoggingServerPlugin.cs</location>
            <body hash="71192484a5b3a5f90f1f08bccd9d822b"><![CDATA[{
			// Stops the sink from receiving messages
			RemotingServices.Disconnect(m_sink);
			m_sink = null;

			base.Shutdown();
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(RemoteLoggingServerPlugin);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_sink">
          <declaration><![CDATA[private RemoteLoggingServerPlugin.RemoteLoggingSinkImpl m_sink;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_sinkUri">
          <declaration><![CDATA[private string m_sinkUri;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="SinkUri">
          <declaration><![CDATA[public virtual string SinkUri]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="log4net.Repository">
    <class name="ConfigurationChangedEventArgs">
      <declaration><![CDATA[public class ConfigurationChangedEventArgs : EventArgs]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ConfigurationChangedEventArgs(ICollection configurationMessages)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="38" sc="9" el="41" ec="10">log4net\Repository\ConfigurationChangedEventArgs.cs</location>
            <body hash="667c157de6e39e5ee005d927cca6d2e5"><![CDATA[public ConfigurationChangedEventArgs(ICollection configurationMessages)
        {
            this.configurationMessages = configurationMessages;
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="configurationMessages">
          <declaration><![CDATA[private readonly ICollection configurationMessages;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="ConfigurationMessages">
          <declaration><![CDATA[public ICollection ConfigurationMessages]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="IBasicRepositoryConfigurator">
      <declaration><![CDATA[public interface IBasicRepositoryConfigurator]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="Configure">
          <declaration><![CDATA[void Configure(IAppender appender);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Configure">
          <declaration><![CDATA[void Configure(params IAppender[] appenders);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="ILoggerRepository">
      <declaration><![CDATA[public interface ILoggerRepository]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="add_ConfigurationChanged">
          <declaration><![CDATA[void add_ConfigurationChanged(LoggerRepositoryConfigurationChangedEventHandler value);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="add_ConfigurationReset">
          <declaration><![CDATA[void add_ConfigurationReset(LoggerRepositoryConfigurationResetEventHandler value);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="add_ShutdownEvent">
          <declaration><![CDATA[void add_ShutdownEvent(LoggerRepositoryShutdownEventHandler value);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Exists">
          <declaration><![CDATA[ILogger Exists(string name);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetAppenders">
          <declaration><![CDATA[IAppender[] GetAppenders();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetCurrentLoggers">
          <declaration><![CDATA[ILogger[] GetCurrentLoggers();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetLogger">
          <declaration><![CDATA[ILogger GetLogger(string name);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Log">
          <declaration><![CDATA[void Log(LoggingEvent logEvent);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="remove_ConfigurationChanged">
          <declaration><![CDATA[void remove_ConfigurationChanged(LoggerRepositoryConfigurationChangedEventHandler value);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="remove_ConfigurationReset">
          <declaration><![CDATA[void remove_ConfigurationReset(LoggerRepositoryConfigurationResetEventHandler value);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="remove_ShutdownEvent">
          <declaration><![CDATA[void remove_ShutdownEvent(LoggerRepositoryShutdownEventHandler value);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="ResetConfiguration">
          <declaration><![CDATA[void ResetConfiguration();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Shutdown">
          <declaration><![CDATA[void Shutdown();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="ConfigurationMessages">
          <declaration><![CDATA[ICollection ConfigurationMessages]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Configured">
          <declaration><![CDATA[bool Configured]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="LevelMap">
          <declaration><![CDATA[LevelMap LevelMap]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Name">
          <declaration><![CDATA[string Name]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="PluginMap">
          <declaration><![CDATA[PluginMap PluginMap]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Properties">
          <declaration><![CDATA[PropertiesDictionary Properties]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="RendererMap">
          <declaration><![CDATA[RendererMap RendererMap]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Threshold">
          <declaration><![CDATA[Level Threshold]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
        <event name="ConfigurationChanged">
          <declaration><![CDATA[event LoggerRepositoryConfigurationChangedEventHandler ConfigurationChanged;]]></declaration>
          <documentation>
          </documentation>
        </event>
        <event name="ConfigurationReset">
          <declaration><![CDATA[event LoggerRepositoryConfigurationResetEventHandler ConfigurationReset;]]></declaration>
          <documentation>
          </documentation>
        </event>
        <event name="ShutdownEvent">
          <declaration><![CDATA[event LoggerRepositoryShutdownEventHandler ShutdownEvent;]]></declaration>
          <documentation>
          </documentation>
        </event>
      </events>
    </class>
    <class name="IXmlRepositoryConfigurator">
      <declaration><![CDATA[public interface IXmlRepositoryConfigurator]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="Configure">
          <declaration><![CDATA[void Configure(XmlElement element);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="e);">
      <declaration><![CDATA[public delegate void LoggerRepositoryConfigurationChangedEventHandler(object sender, EventArgs e);]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public extern LoggerRepositoryConfigurationChangedEventHandler(object @object, IntPtr method);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="BeginInvoke">
          <declaration><![CDATA[public virtual extern IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object @object);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="EndInvoke">
          <declaration><![CDATA[public virtual extern void EndInvoke(IAsyncResult result);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Invoke">
          <declaration><![CDATA[public virtual extern void Invoke(object sender, EventArgs e);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="e);">
      <declaration><![CDATA[public delegate void LoggerRepositoryConfigurationResetEventHandler(object sender, EventArgs e);]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public extern LoggerRepositoryConfigurationResetEventHandler(object @object, IntPtr method);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="BeginInvoke">
          <declaration><![CDATA[public virtual extern IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object @object);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="EndInvoke">
          <declaration><![CDATA[public virtual extern void EndInvoke(IAsyncResult result);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Invoke">
          <declaration><![CDATA[public virtual extern void Invoke(object sender, EventArgs e);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="e);">
      <declaration><![CDATA[public delegate void LoggerRepositoryShutdownEventHandler(object sender, EventArgs e);]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public extern LoggerRepositoryShutdownEventHandler(object @object, IntPtr method);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="BeginInvoke">
          <declaration><![CDATA[public virtual extern IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object @object);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="EndInvoke">
          <declaration><![CDATA[public virtual extern void EndInvoke(IAsyncResult result);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Invoke">
          <declaration><![CDATA[public virtual extern void Invoke(object sender, EventArgs e);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="LoggerRepositorySkeleton">
      <declaration><![CDATA[public abstract class LoggerRepositorySkeleton : ILoggerRepository, IFlushable]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[protected LoggerRepositorySkeleton() : this(new PropertiesDictionary())]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="72" sc="42" el="74" ec="4">log4net\Repository\LoggerRepositorySkeleton.cs</location>
            <body hash="700697dccd77d1d06c61cf8fbf6ce5dc"><![CDATA[this(new PropertiesDictionary())
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[protected LoggerRepositorySkeleton(PropertiesDictionary properties)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="85" sc="3" el="98" ec="4">log4net\Repository\LoggerRepositorySkeleton.cs</location>
            <body hash="752fc2660f5c0025ce7c5beadc98015f"><![CDATA[protected LoggerRepositorySkeleton(PropertiesDictionary properties)
		{
			m_properties = properties;
			m_rendererMap = new RendererMap();
			m_pluginMap = new PluginMap(this);
			m_levelMap = new LevelMap();
            m_configurationMessages = EmptyCollection.Instance;
			m_configured = false;

			AddBuiltinLevels();

			// Don't disable any levels by default.
			m_threshold = Level.All;
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static LoggerRepositorySkeleton()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="435" sc="6" el="435" ec="84">log4net\Repository\LoggerRepositorySkeleton.cs</location>
            <body hash="a7742da17a73e731dfefbe55e812a40f"><![CDATA[private readonly static Type declaringType = typeof(LoggerRepositorySkeleton)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="add_ConfigurationChanged">
          <declaration><![CDATA[public void add_ConfigurationChanged(LoggerRepositoryConfigurationChangedEventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="395" sc="8" el="395" ec="9">log4net\Repository\LoggerRepositorySkeleton.cs</location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="add_ConfigurationReset">
          <declaration><![CDATA[public void add_ConfigurationReset(LoggerRepositoryConfigurationResetEventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="378" sc="8" el="378" ec="9">log4net\Repository\LoggerRepositorySkeleton.cs</location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="add_m_configurationChangedEvent">
          <declaration><![CDATA[private void add_m_configurationChangedEvent(LoggerRepositoryConfigurationChangedEventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="add_m_configurationResetEvent">
          <declaration><![CDATA[private void add_m_configurationResetEvent(LoggerRepositoryConfigurationResetEventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="add_m_shutdownEvent">
          <declaration><![CDATA[private void add_m_shutdownEvent(LoggerRepositoryShutdownEventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="add_ShutdownEvent">
          <declaration><![CDATA[public void add_ShutdownEvent(LoggerRepositoryShutdownEventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="360" sc="8" el="360" ec="9">log4net\Repository\LoggerRepositorySkeleton.cs</location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="AddBuiltinLevels">
          <declaration><![CDATA[private void AddBuiltinLevels()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="440" sc="3" el="468" ec="4">log4net\Repository\LoggerRepositorySkeleton.cs</location>
            <body hash="6dcc4ab5151068fc06b2d3fa88690f9f"><![CDATA[{
			// Add the predefined levels to the map
			m_levelMap.Add(Level.Off);

			// Unrecoverable errors
			m_levelMap.Add(Level.Emergency);
			m_levelMap.Add(Level.Fatal);
			m_levelMap.Add(Level.Alert); 

			// Recoverable errors
			m_levelMap.Add(Level.Critical); 
			m_levelMap.Add(Level.Severe); 
			m_levelMap.Add(Level.Error); 
			m_levelMap.Add(Level.Warn);

			// Information
			m_levelMap.Add(Level.Notice); 
			m_levelMap.Add(Level.Info); 

			// Debug
			m_levelMap.Add(Level.Debug);
			m_levelMap.Add(Level.Fine);
			m_levelMap.Add(Level.Trace);
			m_levelMap.Add(Level.Finer);
			m_levelMap.Add(Level.Verbose);
			m_levelMap.Add(Level.Finest);

			m_levelMap.Add(Level.All);
		}]]></body>
          </codeblock>
        </method>
        <method name="AddRenderer">
          <declaration><![CDATA[public virtual void AddRenderer(Type typeToRender, IObjectRenderer rendererInstance)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="481" sc="3" el="492" ec="4">log4net\Repository\LoggerRepositorySkeleton.cs</location>
            <body hash="009764c574f8807449fe8bbe202c386a"><![CDATA[{
			if (typeToRender == null)
			{
				throw new ArgumentNullException("typeToRender");
			}
			if (rendererInstance == null)
			{
				throw new ArgumentNullException("rendererInstance");
			}

			m_rendererMap.Put(typeToRender, rendererInstance);
		}]]></body>
          </codeblock>
        </method>
        <method name="Exists">
          <declaration><![CDATA[public abstract ILogger Exists(string name);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Flush">
          <declaration><![CDATA[public bool Flush(int millisecondsTimeout)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="596" sc="9" el="630" ec="10">log4net\Repository\LoggerRepositorySkeleton.cs</location>
            <body hash="029bad0ff603cb631fe87947a653f819"><![CDATA[{
            if (millisecondsTimeout < -1) throw new ArgumentOutOfRangeException("millisecondsTimeout", "Timeout must be -1 (Timeout.Infinite) or non-negative");

            // Assume success until one of the appenders fails
            bool result = true;

            // Use DateTime.UtcNow rather than a System.Diagnostics.Stopwatch for compatibility with .NET 1.x
            DateTime startTimeUtc = DateTime.UtcNow;

            // Do buffering appenders first.  These may be forwarding to other appenders
            foreach(log4net.Appender.IAppender appender in GetAppenders())
            {
                log4net.Appender.IFlushable flushable = appender as log4net.Appender.IFlushable;
                if (flushable == null) continue;
                if (appender is Appender.BufferingAppenderSkeleton)
                {
                    int timeout = GetWaitTime(startTimeUtc, millisecondsTimeout);
                    if (!flushable.Flush(timeout)) result = false;
                }
            }

            // Do non-buffering appenders.
            foreach (log4net.Appender.IAppender appender in GetAppenders())
            {
                log4net.Appender.IFlushable flushable = appender as log4net.Appender.IFlushable;
                if (flushable == null) continue;
                if (!(appender is Appender.BufferingAppenderSkeleton))
                {
                    int timeout = GetWaitTime(startTimeUtc, millisecondsTimeout);
                    if (!flushable.Flush(timeout)) result = false;
                }
            }

            return result;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAppenders">
          <declaration><![CDATA[public abstract IAppender[] GetAppenders();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetCurrentLoggers">
          <declaration><![CDATA[public abstract ILogger[] GetCurrentLoggers();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetLogger">
          <declaration><![CDATA[public abstract ILogger GetLogger(string name);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetWaitTime">
          <declaration><![CDATA[private static int GetWaitTime(DateTime startTimeUtc, int millisecondsTimeout)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="579" sc="9" el="587" ec="10">log4net\Repository\LoggerRepositorySkeleton.cs</location>
            <body hash="1f66f1ad933242dbddf5822e8c7d6080"><![CDATA[{
            if (millisecondsTimeout == Timeout.Infinite) return Timeout.Infinite;
            if (millisecondsTimeout == 0) return 0;

            int elapsedMilliseconds = (int)(DateTime.UtcNow - startTimeUtc).TotalMilliseconds;
            int timeout = millisecondsTimeout - elapsedMilliseconds;
            if (timeout < 0) timeout = 0;
            return timeout;
        }]]></body>
          </codeblock>
        </method>
        <method name="Log">
          <declaration><![CDATA[public abstract void Log(LoggingEvent logEvent);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="OnConfigurationChanged">
          <declaration><![CDATA[protected virtual void OnConfigurationChanged(EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="550" sc="3" el="561" ec="4">log4net\Repository\LoggerRepositorySkeleton.cs</location>
            <body hash="3b027c51828f05638fe168386fde2e35"><![CDATA[{
			if (e == null)
			{
				e = EventArgs.Empty;
			}

			LoggerRepositoryConfigurationChangedEventHandler handler = m_configurationChangedEvent;
			if (handler != null)
			{
				handler(this, e);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="OnConfigurationReset">
          <declaration><![CDATA[protected virtual void OnConfigurationReset(EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="527" sc="3" el="538" ec="4">log4net\Repository\LoggerRepositorySkeleton.cs</location>
            <body hash="7a6db4d4e0edafda2757c19165f00bde"><![CDATA[{
			if (e == null)
			{
				e = EventArgs.Empty;
			}

			LoggerRepositoryConfigurationResetEventHandler handler = m_configurationResetEvent;
			if (handler != null)
			{
				handler(this, e);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="OnShutdown">
          <declaration><![CDATA[protected virtual void OnShutdown(EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="504" sc="3" el="515" ec="4">log4net\Repository\LoggerRepositorySkeleton.cs</location>
            <body hash="51ca877d7bc0c731be630af7e1c84dbb"><![CDATA[{
			if (e == null)
			{
				e = EventArgs.Empty;
			}

			LoggerRepositoryShutdownEventHandler handler = m_shutdownEvent;
			if (handler != null)
			{
				handler(this, e);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="RaiseConfigurationChanged">
          <declaration><![CDATA[public void RaiseConfigurationChanged(EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="574" sc="3" el="576" ec="4">log4net\Repository\LoggerRepositorySkeleton.cs</location>
            <body hash="0bf45eaca6962955b99e60ae918359d5"><![CDATA[{
			OnConfigurationChanged(e);
		}]]></body>
          </codeblock>
        </method>
        <method name="remove_ConfigurationChanged">
          <declaration><![CDATA[public void remove_ConfigurationChanged(LoggerRepositoryConfigurationChangedEventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="396" sc="11" el="396" ec="12">log4net\Repository\LoggerRepositorySkeleton.cs</location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="remove_ConfigurationReset">
          <declaration><![CDATA[public void remove_ConfigurationReset(LoggerRepositoryConfigurationResetEventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="379" sc="11" el="379" ec="12">log4net\Repository\LoggerRepositorySkeleton.cs</location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="remove_m_configurationChangedEvent">
          <declaration><![CDATA[private void remove_m_configurationChangedEvent(LoggerRepositoryConfigurationChangedEventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="remove_m_configurationResetEvent">
          <declaration><![CDATA[private void remove_m_configurationResetEvent(LoggerRepositoryConfigurationResetEventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="remove_m_shutdownEvent">
          <declaration><![CDATA[private void remove_m_shutdownEvent(LoggerRepositoryShutdownEventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="remove_ShutdownEvent">
          <declaration><![CDATA[public void remove_ShutdownEvent(LoggerRepositoryShutdownEventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="361" sc="11" el="361" ec="12">log4net\Repository\LoggerRepositorySkeleton.cs</location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="ResetConfiguration">
          <declaration><![CDATA[public virtual void ResetConfiguration()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="287" sc="3" el="300" ec="4">log4net\Repository\LoggerRepositorySkeleton.cs</location>
            <body hash="390558715b989180797eb2df48057c6f"><![CDATA[{
			// Clear internal data structures
			m_rendererMap.Clear();
			m_levelMap.Clear();
            m_configurationMessages = EmptyCollection.Instance;

			// Add the predefined levels to the map
			AddBuiltinLevels();

			Configured = false;

			// Notify listeners
			OnConfigurationReset(null);
		}]]></body>
          </codeblock>
        </method>
        <method name="Shutdown">
          <declaration><![CDATA[public virtual void Shutdown()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="259" sc="3" el="268" ec="4">log4net\Repository\LoggerRepositorySkeleton.cs</location>
            <body hash="870be22b802986da5f5bd0a4982a4511"><![CDATA[{
			// Shutdown attached plugins
			foreach(IPlugin plugin in PluginMap.AllPlugins)
			{
				plugin.Shutdown();
			}

			// Notify listeners
			OnShutdown(null);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(LoggerRepositorySkeleton);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_configurationChangedEvent">
          <declaration><![CDATA[private LoggerRepositoryConfigurationChangedEventHandler m_configurationChangedEvent;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_configurationMessages">
          <declaration><![CDATA[private ICollection m_configurationMessages;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_configurationResetEvent">
          <declaration><![CDATA[private LoggerRepositoryConfigurationResetEventHandler m_configurationResetEvent;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_configured">
          <declaration><![CDATA[private bool m_configured;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_levelMap">
          <declaration><![CDATA[private LevelMap m_levelMap;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_name">
          <declaration><![CDATA[private string m_name;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_pluginMap">
          <declaration><![CDATA[private PluginMap m_pluginMap;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_properties">
          <declaration><![CDATA[private PropertiesDictionary m_properties;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_rendererMap">
          <declaration><![CDATA[private RendererMap m_rendererMap;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_shutdownEvent">
          <declaration><![CDATA[private LoggerRepositoryShutdownEventHandler m_shutdownEvent;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_threshold">
          <declaration><![CDATA[private Level m_threshold;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="ConfigurationMessages">
          <declaration><![CDATA[public virtual ICollection ConfigurationMessages]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Configured">
          <declaration><![CDATA[public virtual bool Configured]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="LevelMap">
          <declaration><![CDATA[public virtual LevelMap LevelMap]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Name">
          <declaration><![CDATA[public virtual string Name]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="PluginMap">
          <declaration><![CDATA[public virtual PluginMap PluginMap]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Properties">
          <declaration><![CDATA[public PropertiesDictionary Properties]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="RendererMap">
          <declaration><![CDATA[public virtual RendererMap RendererMap]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Threshold">
          <declaration><![CDATA[public virtual Level Threshold]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="138" sc="4" el="149" ec="5">log4net\Repository\LoggerRepositorySkeleton.cs</location>
            <body hash="42aa336ba9f31c1509afb8de08f134bf"><![CDATA[{ 
				if (value != null)
				{
					m_threshold = value; 
				}
				else
				{
					// Must not set threshold to null
					LogLog.Warn(declaringType, "LoggerRepositorySkeleton: Threshold cannot be set to null. Setting to ALL");
					m_threshold = Level.All;
				}
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
        <event name="ConfigurationChanged">
          <declaration><![CDATA[public event LoggerRepositoryConfigurationChangedEventHandler ConfigurationChanged]]></declaration>
          <documentation>
          </documentation>
        </event>
        <event name="ConfigurationReset">
          <declaration><![CDATA[public event LoggerRepositoryConfigurationResetEventHandler ConfigurationReset]]></declaration>
          <documentation>
          </documentation>
        </event>
        <event name="m_configurationChangedEvent">
          <declaration><![CDATA[private event LoggerRepositoryConfigurationChangedEventHandler m_configurationChangedEvent;]]></declaration>
          <documentation>
          </documentation>
        </event>
        <event name="m_configurationResetEvent">
          <declaration><![CDATA[private event LoggerRepositoryConfigurationResetEventHandler m_configurationResetEvent;]]></declaration>
          <documentation>
          </documentation>
        </event>
        <event name="m_shutdownEvent">
          <declaration><![CDATA[private event LoggerRepositoryShutdownEventHandler m_shutdownEvent;]]></declaration>
          <documentation>
          </documentation>
        </event>
        <event name="ShutdownEvent">
          <declaration><![CDATA[public event LoggerRepositoryShutdownEventHandler ShutdownEvent]]></declaration>
          <documentation>
          </documentation>
        </event>
      </events>
    </class>
  </namespace>
  <namespace name="log4net.Repository.Hierarchy">
    <class name="DefaultLoggerFactory">
      <declaration><![CDATA[internal class DefaultLoggerFactory : ILoggerFactory]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[internal DefaultLoggerFactory()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="48" sc="3" el="50" ec="4">log4net\Repository\Hierarchy\DefaultLoggerFactory.cs</location>
            <body hash="60921d9e9592d815a085852bc49893df"><![CDATA[internal DefaultLoggerFactory()
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CreateLogger">
          <declaration><![CDATA[public Logger CreateLogger(ILoggerRepository repository, string name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="77" sc="3" el="83" ec="4">log4net\Repository\Hierarchy\DefaultLoggerFactory.cs</location>
            <body hash="9bffe873deef9b009db8c92e39b33580"><![CDATA[{
			if (name == null)
			{
				return new RootLogger(repository.LevelMap.LookupWithDefault(Level.Debug));
			}
			return new LoggerImpl(name);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="Hierarchy">
      <declaration><![CDATA[public class Hierarchy : LoggerRepositorySkeleton, IBasicRepositoryConfigurator, IXmlRepositoryConfigurator]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public Hierarchy() : this(new DefaultLoggerFactory())]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="152" sc="24" el="154" ec="4">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="7f1bfcab18fbffa0a583eccb1aabd0de"><![CDATA[this(new DefaultLoggerFactory())
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public Hierarchy(PropertiesDictionary properties) : this(properties, new DefaultLoggerFactory())]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="165" sc="55" el="167" ec="4">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="516830664e28985546e444eca64585e3"><![CDATA[this(properties, new DefaultLoggerFactory())
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public Hierarchy(ILoggerFactory loggerFactory) : this(new PropertiesDictionary(), loggerFactory)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="179" sc="52" el="181" ec="4">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="be3904e99a3353e213c496f676e03756"><![CDATA[this(new PropertiesDictionary(), loggerFactory)
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private bool m_emittedNoAppenderWarning = false;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="194" sc="85" el="1067" ec="51">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="3ce08df8f1963ca2d66e2992d4475679"><![CDATA[base(properties)
		{
			if (loggerFactory == null)
			{
				throw new ArgumentNullException("loggerFactory");
			}

			m_defaultFactory = loggerFactory;

			m_ht = System.Collections.Hashtable.Synchronized(new System.Collections.Hashtable());
		}

		#endregion Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Has no appender warning been emitted
		/// </summary>
		/// <remarks>
		/// <para>
		/// Flag to indicate if we have already issued a warning
		/// about not having an appender warning.
		/// </para>
		/// </remarks>
		public bool EmittedNoAppenderWarning
		{
			get { return m_emittedNoAppenderWarning; }
			set { m_emittedNoAppenderWarning = value; }
		}

		/// <summary>
		/// Get the root of this hierarchy
		/// </summary>
		/// <remarks>
		/// <para>
		/// Get the root of this hierarchy.
		/// </para>
		/// </remarks>
		public Logger Root
		{
			get 
			{ 
				if (m_root == null)
				{
					lock(this)
					{
						if (m_root == null)
						{
							// Create the root logger
							Logger root = m_defaultFactory.CreateLogger(this, null);
							root.Hierarchy = this;

							// Store root
							m_root = root;
						}
					}
				}
				return m_root; 
			}
		}

		/// <summary>
		/// Gets or sets the default <see cref="ILoggerFactory" /> instance.
		/// </summary>
		/// <value>The default <see cref="ILoggerFactory" /></value>
		/// <remarks>
		/// <para>
		/// The logger factory is used to create logger instances.
		/// </para>
		/// </remarks>
		public ILoggerFactory LoggerFactory
		{
			get { return m_defaultFactory; }
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				m_defaultFactory = value;
			}
		}

		#endregion Public Instance Properties

		#region Override Implementation of LoggerRepositorySkeleton

		/// <summary>
		/// Test if a logger exists
		/// </summary>
		/// <param name="name">The name of the logger to lookup</param>
		/// <returns>The Logger object with the name specified</returns>
		/// <remarks>
		/// <para>
		/// Check if the named logger exists in the hierarchy. If so return
		/// its reference, otherwise returns <c>null</c>.
		/// </para>
		/// </remarks>
		override public ILogger Exists(string name) 
		{	
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}

			lock(m_ht) 
			{
				return m_ht[new LoggerKey(name)] as Logger;
			}
		}

		/// <summary>
		/// Returns all the currently defined loggers in the hierarchy as an Array
		/// </summary>
		/// <returns>All the defined loggers</returns>
		/// <remarks>
		/// <para>
		/// Returns all the currently defined loggers in the hierarchy as an Array.
		/// The root logger is <b>not</b> included in the returned
		/// enumeration.
		/// </para>
		/// </remarks>
		override public ILogger[] GetCurrentLoggers() 
		{
			// The accumulation in loggers is necessary because not all elements in
			// ht are Logger objects as there might be some ProvisionNodes
			// as well.
			lock(m_ht) 
			{
				System.Collections.ArrayList loggers = new System.Collections.ArrayList(m_ht.Count);
	
				// Iterate through m_ht values
				foreach(object node in m_ht.Values)
				{
					if (node is Logger) 
					{
						loggers.Add(node);
					}
				}
				return (Logger[])loggers.ToArray(typeof(Logger));
			}
		}

		/// <summary>
		/// Return a new logger instance named as the first parameter using
		/// the default factory.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Return a new logger instance named as the first parameter using
		/// the default factory.
		/// </para>
		/// <para>
		/// If a logger of that name already exists, then it will be
		/// returned.  Otherwise, a new logger will be instantiated and
		/// then linked with its existing ancestors as well as children.
		/// </para>
		/// </remarks>
		/// <param name="name">The name of the logger to retrieve</param>
		/// <returns>The logger object with the name specified</returns>
		override public ILogger GetLogger(string name) 
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}

			return GetLogger(name, m_defaultFactory);
		}

		/// <summary>
		/// Shutting down a hierarchy will <i>safely</i> close and remove
		/// all appenders in all loggers including the root logger.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Shutting down a hierarchy will <i>safely</i> close and remove
		/// all appenders in all loggers including the root logger.
		/// </para>
		/// <para>
		/// Some appenders need to be closed before the
		/// application exists. Otherwise, pending logging events might be
		/// lost.
		/// </para>
		/// <para>
		/// The <c>Shutdown</c> method is careful to close nested
		/// appenders before closing regular appenders. This is allows
		/// configurations where a regular appender is attached to a logger
		/// and again to a nested appender.
		/// </para>
		/// </remarks>
		override public void Shutdown() 
		{
			LogLog.Debug(declaringType, "Shutdown called on Hierarchy ["+this.Name+"]");

			// begin by closing nested appenders
			Root.CloseNestedAppenders();

			lock(m_ht) 
			{
				ILogger[] currentLoggers = this.GetCurrentLoggers();

				foreach(Logger logger in currentLoggers)
				{
					logger.CloseNestedAppenders();
				}

				// then, remove all appenders
				Root.RemoveAllAppenders();

				foreach(Logger logger in currentLoggers)
				{
					logger.RemoveAllAppenders();
				}
			}

			base.Shutdown();
		}

		/// <summary>
		/// Reset all values contained in this hierarchy instance to their default.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Reset all values contained in this hierarchy instance to their
		/// default.  This removes all appenders from all loggers, sets
		/// the level of all non-root loggers to <c>null</c>,
		/// sets their additivity flag to <c>true</c> and sets the level
		/// of the root logger to <see cref="Level.Debug"/>. Moreover,
		/// message disabling is set its default "off" value.
		/// </para>
		/// <para>
		/// Existing loggers are not removed. They are just reset.
		/// </para>
		/// <para>
		/// This method should be used sparingly and with care as it will
		/// block all logging until it is completed.
		/// </para>
		/// </remarks>
		override public void ResetConfiguration() 
		{
			Root.Level = LevelMap.LookupWithDefault(Level.Debug);
			Threshold = LevelMap.LookupWithDefault(Level.All);
	
			// the synchronization is needed to prevent hashtable surprises
			lock(m_ht) 
			{	
				Shutdown(); // nested locks are OK	
	
				foreach(Logger l in this.GetCurrentLoggers())
				{
					l.Level = null;
					l.Additivity = true;
				}
			}

			base.ResetConfiguration();

			// Notify listeners
			OnConfigurationChanged(null);
		}

		/// <summary>
		/// Log the logEvent through this hierarchy.
		/// </summary>
		/// <param name="logEvent">the event to log</param>
		/// <remarks>
		/// <para>
		/// This method should not normally be used to log.
		/// The <see cref="ILog"/> interface should be used 
		/// for routine logging. This interface can be obtained
		/// using the <see cref="M:log4net.LogManager.GetLogger(string)"/> method.
		/// </para>
		/// <para>
		/// The <c>logEvent</c> is delivered to the appropriate logger and
		/// that logger is then responsible for logging the event.
		/// </para>
		/// </remarks>
		override public void Log(LoggingEvent logEvent)
		{
			if (logEvent == null)
			{
				throw new ArgumentNullException("logEvent");
			}

			this.GetLogger(logEvent.LoggerName, m_defaultFactory).Log(logEvent);
		}

		/// <summary>
		/// Returns all the Appenders that are currently configured
		/// </summary>
		/// <returns>An array containing all the currently configured appenders</returns>
		/// <remarks>
		/// <para>
		/// Returns all the <see cref="log4net.Appender.IAppender"/> instances that are currently configured.
		/// All the loggers are searched for appenders. The appenders may also be containers
		/// for appenders and these are also searched for additional loggers.
		/// </para>
		/// <para>
		/// The list returned is unordered but does not contain duplicates.
		/// </para>
		/// </remarks>
		override public Appender.IAppender[] GetAppenders()
		{
			System.Collections.ArrayList appenderList = new System.Collections.ArrayList();

			CollectAppenders(appenderList, Root);

			foreach(Logger logger in GetCurrentLoggers())
			{
				CollectAppenders(appenderList, logger);
			}

			return (Appender.IAppender[])appenderList.ToArray(typeof(Appender.IAppender));
		}

		#endregion Override Implementation of LoggerRepositorySkeleton

        #region Private Static Methods

        /// <summary>
		/// Collect the appenders from an <see cref="IAppenderAttachable"/>.
		/// The appender may also be a container.
		/// </summary>
		/// <param name="appenderList"></param>
		/// <param name="appender"></param>
		private static void CollectAppender(System.Collections.ArrayList appenderList, Appender.IAppender appender)
		{
			if (!appenderList.Contains(appender))
			{
				appenderList.Add(appender);

				IAppenderAttachable container = appender as IAppenderAttachable;
				if (container != null)
				{
					CollectAppenders(appenderList, container);
				}
			}
		}

		/// <summary>
		/// Collect the appenders from an <see cref="IAppenderAttachable"/> container
		/// </summary>
		/// <param name="appenderList"></param>
		/// <param name="container"></param>
		private static void CollectAppenders(System.Collections.ArrayList appenderList, IAppenderAttachable container)
		{
			foreach(Appender.IAppender appender in container.Appenders)
			{
				CollectAppender(appenderList, appender);
			}
        }

        #endregion

        #region Implementation of IBasicRepositoryConfigurator

        /// <summary>
		/// Initialize the log4net system using the specified appender
		/// </summary>
		/// <param name="appender">the appender to use to log all logging events</param>
		void IBasicRepositoryConfigurator.Configure(IAppender appender)
		{
			BasicRepositoryConfigure(appender);
		}

        /// <summary>
        /// Initialize the log4net system using the specified appenders
        /// </summary>
        /// <param name="appenders">the appenders to use to log all logging events</param>
        void IBasicRepositoryConfigurator.Configure(params IAppender[] appenders)
        {
            BasicRepositoryConfigure(appenders);
        }

		/// <summary>
		/// Initialize the log4net system using the specified appenders
		/// </summary>
		/// <param name="appenders">the appenders to use to log all logging events</param>
		/// <remarks>
		/// <para>
		/// This method provides the same functionality as the 
		/// <see cref="M:IBasicRepositoryConfigurator.Configure(IAppender)"/> method implemented
		/// on this object, but it is protected and therefore can be called by subclasses.
		/// </para>
		/// </remarks>
		protected void BasicRepositoryConfigure(params IAppender[] appenders)
		{
            ArrayList configurationMessages = new ArrayList();

            using (new LogLog.LogReceivedAdapter(configurationMessages))
            {
                foreach (IAppender appender in appenders)
                {
                    Root.AddAppender(appender);
                }
            }

		    Configured = true;

            ConfigurationMessages = configurationMessages;

			// Notify listeners
            OnConfigurationChanged(new ConfigurationChangedEventArgs(configurationMessages));
		}

	    #endregion Implementation of IBasicRepositoryConfigurator

		#region Implementation of IXmlRepositoryConfigurator

		/// <summary>
		/// Initialize the log4net system using the specified config
		/// </summary>
		/// <param name="element">the element containing the root of the config</param>
		void IXmlRepositoryConfigurator.Configure(System.Xml.XmlElement element)
		{
			XmlRepositoryConfigure(element);
		}

		/// <summary>
		/// Initialize the log4net system using the specified config
		/// </summary>
		/// <param name="element">the element containing the root of the config</param>
		/// <remarks>
		/// <para>
		/// This method provides the same functionality as the 
		/// <see cref="M:IBasicRepositoryConfigurator.Configure(IAppender)"/> method implemented
		/// on this object, but it is protected and therefore can be called by subclasses.
		/// </para>
		/// </remarks>
		protected void XmlRepositoryConfigure(System.Xml.XmlElement element)
		{
            ArrayList configurationMessages = new ArrayList();

            using (new LogLog.LogReceivedAdapter(configurationMessages))
		    {
		        XmlHierarchyConfigurator config = new XmlHierarchyConfigurator(this);
                config.Configure(element);
		    }

		    Configured = true;

            ConfigurationMessages = configurationMessages;

			// Notify listeners
            OnConfigurationChanged(new ConfigurationChangedEventArgs(configurationMessages));
		}

		#endregion Implementation of IXmlRepositoryConfigurator

		#region Public Instance Methods

		/// <summary>
		/// Test if this hierarchy is disabled for the specified <see cref="Level"/>.
		/// </summary>
		/// <param name="level">The level to check against.</param>
		/// <returns>
		/// <c>true</c> if the repository is disabled for the level argument, <c>false</c> otherwise.
		/// </returns>
		/// <remarks>
		/// <para>
		/// If this hierarchy has not been configured then this method will
		/// always return <c>true</c>.
		/// </para>
		/// <para>
		/// This method will return <c>true</c> if this repository is
		/// disabled for <c>level</c> object passed as parameter and
		/// <c>false</c> otherwise.
		/// </para>
		/// <para>
		/// See also the <see cref="ILoggerRepository.Threshold"/> property.
		/// </para>
		/// </remarks>
		public bool IsDisabled(Level level) 
		{
			// Cast level to object for performance
			if ((object)level == null)
			{
				throw new ArgumentNullException("level");
			}

			if (Configured)
			{
				return Threshold > level;
			}
			else
			{
				// If not configured the hierarchy is effectively disabled
				return true;
			}
		}

		/// <summary>
		/// Clear all logger definitions from the internal hashtable
		/// </summary>
		/// <remarks>
		/// <para>
		/// This call will clear all logger definitions from the internal
		/// hashtable. Invoking this method will irrevocably mess up the
		/// logger hierarchy.
		/// </para>
		/// <para>
		/// You should <b>really</b> know what you are doing before
		/// invoking this method.
		/// </para>
		/// </remarks>
		public void Clear() 
		{
			lock(m_ht) 
			{
				m_ht.Clear();
			}
		}

		/// <summary>
		/// Return a new logger instance named as the first parameter using
		/// <paramref name="factory"/>.
		/// </summary>
		/// <param name="name">The name of the logger to retrieve</param>
		/// <param name="factory">The factory that will make the new logger instance</param>
		/// <returns>The logger object with the name specified</returns>
		/// <remarks>
		/// <para>
		/// If a logger of that name already exists, then it will be
		/// returned. Otherwise, a new logger will be instantiated by the
		/// <paramref name="factory"/> parameter and linked with its existing
		/// ancestors as well as children.
		/// </para>
		/// </remarks>
		public Logger GetLogger(string name, ILoggerFactory factory) 
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			if (factory == null)
			{
				throw new ArgumentNullException("factory");
			}

			LoggerKey key = new LoggerKey(name);   
 
			// Synchronize to prevent write conflicts. Read conflicts (in
			// GetEffectiveLevel() method) are possible only if variable
			// assignments are non-atomic.

			lock(m_ht) 
			{
				Logger logger = null;

				Object node = m_ht[key];
				if (node == null) 
				{
					logger = factory.CreateLogger(this, name);
					logger.Hierarchy = this;
					m_ht[key] = logger;	  
					UpdateParents(logger);
					OnLoggerCreationEvent(logger);
					return logger;
				} 
				
				Logger nodeLogger = node as Logger;
				if (nodeLogger != null) 
				{
					return nodeLogger;
				} 
				
				ProvisionNode nodeProvisionNode = node as ProvisionNode;
				if (nodeProvisionNode != null) 
				{
					logger = factory.CreateLogger(this, name);
					logger.Hierarchy = this; 
					m_ht[key] = logger;
					UpdateChildren(nodeProvisionNode, logger);
					UpdateParents(logger);	
					OnLoggerCreationEvent(logger);
					return logger;
				}

				// It should be impossible to arrive here but let's keep the compiler happy.
				return null;
			}
		}

		#endregion Public Instance Methods

		#region Protected Instance Methods

		/// <summary>
		/// Sends a logger creation event to all registered listeners
		/// </summary>
		/// <param name="logger">The newly created logger</param>
		/// <remarks>
		/// Raises the logger creation event.
		/// </remarks>
		protected virtual void OnLoggerCreationEvent(Logger logger) 
		{
			LoggerCreationEventHandler handler = m_loggerCreatedEvent;
			if (handler != null)
			{
				handler(this, new LoggerCreationEventArgs(logger));
			}
		}

		#endregion Protected Instance Methods

		#region Private Instance Methods

		/// <summary>
		/// Updates all the parents of the specified logger
		/// </summary>
		/// <param name="log">The logger to update the parents for</param>
		/// <remarks>
		/// <para>
		/// This method loops through all the <i>potential</i> parents of
		/// <paramref name="log"/>. There 3 possible cases:
		/// </para>
		/// <list type="number">
		///		<item>
		///			<term>No entry for the potential parent of <paramref name="log"/> exists</term>
		///			<description>
		///			We create a ProvisionNode for this potential 
		///			parent and insert <paramref name="log"/> in that provision node.
		///			</description>
		///		</item>
		///		<item>
		///			<term>The entry is of type Logger for the potential parent.</term>
		///			<description>
		///			The entry is <paramref name="log"/>'s nearest existing parent. We 
		///			update <paramref name="log"/>'s parent field with this entry. We also break from 
		///			he loop because updating our parent's parent is our parent's 
		///			responsibility.
		///			</description>
		///		</item>
		///		<item>
		///			<term>The entry is of type ProvisionNode for this potential parent.</term>
		///			<description>
		///			We add <paramref name="log"/> to the list of children for this 
		///			potential parent.
		///			</description>
		///		</item>
		/// </list>
		/// </remarks>
		private void UpdateParents(Logger log) 
		{
			string name = log.Name;
			int length = name.Length;
			bool parentFound = false;
	
			// if name = "w.x.y.z", loop through "w.x.y", "w.x" and "w", but not "w.x.y.z" 
			for(int i = name.LastIndexOf('.', length-1); i >= 0; i = name.LastIndexOf('.', i-1))  
			{
				string substr = name.Substring(0, i);

				LoggerKey key = new LoggerKey(substr); // simple constructor
				Object node = m_ht[key];
				// Create a provision node for a future parent.
				if (node == null) 
				{
					ProvisionNode pn = new ProvisionNode(log);
					m_ht[key] = pn;
				} 
				else
				{
					Logger nodeLogger = node as Logger;
					if (nodeLogger != null)
					{
						parentFound = true;
						log.Parent = nodeLogger;
						break; // no need to update the ancestors of the closest ancestor
					}
					else
					{
						ProvisionNode nodeProvisionNode = node as ProvisionNode;
						if (nodeProvisionNode != null)
						{
							nodeProvisionNode.Add(log);
						}
						else
						{
							LogLog.Error(declaringType, "Unexpected object type ["+node.GetType()+"] in ht.", new LogException());
						}
					} 
				}
				if (i == 0) {
				    // logger name starts with a dot
				    // and we've hit the start
				    break;
				}
			}

			// If we could not find any existing parents, then link with root.
			if (!parentFound) 
			{
				log.Parent = this.Root;
			}
		}

		/// <summary>
		/// Replace a <see cref="ProvisionNode"/> with a <see cref="Logger"/> in the hierarchy.
		/// </summary>
		/// <param name="pn"></param>
		/// <param name="log"></param>
		/// <remarks>
		/// <para>
		/// We update the links for all the children that placed themselves
		/// in the provision node 'pn'. The second argument 'log' is a
		/// reference for the newly created Logger, parent of all the
		/// children in 'pn'.
		/// </para>
		/// <para>
		/// We loop on all the children 'c' in 'pn'.
		/// </para>
		/// <para>
		/// If the child 'c' has been already linked to a child of
		/// 'log' then there is no need to update 'c'.
		/// </para>
		/// <para>
		/// Otherwise, we set log's parent field to c's parent and set
		/// c's parent field to log.
		/// </para>
		/// </remarks>
		private static void UpdateChildren(ProvisionNode pn, Logger log) 
		{
			for(int i = 0; i < pn.Count; i++) 
			{
				Logger childLogger = (Logger)pn[i];

				// Unless this child already points to a correct (lower) parent,
				// make log.Parent point to childLogger.Parent and childLogger.Parent to log.
				if (!childLogger.Parent.Name.StartsWith(log.Name)) 
				{
					log.Parent = childLogger.Parent;
					childLogger.Parent = log;	  
				}
			}
		}

		/// <summary>
		/// Define or redefine a Level using the values in the <see cref="LevelEntry"/> argument
		/// </summary>
		/// <param name="levelEntry">the level values</param>
		/// <remarks>
		/// <para>
		/// Define or redefine a Level using the values in the <see cref="LevelEntry"/> argument
		/// </para>
		/// <para>
		/// Supports setting levels via the configuration file.
		/// </para>
		/// </remarks>
		internal void AddLevel(LevelEntry levelEntry)
		{
			if (levelEntry == null) throw new ArgumentNullException("levelEntry");
			if (levelEntry.Name == null) throw new ArgumentNullException("levelEntry.Name");

			// Lookup replacement value
			if (levelEntry.Value == -1)
			{
				Level previousLevel = LevelMap[levelEntry.Name];
				if (previousLevel == null)
				{
					throw new InvalidOperationException("Cannot redefine level ["+levelEntry.Name+"] because it is not defined in the LevelMap. To define the level supply the level value.");
				}

				levelEntry.Value = previousLevel.Value;
			}

			LevelMap.Add(levelEntry.Name, levelEntry.Value, levelEntry.DisplayName);
		}

		/// <summary>
		/// A class to hold the value, name and display name for a level
		/// </summary>
		/// <remarks>
		/// <para>
		/// A class to hold the value, name and display name for a level
		/// </para>
		/// </remarks>
		internal class LevelEntry
		{
			private int m_levelValue = -1;
			private string m_levelName = null;
			private string m_levelDisplayName = null;

			/// <summary>
			/// Value of the level
			/// </summary>
			/// <remarks>
			/// <para>
			/// If the value is not set (defaults to -1) the value will be looked
			/// up for the current level with the same name.
			/// </para>
			/// </remarks>
			public int Value
			{
				get { return m_levelValue; }
				set { m_levelValue = value; }
			}

			/// <summary>
			/// Name of the level
			/// </summary>
			/// <value>
			/// The name of the level
			/// </value>
			/// <remarks>
			/// <para>
			/// The name of the level.
			/// </para>
			/// </remarks>
			public string Name
			{
				get { return m_levelName; }
				set { m_levelName = value; }
			}

			/// <summary>
			/// Display name for the level
			/// </summary>
			/// <value>
			/// The display name of the level
			/// </value>
			/// <remarks>
			/// <para>
			/// The display name of the level.
			/// </para>
			/// </remarks>
			public string DisplayName
			{
				get { return m_levelDisplayName; }
				set { m_levelDisplayName = value; }
			}

			/// <summary>
			/// Override <c>Object.ToString</c> to return sensible debug info
			/// </summary>
			/// <returns>string info about this object</returns>
			public override string ToString()
			{
				return "LevelEntry(Value="+m_levelValue+", Name="+m_levelName+", DisplayName="+m_levelDisplayName+")";
			}
		}

		/// <summary>
		/// Set a Property using the values in the <see cref="LevelEntry"/> argument
		/// </summary>
		/// <param name="propertyEntry">the property value</param>
		/// <remarks>
		/// <para>
		/// Set a Property using the values in the <see cref="LevelEntry"/> argument.
		/// </para>
		/// <para>
		/// Supports setting property values via the configuration file.
		/// </para>
		/// </remarks>
		internal void AddProperty(PropertyEntry propertyEntry)
		{
			if (propertyEntry == null) throw new ArgumentNullException("propertyEntry");
			if (propertyEntry.Key == null) throw new ArgumentNullException("propertyEntry.Key");

			Properties[propertyEntry.Key] = propertyEntry.Value;
		}

		#endregion Private Instance Methods

		#region Private Instance Fields

		private ILoggerFactory m_defaultFactory;

		private System.Collections.Hashtable m_ht;
		private Logger m_root;
  
		private bool m_emittedNoAppenderWarning = false;]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static Hierarchy()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1082" sc="6" el="1082" ec="69">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="0817406aa34da082f9989ba3c638b629"><![CDATA[private readonly static Type declaringType = typeof(Hierarchy)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="add_LoggerCreatedEvent">
          <declaration><![CDATA[public void add_LoggerCreatedEvent(LoggerCreationEventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="136" sc="8" el="136" ec="9">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="add_m_loggerCreatedEvent">
          <declaration><![CDATA[private void add_m_loggerCreatedEvent(LoggerCreationEventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="AddLevel">
          <declaration><![CDATA[internal void AddLevel(Hierarchy.LevelEntry levelEntry)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="946" sc="3" el="963" ec="4">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="292c41ab43c1ae1e12de4e8ded8d568d"><![CDATA[{
			if (levelEntry == null) throw new ArgumentNullException("levelEntry");
			if (levelEntry.Name == null) throw new ArgumentNullException("levelEntry.Name");

			// Lookup replacement value
			if (levelEntry.Value == -1)
			{
				Level previousLevel = LevelMap[levelEntry.Name];
				if (previousLevel == null)
				{
					throw new InvalidOperationException("Cannot redefine level ["+levelEntry.Name+"] because it is not defined in the LevelMap. To define the level supply the level value.");
				}

				levelEntry.Value = previousLevel.Value;
			}

			LevelMap.Add(levelEntry.Name, levelEntry.Value, levelEntry.DisplayName);
		}]]></body>
          </codeblock>
        </method>
        <method name="AddProperty">
          <declaration><![CDATA[internal void AddProperty(PropertyEntry propertyEntry)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1051" sc="3" el="1056" ec="4">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="20a588b46ab45b8e6031e3594c63b6ab"><![CDATA[{
			if (propertyEntry == null) throw new ArgumentNullException("propertyEntry");
			if (propertyEntry.Key == null) throw new ArgumentNullException("propertyEntry.Key");

			Properties[propertyEntry.Key] = propertyEntry.Value;
		}]]></body>
          </codeblock>
        </method>
        <method name="BasicRepositoryConfigure">
          <declaration><![CDATA[protected void BasicRepositoryConfigure(params IAppender[] appenders)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="582" sc="3" el="599" ec="4">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="e20eaefb5ea0362a33319db451b4c72f"><![CDATA[{
            ArrayList configurationMessages = new ArrayList();

            using (new LogLog.LogReceivedAdapter(configurationMessages))
            {
                foreach (IAppender appender in appenders)
                {
                    Root.AddAppender(appender);
                }
            }

		    Configured = true;

            ConfigurationMessages = configurationMessages;

			// Notify listeners
            OnConfigurationChanged(new ConfigurationChangedEventArgs(configurationMessages));
		}]]></body>
          </codeblock>
        </method>
        <method name="Clear">
          <declaration><![CDATA[public void Clear()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="702" sc="3" el="707" ec="4">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="507d0d0e870e242127ad03629251e14c"><![CDATA[{
			lock(m_ht) 
			{
				m_ht.Clear();
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="CollectAppender">
          <declaration><![CDATA[private static void CollectAppender(ArrayList appenderList, IAppender appender)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="522" sc="3" el="533" ec="4">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="6c982c0da9393ea5222b1fa6e8be23ac"><![CDATA[{
			if (!appenderList.Contains(appender))
			{
				appenderList.Add(appender);

				IAppenderAttachable container = appender as IAppenderAttachable;
				if (container != null)
				{
					CollectAppenders(appenderList, container);
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="CollectAppenders">
          <declaration><![CDATA[private static void CollectAppenders(ArrayList appenderList, IAppenderAttachable container)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="541" sc="3" el="546" ec="10">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="cbd682d4a837cf2ae706988976a9bf68"><![CDATA[{
			foreach(Appender.IAppender appender in container.Appenders)
			{
				CollectAppender(appenderList, appender);
			}
        }]]></body>
          </codeblock>
        </method>
        <method name="Exists">
          <declaration><![CDATA[public override ILogger Exists(string name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="294" sc="3" el="304" ec="4">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="e5543c787bade5456c745c2e64558ef2"><![CDATA[{	
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}

			lock(m_ht) 
			{
				return m_ht[new LoggerKey(name)] as Logger;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="GetAppenders">
          <declaration><![CDATA[public override IAppender[] GetAppenders()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="498" sc="3" el="509" ec="4">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="787668fec4a40d203059887fbf7c51bc"><![CDATA[{
			System.Collections.ArrayList appenderList = new System.Collections.ArrayList();

			CollectAppenders(appenderList, Root);

			foreach(Logger logger in GetCurrentLoggers())
			{
				CollectAppenders(appenderList, logger);
			}

			return (Appender.IAppender[])appenderList.ToArray(typeof(Appender.IAppender));
		}]]></body>
          </codeblock>
        </method>
        <method name="GetCurrentLoggers">
          <declaration><![CDATA[public override ILogger[] GetCurrentLoggers()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="318" sc="3" el="336" ec="4">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="6efee58727a7e4dc72c48c90f5aab567"><![CDATA[{
			// The accumulation in loggers is necessary because not all elements in
			// ht are Logger objects as there might be some ProvisionNodes
			// as well.
			lock(m_ht) 
			{
				System.Collections.ArrayList loggers = new System.Collections.ArrayList(m_ht.Count);
	
				// Iterate through m_ht values
				foreach(object node in m_ht.Values)
				{
					if (node is Logger) 
					{
						loggers.Add(node);
					}
				}
				return (Logger[])loggers.ToArray(typeof(Logger));
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="GetLogger">
          <declaration><![CDATA[public override ILogger GetLogger(string name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="356" sc="3" el="363" ec="4">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="1ed96e39fdc5d6bfcc9d9be5ab1d9b53"><![CDATA[{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}

			return GetLogger(name, m_defaultFactory);
		}]]></body>
          </codeblock>
        </method>
        <method name="GetLogger">
          <declaration><![CDATA[public Logger GetLogger(string name, ILoggerFactory factory)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="725" sc="3" el="777" ec="4">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="47b0ec0f8a005f3b4690d7f0c7a52e8d"><![CDATA[{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			if (factory == null)
			{
				throw new ArgumentNullException("factory");
			}

			LoggerKey key = new LoggerKey(name);   
 
			// Synchronize to prevent write conflicts. Read conflicts (in
			// GetEffectiveLevel() method) are possible only if variable
			// assignments are non-atomic.

			lock(m_ht) 
			{
				Logger logger = null;

				Object node = m_ht[key];
				if (node == null) 
				{
					logger = factory.CreateLogger(this, name);
					logger.Hierarchy = this;
					m_ht[key] = logger;	  
					UpdateParents(logger);
					OnLoggerCreationEvent(logger);
					return logger;
				} 
				
				Logger nodeLogger = node as Logger;
				if (nodeLogger != null) 
				{
					return nodeLogger;
				} 
				
				ProvisionNode nodeProvisionNode = node as ProvisionNode;
				if (nodeProvisionNode != null) 
				{
					logger = factory.CreateLogger(this, name);
					logger.Hierarchy = this; 
					m_ht[key] = logger;
					UpdateChildren(nodeProvisionNode, logger);
					UpdateParents(logger);	
					OnLoggerCreationEvent(logger);
					return logger;
				}

				// It should be impossible to arrive here but let's keep the compiler happy.
				return null;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="IsDisabled">
          <declaration><![CDATA[public bool IsDisabled(Level level)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="669" sc="3" el="685" ec="4">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="c63168a59f1d666632caa638d55a142a"><![CDATA[{
			// Cast level to object for performance
			if ((object)level == null)
			{
				throw new ArgumentNullException("level");
			}

			if (Configured)
			{
				return Threshold > level;
			}
			else
			{
				// If not configured the hierarchy is effectively disabled
				return true;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Log">
          <declaration><![CDATA[public override void Log(LoggingEvent logEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="474" sc="3" el="481" ec="4">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="51b2b7813d11593442779314578ae528"><![CDATA[{
			if (logEvent == null)
			{
				throw new ArgumentNullException("logEvent");
			}

			this.GetLogger(logEvent.LoggerName, m_defaultFactory).Log(logEvent);
		}]]></body>
          </codeblock>
        </method>
        <method name="log4net.Repository.IBasicRepositoryConfigurator.Configure">
          <declaration><![CDATA[void IBasicRepositoryConfigurator.Configure(IAppender appender)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="557" sc="3" el="559" ec="4">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="6f90d37c33de7e21e5229c615e6b66ab"><![CDATA[{
			BasicRepositoryConfigure(appender);
		}]]></body>
          </codeblock>
        </method>
        <method name="log4net.Repository.IBasicRepositoryConfigurator.Configure">
          <declaration><![CDATA[void IBasicRepositoryConfigurator.Configure(params IAppender[] appenders)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="566" sc="9" el="568" ec="10">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="2f9636f32f6cd8dfbd94282e4fb7e4b4"><![CDATA[{
            BasicRepositoryConfigure(appenders);
        }]]></body>
          </codeblock>
        </method>
        <method name="log4net.Repository.IXmlRepositoryConfigurator.Configure">
          <declaration><![CDATA[void IXmlRepositoryConfigurator.Configure(XmlElement element)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="610" sc="3" el="612" ec="4">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="1343f8b4eeced4da870598ca8bafa024"><![CDATA[{
			XmlRepositoryConfigure(element);
		}]]></body>
          </codeblock>
        </method>
        <method name="OnLoggerCreationEvent">
          <declaration><![CDATA[protected virtual void OnLoggerCreationEvent(Logger logger)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="791" sc="3" el="797" ec="4">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="44f9d9260e87f783886796ea0ba0d03f"><![CDATA[{
			LoggerCreationEventHandler handler = m_loggerCreatedEvent;
			if (handler != null)
			{
				handler(this, new LoggerCreationEventArgs(logger));
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="remove_LoggerCreatedEvent">
          <declaration><![CDATA[public void remove_LoggerCreatedEvent(LoggerCreationEventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="137" sc="11" el="137" ec="12">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="remove_m_loggerCreatedEvent">
          <declaration><![CDATA[private void remove_m_loggerCreatedEvent(LoggerCreationEventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="ResetConfiguration">
          <declaration><![CDATA[public override void ResetConfiguration()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="435" sc="3" el="455" ec="4">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="90791ce81eca9d97a65aa9d5c0b23e55"><![CDATA[{
			Root.Level = LevelMap.LookupWithDefault(Level.Debug);
			Threshold = LevelMap.LookupWithDefault(Level.All);
	
			// the synchronization is needed to prevent hashtable surprises
			lock(m_ht) 
			{	
				Shutdown(); // nested locks are OK	
	
				foreach(Logger l in this.GetCurrentLoggers())
				{
					l.Level = null;
					l.Additivity = true;
				}
			}

			base.ResetConfiguration();

			// Notify listeners
			OnConfigurationChanged(null);
		}]]></body>
          </codeblock>
        </method>
        <method name="Shutdown">
          <declaration><![CDATA[public override void Shutdown()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="387" sc="3" el="412" ec="4">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="1692dd458692788dd6d519c0d856e43f"><![CDATA[{
			LogLog.Debug(declaringType, "Shutdown called on Hierarchy ["+this.Name+"]");

			// begin by closing nested appenders
			Root.CloseNestedAppenders();

			lock(m_ht) 
			{
				ILogger[] currentLoggers = this.GetCurrentLoggers();

				foreach(Logger logger in currentLoggers)
				{
					logger.CloseNestedAppenders();
				}

				// then, remove all appenders
				Root.RemoveAllAppenders();

				foreach(Logger logger in currentLoggers)
				{
					logger.RemoveAllAppenders();
				}
			}

			base.Shutdown();
		}]]></body>
          </codeblock>
        </method>
        <method name="UpdateChildren">
          <declaration><![CDATA[private static void UpdateChildren(ProvisionNode pn, Logger log)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="918" sc="3" el="931" ec="4">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="bcbc324ebfb63fc5a4760708cd6238b3"><![CDATA[{
			for(int i = 0; i < pn.Count; i++) 
			{
				Logger childLogger = (Logger)pn[i];

				// Unless this child already points to a correct (lower) parent,
				// make log.Parent point to childLogger.Parent and childLogger.Parent to log.
				if (!childLogger.Parent.Name.StartsWith(log.Name)) 
				{
					log.Parent = childLogger.Parent;
					childLogger.Parent = log;	  
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="UpdateParents">
          <declaration><![CDATA[private void UpdateParents(Logger log)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="839" sc="3" el="891" ec="4">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="a232ecec251d9628c5d9577bfbd328f5"><![CDATA[{
			string name = log.Name;
			int length = name.Length;
			bool parentFound = false;
	
			// if name = "w.x.y.z", loop through "w.x.y", "w.x" and "w", but not "w.x.y.z" 
			for(int i = name.LastIndexOf('.', length-1); i >= 0; i = name.LastIndexOf('.', i-1))  
			{
				string substr = name.Substring(0, i);

				LoggerKey key = new LoggerKey(substr); // simple constructor
				Object node = m_ht[key];
				// Create a provision node for a future parent.
				if (node == null) 
				{
					ProvisionNode pn = new ProvisionNode(log);
					m_ht[key] = pn;
				} 
				else
				{
					Logger nodeLogger = node as Logger;
					if (nodeLogger != null)
					{
						parentFound = true;
						log.Parent = nodeLogger;
						break; // no need to update the ancestors of the closest ancestor
					}
					else
					{
						ProvisionNode nodeProvisionNode = node as ProvisionNode;
						if (nodeProvisionNode != null)
						{
							nodeProvisionNode.Add(log);
						}
						else
						{
							LogLog.Error(declaringType, "Unexpected object type ["+node.GetType()+"] in ht.", new LogException());
						}
					} 
				}
				if (i == 0) {
				    // logger name starts with a dot
				    // and we've hit the start
				    break;
				}
			}

			// If we could not find any existing parents, then link with root.
			if (!parentFound) 
			{
				log.Parent = this.Root;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="XmlRepositoryConfigure">
          <declaration><![CDATA[protected void XmlRepositoryConfigure(XmlElement element)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="626" sc="3" el="641" ec="4">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="f2de5b2e1593a31e25e028f35ec9c388"><![CDATA[{
            ArrayList configurationMessages = new ArrayList();

            using (new LogLog.LogReceivedAdapter(configurationMessages))
		    {
		        XmlHierarchyConfigurator config = new XmlHierarchyConfigurator(this);
                config.Configure(element);
		    }

		    Configured = true;

            ConfigurationMessages = configurationMessages;

			// Notify listeners
            OnConfigurationChanged(new ConfigurationChangedEventArgs(configurationMessages));
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(Hierarchy);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_defaultFactory">
          <declaration><![CDATA[private ILoggerFactory m_defaultFactory;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_emittedNoAppenderWarning">
          <declaration><![CDATA[private bool m_emittedNoAppenderWarning = false;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_ht">
          <declaration><![CDATA[private Hashtable m_ht;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_loggerCreatedEvent">
          <declaration><![CDATA[private LoggerCreationEventHandler m_loggerCreatedEvent;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_root">
          <declaration><![CDATA[private Logger m_root;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="EmittedNoAppenderWarning">
          <declaration><![CDATA[public bool EmittedNoAppenderWarning]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="LoggerFactory">
          <declaration><![CDATA[public ILoggerFactory LoggerFactory]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="269" sc="4" el="275" ec="5">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="ab1de66b71a4fcf194e9bc9ad0328246"><![CDATA[{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				m_defaultFactory = value;
			}]]></body>
          </codeblock>
        </property>
        <property name="Root">
          <declaration><![CDATA[public Logger Root]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="236" sc="4" el="253" ec="5">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="12bac5b5e45d22c25d13a4b8ddd5b180"><![CDATA[{ 
				if (m_root == null)
				{
					lock(this)
					{
						if (m_root == null)
						{
							// Create the root logger
							Logger root = m_defaultFactory.CreateLogger(this, null);
							root.Hierarchy = this;

							// Store root
							m_root = root;
						}
					}
				}
				return m_root; 
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
        <event name="LoggerCreatedEvent">
          <declaration><![CDATA[public event LoggerCreationEventHandler LoggerCreatedEvent]]></declaration>
          <documentation>
          </documentation>
        </event>
        <event name="m_loggerCreatedEvent">
          <declaration><![CDATA[private event LoggerCreationEventHandler m_loggerCreatedEvent;]]></declaration>
          <documentation>
          </documentation>
        </event>
      </events>
    </class>
    <class name="ILoggerFactory">
      <declaration><![CDATA[public interface ILoggerFactory]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="CreateLogger">
          <declaration><![CDATA[Logger CreateLogger(ILoggerRepository repository, string name);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="Logger">
      <declaration><![CDATA[public abstract class Logger : IAppenderAttachable, ILogger]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private bool m_additive = true;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="74" sc="3" el="785" ec="77">log4net\Repository\Hierarchy\Logger.cs</location>
            <body hash="ad077badf6cdf3d734dfc2dc9d1d7005"><![CDATA[protected Logger(string name) 
		{
#if NETCF || NETSTANDARD1_3
			// NETCF: String.Intern causes Native Exception
			m_name = name;
#else
			m_name = string.Intern(name);
#endif
		}

		#endregion Protected Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Gets or sets the parent logger in the hierarchy.
		/// </summary>
		/// <value>
		/// The parent logger in the hierarchy.
		/// </value>
		/// <remarks>
		/// <para>
		/// Part of the Composite pattern that makes the hierarchy.
		/// The hierarchy is parent linked rather than child linked.
		/// </para>
		/// </remarks>
		virtual public Logger Parent
		{
			get { return m_parent; }
			set { m_parent = value; }
		}

		/// <summary>
		/// Gets or sets a value indicating if child loggers inherit their parent's appenders.
		/// </summary>
		/// <value>
		/// <c>true</c> if child loggers inherit their parent's appenders.
		/// </value>
		/// <remarks>
		/// <para>
		/// Additivity is set to <c>true</c> by default, that is children inherit
		/// the appenders of their ancestors by default. If this variable is
		/// set to <c>false</c> then the appenders found in the
		/// ancestors of this logger are not used. However, the children
		/// of this logger will inherit its appenders, unless the children
		/// have their additivity flag set to <c>false</c> too. See
		/// the user manual for more details.
		/// </para>
		/// </remarks>
		virtual public bool Additivity
		{
			get { return m_additive; }
			set { m_additive = value; }
		}

		/// <summary>
		/// Gets the effective level for this logger.
		/// </summary>
		/// <returns>The nearest level in the logger hierarchy.</returns>
		/// <remarks>
		/// <para>
		/// Starting from this logger, searches the logger hierarchy for a
		/// non-null level and returns it. Otherwise, returns the level of the
		/// root logger.
		/// </para>
		/// <para>The Logger class is designed so that this method executes as
		/// quickly as possible.</para>
		/// </remarks>
		virtual public Level EffectiveLevel
		{
			get 
			{
				for(Logger c = this; c != null; c = c.m_parent) 
				{
					Level level = c.m_level;

					// Casting level to Object for performance, otherwise the overloaded operator is called
					if ((object)level != null) 
					{
						return level;
					}
				}
				return null; // If reached will cause an NullPointerException.
			}
		}

		/// <summary>
		/// Gets or sets the <see cref="Hierarchy"/> where this 
		/// <c>Logger</c> instance is attached to.
		/// </summary>
		/// <value>The hierarchy that this logger belongs to.</value>
		/// <remarks>
		/// <para>
		/// This logger must be attached to a single <see cref="Hierarchy"/>.
		/// </para>
		/// </remarks>
		virtual public Hierarchy Hierarchy
		{
			get { return m_hierarchy; }
			set { m_hierarchy = value; }
		}

		/// <summary>
		/// Gets or sets the assigned <see cref="Level"/>, if any, for this Logger.  
		/// </summary>
		/// <value>
		/// The <see cref="Level"/> of this logger.
		/// </value>
		/// <remarks>
		/// <para>
		/// The assigned <see cref="Level"/> can be <c>null</c>.
		/// </para>
		/// </remarks>
		virtual public Level Level
		{
			get { return m_level; }
			set { m_level = value; }
		}

		#endregion Public Instance Properties

		#region Implementation of IAppenderAttachable

		/// <summary>
		/// Add <paramref name="newAppender"/> to the list of appenders of this
		/// Logger instance.
		/// </summary>
		/// <param name="newAppender">An appender to add to this logger</param>
		/// <remarks>
		/// <para>
		/// Add <paramref name="newAppender"/> to the list of appenders of this
		/// Logger instance.
		/// </para>
		/// <para>
		/// If <paramref name="newAppender"/> is already in the list of
		/// appenders, then it won't be added again.
		/// </para>
		/// </remarks>
		virtual public void AddAppender(IAppender newAppender) 
		{
			if (newAppender == null)
			{
				throw new ArgumentNullException("newAppender");
			}

			m_appenderLock.AcquireWriterLock();
			try
			{
				if (m_appenderAttachedImpl == null) 
				{
					m_appenderAttachedImpl = new log4net.Util.AppenderAttachedImpl();
				}
				m_appenderAttachedImpl.AddAppender(newAppender);
			}
			finally
			{
				m_appenderLock.ReleaseWriterLock();
			}
		}

		/// <summary>
		/// Get the appenders contained in this logger as an 
		/// <see cref="System.Collections.ICollection"/>.
		/// </summary>
		/// <returns>A collection of the appenders in this logger</returns>
		/// <remarks>
		/// <para>
		/// Get the appenders contained in this logger as an 
		/// <see cref="System.Collections.ICollection"/>. If no appenders 
		/// can be found, then a <see cref="EmptyCollection"/> is returned.
		/// </para>
		/// </remarks>
		virtual public AppenderCollection Appenders 
		{
			get
			{
				m_appenderLock.AcquireReaderLock();
				try
				{
					if (m_appenderAttachedImpl == null)
					{
						return AppenderCollection.EmptyCollection;
					}
					else 
					{
						return m_appenderAttachedImpl.Appenders;
					}
				}
				finally
				{
					m_appenderLock.ReleaseReaderLock();
				}
			}
		}

		/// <summary>
		/// Look for the appender named as <c>name</c>
		/// </summary>
		/// <param name="name">The name of the appender to lookup</param>
		/// <returns>The appender with the name specified, or <c>null</c>.</returns>
		/// <remarks>
		/// <para>
		/// Returns the named appender, or null if the appender is not found.
		/// </para>
		/// </remarks>
		virtual public IAppender GetAppender(string name) 
		{
			m_appenderLock.AcquireReaderLock();
			try
			{
				if (m_appenderAttachedImpl == null || name == null)
				{
					return null;
				}

				return m_appenderAttachedImpl.GetAppender(name);
			}
			finally
			{
				m_appenderLock.ReleaseReaderLock();
			}
		}

		/// <summary>
		/// Remove all previously added appenders from this Logger instance.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Remove all previously added appenders from this Logger instance.
		/// </para>
		/// <para>
		/// This is useful when re-reading configuration information.
		/// </para>
		/// </remarks>
		virtual public void RemoveAllAppenders() 
		{
			m_appenderLock.AcquireWriterLock();
			try
			{
				if (m_appenderAttachedImpl != null) 
				{
					m_appenderAttachedImpl.RemoveAllAppenders();
					m_appenderAttachedImpl = null;
				}
			}
			finally
			{
				m_appenderLock.ReleaseWriterLock();
			}
		}

		/// <summary>
		/// Remove the appender passed as parameter form the list of appenders.
		/// </summary>
		/// <param name="appender">The appender to remove</param>
		/// <returns>The appender removed from the list</returns>
		/// <remarks>
		/// <para>
		/// Remove the appender passed as parameter form the list of appenders.
		/// The appender removed is not closed.
		/// If you are discarding the appender you must call
		/// <see cref="IAppender.Close"/> on the appender removed.
		/// </para>
		/// </remarks>
		virtual public IAppender RemoveAppender(IAppender appender) 
		{
			m_appenderLock.AcquireWriterLock();
			try
			{
				if (appender != null && m_appenderAttachedImpl != null) 
				{
					return m_appenderAttachedImpl.RemoveAppender(appender);
				}
			}
			finally
			{
				m_appenderLock.ReleaseWriterLock();
			}
			return null;
		}

		/// <summary>
		/// Remove the appender passed as parameter form the list of appenders.
		/// </summary>
		/// <param name="name">The name of the appender to remove</param>
		/// <returns>The appender removed from the list</returns>
		/// <remarks>
		/// <para>
		/// Remove the named appender passed as parameter form the list of appenders.
		/// The appender removed is not closed.
		/// If you are discarding the appender you must call
		/// <see cref="IAppender.Close"/> on the appender removed.
		/// </para>
		/// </remarks>
		virtual public IAppender RemoveAppender(string name) 
		{
			m_appenderLock.AcquireWriterLock();
			try
			{
				if (name != null && m_appenderAttachedImpl != null)
				{
					return m_appenderAttachedImpl.RemoveAppender(name);
				}
			}
			finally
			{
				m_appenderLock.ReleaseWriterLock();
			}
			return null;
		}
  
		#endregion

		#region Implementation of ILogger

		/// <summary>
		/// Gets the logger name.
		/// </summary>
		/// <value>
		/// The name of the logger.
		/// </value>
		/// <remarks>
		/// <para>
		/// The name of this logger
		/// </para>
		/// </remarks>
		virtual public string Name
		{
			get { return m_name; }
		}

		/// <summary>
		/// This generic form is intended to be used by wrappers.
		/// </summary>
		/// <param name="callerStackBoundaryDeclaringType">The declaring type of the method that is
		/// the stack boundary into the logging system for this call.</param>
		/// <param name="level">The level of the message to be logged.</param>
		/// <param name="message">The message object to log.</param>
		/// <param name="exception">The exception to log, including its stack trace.</param>
		/// <remarks>
		/// <para>
		/// Generate a logging event for the specified <paramref name="level"/> using
		/// the <paramref name="message"/> and <paramref name="exception"/>.
		/// </para>
		/// <para>
		/// This method must not throw any exception to the caller.
		/// </para>
		/// </remarks>
		virtual public void Log(Type callerStackBoundaryDeclaringType, Level level, object message, Exception exception) 
		{
			try
			{
				if (IsEnabledFor(level))
				{
                    ForcedLog((callerStackBoundaryDeclaringType != null) ? callerStackBoundaryDeclaringType : declaringType, level, message, exception);
				}
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
#if !NET_2_0 && !MONO_2_0 && !MONO_3_5 && !MONO_4_0 && !NETSTANDARD1_3
			catch
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging");
			}
#endif
		}

		/// <summary>
		/// This is the most generic printing method that is intended to be used 
		/// by wrappers.
		/// </summary>
		/// <param name="logEvent">The event being logged.</param>
		/// <remarks>
		/// <para>
		/// Logs the specified logging event through this logger.
		/// </para>
		/// <para>
		/// This method must not throw any exception to the caller.
		/// </para>
		/// </remarks>
		virtual public void Log(LoggingEvent logEvent)
		{
			try
			{
				if (logEvent != null)
				{
					if (IsEnabledFor(logEvent.Level))
					{
						ForcedLog(logEvent);
					}
				}
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
#if !NET_2_0 && !MONO_2_0 && !MONO_3_5 && !MONO_4_0 && !NETSTANDARD1_3
			catch
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging");
			}
#endif
		}

		/// <summary>
		/// Checks if this logger is enabled for a given <see cref="Level"/> passed as parameter.
		/// </summary>
		/// <param name="level">The level to check.</param>
		/// <returns>
		/// <c>true</c> if this logger is enabled for <c>level</c>, otherwise <c>false</c>.
		/// </returns>
		/// <remarks>
		/// <para>
		/// Test if this logger is going to log events of the specified <paramref name="level"/>.
		/// </para>
		/// <para>
		/// This method must not throw any exception to the caller.
		/// </para>
		/// </remarks>
		virtual public bool IsEnabledFor(Level level)
		{
			try
			{
				if (level != null)
				{
					if (m_hierarchy.IsDisabled(level))
					{
						return false;
					}
					return level >= this.EffectiveLevel;
				}
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
#if !NET_2_0 && !MONO_2_0 && !MONO_3_5 && !MONO_4_0 && !NETSTANDARD1_3
			catch
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging");
			}
#endif
			return false;
		}

		/// <summary>
		/// Gets the <see cref="ILoggerRepository"/> where this 
		/// <c>Logger</c> instance is attached to.
		/// </summary>
		/// <value>
		/// The <see cref="ILoggerRepository" /> that this logger belongs to.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets the <see cref="ILoggerRepository"/> where this 
		/// <c>Logger</c> instance is attached to.
		/// </para>
		/// </remarks>
		public ILoggerRepository Repository
		{ 
			get { return m_hierarchy; }
		}

  		#endregion Implementation of ILogger

		/// <summary>
		/// Deliver the <see cref="LoggingEvent"/> to the attached appenders.
		/// </summary>
		/// <param name="loggingEvent">The event to log.</param>
		/// <remarks>
		/// <para>
		/// Call the appenders in the hierarchy starting at
		/// <c>this</c>. If no appenders could be found, emit a
		/// warning.
		/// </para>
		/// <para>
		/// This method calls all the appenders inherited from the
		/// hierarchy circumventing any evaluation of whether to log or not
		/// to log the particular log request.
		/// </para>
		/// </remarks>
		virtual protected void CallAppenders(LoggingEvent loggingEvent) 
		{
			if (loggingEvent == null)
			{
				throw new ArgumentNullException("loggingEvent");
			}

			int writes = 0;

			for(Logger c=this; c != null; c=c.m_parent) 
			{
				if (c.m_appenderAttachedImpl != null) 
				{
					// Protected against simultaneous call to addAppender, removeAppender,...
					c.m_appenderLock.AcquireReaderLock();
					try
					{
						if (c.m_appenderAttachedImpl != null) 
						{
							writes += c.m_appenderAttachedImpl.AppendLoopOnAppenders(loggingEvent);
						}
					}
					finally
					{
						c.m_appenderLock.ReleaseReaderLock();
					}
				}

				if (!c.m_additive) 
				{
					break;
				}
			}
			
			// No appenders in hierarchy, warn user only once.
			//
			// Note that by including the AppDomain values for the currently running
			// thread, it becomes much easier to see which application the warning
			// is from, which is especially helpful in a multi-AppDomain environment
			// (like IIS with multiple VDIRS).  Without this, it can be difficult
			// or impossible to determine which .config file is missing appender
			// definitions.
			//
			if (!m_hierarchy.EmittedNoAppenderWarning && writes == 0) 
			{
				m_hierarchy.EmittedNoAppenderWarning = true;
				LogLog.Debug(declaringType, "No appenders could be found for logger [" + Name + "] repository [" + Repository.Name + "]");
				LogLog.Debug(declaringType, "Please initialize the log4net system properly.");
				try
				{
					LogLog.Debug(declaringType, "    Current AppDomain context information: ");
					LogLog.Debug(declaringType, "       BaseDirectory   : " + SystemInfo.ApplicationBaseDirectory);
#if !(NETCF || NETSTANDARD1_3)
					LogLog.Debug(declaringType, "       FriendlyName    : " + AppDomain.CurrentDomain.FriendlyName);
					LogLog.Debug(declaringType, "       DynamicDirectory: " + AppDomain.CurrentDomain.DynamicDirectory);
#endif
				}
				catch(System.Security.SecurityException)
				{
					// Insufficient permissions to display info from the AppDomain
				}
			}
		}

		/// <summary>
		/// Closes all attached appenders implementing the <see cref="IAppenderAttachable"/> interface.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Used to ensure that the appenders are correctly shutdown.
		/// </para>
		/// </remarks>
		virtual public void CloseNestedAppenders() 
		{
			m_appenderLock.AcquireWriterLock();
			try
			{
				if (m_appenderAttachedImpl != null)
				{
					AppenderCollection appenders = m_appenderAttachedImpl.Appenders;
					foreach(IAppender appender in appenders)
					{
						if (appender is IAppenderAttachable)
						{
							appender.Close();
						}
					}
				}
			}
			finally
			{
				m_appenderLock.ReleaseWriterLock();
			}
		}

		/// <summary>
		/// This is the most generic printing method. This generic form is intended to be used by wrappers
		/// </summary>
		/// <param name="level">The level of the message to be logged.</param>
		/// <param name="message">The message object to log.</param>
		/// <param name="exception">The exception to log, including its stack trace.</param>
		/// <remarks>
		/// <para>
		/// Generate a logging event for the specified <paramref name="level"/> using
		/// the <paramref name="message"/>.
		/// </para>
		/// </remarks>
		virtual public void Log(Level level, object message, Exception exception) 
		{
			if (IsEnabledFor(level))
			{
                ForcedLog(declaringType, level, message, exception);
			}
		}

		/// <summary>
		/// Creates a new logging event and logs the event without further checks.
		/// </summary>
		/// <param name="callerStackBoundaryDeclaringType">The declaring type of the method that is
		/// the stack boundary into the logging system for this call.</param>
		/// <param name="level">The level of the message to be logged.</param>
		/// <param name="message">The message object to log.</param>
		/// <param name="exception">The exception to log, including its stack trace.</param>
		/// <remarks>
		/// <para>
		/// Generates a logging event and delivers it to the attached
		/// appenders.
		/// </para>
		/// </remarks>
		virtual protected void ForcedLog(Type callerStackBoundaryDeclaringType, Level level, object message, Exception exception) 
		{
			CallAppenders(new LoggingEvent(callerStackBoundaryDeclaringType, this.Hierarchy, this.Name, level, message, exception));
		}

		/// <summary>
		/// Creates a new logging event and logs the event without further checks.
		/// </summary>
		/// <param name="logEvent">The event being logged.</param>
		/// <remarks>
		/// <para>
		/// Delivers the logging event to the attached appenders.
		/// </para>
		/// </remarks>
		virtual protected void ForcedLog(LoggingEvent logEvent) 
		{
			// The logging event may not have been created by this logger
			// the Repository may not be correctly set on the event. This
			// is required for the appenders to correctly lookup renderers etc...
			logEvent.EnsureRepository(this.Hierarchy);

			CallAppenders(logEvent);
		}

		#region Private Static Fields

        /// <summary>
        /// The fully qualified type of the Logger class.
        /// </summary>
        private readonly static Type declaringType = typeof(Logger);

		#endregion Private Static Fields

		#region Private Instance Fields

		/// <summary>
		/// The name of this logger.
		/// </summary>
		private readonly string m_name;  

		/// <summary>
		/// The assigned level of this logger. 
		/// </summary>
		/// <remarks>
		/// <para>
		/// The <c>level</c> variable need not be 
		/// assigned a value in which case it is inherited 
		/// form the hierarchy.
		/// </para>
		/// </remarks>
		private Level m_level;

		/// <summary>
		/// The parent of this logger.
		/// </summary>
		/// <remarks>
		/// <para>
		/// The parent of this logger. 
		/// All loggers have at least one ancestor which is the root logger.
		/// </para>
		/// </remarks>
		private Logger m_parent;

		/// <summary>
		/// Loggers need to know what Hierarchy they are in.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Loggers need to know what Hierarchy they are in.
		/// The hierarchy that this logger is a member of is stored
		/// here.
		/// </para>
		/// </remarks>
		private Hierarchy m_hierarchy;

		/// <summary>
		/// Helper implementation of the <see cref="IAppenderAttachable"/> interface
		/// </summary>
		private log4net.Util.AppenderAttachedImpl m_appenderAttachedImpl;

		/// <summary>
		/// Flag indicating if child loggers inherit their parents appenders
		/// </summary>
		/// <remarks>
		/// <para>
		/// Additivity is set to true by default, that is children inherit
		/// the appenders of their ancestors by default. If this variable is
		/// set to <c>false</c> then the appenders found in the
		/// ancestors of this logger are not used. However, the children
		/// of this logger will inherit its appenders, unless the children
		/// have their additivity flag set to <c>false</c> too. See
		/// the user manual for more details.
		/// </para>
		/// </remarks>
		private bool m_additive = true;

		/// <summary>
		/// Lock to protect AppenderAttachedImpl variable m_appenderAttachedImpl
		/// </summary>
		private readonly ReaderWriterLock m_appenderLock = new ReaderWriterLock();]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static Logger()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="715" sc="9" el="715" ec="69">log4net\Repository\Hierarchy\Logger.cs</location>
            <body hash="e743d562e0ed88725e04b2afc5577e33"><![CDATA[private readonly static Type declaringType = typeof(Logger)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AddAppender">
          <declaration><![CDATA[public virtual void AddAppender(IAppender newAppender)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="213" sc="3" el="232" ec="4">log4net\Repository\Hierarchy\Logger.cs</location>
            <body hash="17e694da2739e7094ff546d360c3799b"><![CDATA[{
			if (newAppender == null)
			{
				throw new ArgumentNullException("newAppender");
			}

			m_appenderLock.AcquireWriterLock();
			try
			{
				if (m_appenderAttachedImpl == null) 
				{
					m_appenderAttachedImpl = new log4net.Util.AppenderAttachedImpl();
				}
				m_appenderAttachedImpl.AddAppender(newAppender);
			}
			finally
			{
				m_appenderLock.ReleaseWriterLock();
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="CallAppenders">
          <declaration><![CDATA[protected virtual void CallAppenders(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="558" sc="3" el="619" ec="4">log4net\Repository\Hierarchy\Logger.cs</location>
            <body hash="4ea5f97eaa8f99f11b3384e757dd1a92"><![CDATA[{
			if (loggingEvent == null)
			{
				throw new ArgumentNullException("loggingEvent");
			}

			int writes = 0;

			for(Logger c=this; c != null; c=c.m_parent) 
			{
				if (c.m_appenderAttachedImpl != null) 
				{
					// Protected against simultaneous call to addAppender, removeAppender,...
					c.m_appenderLock.AcquireReaderLock();
					try
					{
						if (c.m_appenderAttachedImpl != null) 
						{
							writes += c.m_appenderAttachedImpl.AppendLoopOnAppenders(loggingEvent);
						}
					}
					finally
					{
						c.m_appenderLock.ReleaseReaderLock();
					}
				}

				if (!c.m_additive) 
				{
					break;
				}
			}
			
			// No appenders in hierarchy, warn user only once.
			//
			// Note that by including the AppDomain values for the currently running
			// thread, it becomes much easier to see which application the warning
			// is from, which is especially helpful in a multi-AppDomain environment
			// (like IIS with multiple VDIRS).  Without this, it can be difficult
			// or impossible to determine which .config file is missing appender
			// definitions.
			//
			if (!m_hierarchy.EmittedNoAppenderWarning && writes == 0) 
			{
				m_hierarchy.EmittedNoAppenderWarning = true;
				LogLog.Debug(declaringType, "No appenders could be found for logger [" + Name + "] repository [" + Repository.Name + "]");
				LogLog.Debug(declaringType, "Please initialize the log4net system properly.");
				try
				{
					LogLog.Debug(declaringType, "    Current AppDomain context information: ");
					LogLog.Debug(declaringType, "       BaseDirectory   : " + SystemInfo.ApplicationBaseDirectory);
#if !(NETCF || NETSTANDARD1_3)
					LogLog.Debug(declaringType, "       FriendlyName    : " + AppDomain.CurrentDomain.FriendlyName);
					LogLog.Debug(declaringType, "       DynamicDirectory: " + AppDomain.CurrentDomain.DynamicDirectory);
#endif
				}
				catch(System.Security.SecurityException)
				{
					// Insufficient permissions to display info from the AppDomain
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="CloseNestedAppenders">
          <declaration><![CDATA[public virtual void CloseNestedAppenders()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="630" sc="3" el="650" ec="4">log4net\Repository\Hierarchy\Logger.cs</location>
            <body hash="61b737f6fffd0050595af03ce285928c"><![CDATA[{
			m_appenderLock.AcquireWriterLock();
			try
			{
				if (m_appenderAttachedImpl != null)
				{
					AppenderCollection appenders = m_appenderAttachedImpl.Appenders;
					foreach(IAppender appender in appenders)
					{
						if (appender is IAppenderAttachable)
						{
							appender.Close();
						}
					}
				}
			}
			finally
			{
				m_appenderLock.ReleaseWriterLock();
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ForcedLog">
          <declaration><![CDATA[protected virtual void ForcedLog(Type callerStackBoundaryDeclaringType, Level level, object message, Exception exception)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="687" sc="3" el="689" ec="4">log4net\Repository\Hierarchy\Logger.cs</location>
            <body hash="cdf92e888d43d841bb3ad71963462ebc"><![CDATA[{
			CallAppenders(new LoggingEvent(callerStackBoundaryDeclaringType, this.Hierarchy, this.Name, level, message, exception));
		}]]></body>
          </codeblock>
        </method>
        <method name="ForcedLog">
          <declaration><![CDATA[protected virtual void ForcedLog(LoggingEvent logEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="701" sc="3" el="708" ec="4">log4net\Repository\Hierarchy\Logger.cs</location>
            <body hash="00090c615a885a4c9a920e18cf968b03"><![CDATA[{
			// The logging event may not have been created by this logger
			// the Repository may not be correctly set on the event. This
			// is required for the appenders to correctly lookup renderers etc...
			logEvent.EnsureRepository(this.Hierarchy);

			CallAppenders(logEvent);
		}]]></body>
          </codeblock>
        </method>
        <method name="GetAppender">
          <declaration><![CDATA[public virtual IAppender GetAppender(string name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="280" sc="3" el="295" ec="4">log4net\Repository\Hierarchy\Logger.cs</location>
            <body hash="84486524e066ce39e7367e72bff3ee21"><![CDATA[{
			m_appenderLock.AcquireReaderLock();
			try
			{
				if (m_appenderAttachedImpl == null || name == null)
				{
					return null;
				}

				return m_appenderAttachedImpl.GetAppender(name);
			}
			finally
			{
				m_appenderLock.ReleaseReaderLock();
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="IsEnabledFor">
          <declaration><![CDATA[public virtual bool IsEnabledFor(Level level)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="496" sc="3" el="519" ec="4">log4net\Repository\Hierarchy\Logger.cs</location>
            <body hash="b1bed02588b9498dbbeed81916c7f3d7"><![CDATA[{
			try
			{
				if (level != null)
				{
					if (m_hierarchy.IsDisabled(level))
					{
						return false;
					}
					return level >= this.EffectiveLevel;
				}
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
#if !NET_2_0 && !MONO_2_0 && !MONO_3_5 && !MONO_4_0 && !NETSTANDARD1_3
			catch
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging");
			}
#endif
			return false;
		}]]></body>
          </codeblock>
        </method>
        <method name="Log">
          <declaration><![CDATA[public virtual void Log(Type callerStackBoundaryDeclaringType, Level level, object message, Exception exception)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="423" sc="3" el="441" ec="4">log4net\Repository\Hierarchy\Logger.cs</location>
            <body hash="dd37dfb3e41a60140a4acaf853c6b1d1"><![CDATA[{
			try
			{
				if (IsEnabledFor(level))
				{
                    ForcedLog((callerStackBoundaryDeclaringType != null) ? callerStackBoundaryDeclaringType : declaringType, level, message, exception);
				}
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
#if !NET_2_0 && !MONO_2_0 && !MONO_3_5 && !MONO_4_0 && !NETSTANDARD1_3
			catch
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging");
			}
#endif
		}]]></body>
          </codeblock>
        </method>
        <method name="Log">
          <declaration><![CDATA[public virtual void Log(LoggingEvent logEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="457" sc="3" el="478" ec="4">log4net\Repository\Hierarchy\Logger.cs</location>
            <body hash="46cf915dc2d309e8a8f4fb8ea4220d38"><![CDATA[{
			try
			{
				if (logEvent != null)
				{
					if (IsEnabledFor(logEvent.Level))
					{
						ForcedLog(logEvent);
					}
				}
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
#if !NET_2_0 && !MONO_2_0 && !MONO_3_5 && !MONO_4_0 && !NETSTANDARD1_3
			catch
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging");
			}
#endif
		}]]></body>
          </codeblock>
        </method>
        <method name="Log">
          <declaration><![CDATA[public virtual void Log(Level level, object message, Exception exception)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="665" sc="3" el="670" ec="4">log4net\Repository\Hierarchy\Logger.cs</location>
            <body hash="26013c98f9b25aa6f9f05fa86c46be64"><![CDATA[{
			if (IsEnabledFor(level))
			{
                ForcedLog(declaringType, level, message, exception);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="RemoveAllAppenders">
          <declaration><![CDATA[public virtual void RemoveAllAppenders()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="309" sc="3" el="323" ec="4">log4net\Repository\Hierarchy\Logger.cs</location>
            <body hash="c4fb19c770957d0426bf0a86cc18f639"><![CDATA[{
			m_appenderLock.AcquireWriterLock();
			try
			{
				if (m_appenderAttachedImpl != null) 
				{
					m_appenderAttachedImpl.RemoveAllAppenders();
					m_appenderAttachedImpl = null;
				}
			}
			finally
			{
				m_appenderLock.ReleaseWriterLock();
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="RemoveAppender">
          <declaration><![CDATA[public virtual IAppender RemoveAppender(IAppender appender)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="339" sc="3" el="353" ec="4">log4net\Repository\Hierarchy\Logger.cs</location>
            <body hash="43ad6c935fee355016b2b0f6e7a203b7"><![CDATA[{
			m_appenderLock.AcquireWriterLock();
			try
			{
				if (appender != null && m_appenderAttachedImpl != null) 
				{
					return m_appenderAttachedImpl.RemoveAppender(appender);
				}
			}
			finally
			{
				m_appenderLock.ReleaseWriterLock();
			}
			return null;
		}]]></body>
          </codeblock>
        </method>
        <method name="RemoveAppender">
          <declaration><![CDATA[public virtual IAppender RemoveAppender(string name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="369" sc="3" el="383" ec="4">log4net\Repository\Hierarchy\Logger.cs</location>
            <body hash="35bd3e39356fd6469bcf04a39bb9ce85"><![CDATA[{
			m_appenderLock.AcquireWriterLock();
			try
			{
				if (name != null && m_appenderAttachedImpl != null)
				{
					return m_appenderAttachedImpl.RemoveAppender(name);
				}
			}
			finally
			{
				m_appenderLock.ReleaseWriterLock();
			}
			return null;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(Logger);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_additive">
          <declaration><![CDATA[private bool m_additive = true;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_appenderAttachedImpl">
          <declaration><![CDATA[private AppenderAttachedImpl m_appenderAttachedImpl;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_appenderLock">
          <declaration><![CDATA[private readonly ReaderWriterLock m_appenderLock = new ReaderWriterLock();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_hierarchy">
          <declaration><![CDATA[private Hierarchy m_hierarchy;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_level">
          <declaration><![CDATA[private Level m_level;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_name">
          <declaration><![CDATA[private readonly string m_name;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_parent">
          <declaration><![CDATA[private Logger m_parent;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Additivity">
          <declaration><![CDATA[public virtual bool Additivity]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Appenders">
          <declaration><![CDATA[public virtual AppenderCollection Appenders]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="249" sc="4" el="266" ec="5">log4net\Repository\Hierarchy\Logger.cs</location>
            <body hash="be78d8d6386a97188d54ac1f11da9a5d"><![CDATA[{
				m_appenderLock.AcquireReaderLock();
				try
				{
					if (m_appenderAttachedImpl == null)
					{
						return AppenderCollection.EmptyCollection;
					}
					else 
					{
						return m_appenderAttachedImpl.Appenders;
					}
				}
				finally
				{
					m_appenderLock.ReleaseReaderLock();
				}
			}]]></body>
          </codeblock>
        </property>
        <property name="EffectiveLevel">
          <declaration><![CDATA[public virtual Level EffectiveLevel]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="145" sc="4" el="157" ec="5">log4net\Repository\Hierarchy\Logger.cs</location>
            <body hash="9590972e37c3fb08ee1061ace80af388"><![CDATA[{
				for(Logger c = this; c != null; c = c.m_parent) 
				{
					Level level = c.m_level;

					// Casting level to Object for performance, otherwise the overloaded operator is called
					if ((object)level != null) 
					{
						return level;
					}
				}
				return null; // If reached will cause an NullPointerException.
			}]]></body>
          </codeblock>
        </property>
        <property name="Hierarchy">
          <declaration><![CDATA[public virtual Hierarchy Hierarchy]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Level">
          <declaration><![CDATA[public virtual Level Level]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Name">
          <declaration><![CDATA[public virtual string Name]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Parent">
          <declaration><![CDATA[public virtual Logger Parent]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Repository">
          <declaration><![CDATA[public ILoggerRepository Repository]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="LoggerCreationEventArgs">
      <declaration><![CDATA[public class LoggerCreationEventArgs : EventArgs]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public LoggerCreationEventArgs(Logger log)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="69" sc="3" el="72" ec="4">log4net\Repository\Hierarchy\Hierarchy.cs</location>
            <body hash="3e8412f2437dc242dcb3c1faaf3b69b1"><![CDATA[public LoggerCreationEventArgs(Logger log)
		{
			m_log = log;
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="m_log">
          <declaration><![CDATA[private Logger m_log;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Logger">
          <declaration><![CDATA[public Logger Logger]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="e);">
      <declaration><![CDATA[public delegate void LoggerCreationEventHandler(object sender, LoggerCreationEventArgs e);]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public extern LoggerCreationEventHandler(object @object, IntPtr method);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="BeginInvoke">
          <declaration><![CDATA[public virtual extern IAsyncResult BeginInvoke(object sender, LoggerCreationEventArgs e, AsyncCallback callback, object @object);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="EndInvoke">
          <declaration><![CDATA[public virtual extern void EndInvoke(IAsyncResult result);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Invoke">
          <declaration><![CDATA[public virtual extern void Invoke(object sender, LoggerCreationEventArgs e);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="LoggerKey">
      <declaration><![CDATA[internal sealed class LoggerKey]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[internal LoggerKey(string name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="65" sc="3" el="74" ec="4">log4net\Repository\Hierarchy\LoggerKey.cs</location>
            <body hash="a15ca73e2779b372f6c69c8e47d532f1"><![CDATA[internal LoggerKey(string name) 
		{
#if NETCF || NETSTANDARD1_3
			// NETCF: String.Intern causes Native Exception
			m_name = name;
#else
			m_name = string.Intern(name);
#endif
			m_hashCache = name.GetHashCode();
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Equals">
          <declaration><![CDATA[public override bool Equals(object obj)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="108" sc="3" el="126" ec="4">log4net\Repository\Hierarchy\LoggerKey.cs</location>
            <body hash="47e1a708e7d311d7baa616d5b415826c"><![CDATA[{
			// Compare reference type of this against argument
			if (((object)this) == obj)
			{
				return true;
			}
			
			LoggerKey objKey = obj as LoggerKey;
			if (objKey != null) 
			{
#if NETCF || NETSTANDARD1_3
				return ( m_name == objKey.m_name );
#else
				// Compare reference types rather than string's overloaded ==
				return ( ((object)m_name) == ((object)objKey.m_name) );
#endif
			}
			return false;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetHashCode">
          <declaration><![CDATA[public override int GetHashCode()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="90" sc="3" el="92" ec="4">log4net\Repository\Hierarchy\LoggerKey.cs</location>
            <body hash="a39b893b5a81b7728a15b15140fa9ee9"><![CDATA[{
			return m_hashCache;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_hashCache">
          <declaration><![CDATA[private readonly int m_hashCache;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_name">
          <declaration><![CDATA[private readonly string m_name;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="ProvisionNode">
      <declaration><![CDATA[internal sealed class ProvisionNode : ArrayList]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[internal ProvisionNode(Logger log)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="53" sc="40" el="56" ec="4">log4net\Repository\Hierarchy\ProvisionNode.cs</location>
            <body hash="42b2ce7ae0f9f778719cd0de13a8dc98"><![CDATA[base()
		{
			this.Add(log);
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="RootLogger">
      <declaration><![CDATA[public class RootLogger : Logger]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public RootLogger(Level level) : base("root")]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="62" sc="36" el="65" ec="4">log4net\Repository\Hierarchy\RootLogger.cs</location>
            <body hash="7ee113b473682d9068defcb73ff203c4"><![CDATA[base("root")
		{
			this.Level = level;
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static RootLogger()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="129" sc="6" el="129" ec="70">log4net\Repository\Hierarchy\RootLogger.cs</location>
            <body hash="3ed3aee003e963f21169473ffd4e7491"><![CDATA[private readonly static Type declaringType = typeof(RootLogger)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(RootLogger);]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="EffectiveLevel">
          <declaration><![CDATA[public override Level EffectiveLevel]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="85" sc="4" el="87" ec="5">log4net\Repository\Hierarchy\RootLogger.cs</location>
            <body hash="dfddf81eef38d4290517894eed0b3c7f"><![CDATA[{
				return base.Level;
			}]]></body>
          </codeblock>
        </property>
        <property name="Level">
          <declaration><![CDATA[public override Level Level]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="106" sc="4" el="115" ec="5">log4net\Repository\Hierarchy\RootLogger.cs</location>
            <body hash="7ee28b79c3e003e039d70acc718357bc"><![CDATA[{
				if (value == null) 
				{
					LogLog.Error(declaringType, "You have tried to set a null level to root.", new LogException());
				}
				else 
				{
					base.Level = value;
				}
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="XmlHierarchyConfigurator">
      <declaration><![CDATA[public class XmlHierarchyConfigurator]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public XmlHierarchyConfigurator(Hierarchy hierarchy)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="63" sc="3" el="67" ec="4">log4net\Repository\Hierarchy\XmlHierarchyConfigurator.cs</location>
            <body hash="ddceb271f88a7365b42148f1c11c47a5"><![CDATA[public XmlHierarchyConfigurator(Hierarchy hierarchy) 
		{
			m_hierarchy = hierarchy;
			m_appenderBag = new Hashtable();
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static XmlHierarchyConfigurator()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1159" sc="6" el="1159" ec="84">log4net\Repository\Hierarchy\XmlHierarchyConfigurator.cs</location>
            <body hash="c0334345e153e6014308de6690272c71"><![CDATA[private readonly static Type declaringType = typeof(XmlHierarchyConfigurator)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Configure">
          <declaration><![CDATA[public void Configure(XmlElement element)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="83" sc="3" el="224" ec="4">log4net\Repository\Hierarchy\XmlHierarchyConfigurator.cs</location>
            <body hash="3bf33c81745ba10a160f3080599f50cb"><![CDATA[{
			if (element == null || m_hierarchy == null)
			{
                return;
			}

			string rootElementName = element.LocalName;

			if (rootElementName != CONFIGURATION_TAG)
			{
				LogLog.Error(declaringType, "Xml element is - not a <" + CONFIGURATION_TAG + "> element.");
                return;
			}

            if (!LogLog.EmitInternalMessages)
            {
                // Look for a emitDebug attribute to enable internal debug
                string emitDebugAttribute = element.GetAttribute(EMIT_INTERNAL_DEBUG_ATTR);
                LogLog.Debug(declaringType, EMIT_INTERNAL_DEBUG_ATTR + " attribute [" + emitDebugAttribute + "].");

                if (emitDebugAttribute.Length > 0 && emitDebugAttribute != "null")
                {
                    LogLog.EmitInternalMessages = OptionConverter.ToBoolean(emitDebugAttribute, true);
                }
                else
                {
                    LogLog.Debug(declaringType, "Ignoring " + EMIT_INTERNAL_DEBUG_ATTR + " attribute.");
                }
            }

		    if (!LogLog.InternalDebugging)
			{
				// Look for a debug attribute to enable internal debug
				string debugAttribute = element.GetAttribute(INTERNAL_DEBUG_ATTR);
				LogLog.Debug(declaringType, INTERNAL_DEBUG_ATTR+" attribute [" + debugAttribute + "].");

				if (debugAttribute.Length>0 && debugAttribute != "null") 
				{	  
					LogLog.InternalDebugging = OptionConverter.ToBoolean(debugAttribute, true);
				}
				else 
				{
					LogLog.Debug(declaringType, "Ignoring " + INTERNAL_DEBUG_ATTR + " attribute.");
				}

				string confDebug = element.GetAttribute(CONFIG_DEBUG_ATTR);
				if (confDebug.Length>0 && confDebug != "null")
				{	  
					LogLog.Warn(declaringType, "The \"" + CONFIG_DEBUG_ATTR + "\" attribute is deprecated.");
					LogLog.Warn(declaringType, "Use the \"" + INTERNAL_DEBUG_ATTR + "\" attribute instead.");
					LogLog.InternalDebugging = OptionConverter.ToBoolean(confDebug, true);
				}
			}

			// Default mode is merge
			ConfigUpdateMode configUpdateMode = ConfigUpdateMode.Merge;

			// Look for the config update attribute
			string configUpdateModeAttribute = element.GetAttribute(CONFIG_UPDATE_MODE_ATTR);
			if (configUpdateModeAttribute != null && configUpdateModeAttribute.Length > 0)
			{
				// Parse the attribute
				try
				{
					configUpdateMode = (ConfigUpdateMode)OptionConverter.ConvertStringTo(typeof(ConfigUpdateMode), configUpdateModeAttribute);
				}
				catch
				{
					LogLog.Error(declaringType, "Invalid " + CONFIG_UPDATE_MODE_ATTR + " attribute value [" + configUpdateModeAttribute + "]");
				}
			}

			// IMPL: The IFormatProvider argument to Enum.ToString() is deprecated in .NET 2.0
			LogLog.Debug(declaringType, "Configuration update mode [" + configUpdateMode.ToString() + "].");

			// Only reset configuration if overwrite flag specified
			if (configUpdateMode == ConfigUpdateMode.Overwrite)
			{
				// Reset to original unset configuration
				m_hierarchy.ResetConfiguration();
				LogLog.Debug(declaringType, "Configuration reset before reading config.");
			}

			/* Building Appender objects, placing them in a local namespace
			   for future reference */

			/* Process all the top level elements */

			foreach (XmlNode currentNode in element.ChildNodes)
			{
				if (currentNode.NodeType == XmlNodeType.Element) 
				{
					XmlElement currentElement = (XmlElement)currentNode;

					if (currentElement.LocalName == LOGGER_TAG)
					{
						ParseLogger(currentElement);
					} 
					else if (currentElement.LocalName == CATEGORY_TAG)
					{
						// TODO: deprecated use of category
						ParseLogger(currentElement);
					} 
					else if (currentElement.LocalName == ROOT_TAG)
					{
						ParseRoot(currentElement);
					} 
					else if (currentElement.LocalName == RENDERER_TAG)
					{
						ParseRenderer(currentElement);
					}
					else if (currentElement.LocalName == APPENDER_TAG)
					{
						// We ignore appenders in this pass. They will
						// be found and loaded if they are referenced.
					}
					else
					{
						// Read the param tags and set properties on the hierarchy
						SetParameter(currentElement, m_hierarchy);
					}
				}
			}

			// Lastly set the hierarchy threshold
			string thresholdStr = element.GetAttribute(THRESHOLD_ATTR);
			LogLog.Debug(declaringType, "Hierarchy Threshold [" + thresholdStr + "]");
			if (thresholdStr.Length > 0 && thresholdStr != "null") 
			{
				Level thresholdLevel = (Level) ConvertStringTo(typeof(Level), thresholdStr);
				if (thresholdLevel != null)
				{
					m_hierarchy.Threshold = thresholdLevel;
				}
				else
				{
					LogLog.Warn(declaringType, "Unable to set hierarchy threshold using value [" + thresholdStr + "] (with acceptable conversion types)");
				}
			}

			// Done reading config
		}]]></body>
          </codeblock>
        </method>
        <method name="ConvertStringTo">
          <declaration><![CDATA[protected object ConvertStringTo(Type type, string value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="933" sc="3" el="948" ec="4">log4net\Repository\Hierarchy\XmlHierarchyConfigurator.cs</location>
            <body hash="52358389c9d42d38923573c2746af483"><![CDATA[{
			// Hack to allow use of Level in property
			if (typeof(Level) == type)
			{
				// Property wants a level
				Level levelValue = m_hierarchy.LevelMap[value];

				if (levelValue == null)
				{
					LogLog.Error(declaringType, "XmlHierarchyConfigurator: Unknown Level Specified ["+ value +"]");
				}

				return levelValue;
			}
			return OptionConverter.ConvertStringTo(type, value);
		}]]></body>
          </codeblock>
        </method>
        <method name="CreateCaseInsensitiveWrapper">
          <declaration><![CDATA[private IDictionary CreateCaseInsensitiveWrapper(IDictionary dict)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1088" sc="10" el="1098" ec="4">log4net\Repository\Hierarchy\XmlHierarchyConfigurator.cs</location>
            <body hash="6fd2d9ba9d52fc2c8b382f479162687c"><![CDATA[{
		    if (dict == null)
		    {
			return dict;
		    }
		    Hashtable hash = SystemInfo.CreateCaseInsensitiveHashtable();
		    foreach (DictionaryEntry entry in dict) {
			hash[entry.Key] = entry.Value;
		    }
		    return hash;
		}]]></body>
          </codeblock>
        </method>
        <method name="CreateObjectFromXml">
          <declaration><![CDATA[protected object CreateObjectFromXml(XmlElement element, Type defaultTargetType, Type typeConstraint)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="970" sc="3" el="1065" ec="4">log4net\Repository\Hierarchy\XmlHierarchyConfigurator.cs</location>
            <body hash="4480d4af09a1470b4bf583741b03bd86"><![CDATA[{
			Type objectType = null;

			// Get the object type
			string objectTypeString = element.GetAttribute(TYPE_ATTR);
			if (objectTypeString == null || objectTypeString.Length == 0)
			{
				if (defaultTargetType == null)
				{
					LogLog.Error(declaringType, "Object type not specified. Cannot create object of type ["+typeConstraint.FullName+"]. Missing Value or Type.");
					return null;
				}
				else
				{
					// Use the default object type
					objectType = defaultTargetType;
				}
			}
			else
			{
				// Read the explicit object type
				try
				{
#if NETSTANDARD1_3
					objectType = SystemInfo.GetTypeFromString(this.GetType().GetTypeInfo().Assembly, objectTypeString, true, true);
#else
					objectType = SystemInfo.GetTypeFromString(objectTypeString, true, true);
#endif
				}
				catch(Exception ex)
				{
					LogLog.Error(declaringType, "Failed to find type ["+objectTypeString+"]", ex);
					return null;
				}
			}

			bool requiresConversion = false;

			// Got the object type. Check that it meets the typeConstraint
			if (typeConstraint != null)
			{
				if (!typeConstraint.IsAssignableFrom(objectType))
				{
					// Check if there is an appropriate type converter
					if (OptionConverter.CanConvertTypeTo(objectType, typeConstraint))
					{
						requiresConversion = true;
					}
					else
					{
						LogLog.Error(declaringType, "Object type ["+objectType.FullName+"] is not assignable to type ["+typeConstraint.FullName+"]. There are no acceptable type conversions.");
						return null;
					}
				}
			}

			// Create using the default constructor
			object createdObject = null;
			try
			{
				createdObject = Activator.CreateInstance(objectType);
			}
			catch(Exception createInstanceEx)
			{
				LogLog.Error(declaringType, "XmlHierarchyConfigurator: Failed to construct object of type [" + objectType.FullName + "] Exception: "+createInstanceEx.ToString());
			}

			// Set any params on object
			foreach (XmlNode currentNode in element.ChildNodes)
			{
				if (currentNode.NodeType == XmlNodeType.Element) 
				{
					SetParameter((XmlElement)currentNode, createdObject);
				}
			}

			// Check if we need to call ActivateOptions
			IOptionHandler optionHandler = createdObject as IOptionHandler;
			if (optionHandler != null)
			{
				optionHandler.ActivateOptions();
			}

			// Ok object should be initialized

			if (requiresConversion)
			{
				// Convert the object type
				return OptionConverter.ConvertTypeTo(createdObject, typeConstraint);
			}
			else
			{
				// The object is of the correct type
				return createdObject;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="FindAppenderByReference">
          <declaration><![CDATA[protected IAppender FindAppenderByReference(XmlElement appenderRef)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="242" sc="3" el="282" ec="4">log4net\Repository\Hierarchy\XmlHierarchyConfigurator.cs</location>
            <body hash="aee8716d494ce68f8535628cdcdeaba8"><![CDATA[{	
			string appenderName = appenderRef.GetAttribute(REF_ATTR);

			IAppender appender = (IAppender)m_appenderBag[appenderName];
			if (appender != null) 
			{
				return appender;
			} 
			else 
			{
				// Find the element with that id
				XmlElement element = null;

				if (appenderName != null && appenderName.Length > 0)
				{
					foreach (XmlElement curAppenderElement in appenderRef.OwnerDocument.GetElementsByTagName(APPENDER_TAG))
					{
						if (curAppenderElement.GetAttribute("name") == appenderName)
						{
							element = curAppenderElement;
							break;
						}
					}
				}

				if (element == null) 
				{
					LogLog.Error(declaringType, "XmlHierarchyConfigurator: No appender named [" + appenderName + "] could be found."); 
					return null;
				} 
				else
				{
					appender = ParseAppender(element);
					if (appender != null)
					{
						m_appenderBag[appenderName] = appender;
					}
					return appender;
				}
			} 
		}]]></body>
          </codeblock>
        </method>
        <method name="FindMethodInfo">
          <declaration><![CDATA[private MethodInfo FindMethodInfo(Type targetType, string name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="892" sc="3" el="919" ec="4">log4net\Repository\Hierarchy\XmlHierarchyConfigurator.cs</location>
            <body hash="15cd9a61a22c3403a15a2c9404233547"><![CDATA[{
			string requiredMethodNameA = name;
			string requiredMethodNameB = "Add" + name;

			MethodInfo[] methods = targetType.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

			foreach(MethodInfo methInfo in methods)
			{
				if (!methInfo.IsStatic)
				{
					string methodInfoName = methInfo.Name;

					if (SystemInfo.EqualsIgnoringCase(methodInfoName, requiredMethodNameA) ||
					    SystemInfo.EqualsIgnoringCase(methodInfoName, requiredMethodNameB))
					{
						// Found matching method name

						// Look for version with one arg only
						System.Reflection.ParameterInfo[] methParams = methInfo.GetParameters();
						if (methParams.Length == 1)
						{
							return methInfo;
						}
					}
				}
			}
			return null;
		}]]></body>
          </codeblock>
        </method>
        <method name="HasAttributesOrElements">
          <declaration><![CDATA[private bool HasAttributesOrElements(XmlElement element)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="844" sc="3" el="853" ec="4">log4net\Repository\Hierarchy\XmlHierarchyConfigurator.cs</location>
            <body hash="b6be421303ad70f3430d1b592f67655c"><![CDATA[{
			foreach(XmlNode node in element.ChildNodes)
			{
				if (node.NodeType == XmlNodeType.Attribute || node.NodeType == XmlNodeType.Element)
				{
					return true;
				}
			}
			return false;
		}]]></body>
          </codeblock>
        </method>
        <method name="IsTypeConstructible">
          <declaration><![CDATA[private static bool IsTypeConstructible(Type type)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="861" sc="3" el="876" ec="4">log4net\Repository\Hierarchy\XmlHierarchyConfigurator.cs</location>
            <body hash="983e816f80d121958c48dc9c91c73934"><![CDATA[{
#if NETSTANDARD1_3
			TypeInfo typeInfo = type.GetTypeInfo();
			if (typeInfo.IsClass && !typeInfo.IsAbstract)
#else
			if (type.IsClass && !type.IsAbstract)
#endif
			{
				ConstructorInfo defaultConstructor = type.GetConstructor(new Type[0]);
				if (defaultConstructor != null && !defaultConstructor.IsAbstract && !defaultConstructor.IsPrivate)
				{
					return true;
				}
			}
			return false;
		}]]></body>
          </codeblock>
        </method>
        <method name="ParseAppender">
          <declaration><![CDATA[protected IAppender ParseAppender(XmlElement appenderElement)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="296" sc="3" el="362" ec="4">log4net\Repository\Hierarchy\XmlHierarchyConfigurator.cs</location>
            <body hash="f665339f76aee18e49aa78f053915bef"><![CDATA[{
			string appenderName = appenderElement.GetAttribute(NAME_ATTR);
			string typeName = appenderElement.GetAttribute(TYPE_ATTR);

			LogLog.Debug(declaringType, "Loading Appender [" + appenderName + "] type: [" + typeName + "]");
			try 
			{
#if NETSTANDARD1_3
				IAppender appender = (IAppender)Activator.CreateInstance(SystemInfo.GetTypeFromString(this.GetType().GetTypeInfo().Assembly, typeName, true, true));
#else
				IAppender appender = (IAppender)Activator.CreateInstance(SystemInfo.GetTypeFromString(typeName, true, true));
#endif
				appender.Name = appenderName;

				foreach (XmlNode currentNode in appenderElement.ChildNodes)
				{
					/* We're only interested in Elements */
					if (currentNode.NodeType == XmlNodeType.Element) 
					{
						XmlElement currentElement = (XmlElement)currentNode;

						// Look for the appender ref tag
						if (currentElement.LocalName == APPENDER_REF_TAG)
						{
							string refName = currentElement.GetAttribute(REF_ATTR);

							IAppenderAttachable appenderContainer = appender as IAppenderAttachable;
							if (appenderContainer != null) 
							{
								LogLog.Debug(declaringType, "Attaching appender named [" + refName + "] to appender named [" + appender.Name + "].");

								IAppender referencedAppender = FindAppenderByReference(currentElement);
								if (referencedAppender != null)
								{
									appenderContainer.AddAppender(referencedAppender);
								}
							} 
							else 
							{
								LogLog.Error(declaringType, "Requesting attachment of appender named ["+refName+ "] to appender named [" + appender.Name + "] which does not implement log4net.Core.IAppenderAttachable.");
							}
						}
						else
						{
							// For all other tags we use standard set param method
							SetParameter(currentElement, appender);
						}
					}
				}

				IOptionHandler optionHandler = appender as IOptionHandler;
				if (optionHandler != null) 
				{
					optionHandler.ActivateOptions();
				}

				LogLog.Debug(declaringType, "Created Appender [" + appenderName + "]");	
				return appender;
			}
			catch (Exception ex) 
			{
				// Yes, it's ugly.  But all exceptions point to the same problem: we can't create an Appender

				LogLog.Error(declaringType, "Could not create Appender [" + appenderName + "] of type [" + typeName + "]. Reported error follows.", ex);
				return null;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ParseChildrenOfLoggerElement">
          <declaration><![CDATA[protected void ParseChildrenOfLoggerElement(XmlElement catElement, Logger log, bool isRoot)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="425" sc="3" el="466" ec="4">log4net\Repository\Hierarchy\XmlHierarchyConfigurator.cs</location>
            <body hash="8a14057a51781c353790b4ed28ef68af"><![CDATA[{
			// Remove all existing appenders from log. They will be
			// reconstructed if need be.
			log.RemoveAllAppenders();

			foreach (XmlNode currentNode in catElement.ChildNodes)
			{
				if (currentNode.NodeType == XmlNodeType.Element) 
				{
					XmlElement currentElement = (XmlElement) currentNode;
	
					if (currentElement.LocalName == APPENDER_REF_TAG)
					{
						IAppender appender = FindAppenderByReference(currentElement);
						string refName =  currentElement.GetAttribute(REF_ATTR);
						if (appender != null)
						{
							LogLog.Debug(declaringType, "Adding appender named [" + refName + "] to logger [" + log.Name + "].");
							log.AddAppender(appender);
						}
						else 
						{
							LogLog.Error(declaringType, "Appender named [" + refName + "] not found.");
						}
					} 
					else if (currentElement.LocalName == LEVEL_TAG || currentElement.LocalName == PRIORITY_TAG) 
					{
						ParseLevel(currentElement, log, isRoot);	
					} 
					else
					{
						SetParameter(currentElement, log);
					}
				}
			}

			IOptionHandler optionHandler = log as IOptionHandler;
			if (optionHandler != null) 
			{
				optionHandler.ActivateOptions();
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ParseLevel">
          <declaration><![CDATA[protected void ParseLevel(XmlElement element, Logger log, bool isRoot)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="518" sc="3" el="552" ec="4">log4net\Repository\Hierarchy\XmlHierarchyConfigurator.cs</location>
            <body hash="737fa5ab5cd0d2b25d43e490cb0c7da5"><![CDATA[{
			string loggerName = log.Name;
			if (isRoot) 
			{
				loggerName = "root";
			}

			string levelStr = element.GetAttribute(VALUE_ATTR);
			LogLog.Debug(declaringType, "Logger [" + loggerName + "] Level string is [" + levelStr + "].");
	
			if (INHERITED == levelStr) 
			{
				if (isRoot) 
				{
					LogLog.Error(declaringType, "Root level cannot be inherited. Ignoring directive.");
				} 
				else 
				{
					LogLog.Debug(declaringType, "Logger [" + loggerName + "] level set to inherit from parent.");	
					log.Level = null;
				}
			} 
			else 
			{
				log.Level = log.Hierarchy.LevelMap[levelStr];
				if (log.Level == null)
				{
					LogLog.Error(declaringType, "Undefined level [" + levelStr + "] on Logger [" + loggerName + "].");
				}
				else
				{
					LogLog.Debug(declaringType, "Logger [" + loggerName + "] level set to [name=\"" + log.Level.Name + "\",value=" + log.Level.Value + "].");	
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ParseLogger">
          <declaration><![CDATA[protected void ParseLogger(XmlElement loggerElement)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="374" sc="3" el="392" ec="4">log4net\Repository\Hierarchy\XmlHierarchyConfigurator.cs</location>
            <body hash="e9beca8ffbb811a1786c406cfce00e83"><![CDATA[{
			// Create a new log4net.Logger object from the <logger> element.
			string loggerName = loggerElement.GetAttribute(NAME_ATTR);

			LogLog.Debug(declaringType, "Retrieving an instance of log4net.Repository.Logger for logger [" + loggerName + "].");
			Logger log = m_hierarchy.GetLogger(loggerName) as Logger;

			// Setting up a logger needs to be an atomic operation, in order
			// to protect potential log operations while logger
			// configuration is in progress.
			lock(log) 
			{
				bool additivity = OptionConverter.ToBoolean(loggerElement.GetAttribute(ADDITIVITY_ATTR), true);
	
				LogLog.Debug(declaringType, "Setting [" + log.Name + "] additivity to [" + additivity + "].");
				log.Additivity = additivity;
				ParseChildrenOfLoggerElement(loggerElement, log, false);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ParseRenderer">
          <declaration><![CDATA[protected void ParseRenderer(XmlElement element)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="478" sc="3" el="504" ec="4">log4net\Repository\Hierarchy\XmlHierarchyConfigurator.cs</location>
            <body hash="96cbb6098527cd693963a598dcdd479a"><![CDATA[{
			string renderingClassName = element.GetAttribute(RENDERING_TYPE_ATTR);
			string renderedClassName = element.GetAttribute(RENDERED_TYPE_ATTR);

			LogLog.Debug(declaringType, "Rendering class [" + renderingClassName + "], Rendered class [" + renderedClassName + "].");
			IObjectRenderer renderer = (IObjectRenderer)OptionConverter.InstantiateByClassName(renderingClassName, typeof(IObjectRenderer), null);
			if (renderer == null) 
			{
				LogLog.Error(declaringType, "Could not instantiate renderer [" + renderingClassName + "].");
				return;
			} 
			else 
			{
				try 
				{
#if NETSTANDARD1_3
					m_hierarchy.RendererMap.Put(SystemInfo.GetTypeFromString(this.GetType().GetTypeInfo().Assembly, renderedClassName, true, true), renderer);
#else
					m_hierarchy.RendererMap.Put(SystemInfo.GetTypeFromString(renderedClassName, true, true), renderer);
#endif
				} 
				catch(Exception e) 
				{
					LogLog.Error(declaringType, "Could not find class [" + renderedClassName + "].", e);
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ParseRoot">
          <declaration><![CDATA[protected void ParseRoot(XmlElement rootElement)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="404" sc="3" el="411" ec="4">log4net\Repository\Hierarchy\XmlHierarchyConfigurator.cs</location>
            <body hash="2c94f7dba2e4fc32c58a455b41e648f7"><![CDATA[{
			Logger root = m_hierarchy.Root;
			// logger configuration needs to be atomic
			lock(root) 
			{	
				ParseChildrenOfLoggerElement(rootElement, root, true);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="SetParameter">
          <declaration><![CDATA[protected void SetParameter(XmlElement element, object target)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="571" sc="3" el="836" ec="4">log4net\Repository\Hierarchy\XmlHierarchyConfigurator.cs</location>
            <body hash="6e0eec39b70401a34dfd9d0ba861dd4c"><![CDATA[{
			// Get the property name
			string name = element.GetAttribute(NAME_ATTR);

			// If the name attribute does not exist then use the name of the element
			if (element.LocalName != PARAM_TAG || name == null || name.Length == 0)
			{
				name = element.LocalName;
			}

			// Look for the property on the target object
			Type targetType = target.GetType();
			Type propertyType = null;

			PropertyInfo propInfo = null;
			MethodInfo methInfo = null;

			// Try to find a writable property
			propInfo = targetType.GetProperty(name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.IgnoreCase);
			if (propInfo != null && propInfo.CanWrite)
			{
				// found a property
				propertyType = propInfo.PropertyType;
			}
			else
			{
				propInfo = null;

				// look for a method with the signature Add<property>(type)
				methInfo = FindMethodInfo(targetType, name);

				if (methInfo != null)
				{
					propertyType = methInfo.GetParameters()[0].ParameterType;
				}
			}

			if (propertyType == null)
			{
				LogLog.Error(declaringType, "XmlHierarchyConfigurator: Cannot find Property [" + name + "] to set object on [" + target.ToString() + "]");
			}
			else
			{
				string propertyValue = null;

				if (element.GetAttributeNode(VALUE_ATTR) != null)
				{
					propertyValue = element.GetAttribute(VALUE_ATTR);
				}
				else if (element.HasChildNodes)
				{
					// Concatenate the CDATA and Text nodes together
					foreach(XmlNode childNode in element.ChildNodes)
					{
						if (childNode.NodeType == XmlNodeType.CDATA || childNode.NodeType == XmlNodeType.Text)
						{
							if (propertyValue == null)
							{
								propertyValue = childNode.InnerText;
							}
							else
							{
								propertyValue += childNode.InnerText;
							}
						}
					}
				}

				if(propertyValue != null)
				{
#if !(NETCF || NETSTANDARD1_3) // NETSTANDARD1_3: System.Runtime.InteropServices.RuntimeInformation not available on desktop 4.6
					try
					{
						// Expand environment variables in the string.
					    IDictionary environmentVariables = Environment.GetEnvironmentVariables();
					    if (HasCaseInsensitiveEnvironment) {
						environmentVariables = CreateCaseInsensitiveWrapper(environmentVariables);
					    }
						propertyValue = OptionConverter.SubstituteVariables(propertyValue, environmentVariables);
					}
					catch(System.Security.SecurityException)
					{
						// This security exception will occur if the caller does not have 
						// unrestricted environment permission. If this occurs the expansion 
						// will be skipped with the following warning message.
						LogLog.Debug(declaringType, "Security exception while trying to expand environment variables. Error Ignored. No Expansion.");
					}
#endif

					Type parsedObjectConversionTargetType = null;

					// Check if a specific subtype is specified on the element using the 'type' attribute
					string subTypeString = element.GetAttribute(TYPE_ATTR);
					if (subTypeString != null && subTypeString.Length > 0)
					{
						// Read the explicit subtype
						try
						{
#if NETSTANDARD1_3
							Type subType = SystemInfo.GetTypeFromString(this.GetType().GetTypeInfo().Assembly, subTypeString, true, true);
#else
							Type subType = SystemInfo.GetTypeFromString(subTypeString, true, true);
#endif

							LogLog.Debug(declaringType, "Parameter ["+name+"] specified subtype ["+subType.FullName+"]");

							if (!propertyType.IsAssignableFrom(subType))
							{
								// Check if there is an appropriate type converter
								if (OptionConverter.CanConvertTypeTo(subType, propertyType))
								{
									// Must re-convert to the real property type
									parsedObjectConversionTargetType = propertyType;

									// Use sub type as intermediary type
									propertyType = subType;
								}
								else
								{
									LogLog.Error(declaringType, "subtype ["+subType.FullName+"] set on ["+name+"] is not a subclass of property type ["+propertyType.FullName+"] and there are no acceptable type conversions.");
								}
							}
							else
							{
								// The subtype specified is found and is actually a subtype of the property
								// type, therefore we can switch to using this type.
								propertyType = subType;
							}
						}
						catch(Exception ex)
						{
							LogLog.Error(declaringType, "Failed to find type ["+subTypeString+"] set on ["+name+"]", ex);
						}
					}

					// Now try to convert the string value to an acceptable type
					// to pass to this property.

					object convertedValue = ConvertStringTo(propertyType, propertyValue);
					
					// Check if we need to do an additional conversion
					if (convertedValue != null && parsedObjectConversionTargetType != null)
					{
						LogLog.Debug(declaringType, "Performing additional conversion of value from [" + convertedValue.GetType().Name + "] to [" + parsedObjectConversionTargetType.Name + "]");
						convertedValue = OptionConverter.ConvertTypeTo(convertedValue, parsedObjectConversionTargetType);
					}

					if (convertedValue != null)
					{
						if (propInfo != null)
						{
							// Got a converted result
							LogLog.Debug(declaringType, "Setting Property [" + propInfo.Name + "] to " + convertedValue.GetType().Name + " value [" + convertedValue.ToString() + "]");

							try
							{
								// Pass to the property
#if NETSTANDARD1_3 // TODO BindingFlags is available for netstandard1.5
								propInfo.SetValue(target, convertedValue, null);
#else
								propInfo.SetValue(target, convertedValue, BindingFlags.SetProperty, null, null, CultureInfo.InvariantCulture);
#endif
							}
							catch(TargetInvocationException targetInvocationEx)
							{
								LogLog.Error(declaringType, "Failed to set parameter [" + propInfo.Name + "] on object [" + target + "] using value [" + convertedValue + "]", targetInvocationEx.InnerException);
							}
						}
						else if (methInfo != null)
						{
							// Got a converted result
							LogLog.Debug(declaringType, "Setting Collection Property [" + methInfo.Name + "] to " + convertedValue.GetType().Name + " value [" + convertedValue.ToString() + "]");

							try
							{
								// Pass to the property
#if NETSTANDARD1_3 // TODO BindingFlags is available for netstandard1.5
								methInfo.Invoke(target, new[] { convertedValue });
#else
								methInfo.Invoke(target, BindingFlags.InvokeMethod, null, new object[] {convertedValue}, CultureInfo.InvariantCulture);
#endif
							}
							catch(TargetInvocationException targetInvocationEx)
							{
								LogLog.Error(declaringType, "Failed to set parameter [" + name + "] on object [" + target + "] using value [" + convertedValue + "]", targetInvocationEx.InnerException);
							}
						}
					}
					else
					{
						LogLog.Warn(declaringType, "Unable to set property [" + name + "] on object [" + target + "] using value [" + propertyValue + "] (with acceptable conversion types)");
					}
				}
				else
				{
					object createdObject = null;

					if (propertyType == typeof(string) && !HasAttributesOrElements(element))
					{
						// If the property is a string and the element is empty (no attributes
						// or child elements) then we special case the object value to an empty string.
						// This is necessary because while the String is a class it does not have
						// a default constructor that creates an empty string, which is the behavior
						// we are trying to simulate and would be expected from CreateObjectFromXml
						createdObject = "";
					}
					else
					{
						// No value specified
						Type defaultObjectType = null;
						if (IsTypeConstructible(propertyType))
						{
							defaultObjectType = propertyType;
						}

						createdObject = CreateObjectFromXml(element, defaultObjectType, propertyType);
					}

					if (createdObject == null)
					{
						LogLog.Error(declaringType, "Failed to create object to set param: "+name);
					}
					else
					{
						if (propInfo != null)
						{
							// Got a converted result
							LogLog.Debug(declaringType, "Setting Property ["+ propInfo.Name +"] to object ["+ createdObject +"]");

							try
							{
								// Pass to the property
#if NETSTANDARD1_3 // TODO BindingFlags is available for netstandard1.5
								propInfo.SetValue(target, createdObject, null);
#else
								propInfo.SetValue(target, createdObject, BindingFlags.SetProperty, null, null, CultureInfo.InvariantCulture);
#endif
							}
							catch(TargetInvocationException targetInvocationEx)
							{
								LogLog.Error(declaringType, "Failed to set parameter [" + propInfo.Name + "] on object [" + target + "] using value [" + createdObject + "]", targetInvocationEx.InnerException);
							}
						}
						else if (methInfo != null)
						{
							// Got a converted result
							LogLog.Debug(declaringType, "Setting Collection Property ["+ methInfo.Name +"] to object ["+ createdObject +"]");

							try
							{
								// Pass to the property
#if NETSTANDARD1_3 // TODO BindingFlags is available for netstandard1.5
								methInfo.Invoke(target, new[] { createdObject });
#else
								methInfo.Invoke(target, BindingFlags.InvokeMethod, null, new object[] {createdObject}, CultureInfo.InvariantCulture);
#endif
							}
							catch(TargetInvocationException targetInvocationEx)
							{
								LogLog.Error(declaringType, "Failed to set parameter [" + methInfo.Name + "] on object [" + target + "] using value [" + createdObject + "]", targetInvocationEx.InnerException);
							}
						}
					}
				}
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="ADDITIVITY_ATTR">
          <declaration><![CDATA[private const string ADDITIVITY_ATTR = "additivity";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="APPENDER_REF_TAG">
          <declaration><![CDATA[private const string APPENDER_REF_TAG = "appender-ref";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="APPENDER_TAG">
          <declaration><![CDATA[private const string APPENDER_TAG = "appender";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="CATEGORY_TAG">
          <declaration><![CDATA[private const string CATEGORY_TAG = "category";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="CONFIG_DEBUG_ATTR">
          <declaration><![CDATA[private const string CONFIG_DEBUG_ATTR = "configDebug";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="CONFIG_UPDATE_MODE_ATTR">
          <declaration><![CDATA[private const string CONFIG_UPDATE_MODE_ATTR = "update";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="CONFIGURATION_TAG">
          <declaration><![CDATA[private const string CONFIGURATION_TAG = "log4net";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(XmlHierarchyConfigurator);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="EMIT_INTERNAL_DEBUG_ATTR">
          <declaration><![CDATA[private const string EMIT_INTERNAL_DEBUG_ATTR = "emitDebug";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="INHERITED">
          <declaration><![CDATA[private const string INHERITED = "inherited";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="INTERNAL_DEBUG_ATTR">
          <declaration><![CDATA[private const string INTERNAL_DEBUG_ATTR = "debug";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="LEVEL_TAG">
          <declaration><![CDATA[private const string LEVEL_TAG = "level";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="LOGGER_TAG">
          <declaration><![CDATA[private const string LOGGER_TAG = "logger";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_appenderBag">
          <declaration><![CDATA[private Hashtable m_appenderBag;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_hierarchy">
          <declaration><![CDATA[private readonly Hierarchy m_hierarchy;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="NAME_ATTR">
          <declaration><![CDATA[private const string NAME_ATTR = "name";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="PARAM_TAG">
          <declaration><![CDATA[private const string PARAM_TAG = "param";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="PRIORITY_TAG">
          <declaration><![CDATA[private const string PRIORITY_TAG = "priority";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="REF_ATTR">
          <declaration><![CDATA[private const string REF_ATTR = "ref";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="RENDERED_TYPE_ATTR">
          <declaration><![CDATA[private const string RENDERED_TYPE_ATTR = "renderedClass";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="RENDERER_TAG">
          <declaration><![CDATA[private const string RENDERER_TAG = "renderer";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="RENDERING_TYPE_ATTR">
          <declaration><![CDATA[private const string RENDERING_TYPE_ATTR = "renderingClass";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ROOT_TAG">
          <declaration><![CDATA[private const string ROOT_TAG = "root";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="THRESHOLD_ATTR">
          <declaration><![CDATA[private const string THRESHOLD_ATTR = "threshold";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="TYPE_ATTR">
          <declaration><![CDATA[private const string TYPE_ATTR = "type";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="VALUE_ATTR">
          <declaration><![CDATA[private const string VALUE_ATTR = "value";]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="HasCaseInsensitiveEnvironment">
          <declaration><![CDATA[private bool HasCaseInsensitiveEnvironment]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1073" sc="7" el="1084" ec="8">log4net\Repository\Hierarchy\XmlHierarchyConfigurator.cs</location>
            <body hash="bf3e5018706fcd358c4a8236eba63fd6"><![CDATA[{
#if NET_1_0 || NET_1_1 || CLI_1_0
			// actually there is no guarantee, but we don't know better
			return true;
#elif MONO_1_0
			// see above
			return false;
#else
			PlatformID platform = Environment.OSVersion.Platform;
			return platform != PlatformID.Unix && platform != PlatformID.MacOSX;
#endif
		    }]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="log4net.Util">
    <class name="AppenderAttachedImpl">
      <declaration><![CDATA[public class AppenderAttachedImpl : IAppenderAttachable]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public AppenderAttachedImpl()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="51" sc="3" el="53" ec="4">log4net\Util\AppenderAttachedImpl.cs</location>
            <body hash="6f2bd34800ae85c6f25b4924a1331c7b"><![CDATA[public AppenderAttachedImpl()
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static AppenderAttachedImpl()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="372" sc="6" el="372" ec="80">log4net\Util\AppenderAttachedImpl.cs</location>
            <body hash="423e54aa177fb92517dfc680f2eb014b"><![CDATA[private readonly static Type declaringType = typeof(AppenderAttachedImpl)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AddAppender">
          <declaration><![CDATA[public void AddAppender(IAppender newAppender)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="202" sc="3" el="218" ec="4">log4net\Util\AppenderAttachedImpl.cs</location>
            <body hash="41cfafe80d40826f4ce3924697804f12"><![CDATA[{
			// Null values for newAppender parameter are strictly forbidden.
			if (newAppender == null)
			{
				throw new ArgumentNullException("newAppender");
			}
	
			m_appenderArray = null;
			if (m_appenderList == null) 
			{
				m_appenderList = new AppenderCollection(1);
			}
			if (!m_appenderList.Contains(newAppender))
			{
				m_appenderList.Add(newAppender);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="AppendLoopOnAppenders">
          <declaration><![CDATA[public int AppendLoopOnAppenders(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="71" sc="3" el="100" ec="4">log4net\Util\AppenderAttachedImpl.cs</location>
            <body hash="c7e8caba048b54bb58de29d19a6590b9"><![CDATA[{
			if (loggingEvent == null)
			{
				throw new ArgumentNullException("loggingEvent");
			}

			// m_appenderList is null when empty
			if (m_appenderList == null) 
			{
				return 0;
			}

			if (m_appenderArray == null)
			{
				m_appenderArray = m_appenderList.ToArray();
			}

			foreach(IAppender appender in m_appenderArray)
			{
				try
				{
					appender.DoAppend(loggingEvent);
				}
				catch(Exception ex)
				{
					LogLog.Error(declaringType, "Failed to append to appender [" + appender.Name + "]", ex);
				}
			}
			return m_appenderList.Count;
		}]]></body>
          </codeblock>
        </method>
        <method name="AppendLoopOnAppenders">
          <declaration><![CDATA[public int AppendLoopOnAppenders(LoggingEvent[] loggingEvents)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="114" sc="3" el="152" ec="4">log4net\Util\AppenderAttachedImpl.cs</location>
            <body hash="a7faed72b10e0445895a8aa5e00c2acb"><![CDATA[{
			if (loggingEvents == null)
			{
				throw new ArgumentNullException("loggingEvents");
			}
			if (loggingEvents.Length == 0)
			{
				throw new ArgumentException("loggingEvents array must not be empty", "loggingEvents");
			}
			if (loggingEvents.Length == 1)
			{
				// Fall back to single event path
				return AppendLoopOnAppenders(loggingEvents[0]);
			}

			// m_appenderList is null when empty
			if (m_appenderList == null) 
			{
				return 0;
			}

			if (m_appenderArray == null)
			{
				m_appenderArray = m_appenderList.ToArray();
			}

			foreach(IAppender appender in m_appenderArray)
			{
				try
				{
					CallAppend(appender, loggingEvents);
				}
				catch(Exception ex)
				{
					LogLog.Error(declaringType, "Failed to append to appender [" + appender.Name + "]", ex);
				}
			}
			return m_appenderList.Count;
		}]]></body>
          </codeblock>
        </method>
        <method name="CallAppend">
          <declaration><![CDATA[private static void CallAppend(IAppender appender, LoggingEvent[] loggingEvents)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="173" sc="3" el="186" ec="10">log4net\Util\AppenderAttachedImpl.cs</location>
            <body hash="8c0725fb20c82009441dde8e86e9921a"><![CDATA[{
			IBulkAppender bulkAppender = appender as IBulkAppender;
			if (bulkAppender != null)
			{
				bulkAppender.DoAppend(loggingEvents);
			}
			else
			{
				foreach(LoggingEvent loggingEvent in loggingEvents)
				{
					appender.DoAppend(loggingEvent);
				}
			}
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAppender">
          <declaration><![CDATA[public IAppender GetAppender(string name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="262" sc="3" el="274" ec="4">log4net\Util\AppenderAttachedImpl.cs</location>
            <body hash="4bdb3cffb2a8a27fcaaa24060be0fa0f"><![CDATA[{
			if (m_appenderList != null && name != null)
			{
				foreach(IAppender appender in m_appenderList)
				{
					if (name == appender.Name)
					{
						return appender;
					}
				}
			}
			return null;   
		}]]></body>
          </codeblock>
        </method>
        <method name="RemoveAllAppenders">
          <declaration><![CDATA[public void RemoveAllAppenders()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="285" sc="3" el="302" ec="4">log4net\Util\AppenderAttachedImpl.cs</location>
            <body hash="130c7972fd43de742424fbd327d013e9"><![CDATA[{
			if (m_appenderList != null) 
			{
				foreach(IAppender appender in m_appenderList)
				{
					try
					{
						appender.Close();
					}
					catch(Exception ex)
					{
						LogLog.Error(declaringType, "Failed to Close appender ["+appender.Name+"]", ex);
					}
				}
				m_appenderList = null;	  
				m_appenderArray = null;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="RemoveAppender">
          <declaration><![CDATA[public IAppender RemoveAppender(IAppender appender)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="317" sc="3" el="328" ec="4">log4net\Util\AppenderAttachedImpl.cs</location>
            <body hash="529a1a22608b2249f8cbd25602627109"><![CDATA[{
			if (appender != null && m_appenderList != null) 
			{
				m_appenderList.Remove(appender);
				if (m_appenderList.Count == 0)
				{
					m_appenderList = null;
				}
				m_appenderArray = null;
			}
			return appender;
		}]]></body>
          </codeblock>
        </method>
        <method name="RemoveAppender">
          <declaration><![CDATA[public IAppender RemoveAppender(string name)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="343" sc="3" el="345" ec="4">log4net\Util\AppenderAttachedImpl.cs</location>
            <body hash="4ccf5bdb384e2c4e9914453481b67b28"><![CDATA[{
			return RemoveAppender(GetAppender(name));
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(AppenderAttachedImpl);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_appenderArray">
          <declaration><![CDATA[private IAppender[] m_appenderArray;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_appenderList">
          <declaration><![CDATA[private AppenderCollection m_appenderList;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Appenders">
          <declaration><![CDATA[public AppenderCollection Appenders]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="235" sc="4" el="245" ec="5">log4net\Util\AppenderAttachedImpl.cs</location>
            <body hash="55b0b3e6208d8520b7be18fc21d66ce9"><![CDATA[{
				if (m_appenderList == null)
				{
					// We must always return a valid collection
					return AppenderCollection.EmptyCollection;
				}
				else 
				{
					return AppenderCollection.ReadOnly(m_appenderList);
				}
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="CompositeProperties">
      <declaration><![CDATA[public sealed class CompositeProperties]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private PropertiesDictionary m_flattened = null;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="39" sc="3" el="56" ec="4">log4net\Util\CompositeProperties.cs</location>
            <body hash="e8096d56f0baea9615257c02c84e3669"><![CDATA[private PropertiesDictionary m_flattened = null;
		private ArrayList m_nestedProperties = new ArrayList();

		#endregion Private Instance Fields

		#region Public Instance Constructors

		/// <summary>
		/// Constructor
		/// </summary>
		/// <remarks>
		/// <para>
		/// Initializes a new instance of the <see cref="CompositeProperties" /> class.
		/// </para>
		/// </remarks>
		internal CompositeProperties()
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Add">
          <declaration><![CDATA[public void Add(ReadOnlyPropertiesDictionary properties)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="118" sc="3" el="121" ec="4">log4net\Util\CompositeProperties.cs</location>
            <body hash="c6dc00b1ad459e3ff7a4b8d1180f8dde"><![CDATA[{
			m_flattened = null;
			m_nestedProperties.Add(properties);
		}]]></body>
          </codeblock>
        </method>
        <method name="Flatten">
          <declaration><![CDATA[public PropertiesDictionary Flatten()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="134" sc="3" el="150" ec="4">log4net\Util\CompositeProperties.cs</location>
            <body hash="3eb28f1a6bf976a9435f15e0f2057a46"><![CDATA[{
			if (m_flattened == null)
			{
				m_flattened = new PropertiesDictionary();

				for(int i=m_nestedProperties.Count; --i>=0; )
				{
					ReadOnlyPropertiesDictionary cur = (ReadOnlyPropertiesDictionary)m_nestedProperties[i];

					foreach(DictionaryEntry entry in cur)
					{
						m_flattened[(string)entry.Key] = entry.Value;
					}
				}
			}
			return m_flattened;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_flattened">
          <declaration><![CDATA[private PropertiesDictionary m_flattened = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_nestedProperties">
          <declaration><![CDATA[private ArrayList m_nestedProperties = new ArrayList();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Item">
          <declaration><![CDATA[public object this[string key]]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="84" sc="4" el="100" ec="5">log4net\Util\CompositeProperties.cs</location>
            <body hash="6b2e3c6b48f2274aec930a0d02ed19a4"><![CDATA[{
				// Look in the flattened properties first
				if (m_flattened != null)
				{
					return m_flattened[key];
				}

				// Look for the key in all the nested properties
				foreach(ReadOnlyPropertiesDictionary cur in m_nestedProperties)
				{
					if (cur.Contains(key))
					{
						return cur[key];
					}
				}
				return null;
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ContextPropertiesBase">
      <declaration><![CDATA[public abstract class ContextPropertiesBase]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[protected ContextPropertiesBase()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Item">
          <declaration><![CDATA[public abstract object this[string key]]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ConverterInfo">
      <declaration><![CDATA[public sealed class ConverterInfo]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private readonly PropertiesDictionary properties = new PropertiesDictionary();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="39" sc="9" el="46" ec="10">log4net\Util\ConverterInfo.cs</location>
            <body hash="569d166419f697ddec1c0620b4eed004"><![CDATA[private readonly PropertiesDictionary properties = new PropertiesDictionary();

        /// <summary>
        /// default constructor
        /// </summary>
        public ConverterInfo()
        {
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AddProperty">
          <declaration><![CDATA[public void AddProperty(PropertyEntry entry)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="82" sc="9" el="84" ec="10">log4net\Util\ConverterInfo.cs</location>
            <body hash="c5847f7c43ed3d9e15e94bd83274e3e5"><![CDATA[{
            properties[entry.Key] = entry.Value;
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_name">
          <declaration><![CDATA[private string m_name;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_type">
          <declaration><![CDATA[private Type m_type;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="properties">
          <declaration><![CDATA[private readonly PropertiesDictionary properties = new PropertiesDictionary();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Name">
          <declaration><![CDATA[public string Name]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Properties">
          <declaration><![CDATA[public PropertiesDictionary Properties]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Type">
          <declaration><![CDATA[public Type Type]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="CountingQuietTextWriter">
      <declaration><![CDATA[public class CountingQuietTextWriter : QuietTextWriter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public CountingQuietTextWriter(TextWriter writer, IErrorHandler errorHandler) : base(writer, errorHandler)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="53" sc="83" el="56" ec="4">log4net\Util\CountingQuietTextWriter.cs</location>
            <body hash="4f853410d3fb0f544a401bd652e3d761"><![CDATA[base(writer, errorHandler)
		{
			m_countBytes = 0;
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Write">
          <declaration><![CDATA[public override void Write(char value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="73" sc="3" el="86" ec="4">log4net\Util\CountingQuietTextWriter.cs</location>
            <body hash="2a010e5ddfc18156d5edddc907b18785"><![CDATA[{
			try 
			{
				base.Write(value);

				// get the number of bytes needed to represent the 
				// char using the supplied encoding.
				m_countBytes += this.Encoding.GetByteCount(new char[] { value });
			} 
			catch(Exception e) 
			{
				this.ErrorHandler.Error("Failed to write [" + value + "].", e, ErrorCode.WriteFailure);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Write">
          <declaration><![CDATA[public override void Write(char[] buffer, int index, int count)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="101" sc="3" el="117" ec="4">log4net\Util\CountingQuietTextWriter.cs</location>
            <body hash="b183a0434907492f7524e5ddb6eae0ab"><![CDATA[{
			if (count > 0)
			{
				try 
				{
					base.Write(buffer, index, count);

					// get the number of bytes needed to represent the 
					// char array using the supplied encoding.
					m_countBytes += this.Encoding.GetByteCount(buffer, index, count);
				} 
				catch(Exception e) 
				{
					this.ErrorHandler.Error("Failed to write buffer.", e, ErrorCode.WriteFailure);
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Write">
          <declaration><![CDATA[public override void Write(string str)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="130" sc="3" el="146" ec="4">log4net\Util\CountingQuietTextWriter.cs</location>
            <body hash="8dd9ec894157b596c40dcbbb7b84bdb7"><![CDATA[{
			if (str != null && str.Length > 0)
			{
				try 
				{
					base.Write(str);

					// get the number of bytes needed to represent the 
					// string using the supplied encoding.
					m_countBytes += this.Encoding.GetByteCount(str);
				}
				catch(Exception e) 
				{
					this.ErrorHandler.Error("Failed to write [" + str + "].", e, ErrorCode.WriteFailure);
				}
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_countBytes">
          <declaration><![CDATA[private long m_countBytes;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Count">
          <declaration><![CDATA[public long Count]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="CyclicBuffer">
      <declaration><![CDATA[public class CyclicBuffer]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public CyclicBuffer(int maxSize)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="51" sc="3" el="63" ec="4">log4net\Util\CyclicBuffer.cs</location>
            <body hash="1a9164be62931c282b02e116b63e90ca"><![CDATA[public CyclicBuffer(int maxSize) 
		{
			if (maxSize < 1) 
			{
				throw SystemInfo.CreateArgumentOutOfRangeException("maxSize", (object)maxSize, "Parameter: maxSize, Value: [" + maxSize + "] out of range. Non zero positive integer required");
			}

			m_maxSize = maxSize;
			m_events = new LoggingEvent[maxSize];
			m_first = 0;
			m_last = 0;
			m_numElems = 0;
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Append">
          <declaration><![CDATA[public LoggingEvent Append(LoggingEvent loggingEvent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="82" sc="3" el="120" ec="4">log4net\Util\CyclicBuffer.cs</location>
            <body hash="982e75533248a132e316d7662cd1ca10"><![CDATA[{	
			if (loggingEvent == null)
			{
				throw new ArgumentNullException("loggingEvent");
			}

			lock(this)
			{
				// save the discarded event
				LoggingEvent discardedLoggingEvent = m_events[m_last];

				// overwrite the last event position
				m_events[m_last] = loggingEvent;	
				if (++m_last == m_maxSize)
				{
					m_last = 0;
				}

				if (m_numElems < m_maxSize)
				{
					m_numElems++;
				}
				else if (++m_first == m_maxSize)
				{
					m_first = 0;
				}

				if (m_numElems < m_maxSize)
				{
					// Space remaining
					return null;
				}
				else
				{
					// Buffer is full and discarding an event
					return discardedLoggingEvent;
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Clear">
          <declaration><![CDATA[public void Clear()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="194" sc="3" el="204" ec="4">log4net\Util\CyclicBuffer.cs</location>
            <body hash="0fecff2305ef9d1ae5e4e4e1522a97d0"><![CDATA[{
			lock(this)
			{
				// Set all the elements to null
				Array.Clear(m_events, 0, m_events.Length);

				m_first = 0;
				m_last = 0;
				m_numElems = 0;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="PopAll">
          <declaration><![CDATA[public LoggingEvent[] PopAll()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="161" sc="3" el="183" ec="4">log4net\Util\CyclicBuffer.cs</location>
            <body hash="81013d3f9d7120491c9de1d240b98be2"><![CDATA[{
			lock(this)
			{
				LoggingEvent[] ret = new LoggingEvent[m_numElems];

				if (m_numElems > 0)
				{
					if (m_first < m_last)
					{
						Array.Copy(m_events, m_first, ret, 0, m_numElems);
					}
					else
					{
						Array.Copy(m_events, m_first, ret, 0, m_maxSize - m_first);
						Array.Copy(m_events, 0, ret, m_maxSize - m_first, m_last);
					}
				}

				Clear();

				return ret;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="PopOldest">
          <declaration><![CDATA[public LoggingEvent PopOldest()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="133" sc="3" el="149" ec="4">log4net\Util\CyclicBuffer.cs</location>
            <body hash="32f96e1ee14fbd1ceee89d05407e84ba"><![CDATA[{
			lock(this)
			{
				LoggingEvent ret = null;
				if (m_numElems > 0) 
				{
					m_numElems--;
					ret = m_events[m_first];
					m_events[m_first] = null;
					if (++m_first == m_maxSize)
					{
						m_first = 0;
					}
				} 
				return ret;
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_events">
          <declaration><![CDATA[private LoggingEvent[] m_events;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_first">
          <declaration><![CDATA[private int m_first;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_last">
          <declaration><![CDATA[private int m_last;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_maxSize">
          <declaration><![CDATA[private int m_maxSize;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_numElems">
          <declaration><![CDATA[private int m_numElems;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Item">
          <declaration><![CDATA[public LoggingEvent this[int i]]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="282" sc="4" el="292" ec="5">log4net\Util\CyclicBuffer.cs</location>
            <body hash="8ebe536b14d07abba95e3a9462abbc6a"><![CDATA[{
				lock(this)
				{
					if (i < 0 || i >= m_numElems)
					{
						return null;
					}

					return m_events[(m_first + i) % m_maxSize];
				}
			}]]></body>
          </codeblock>
        </property>
        <property name="Length">
          <declaration><![CDATA[public int Length]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="335" sc="4" el="340" ec="5">log4net\Util\CyclicBuffer.cs</location>
            <body hash="8baa291b6493883f18d679c07e4df78b"><![CDATA[{ 
				lock(this) 
				{ 
					return m_numElems; 
				}
			}]]></body>
          </codeblock>
        </property>
        <property name="MaxSize">
          <declaration><![CDATA[public int MaxSize]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="307" sc="4" el="312" ec="5">log4net\Util\CyclicBuffer.cs</location>
            <body hash="221892541600e9f8fa463ac810628a77"><![CDATA[{ 
				lock(this)
				{
					return m_maxSize; 
				}
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="EmptyCollection">
      <declaration><![CDATA[public sealed class EmptyCollection : ICollection, IEnumerable]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private EmptyCollection()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="51" sc="3" el="53" ec="4">log4net\Util\EmptyCollection.cs</location>
            <body hash="4d68f1ddfba891db91e5b599ff0cef8e"><![CDATA[private EmptyCollection()
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static EmptyCollection()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="174" sc="3" el="174" ec="78">log4net\Util\EmptyCollection.cs</location>
            <body hash="d5a75fcca9f32d91bd27ae47459d575e"><![CDATA[private readonly static EmptyCollection s_instance = new EmptyCollection()]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CopyTo">
          <declaration><![CDATA[public void CopyTo(Array array, int index)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="93" sc="3" el="95" ec="4">log4net\Util\EmptyCollection.cs</location>
            <body hash="ebf1c593fea55310ef9797ddd84d916a"><![CDATA[{
			// copy nothing
		}]]></body>
          </codeblock>
        </method>
        <method name="GetEnumerator">
          <declaration><![CDATA[public IEnumerator GetEnumerator()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="163" sc="3" el="165" ec="4">log4net\Util\EmptyCollection.cs</location>
            <body hash="27a22eb0c2c582fe02da2ccd0272e699"><![CDATA[{
			return NullEnumerator.Instance;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="s_instance">
          <declaration><![CDATA[private static readonly EmptyCollection s_instance = new EmptyCollection();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Count">
          <declaration><![CDATA[public int Count]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Instance">
          <declaration><![CDATA[public static EmptyCollection Instance]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IsSynchronized">
          <declaration><![CDATA[public bool IsSynchronized]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="SyncRoot">
          <declaration><![CDATA[public object SyncRoot]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="EmptyDictionary">
      <declaration><![CDATA[public sealed class EmptyDictionary : IDictionary, ICollection, IEnumerable]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private EmptyDictionary()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="51" sc="3" el="53" ec="4">log4net\Util\EmptyDictionary.cs</location>
            <body hash="962eca6c127301cc2f763c5fcb3305a1"><![CDATA[private EmptyDictionary()
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static EmptyDictionary()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="335" sc="3" el="335" ec="78">log4net\Util\EmptyDictionary.cs</location>
            <body hash="b0acf1acfd45775cd0f563b4b78a68ba"><![CDATA[private readonly static EmptyDictionary s_instance = new EmptyDictionary()]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Add">
          <declaration><![CDATA[public void Add(object key, object value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="185" sc="3" el="186" ec="42">log4net\Util\EmptyDictionary.cs</location>
            <body hash="6242d667ead7b6ec5768ab8093828515"><![CDATA[{
			throw new InvalidOperationException();]]></body>
          </codeblock>
        </method>
        <method name="Clear">
          <declaration><![CDATA[public void Clear()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="200" sc="3" el="201" ec="42">log4net\Util\EmptyDictionary.cs</location>
            <body hash="6242d667ead7b6ec5768ab8093828515"><![CDATA[{
			throw new InvalidOperationException();]]></body>
          </codeblock>
        </method>
        <method name="Contains">
          <declaration><![CDATA[public bool Contains(object key)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="216" sc="3" el="218" ec="4">log4net\Util\EmptyDictionary.cs</location>
            <body hash="95329ba72f6d873bf64cd96c35ffa442"><![CDATA[{
			return false;
		}]]></body>
          </codeblock>
        </method>
        <method name="CopyTo">
          <declaration><![CDATA[public void CopyTo(Array array, int index)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="93" sc="3" el="95" ec="4">log4net\Util\EmptyDictionary.cs</location>
            <body hash="ebf1c593fea55310ef9797ddd84d916a"><![CDATA[{
			// copy nothing
		}]]></body>
          </codeblock>
        </method>
        <method name="GetEnumerator">
          <declaration><![CDATA[public IDictionaryEnumerator GetEnumerator()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="233" sc="3" el="235" ec="4">log4net\Util\EmptyDictionary.cs</location>
            <body hash="018f2ce094659af083e6fc6fd88fdfb7"><![CDATA[{
			return NullDictionaryEnumerator.Instance;
		}]]></body>
          </codeblock>
        </method>
        <method name="Remove">
          <declaration><![CDATA[public void Remove(object key)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="249" sc="3" el="250" ec="42">log4net\Util\EmptyDictionary.cs</location>
            <body hash="6242d667ead7b6ec5768ab8093828515"><![CDATA[{
			throw new InvalidOperationException();]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IEnumerable.GetEnumerator">
          <declaration><![CDATA[IEnumerator IEnumerable.GetEnumerator()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="163" sc="3" el="165" ec="4">log4net\Util\EmptyDictionary.cs</location>
            <body hash="27a22eb0c2c582fe02da2ccd0272e699"><![CDATA[{
			return NullEnumerator.Instance;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="s_instance">
          <declaration><![CDATA[private static readonly EmptyDictionary s_instance = new EmptyDictionary();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Count">
          <declaration><![CDATA[public int Count]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Instance">
          <declaration><![CDATA[public static EmptyDictionary Instance]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IsFixedSize">
          <declaration><![CDATA[public bool IsFixedSize]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IsReadOnly">
          <declaration><![CDATA[public bool IsReadOnly]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IsSynchronized">
          <declaration><![CDATA[public bool IsSynchronized]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Item">
          <declaration><![CDATA[public object this[object key]]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Keys">
          <declaration><![CDATA[public ICollection Keys]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="SyncRoot">
          <declaration><![CDATA[public object SyncRoot]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Values">
          <declaration><![CDATA[public ICollection Values]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="FormattingInfo">
      <declaration><![CDATA[public class FormattingInfo]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_min = -1;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="50" sc="3" el="132" ec="36">log4net\Util\FormattingInfo.cs</location>
            <body hash="06a115b025d7ac1ff6814cbee8f40b17"><![CDATA[public FormattingInfo() 
		{
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <remarks>
		/// <para>
		/// Initializes a new instance of the <see cref="FormattingInfo" /> class
		/// with the specified parameters.
		/// </para>
		/// </remarks>
		public FormattingInfo(int min, int max, bool leftAlign) 
		{
			m_min = min;
			m_max = max;
			m_leftAlign = leftAlign;
		}

		#endregion Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Gets or sets the minimum value.
		/// </summary>
		/// <value>
		/// The minimum value.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets or sets the minimum value.
		/// </para>
		/// </remarks>
		public int Min
		{
			get { return m_min; }
			set { m_min = value; }
		}

		/// <summary>
		/// Gets or sets the maximum value.
		/// </summary>
		/// <value>
		/// The maximum value.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets or sets the maximum value.
		/// </para>
		/// </remarks>
		public int Max
		{
			get { return m_max; }
			set { m_max = value; }
		}

		/// <summary>
		/// Gets or sets a flag indicating whether left align is enabled
		/// or not.
		/// </summary>
		/// <value>
		/// A flag indicating whether left align is enabled or not.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets or sets a flag indicating whether left align is enabled or not.
		/// </para>
		/// </remarks>
		public bool LeftAlign
		{
			get { return m_leftAlign; }
			set { m_leftAlign = value; }
		}

		#endregion Public Instance Properties

		#region Private Instance Fields

		private int m_min = -1;
		private int m_max = int.MaxValue;
		private bool m_leftAlign = false;]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_min = -1;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="63" sc="3" el="132" ec="36">log4net\Util\FormattingInfo.cs</location>
            <body hash="b7f115d3a9be7d3efffce121ae5fc2e3"><![CDATA[public FormattingInfo(int min, int max, bool leftAlign) 
		{
			m_min = min;
			m_max = max;
			m_leftAlign = leftAlign;
		}

		#endregion Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Gets or sets the minimum value.
		/// </summary>
		/// <value>
		/// The minimum value.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets or sets the minimum value.
		/// </para>
		/// </remarks>
		public int Min
		{
			get { return m_min; }
			set { m_min = value; }
		}

		/// <summary>
		/// Gets or sets the maximum value.
		/// </summary>
		/// <value>
		/// The maximum value.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets or sets the maximum value.
		/// </para>
		/// </remarks>
		public int Max
		{
			get { return m_max; }
			set { m_max = value; }
		}

		/// <summary>
		/// Gets or sets a flag indicating whether left align is enabled
		/// or not.
		/// </summary>
		/// <value>
		/// A flag indicating whether left align is enabled or not.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets or sets a flag indicating whether left align is enabled or not.
		/// </para>
		/// </remarks>
		public bool LeftAlign
		{
			get { return m_leftAlign; }
			set { m_leftAlign = value; }
		}

		#endregion Public Instance Properties

		#region Private Instance Fields

		private int m_min = -1;
		private int m_max = int.MaxValue;
		private bool m_leftAlign = false;]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="m_leftAlign">
          <declaration><![CDATA[private bool m_leftAlign = false;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_max">
          <declaration><![CDATA[private int m_max = 2147483647;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_min">
          <declaration><![CDATA[private int m_min = -1;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="LeftAlign">
          <declaration><![CDATA[public bool LeftAlign]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Max">
          <declaration><![CDATA[public int Max]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Min">
          <declaration><![CDATA[public int Min]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="GlobalContextProperties">
      <declaration><![CDATA[public sealed class GlobalContextProperties : ContextPropertiesBase]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private volatile ReadOnlyPropertiesDictionary m_readOnlyProperties = new ReadOnlyPropertiesDictionary();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="55" sc="3" el="77" ec="4">log4net\Util\GlobalContextProperties.cs</location>
            <body hash="7541e18ab596c9e60a990b474458999f"><![CDATA[private volatile ReadOnlyPropertiesDictionary m_readOnlyProperties = new ReadOnlyPropertiesDictionary();
#endif

		/// <summary>
		/// Lock object used to synchronize updates within this instance
		/// </summary>
		private readonly object m_syncRoot = new object();

		#endregion Private Instance Fields

		#region Public Instance Constructors

		/// <summary>
		/// Constructor
		/// </summary>
		/// <remarks>
		/// <para>
		/// Initializes a new instance of the <see cref="GlobalContextProperties" /> class.
		/// </para>
		/// </remarks>
		internal GlobalContextProperties()
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Clear">
          <declaration><![CDATA[public void Clear()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="148" sc="3" el="153" ec="4">log4net\Util\GlobalContextProperties.cs</location>
            <body hash="8c33e54c1e9b342dd9617057a8d29088"><![CDATA[{
			lock(m_syncRoot)
			{
				m_readOnlyProperties = new ReadOnlyPropertiesDictionary();
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="GetReadOnlyProperties">
          <declaration><![CDATA[internal ReadOnlyPropertiesDictionary GetReadOnlyProperties()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="170" sc="3" el="172" ec="4">log4net\Util\GlobalContextProperties.cs</location>
            <body hash="5f53eef16f0add4cb238da663e7ade5c"><![CDATA[{
			return m_readOnlyProperties;
		}]]></body>
          </codeblock>
        </method>
        <method name="Remove">
          <declaration><![CDATA[public void Remove(string key)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="130" sc="3" el="142" ec="4">log4net\Util\GlobalContextProperties.cs</location>
            <body hash="6e7526854eddb996a154760de29a21a6"><![CDATA[{
			lock(m_syncRoot)
			{
				if (m_readOnlyProperties.Contains(key))
				{
					PropertiesDictionary mutableProps = new PropertiesDictionary(m_readOnlyProperties);

					mutableProps.Remove(key);

					m_readOnlyProperties = new ReadOnlyPropertiesDictionary(mutableProps);
				}
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_readOnlyProperties">
          <declaration><![CDATA[private volatile ReadOnlyPropertiesDictionary m_readOnlyProperties = new ReadOnlyPropertiesDictionary();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_syncRoot">
          <declaration><![CDATA[private readonly object m_syncRoot = new object();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Item">
          <declaration><![CDATA[public override object this[string key]]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="99" sc="4" el="101" ec="5">log4net\Util\GlobalContextProperties.cs</location>
            <body hash="a93463cc3e55f6363a0315676bdf57b0"><![CDATA[{ 
				return m_readOnlyProperties[key];
			}]]></body>
          </codeblock>
          <codeblock>
            <location sl="103" sc="4" el="112" ec="5">log4net\Util\GlobalContextProperties.cs</location>
            <body hash="1b54a3f965302e853e35349e2caef3de"><![CDATA[{
				lock(m_syncRoot)
				{
					PropertiesDictionary mutableProps = new PropertiesDictionary(m_readOnlyProperties);

					mutableProps[key] = value;

					m_readOnlyProperties = new ReadOnlyPropertiesDictionary(mutableProps);
				}
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ILogExtensions">
      <declaration><![CDATA[public static class ILogExtensions]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".cctor">
          <declaration><![CDATA[static ILogExtensions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="56" sc="3" el="56" ec="71">log4net\Util\ILogExtensions.cs</location>
            <body hash="a44fa09736f5f80c220a82928df7bf61"><![CDATA[private readonly static Type declaringType = typeof(ILogExtensions)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="DebugExt">
          <declaration><![CDATA[public static void DebugExt(this ILog logger, Func<object> callback)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="90" sc="3" el="102" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="8dfaaaf643d41ea0ed6391838e3e43dc"><![CDATA[{
			try
			{
				if (!logger.IsDebugEnabled)
					return;

				logger.Debug(callback());
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="DebugExt">
          <declaration><![CDATA[public static void DebugExt(this ILog logger, Func<object> callback, Exception exception)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="120" sc="3" el="132" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="23e228d28c16ed841fde110124f2d286"><![CDATA[{
			try
			{
				if (!logger.IsDebugEnabled)
					return;

				logger.Debug(callback(), exception);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="DebugExt">
          <declaration><![CDATA[public static void DebugExt(this ILog logger, object message)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="165" sc="3" el="177" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="7cd2bd3fc8bda930c79a7924039da50b"><![CDATA[{
			try
			{
				if (!logger.IsDebugEnabled)
					return;

				logger.Debug(message);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="DebugExt">
          <declaration><![CDATA[public static void DebugExt(this ILog logger, object message, Exception exception)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="195" sc="3" el="207" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="86d309562c579481b5ad4d8363f206ae"><![CDATA[{
			try
			{
				if (!logger.IsDebugEnabled)
					return;

				logger.Debug(message, exception);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="DebugFormatExt">
          <declaration><![CDATA[public static void DebugFormatExt(this ILog logger, string format, object arg0)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="234" sc="3" el="246" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="8526e55a1710fe50896ed2e2b090c629"><![CDATA[{
			try
			{
				if (!logger.IsDebugEnabled)
					return;

				logger.DebugFormat(format, arg0);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="DebugFormatExt">
          <declaration><![CDATA[public static void DebugFormatExt(this ILog logger, string format, params object[] args)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="269" sc="3" el="281" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="51ee32d7fca57ed356fc2c1b0e8a2d86"><![CDATA[{
			try
			{
				if (!logger.IsDebugEnabled)
					return;

				logger.DebugFormat(format, args);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="DebugFormatExt">
          <declaration><![CDATA[public static void DebugFormatExt(this ILog logger, IFormatProvider provider, string format, params object[] args)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="305" sc="3" el="317" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="5927358c77a4157c47402a45ff5494dc"><![CDATA[{
			try
			{
				if (!logger.IsDebugEnabled)
					return;

				logger.DebugFormat(provider, format, args);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="DebugFormatExt">
          <declaration><![CDATA[public static void DebugFormatExt(this ILog logger, string format, object arg0, object arg1)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="341" sc="3" el="353" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="a9c6024522f68878480293ec690038d6"><![CDATA[{
			try
			{
				if (!logger.IsDebugEnabled)
					return;

				logger.DebugFormat(format, arg0, arg1);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="DebugFormatExt">
          <declaration><![CDATA[public static void DebugFormatExt(this ILog logger, string format, object arg0, object arg1, object arg2)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="378" sc="3" el="390" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="1eb9485c69c235be25697e491054e818"><![CDATA[{
			try
			{
				if (!logger.IsDebugEnabled)
					return;

				logger.DebugFormat(format, arg0, arg1, arg2);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ErrorExt">
          <declaration><![CDATA[public static void ErrorExt(this ILog logger, Func<object> callback)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1098" sc="3" el="1110" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="8db0c44b501bb8d44f4da9bd99e4ae0e"><![CDATA[{
			try
			{
				if (!logger.IsErrorEnabled)
					return;

				logger.Error(callback());
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ErrorExt">
          <declaration><![CDATA[public static void ErrorExt(this ILog logger, Func<object> callback, Exception exception)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1128" sc="3" el="1140" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="253e43874a274ea4f0283af194e0bf40"><![CDATA[{
			try
			{
				if (!logger.IsErrorEnabled)
					return;

				logger.Error(callback(), exception);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ErrorExt">
          <declaration><![CDATA[public static void ErrorExt(this ILog logger, object message)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1173" sc="3" el="1185" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="71949ec3cbc04d80bd00d733c591ee5d"><![CDATA[{
			try
			{
				if (!logger.IsErrorEnabled)
					return;

				logger.Error(message);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ErrorExt">
          <declaration><![CDATA[public static void ErrorExt(this ILog logger, object message, Exception exception)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1203" sc="3" el="1215" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="10252bd7e33edc677e6a97135cd90441"><![CDATA[{
			try
			{
				if (!logger.IsErrorEnabled)
					return;

				logger.Error(message, exception);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ErrorFormatExt">
          <declaration><![CDATA[public static void ErrorFormatExt(this ILog logger, string format, object arg0)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1242" sc="3" el="1254" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="bc6a61edce29c451038542f5109b434a"><![CDATA[{
			try
			{
				if (!logger.IsErrorEnabled)
					return;

				logger.ErrorFormat(format, arg0);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ErrorFormatExt">
          <declaration><![CDATA[public static void ErrorFormatExt(this ILog logger, string format, params object[] args)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1277" sc="3" el="1289" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="e61963c68fa72fd6f66f5276423f3e88"><![CDATA[{
			try
			{
				if (!logger.IsErrorEnabled)
					return;

				logger.ErrorFormat(format, args);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ErrorFormatExt">
          <declaration><![CDATA[public static void ErrorFormatExt(this ILog logger, IFormatProvider provider, string format, params object[] args)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1313" sc="3" el="1325" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="bd02af0e25c9c1728a3ba706a26751c3"><![CDATA[{
			try
			{
				if (!logger.IsErrorEnabled)
					return;

				logger.ErrorFormat(provider, format, args);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ErrorFormatExt">
          <declaration><![CDATA[public static void ErrorFormatExt(this ILog logger, string format, object arg0, object arg1)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1349" sc="3" el="1361" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="7ec64b5bd596d647a28510b802f66fd0"><![CDATA[{
			try
			{
				if (!logger.IsErrorEnabled)
					return;

				logger.ErrorFormat(format, arg0, arg1);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ErrorFormatExt">
          <declaration><![CDATA[public static void ErrorFormatExt(this ILog logger, string format, object arg0, object arg1, object arg2)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1386" sc="3" el="1398" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="d7a69f567367787dea582597ff0edba2"><![CDATA[{
			try
			{
				if (!logger.IsErrorEnabled)
					return;

				logger.ErrorFormat(format, arg0, arg1, arg2);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="FatalExt">
          <declaration><![CDATA[public static void FatalExt(this ILog logger, Func<object> callback)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1434" sc="3" el="1446" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="e014209326b93b5dd2809146cbcbba02"><![CDATA[{
			try
			{
				if (!logger.IsFatalEnabled)
					return;

				logger.Fatal(callback());
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="FatalExt">
          <declaration><![CDATA[public static void FatalExt(this ILog logger, Func<object> callback, Exception exception)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1464" sc="3" el="1476" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="de5ad9c51e34108e19b1cc10796276bf"><![CDATA[{
			try
			{
				if (!logger.IsFatalEnabled)
					return;

				logger.Fatal(callback(), exception);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="FatalExt">
          <declaration><![CDATA[public static void FatalExt(this ILog logger, object message)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1509" sc="3" el="1521" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="3ec56e2e03daccc11f2872abc06b5596"><![CDATA[{
			try
			{
				if (!logger.IsFatalEnabled)
					return;

				logger.Fatal(message);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="FatalExt">
          <declaration><![CDATA[public static void FatalExt(this ILog logger, object message, Exception exception)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1539" sc="3" el="1551" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="83f117b6b72f857d1304dc47d319786a"><![CDATA[{
			try
			{
				if (!logger.IsFatalEnabled)
					return;

				logger.Fatal(message, exception);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="FatalFormatExt">
          <declaration><![CDATA[public static void FatalFormatExt(this ILog logger, string format, object arg0)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1578" sc="3" el="1590" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="500e512f3d75dc5b02b1036f6e7ae4ca"><![CDATA[{
			try
			{
				if (!logger.IsFatalEnabled)
					return;

				logger.FatalFormat(format, arg0);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="FatalFormatExt">
          <declaration><![CDATA[public static void FatalFormatExt(this ILog logger, string format, params object[] args)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1613" sc="3" el="1625" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="a5036e34ad2e0dc5623b9982f04cb7a1"><![CDATA[{
			try
			{
				if (!logger.IsFatalEnabled)
					return;

				logger.FatalFormat(format, args);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="FatalFormatExt">
          <declaration><![CDATA[public static void FatalFormatExt(this ILog logger, IFormatProvider provider, string format, params object[] args)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1649" sc="3" el="1661" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="15a2275393f94c744cec57bc5155891c"><![CDATA[{
			try
			{
				if (!logger.IsFatalEnabled)
					return;

				logger.FatalFormat(provider, format, args);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="FatalFormatExt">
          <declaration><![CDATA[public static void FatalFormatExt(this ILog logger, string format, object arg0, object arg1)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1685" sc="3" el="1697" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="5e446d799d41a9237b1e4c54a9f2bb1c"><![CDATA[{
			try
			{
				if (!logger.IsFatalEnabled)
					return;

				logger.FatalFormat(format, arg0, arg1);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="FatalFormatExt">
          <declaration><![CDATA[public static void FatalFormatExt(this ILog logger, string format, object arg0, object arg1, object arg2)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1722" sc="3" el="1734" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="048abcc09ccf1c8898bc2114ecd07f16"><![CDATA[{
			try
			{
				if (!logger.IsFatalEnabled)
					return;

				logger.FatalFormat(format, arg0, arg1, arg2);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="InfoExt">
          <declaration><![CDATA[public static void InfoExt(this ILog logger, Func<object> callback)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="426" sc="3" el="438" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="49dc0e0bf74585fab423e949d1f58377"><![CDATA[{
			try
			{
				if (!logger.IsInfoEnabled)
					return;

				logger.Info(callback());
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="InfoExt">
          <declaration><![CDATA[public static void InfoExt(this ILog logger, Func<object> callback, Exception exception)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="456" sc="3" el="468" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="e07625f7019fb54b9b6c461e3497eb75"><![CDATA[{
			try
			{
				if (!logger.IsInfoEnabled)
					return;

				logger.Info(callback(), exception);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="InfoExt">
          <declaration><![CDATA[public static void InfoExt(this ILog logger, object message)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="501" sc="3" el="513" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="c8e5eaf6cf2bcd75947f7b5f8f368dbe"><![CDATA[{
			try
			{
				if (!logger.IsInfoEnabled)
					return;

				logger.Info(message);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="InfoExt">
          <declaration><![CDATA[public static void InfoExt(this ILog logger, object message, Exception exception)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="531" sc="3" el="543" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="bc6055e4ed440367f23791bcf9b72b88"><![CDATA[{
			try
			{
				if (!logger.IsInfoEnabled)
					return;

				logger.Info(message, exception);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="InfoFormatExt">
          <declaration><![CDATA[public static void InfoFormatExt(this ILog logger, string format, object arg0)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="570" sc="3" el="582" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="66e68a1ce914eddab1e4654dac07f85a"><![CDATA[{
			try
			{
				if (!logger.IsInfoEnabled)
					return;

				logger.InfoFormat(format, arg0);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="InfoFormatExt">
          <declaration><![CDATA[public static void InfoFormatExt(this ILog logger, string format, params object[] args)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="605" sc="3" el="617" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="692767a6f27d826acb6dc4d483a01c95"><![CDATA[{
			try
			{
				if (!logger.IsInfoEnabled)
					return;

				logger.InfoFormat(format, args);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="InfoFormatExt">
          <declaration><![CDATA[public static void InfoFormatExt(this ILog logger, IFormatProvider provider, string format, params object[] args)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="641" sc="3" el="653" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="431f29c74a1b263af069950721b87c76"><![CDATA[{
			try
			{
				if (!logger.IsInfoEnabled)
					return;

				logger.InfoFormat(provider, format, args);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="InfoFormatExt">
          <declaration><![CDATA[public static void InfoFormatExt(this ILog logger, string format, object arg0, object arg1)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="677" sc="3" el="689" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="242dc2399aa0e03c13883e32d55753f2"><![CDATA[{
			try
			{
				if (!logger.IsInfoEnabled)
					return;

				logger.InfoFormat(format, arg0, arg1);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="InfoFormatExt">
          <declaration><![CDATA[public static void InfoFormatExt(this ILog logger, string format, object arg0, object arg1, object arg2)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="714" sc="3" el="726" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="a1e038f787fc18be00d2dc1905241309"><![CDATA[{
			try
			{
				if (!logger.IsInfoEnabled)
					return;

				logger.InfoFormat(format, arg0, arg1, arg2);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="WarnExt">
          <declaration><![CDATA[public static void WarnExt(this ILog logger, Func<object> callback)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="762" sc="3" el="774" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="bfa1bc443006c5bd09ecfd895a3a11c2"><![CDATA[{
			try
			{
				if (!logger.IsWarnEnabled)
					return;

				logger.Warn(callback());
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="WarnExt">
          <declaration><![CDATA[public static void WarnExt(this ILog logger, Func<object> callback, Exception exception)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="792" sc="3" el="804" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="6bbf0b125f75c82d940a5b78bebb71cd"><![CDATA[{
			try
			{
				if (!logger.IsWarnEnabled)
					return;

				logger.Warn(callback(), exception);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="WarnExt">
          <declaration><![CDATA[public static void WarnExt(this ILog logger, object message)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="837" sc="3" el="849" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="9ca345d1613d2b49d3997cbe8dc30159"><![CDATA[{
			try
			{
				if (!logger.IsWarnEnabled)
					return;

				logger.Warn(message);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="WarnExt">
          <declaration><![CDATA[public static void WarnExt(this ILog logger, object message, Exception exception)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="867" sc="3" el="879" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="9717599948ae2cda4bf05550fa19af1d"><![CDATA[{
			try
			{
				if (!logger.IsWarnEnabled)
					return;

				logger.Warn(message, exception);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="WarnFormatExt">
          <declaration><![CDATA[public static void WarnFormatExt(this ILog logger, string format, object arg0)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="906" sc="3" el="918" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="336187a27e99412c770c1a16596cf428"><![CDATA[{
			try
			{
				if (!logger.IsWarnEnabled)
					return;

				logger.WarnFormat(format, arg0);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="WarnFormatExt">
          <declaration><![CDATA[public static void WarnFormatExt(this ILog logger, string format, params object[] args)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="941" sc="3" el="953" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="0ea89e8791e3a8f8a661e29869429d2f"><![CDATA[{
			try
			{
				if (!logger.IsWarnEnabled)
					return;

				logger.WarnFormat(format, args);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="WarnFormatExt">
          <declaration><![CDATA[public static void WarnFormatExt(this ILog logger, IFormatProvider provider, string format, params object[] args)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="977" sc="3" el="989" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="4161fce4dda79f71568ea48652c5bd92"><![CDATA[{
			try
			{
				if (!logger.IsWarnEnabled)
					return;

				logger.WarnFormat(provider, format, args);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="WarnFormatExt">
          <declaration><![CDATA[public static void WarnFormatExt(this ILog logger, string format, object arg0, object arg1)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1013" sc="3" el="1025" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="b7b533b87f527f6b1d4badee96bc5c68"><![CDATA[{
			try
			{
				if (!logger.IsWarnEnabled)
					return;

				logger.WarnFormat(format, arg0, arg1);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="WarnFormatExt">
          <declaration><![CDATA[public static void WarnFormatExt(this ILog logger, string format, object arg0, object arg1, object arg2)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1050" sc="3" el="1062" ec="4">log4net\Util\ILogExtensions.cs</location>
            <body hash="03242125c2d9925410cbd47ae8120d00"><![CDATA[{
			try
			{
				if (!logger.IsWarnEnabled)
					return;

				logger.WarnFormat(format, arg0, arg1, arg2);
			}
			catch (Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "Exception while logging", ex);
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(ILogExtensions);]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="LevelMapping">
      <declaration><![CDATA[public sealed class LevelMapping : IOptionHandler]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private Hashtable m_entriesMap = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="49" sc="3" el="146" ec="48">log4net\Util\LevelMapping.cs</location>
            <body hash="b90c0d9f37f8fcbb9b3c40640cdf1913"><![CDATA[public LevelMapping() 
		{
		}

		#endregion // Public Instance Constructors

		#region Public Instance Methods
	
		/// <summary>
		/// Add a <see cref="LevelMappingEntry"/> to this mapping
		/// </summary>
		/// <param name="entry">the entry to add</param>
		/// <remarks>
		/// <para>
		/// If a <see cref="LevelMappingEntry"/> has previously been added
		/// for the same <see cref="Level"/> then that entry will be 
		/// overwritten.
		/// </para>
		/// </remarks>
		public void Add(LevelMappingEntry entry)
		{
			if (m_entriesMap.ContainsKey(entry.Level))
			{
				m_entriesMap.Remove(entry.Level);
			}
			m_entriesMap.Add(entry.Level, entry);
		}

		/// <summary>
		/// Lookup the mapping for the specified level
		/// </summary>
		/// <param name="level">the level to lookup</param>
		/// <returns>the <see cref="LevelMappingEntry"/> for the level or <c>null</c> if no mapping found</returns>
		/// <remarks>
		/// <para>
		/// Lookup the value for the specified level. Finds the nearest
		/// mapping value for the level that is equal to or less than the
		/// <paramref name="level"/> specified.
		/// </para>
		/// <para>
		/// If no mapping could be found then <c>null</c> is returned.
		/// </para>
		/// </remarks>
		public LevelMappingEntry Lookup(Level level)
		{
			if (m_entries != null)
			{
				foreach(LevelMappingEntry entry in m_entries)
				{
					if (level >= entry.Level)
					{
						return entry;
					}
				}
			}
			return null;
		}

		#endregion // Public Instance Methods

		#region IOptionHandler Members

		/// <summary>
		/// Initialize options
		/// </summary>
		/// <remarks>
		/// <para>
		/// Caches the sorted list of <see cref="LevelMappingEntry"/> in an array
		/// </para>
		/// </remarks>
		public void ActivateOptions()
		{
			Level[] sortKeys = new Level[m_entriesMap.Count];
			LevelMappingEntry[] sortValues = new LevelMappingEntry[m_entriesMap.Count];

			m_entriesMap.Keys.CopyTo(sortKeys, 0);
			m_entriesMap.Values.CopyTo(sortValues, 0);

			// Sort in level order
			Array.Sort(sortKeys, sortValues, 0, sortKeys.Length, null);

			// Reverse list so that highest level is first
			Array.Reverse(sortValues, 0, sortValues.Length);

			foreach(LevelMappingEntry entry in sortValues)
			{
				entry.ActivateOptions();
			}

			 m_entries = sortValues;
		}

		#endregion // IOptionHandler Members

		#region Private Instance Fields

		private Hashtable m_entriesMap = new Hashtable();
		private LevelMappingEntry[] m_entries = null;]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="120" sc="3" el="139" ec="4">log4net\Util\LevelMapping.cs</location>
            <body hash="e7cc5a12421972d4652b243645452806"><![CDATA[{
			Level[] sortKeys = new Level[m_entriesMap.Count];
			LevelMappingEntry[] sortValues = new LevelMappingEntry[m_entriesMap.Count];

			m_entriesMap.Keys.CopyTo(sortKeys, 0);
			m_entriesMap.Values.CopyTo(sortValues, 0);

			// Sort in level order
			Array.Sort(sortKeys, sortValues, 0, sortKeys.Length, null);

			// Reverse list so that highest level is first
			Array.Reverse(sortValues, 0, sortValues.Length);

			foreach(LevelMappingEntry entry in sortValues)
			{
				entry.ActivateOptions();
			}

			 m_entries = sortValues;
		}]]></body>
          </codeblock>
        </method>
        <method name="Add">
          <declaration><![CDATA[public void Add(LevelMappingEntry entry)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="69" sc="3" el="75" ec="4">log4net\Util\LevelMapping.cs</location>
            <body hash="589f9ea65f418b53cf666848fcff5e56"><![CDATA[{
			if (m_entriesMap.ContainsKey(entry.Level))
			{
				m_entriesMap.Remove(entry.Level);
			}
			m_entriesMap.Add(entry.Level, entry);
		}]]></body>
          </codeblock>
        </method>
        <method name="Lookup">
          <declaration><![CDATA[public LevelMappingEntry Lookup(Level level)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="93" sc="3" el="105" ec="4">log4net\Util\LevelMapping.cs</location>
            <body hash="d8aeff7cb0aa69105392e80828d4d990"><![CDATA[{
			if (m_entries != null)
			{
				foreach(LevelMappingEntry entry in m_entries)
				{
					if (level >= entry.Level)
					{
						return entry;
					}
				}
			}
			return null;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_entries">
          <declaration><![CDATA[private LevelMappingEntry[] m_entries = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_entriesMap">
          <declaration><![CDATA[private Hashtable m_entriesMap = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="LevelMappingEntry">
      <declaration><![CDATA[public abstract class LevelMappingEntry : IOptionHandler]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[protected LevelMappingEntry()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="49" sc="3" el="51" ec="4">log4net\Util\LevelMappingEntry.cs</location>
            <body hash="f2c9b7b39cf0c29b43557bc95bf7f7d7"><![CDATA[protected LevelMappingEntry() 
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public virtual void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="88" sc="3" el="90" ec="4">log4net\Util\LevelMappingEntry.cs</location>
            <body hash="383234974def1fb59c7f521be54c89de"><![CDATA[{
			// default implementation is to do nothing
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_level">
          <declaration><![CDATA[private Level m_level;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Level">
          <declaration><![CDATA[public Level Level]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="LogicalThreadContextProperties">
      <declaration><![CDATA[public sealed class LogicalThreadContextProperties : ContextPropertiesBase]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private bool m_disabled = false;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="57" sc="3" el="71" ec="4">log4net\Util\LogicalThreadContextProperties.cs</location>
            <body hash="9bf582a5c3aa5103d423638ee40f6ae6"><![CDATA[private bool m_disabled = false;
		
		#region Public Instance Constructors

		/// <summary>
		/// Constructor
		/// </summary>
		/// <remarks>
		/// <para>
		/// Initializes a new instance of the <see cref="LogicalThreadContextProperties" /> class.
		/// </para>
		/// </remarks>
		internal LogicalThreadContextProperties()
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static LogicalThreadContextProperties()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="258" sc="6" el="258" ec="90">log4net\Util\LogicalThreadContextProperties.cs</location>
            <body hash="8f128640f3db56e3caaab4a8b2484593"><![CDATA[private readonly static Type declaringType = typeof(LogicalThreadContextProperties)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Clear">
          <declaration><![CDATA[public void Clear()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="145" sc="3" el="152" ec="4">log4net\Util\LogicalThreadContextProperties.cs</location>
            <body hash="608f8c359fcc13605e9815e626f3d309"><![CDATA[{
			PropertiesDictionary dictionary = GetProperties(false);
			if (dictionary != null)
			{
				PropertiesDictionary immutableProps = new PropertiesDictionary();
				SetCallContextData(immutableProps);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="GetCallContextData">
          <declaration><![CDATA[private static PropertiesDictionary GetCallContextData()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="218" sc="3" el="224" ec="4">log4net\Util\LogicalThreadContextProperties.cs</location>
            <body hash="da68a6d0398f230ab7a1f84ca9f3a7eb"><![CDATA[{
#if NET_2_0 || MONO_2_0 || MONO_3_5 || MONO_4_0
            return CallContext.LogicalGetData(c_SlotName) as PropertiesDictionary;
#else
			return CallContext.GetData(c_SlotName) as PropertiesDictionary;
#endif
		}]]></body>
          </codeblock>
        </method>
        <method name="GetProperties">
          <declaration><![CDATA[internal PropertiesDictionary GetProperties(bool create)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="171" sc="3" el="199" ec="4">log4net\Util\LogicalThreadContextProperties.cs</location>
            <body hash="a07722cb5f4b4b2ebc3edf23e940e03d"><![CDATA[{
			if (!m_disabled)
			{
				try
				{
					PropertiesDictionary properties = GetCallContextData();
					if (properties == null && create)
					{
						properties = new PropertiesDictionary();
						SetCallContextData(properties);
					}
					return properties;
				}
				catch (SecurityException secEx)
				{
					m_disabled = true;
					
					// Thrown if we don't have permission to read or write the CallContext
					LogLog.Warn(declaringType, "SecurityException while accessing CallContext. Disabling LogicalThreadContextProperties", secEx);
				}
			}
			
			// Only get here is we are disabled because of a security exception
			if (create)
			{
				return new PropertiesDictionary();
			}
			return null;
		}]]></body>
          </codeblock>
        </method>
        <method name="Remove">
          <declaration><![CDATA[public void Remove(string key)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="126" sc="3" el="134" ec="4">log4net\Util\LogicalThreadContextProperties.cs</location>
            <body hash="61701812f7ae660bb8dc610b68cfb664"><![CDATA[{
			PropertiesDictionary dictionary = GetProperties(false);
			if (dictionary != null)
			{
				PropertiesDictionary immutableProps = new PropertiesDictionary(dictionary);
				immutableProps.Remove(key);
				SetCallContextData(immutableProps);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="SetCallContextData">
          <declaration><![CDATA[private static void SetCallContextData(PropertiesDictionary properties)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="239" sc="3" el="245" ec="10">log4net\Util\LogicalThreadContextProperties.cs</location>
            <body hash="5139df627eb76987078e38043c900e2f"><![CDATA[{
#if NET_2_0 || MONO_2_0 || MONO_3_5 || MONO_4_0
			CallContext.LogicalSetData(c_SlotName, properties);
#else
			CallContext.SetData(c_SlotName, properties);
#endif
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="c_SlotName">
          <declaration><![CDATA[private const string c_SlotName = "log4net.Util.LogicalThreadContextProperties";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(LogicalThreadContextProperties);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_disabled">
          <declaration><![CDATA[private bool m_disabled = false;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Item">
          <declaration><![CDATA[public override object this[string key]]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="91" sc="4" el="99" ec="5">log4net\Util\LogicalThreadContextProperties.cs</location>
            <body hash="38ad3e1e5b475ee6dfafd27a84fb69bd"><![CDATA[{ 
				// Don't create the dictionary if it does not already exist
				PropertiesDictionary dictionary = GetProperties(false);
				if (dictionary != null)
				{
					return dictionary[key]; 
				}
				return null;
			}]]></body>
          </codeblock>
          <codeblock>
            <location sl="101" sc="4" el="109" ec="5">log4net\Util\LogicalThreadContextProperties.cs</location>
            <body hash="592a4061eaa2c0e21016e928d80d11b9"><![CDATA[{
				// Force the dictionary to be created
				PropertiesDictionary props = GetProperties(true);
				// Reason for cloning the dictionary below: object instances set on the CallContext
				// need to be immutable to correctly flow through async/await
				PropertiesDictionary immutableProps = new PropertiesDictionary(props);
				immutableProps[key] = value;
				SetCallContextData(immutableProps);
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="LogicalThreadContextStack">
      <declaration><![CDATA[public sealed class LogicalThreadContextStack : IFixingRequired]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private Stack m_stack = new Stack();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="54" sc="3" el="92" ec="4">log4net\Util\LogicalThreadContextStack.cs</location>
            <body hash="116a76830ce1209f1da0997c716259c9"><![CDATA[private Stack m_stack = new Stack();

		/// <summary>
		/// The name of this <see cref="log4net.Util.LogicalThreadContextStack"/> within the
		/// <see cref="log4net.Util.LogicalThreadContextProperties"/>.
		/// </summary>
		private string m_propertyKey;

		/// <summary>
		/// The callback used to let the <see cref="log4net.Util.LogicalThreadContextStacks"/> register a
		/// new instance of a <see cref="log4net.Util.LogicalThreadContextStack"/>.
		/// </summary>
		#if NET_2_0 || MONO_2_0
		private TwoArgAction<string, LogicalThreadContextStack> m_registerNew;
                #else
		private TwoArgAction m_registerNew;
		#endif

		#endregion Private Instance Fields

		#region Public Instance Constructors

		/// <summary>
		/// Internal constructor
		/// </summary>
		/// <remarks>
		/// <para>
		/// Initializes a new instance of the <see cref="LogicalThreadContextStack" /> class. 
		/// </para>
		/// </remarks>
		#if NET_2_0 || MONO_2_0
		internal LogicalThreadContextStack(string propertyKey, TwoArgAction<string, LogicalThreadContextStack> registerNew)
                #else
		internal LogicalThreadContextStack(string propertyKey, TwoArgAction registerNew)
		#endif
		{
			m_propertyKey = propertyKey;
			m_registerNew = registerNew;
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Clear">
          <declaration><![CDATA[public void Clear()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="136" sc="3" el="138" ec="4">log4net\Util\LogicalThreadContextStack.cs</location>
            <body hash="0b97ea7b18c204c43e25920215d30a4b"><![CDATA[{
			m_registerNew(m_propertyKey, new LogicalThreadContextStack(m_propertyKey, m_registerNew));
		}]]></body>
          </codeblock>
        </method>
        <method name="GetFullMessage">
          <declaration><![CDATA[internal string GetFullMessage()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="210" sc="3" el="217" ec="4">log4net\Util\LogicalThreadContextStack.cs</location>
            <body hash="c1791539788d46ff3e7fbd075ac7480e"><![CDATA[{
			Stack stack = m_stack;
			if (stack.Count > 0)
			{
				return ((StackFrame)(stack.Peek())).FullMessage;
			}
			return null;
		}]]></body>
          </codeblock>
        </method>
        <method name="log4net.Core.IFixingRequired.GetFixedObject">
          <declaration><![CDATA[object IFixingRequired.GetFixedObject()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="262" sc="3" el="264" ec="4">log4net\Util\LogicalThreadContextStack.cs</location>
            <body hash="2f125b0f35211370a831f85f9e907cbb"><![CDATA[{
			return GetFullMessage();
		}]]></body>
          </codeblock>
        </method>
        <method name="Pop">
          <declaration><![CDATA[public string Pop()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="152" sc="3" el="164" ec="4">log4net\Util\LogicalThreadContextStack.cs</location>
            <body hash="978da3526901fc9b31f29c3a078ea9c4"><![CDATA[{
			// copy current stack
			Stack stack = new Stack(new Stack(m_stack));
			string result = "";
			if (stack.Count > 0)
			{
				result = ((StackFrame)(stack.Pop())).Message;
			}
			LogicalThreadContextStack ltcs = new LogicalThreadContextStack(m_propertyKey, m_registerNew);
			ltcs.m_stack = stack;
			m_registerNew(m_propertyKey, ltcs);
			return result;
		}]]></body>
          </codeblock>
        </method>
        <method name="Push">
          <declaration><![CDATA[public IDisposable Push(string message)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="190" sc="3" el="199" ec="4">log4net\Util\LogicalThreadContextStack.cs</location>
            <body hash="b3cca14d1fc1d9dd387d7c1615738a5e"><![CDATA[{
			// do modifications on a copy
			Stack stack = new Stack(new Stack(m_stack));
			stack.Push(new StackFrame(message, (stack.Count > 0) ? (StackFrame)stack.Peek() : null));

			LogicalThreadContextStack contextStack = new LogicalThreadContextStack(m_propertyKey, m_registerNew);
			contextStack.m_stack = stack;
			m_registerNew(m_propertyKey, contextStack);
			return new AutoPopStackFrame(contextStack, stack.Count - 1);
		}]]></body>
          </codeblock>
        </method>
        <method name="ToString">
          <declaration><![CDATA[public override string ToString()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="248" sc="3" el="250" ec="4">log4net\Util\LogicalThreadContextStack.cs</location>
            <body hash="2f125b0f35211370a831f85f9e907cbb"><![CDATA[{
			return GetFullMessage();
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_propertyKey">
          <declaration><![CDATA[private string m_propertyKey;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_registerNew">
          <declaration><![CDATA[private TwoArgAction<string, LogicalThreadContextStack> m_registerNew;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_stack">
          <declaration><![CDATA[private Stack m_stack = new Stack();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Count">
          <declaration><![CDATA[public int Count]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="InternalStack">
          <declaration><![CDATA[internal Stack InternalStack]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="LogicalThreadContextStacks">
      <declaration><![CDATA[public sealed class LogicalThreadContextStacks]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[internal LogicalThreadContextStacks(LogicalThreadContextProperties properties)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="49" sc="3" el="52" ec="4">log4net\Util\LogicalThreadContextStacks.cs</location>
            <body hash="61406178b20f629d4b74e92dd1768389"><![CDATA[internal LogicalThreadContextStacks(LogicalThreadContextProperties properties)
		{
			m_properties = properties;
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static LogicalThreadContextStacks()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="137" sc="3" el="137" ec="83">log4net\Util\LogicalThreadContextStacks.cs</location>
            <body hash="3aab1dd90542a9cc6d699f00b9342f68"><![CDATA[private readonly static Type declaringType = typeof(LogicalThreadContextStacks)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="registerNew">
          <declaration><![CDATA[private void registerNew(string stackName, LogicalThreadContextStack stack)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="122" sc="3" el="124" ec="4">log4net\Util\LogicalThreadContextStacks.cs</location>
            <body hash="f4ec78cea5dbedc300b394ce58a1b9f8"><![CDATA[{
			m_properties[stackName] = stack;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(LogicalThreadContextStacks);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_properties">
          <declaration><![CDATA[private readonly LogicalThreadContextProperties m_properties;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Item">
          <declaration><![CDATA[public LogicalThreadContextStack this[string key]]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="72" sc="4" el="114" ec="5">log4net\Util\LogicalThreadContextStacks.cs</location>
            <body hash="d6b51f6fec6d5f149f0660ebb5fdcfef"><![CDATA[{
				LogicalThreadContextStack stack = null;

				object propertyValue = m_properties[key];
				if (propertyValue == null)
				{
					// Stack does not exist, create
#if NET_2_0 || MONO_2_0
					stack = new LogicalThreadContextStack(key, registerNew);
#else
					stack = new LogicalThreadContextStack(key, new TwoArgAction(registerNew));
#endif
					m_properties[key] = stack;
				}
				else
				{
					// Look for existing stack
					stack = propertyValue as LogicalThreadContextStack;
					if (stack == null)
					{
						// Property is not set to a stack!
						string propertyValueString = SystemInfo.NullText;

						try
						{
							propertyValueString = propertyValue.ToString();
						}
						catch
						{
						}

						LogLog.Error(declaringType, "ThreadContextStacks: Request for stack named [" + key + "] failed because a property with the same name exists which is a [" + propertyValue.GetType().Name + "] with value [" + propertyValueString + "]");

#if NET_2_0 || MONO_2_0
						stack = new LogicalThreadContextStack(key, registerNew);
#else
						stack = new LogicalThreadContextStack(key, new TwoArgAction(registerNew));
#endif
					}
				}

				return stack;
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="LogLog">
      <declaration><![CDATA[public sealed class LogLog]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public LogLog(Type source, string prefix, string message, Exception exception)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="141" sc="6" el="149" ec="7">log4net\Util\LogLog.cs</location>
            <body hash="2c3d37cc16d96f9936ad46b4115de3fd"><![CDATA[public LogLog(Type source, string prefix, string message, Exception exception)
	    {
            timeStampUtc = DateTime.UtcNow;
	        
            this.source = source;
	        this.prefix = prefix;
	        this.message = message;
	        this.exception = exception;
	    }]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static LogLog()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="173" sc="3" el="601" ec="59">log4net\Util\LogLog.cs</location>
            <body hash="189fd4c167b054fb57b93bdeac093cf6"><![CDATA[{
#if !NETCF
			try
			{
				InternalDebugging = OptionConverter.ToBoolean(SystemInfo.GetAppSetting("log4net.Internal.Debug"), false);
				QuietMode = OptionConverter.ToBoolean(SystemInfo.GetAppSetting("log4net.Internal.Quiet"), false);
				EmitInternalMessages = OptionConverter.ToBoolean(SystemInfo.GetAppSetting("log4net.Internal.Emit"), true);
			}
			catch(Exception ex)
			{
				// If an exception is thrown here then it looks like the config file does not
				// parse correctly.
				//
				// We will leave debug OFF and print an Error message
				Error(typeof(LogLog), "Exception while reading ConfigurationSettings. Check your .config file is well formed XML.", ex);
			}
#endif
		}

		#endregion Static Constructor

		#region Public Static Properties

		/// <summary>
		/// Gets or sets a value indicating whether log4net internal logging
		/// is enabled or disabled.
		/// </summary>
		/// <value>
		/// <c>true</c> if log4net internal logging is enabled, otherwise 
		/// <c>false</c>.
		/// </value>
		/// <remarks>
		/// <para>
		/// When set to <c>true</c>, internal debug level logging will be 
		/// displayed.
		/// </para>
		/// <para>
		/// This value can be set by setting the application setting 
		/// <c>log4net.Internal.Debug</c> in the application configuration
		/// file.
		/// </para>
		/// <para>
		/// The default value is <c>false</c>, i.e. debugging is
		/// disabled.
		/// </para>
		/// </remarks>
		/// <example>
		/// <para>
		/// The following example enables internal debugging using the 
		/// application configuration file :
		/// </para>
		/// <code lang="XML" escaped="true">
		/// <configuration>
		///		<appSettings>
		///			<add key="log4net.Internal.Debug" value="true" />
		///		</appSettings>
		/// </configuration>
		/// </code>
		/// </example>
		public static bool InternalDebugging
		{
			get { return s_debugEnabled; }
			set { s_debugEnabled = value; }
		}

		/// <summary>
		/// Gets or sets a value indicating whether log4net should generate no output
		/// from internal logging, not even for errors. 
		/// </summary>
		/// <value>
		/// <c>true</c> if log4net should generate no output at all from internal 
		/// logging, otherwise <c>false</c>.
		/// </value>
		/// <remarks>
		/// <para>
		/// When set to <c>true</c> will cause internal logging at all levels to be 
		/// suppressed. This means that no warning or error reports will be logged. 
		/// This option overrides the <see cref="InternalDebugging"/> setting and 
		/// disables all debug also.
		/// </para>
		/// <para>This value can be set by setting the application setting
		/// <c>log4net.Internal.Quiet</c> in the application configuration file.
		/// </para>
		/// <para>
		/// The default value is <c>false</c>, i.e. internal logging is not
		/// disabled.
		/// </para>
		/// </remarks>
		/// <example>
		/// The following example disables internal logging using the 
		/// application configuration file :
		/// <code lang="XML" escaped="true">
		/// <configuration>
		///		<appSettings>
		///			<add key="log4net.Internal.Quiet" value="true" />
		///		</appSettings>
		/// </configuration>
		/// </code>
		/// </example>
		public static bool QuietMode
		{
			get { return s_quietMode; }
			set { s_quietMode = value; }
		}

        /// <summary>
        /// 
        /// </summary>
        public static bool EmitInternalMessages
        {
            get { return s_emitInternalMessages; }
            set { s_emitInternalMessages = value; }
        }

		#endregion Public Static Properties

		#region Public Static Methods

        /// <summary>
        /// Raises the LogReceived event when an internal messages is received.
        /// </summary>
        /// <param name="source"></param>
        /// <param name="prefix"></param>
        /// <param name="message"></param>
        /// <param name="exception"></param>
        public static void OnLogReceived(Type source, string prefix, string message, Exception exception)
        {
            if (LogReceived != null)
            {
                LogReceived(null, new LogReceivedEventArgs(new LogLog(source, prefix, message, exception)));
            }
        }

	    /// <summary>
		/// Test if LogLog.Debug is enabled for output.
		/// </summary>
		/// <value>
		/// <c>true</c> if Debug is enabled
		/// </value>
		/// <remarks>
		/// <para>
		/// Test if LogLog.Debug is enabled for output.
		/// </para>
		/// </remarks>
		public static bool IsDebugEnabled
		{
			get { return s_debugEnabled && !s_quietMode; }
		}

		/// <summary>
		/// Writes log4net internal debug messages to the 
		/// standard output stream.
		/// </summary>
        /// <param name="source"></param>
		/// <param name="message">The message to log.</param>
		/// <remarks>
		/// <para>
		///	All internal debug messages are prepended with 
		///	the string "log4net: ".
		/// </para>
		/// </remarks>
		public static void Debug(Type source, string message) 
		{
			if (IsDebugEnabled) 
			{
                if (EmitInternalMessages)
                {
                    EmitOutLine(PREFIX + message);
                }

                OnLogReceived(source, PREFIX, message, null);
			}
		}

		/// <summary>
		/// Writes log4net internal debug messages to the 
		/// standard output stream.
		/// </summary>
        /// <param name="source">The Type that generated this message.</param>
		/// <param name="message">The message to log.</param>
		/// <param name="exception">An exception to log.</param>
		/// <remarks>
		/// <para>
		///	All internal debug messages are prepended with 
		///	the string "log4net: ".
		/// </para>
		/// </remarks>
		public static void Debug(Type source, string message, Exception exception) 
		{
			if (IsDebugEnabled) 
			{
                if (EmitInternalMessages)
                {
                    EmitOutLine(PREFIX + message);
                    if (exception != null)
                    {
                        EmitOutLine(exception.ToString());
                    }
                }

                OnLogReceived(source, PREFIX, message, exception);
			}
		}
  
		/// <summary>
		/// Test if LogLog.Warn is enabled for output.
		/// </summary>
		/// <value>
		/// <c>true</c> if Warn is enabled
		/// </value>
		/// <remarks>
		/// <para>
		/// Test if LogLog.Warn is enabled for output.
		/// </para>
		/// </remarks>
		public static bool IsWarnEnabled
		{
			get { return !s_quietMode; }
		}

		/// <summary>
		/// Writes log4net internal warning messages to the 
		/// standard error stream.
		/// </summary>
        /// <param name="source">The Type that generated this message.</param>
		/// <param name="message">The message to log.</param>
		/// <remarks>
		/// <para>
		///	All internal warning messages are prepended with 
		///	the string "log4net:WARN ".
		/// </para>
		/// </remarks>
		public static void Warn(Type source, string message) 
		{
			if (IsWarnEnabled)
			{
                if (EmitInternalMessages)
                {
                    EmitErrorLine(WARN_PREFIX + message);
                }

                OnLogReceived(source, WARN_PREFIX, message, null);
			}
		}  

		/// <summary>
		/// Writes log4net internal warning messages to the 
		/// standard error stream.
		/// </summary>
        /// <param name="source">The Type that generated this message.</param>
		/// <param name="message">The message to log.</param>
		/// <param name="exception">An exception to log.</param>
		/// <remarks>
		/// <para>
		///	All internal warning messages are prepended with 
		///	the string "log4net:WARN ".
		/// </para>
		/// </remarks>
		public static void Warn(Type source, string message, Exception exception) 
		{
			if (IsWarnEnabled)
			{
                if (EmitInternalMessages)
                {
                    EmitErrorLine(WARN_PREFIX + message);
                    if (exception != null)
                    {
                        EmitErrorLine(exception.ToString());
                    }
                }

                OnLogReceived(source, WARN_PREFIX, message, exception);
			}
		} 

		/// <summary>
		/// Test if LogLog.Error is enabled for output.
		/// </summary>
		/// <value>
		/// <c>true</c> if Error is enabled
		/// </value>
		/// <remarks>
		/// <para>
		/// Test if LogLog.Error is enabled for output.
		/// </para>
		/// </remarks>
		public static bool IsErrorEnabled
		{
			get { return !s_quietMode; }
		}

		/// <summary>
		/// Writes log4net internal error messages to the 
		/// standard error stream.
		/// </summary>
        /// <param name="source">The Type that generated this message.</param>
		/// <param name="message">The message to log.</param>
		/// <remarks>
		/// <para>
		///	All internal error messages are prepended with 
		///	the string "log4net:ERROR ".
		/// </para>
		/// </remarks>
		public static void Error(Type source, string message) 
		{
			if (IsErrorEnabled)
			{
                if (EmitInternalMessages)
                {
                    EmitErrorLine(ERR_PREFIX + message);
                }

                OnLogReceived(source, ERR_PREFIX, message, null);
			}
		}  

		/// <summary>
		/// Writes log4net internal error messages to the 
		/// standard error stream.
		/// </summary>
        /// <param name="source">The Type that generated this message.</param>
		/// <param name="message">The message to log.</param>
		/// <param name="exception">An exception to log.</param>
		/// <remarks>
		/// <para>
		///	All internal debug messages are prepended with 
		///	the string "log4net:ERROR ".
		/// </para>
		/// </remarks>
		public static void Error(Type source, string message, Exception exception) 
		{
			if (IsErrorEnabled)
			{
                if (EmitInternalMessages)
                {
                    EmitErrorLine(ERR_PREFIX + message);
                    if (exception != null)
                    {
                        EmitErrorLine(exception.ToString());
                    }
                }

                OnLogReceived(source, ERR_PREFIX, message, exception);
			}
		}  

		#endregion Public Static Methods

		/// <summary>
		/// Writes output to the standard output stream.  
		/// </summary>
		/// <param name="message">The message to log.</param>
		/// <remarks>
		/// <para>
		/// Writes to both Console.Out and System.Diagnostics.Trace.
		/// Note that the System.Diagnostics.Trace is not supported
		/// on the Compact Framework.
		/// </para>
		/// <para>
		/// If the AppDomain is not configured with a config file then
		/// the call to System.Diagnostics.Trace may fail. This is only
		/// an issue if you are programmatically creating your own AppDomains.
		/// </para>
		/// </remarks>
		private static void EmitOutLine(string message)
		{
			try
			{
#if NETCF
				Console.WriteLine(message);
				//System.Diagnostics.Debug.WriteLine(message);
#else
				Console.Out.WriteLine(message);
				Trace.WriteLine(message);
#endif
			}
			catch
			{
				// Ignore exception, what else can we do? Not really a good idea to propagate back to the caller
			}
		}

		/// <summary>
		/// Writes output to the standard error stream.  
		/// </summary>
		/// <param name="message">The message to log.</param>
		/// <remarks>
		/// <para>
		/// Writes to both Console.Error and System.Diagnostics.Trace.
		/// Note that the System.Diagnostics.Trace is not supported
		/// on the Compact Framework.
		/// </para>
		/// <para>
		/// If the AppDomain is not configured with a config file then
		/// the call to System.Diagnostics.Trace may fail. This is only
		/// an issue if you are programmatically creating your own AppDomains.
		/// </para>
		/// </remarks>
		private static void EmitErrorLine(string message)
		{
			try
			{
#if NETCF
				Console.WriteLine(message);
				//System.Diagnostics.Debug.WriteLine(message);
#else
				Console.Error.WriteLine(message);
				Trace.WriteLine(message);
#endif
			}
			catch
			{
				// Ignore exception, what else can we do? Not really a good idea to propagate back to the caller
			}
		}

		#region Private Static Fields

		/// <summary>
		///  Default debug level
		/// </summary>
		private static bool s_debugEnabled = false;

		/// <summary>
		/// In quietMode not even errors generate any output.
		/// </summary>
		private static bool s_quietMode = false;

        private static bool s_emitInternalMessages = true;]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="add_LogReceived">
          <declaration><![CDATA[public static void add_LogReceived(LogReceivedEventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Debug">
          <declaration><![CDATA[public static void Debug(Type source, string message)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="335" sc="3" el="345" ec="4">log4net\Util\LogLog.cs</location>
            <body hash="5911d6a7ae802746d23b39209ee2ea1f"><![CDATA[{
			if (IsDebugEnabled) 
			{
                if (EmitInternalMessages)
                {
                    EmitOutLine(PREFIX + message);
                }

                OnLogReceived(source, PREFIX, message, null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Debug">
          <declaration><![CDATA[public static void Debug(Type source, string message, Exception exception)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="361" sc="3" el="375" ec="4">log4net\Util\LogLog.cs</location>
            <body hash="e216ae837593e18b9bb2930ffe406d2a"><![CDATA[{
			if (IsDebugEnabled) 
			{
                if (EmitInternalMessages)
                {
                    EmitOutLine(PREFIX + message);
                    if (exception != null)
                    {
                        EmitOutLine(exception.ToString());
                    }
                }

                OnLogReceived(source, PREFIX, message, exception);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="EmitErrorLine">
          <declaration><![CDATA[private static void EmitErrorLine(string message)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="572" sc="3" el="587" ec="4">log4net\Util\LogLog.cs</location>
            <body hash="31dc0c219726a2ec7b184eace4ea90ad"><![CDATA[{
			try
			{
#if NETCF
				Console.WriteLine(message);
				//System.Diagnostics.Debug.WriteLine(message);
#else
				Console.Error.WriteLine(message);
				Trace.WriteLine(message);
#endif
			}
			catch
			{
				// Ignore exception, what else can we do? Not really a good idea to propagate back to the caller
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="EmitOutLine">
          <declaration><![CDATA[private static void EmitOutLine(string message)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="538" sc="3" el="553" ec="4">log4net\Util\LogLog.cs</location>
            <body hash="a5678f5876f80cf5bde3f2a36a99bd51"><![CDATA[{
			try
			{
#if NETCF
				Console.WriteLine(message);
				//System.Diagnostics.Debug.WriteLine(message);
#else
				Console.Out.WriteLine(message);
				Trace.WriteLine(message);
#endif
			}
			catch
			{
				// Ignore exception, what else can we do? Not really a good idea to propagate back to the caller
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Error">
          <declaration><![CDATA[public static void Error(Type source, string message)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="477" sc="3" el="487" ec="4">log4net\Util\LogLog.cs</location>
            <body hash="c135b0f81502b4c1938f5ecc5dbf6c4b"><![CDATA[{
			if (IsErrorEnabled)
			{
                if (EmitInternalMessages)
                {
                    EmitErrorLine(ERR_PREFIX + message);
                }

                OnLogReceived(source, ERR_PREFIX, message, null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Error">
          <declaration><![CDATA[public static void Error(Type source, string message, Exception exception)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="503" sc="3" el="517" ec="4">log4net\Util\LogLog.cs</location>
            <body hash="6c30639e7f9f04ee3f1417efa378326e"><![CDATA[{
			if (IsErrorEnabled)
			{
                if (EmitInternalMessages)
                {
                    EmitErrorLine(ERR_PREFIX + message);
                    if (exception != null)
                    {
                        EmitErrorLine(exception.ToString());
                    }
                }

                OnLogReceived(source, ERR_PREFIX, message, exception);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="OnLogReceived">
          <declaration><![CDATA[public static void OnLogReceived(Type source, string prefix, string message, Exception exception)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="299" sc="9" el="304" ec="10">log4net\Util\LogLog.cs</location>
            <body hash="a349180c3af734a0bb08c946b6f6bd2c"><![CDATA[{
            if (LogReceived != null)
            {
                LogReceived(null, new LogReceivedEventArgs(new LogLog(source, prefix, message, exception)));
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="remove_LogReceived">
          <declaration><![CDATA[public static void remove_LogReceived(LogReceivedEventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="ToString">
          <declaration><![CDATA[public override string ToString()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="128" sc="6" el="130" ec="7">log4net\Util\LogLog.cs</location>
            <body hash="17ed3f7fdf7f164d6d1d6593a22b24d6"><![CDATA[{
            return Prefix + Source.Name + ": " + Message;
	    }]]></body>
          </codeblock>
        </method>
        <method name="Warn">
          <declaration><![CDATA[public static void Warn(Type source, string message)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="406" sc="3" el="416" ec="4">log4net\Util\LogLog.cs</location>
            <body hash="7fecaa5d63c65d1d12b3c186f037f6b8"><![CDATA[{
			if (IsWarnEnabled)
			{
                if (EmitInternalMessages)
                {
                    EmitErrorLine(WARN_PREFIX + message);
                }

                OnLogReceived(source, WARN_PREFIX, message, null);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Warn">
          <declaration><![CDATA[public static void Warn(Type source, string message, Exception exception)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="432" sc="3" el="446" ec="4">log4net\Util\LogLog.cs</location>
            <body hash="e65e60e27afe22226b844f8f5bb6417c"><![CDATA[{
			if (IsWarnEnabled)
			{
                if (EmitInternalMessages)
                {
                    EmitErrorLine(WARN_PREFIX + message);
                    if (exception != null)
                    {
                        EmitErrorLine(exception.ToString());
                    }
                }

                OnLogReceived(source, WARN_PREFIX, message, exception);
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="ERR_PREFIX">
          <declaration><![CDATA[private const string ERR_PREFIX = "log4net:ERROR ";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="exception">
          <declaration><![CDATA[private readonly Exception exception;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="LogReceived">
          <declaration><![CDATA[private static LogReceivedEventHandler LogReceived;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="message">
          <declaration><![CDATA[private readonly string message;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="prefix">
          <declaration><![CDATA[private readonly string prefix;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="PREFIX">
          <declaration><![CDATA[private const string PREFIX = "log4net: ";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="s_debugEnabled">
          <declaration><![CDATA[private static bool s_debugEnabled;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="s_emitInternalMessages">
          <declaration><![CDATA[private static bool s_emitInternalMessages;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="s_quietMode">
          <declaration><![CDATA[private static bool s_quietMode;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="source">
          <declaration><![CDATA[private readonly Type source;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="timeStampUtc">
          <declaration><![CDATA[private readonly DateTime timeStampUtc;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="WARN_PREFIX">
          <declaration><![CDATA[private const string WARN_PREFIX = "log4net:WARN ";]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="EmitInternalMessages">
          <declaration><![CDATA[public static bool EmitInternalMessages]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Exception">
          <declaration><![CDATA[public Exception Exception]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="InternalDebugging">
          <declaration><![CDATA[public static bool InternalDebugging]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IsDebugEnabled">
          <declaration><![CDATA[public static bool IsDebugEnabled]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IsErrorEnabled">
          <declaration><![CDATA[public static bool IsErrorEnabled]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IsWarnEnabled">
          <declaration><![CDATA[public static bool IsWarnEnabled]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Message">
          <declaration><![CDATA[public string Message]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Prefix">
          <declaration><![CDATA[public string Prefix]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="QuietMode">
          <declaration><![CDATA[public static bool QuietMode]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Source">
          <declaration><![CDATA[public Type Source]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="TimeStamp">
          <declaration><![CDATA[public DateTime TimeStamp]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="TimeStampUtc">
          <declaration><![CDATA[public DateTime TimeStampUtc]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
        <event name="LogReceived">
          <declaration><![CDATA[public static event LogReceivedEventHandler LogReceived;]]></declaration>
          <documentation>
          </documentation>
        </event>
      </events>
    </class>
    <class name="LogReceivedEventArgs">
      <declaration><![CDATA[public class LogReceivedEventArgs : EventArgs]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public LogReceivedEventArgs(LogLog loglog)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="665" sc="9" el="668" ec="10">log4net\Util\LogLog.cs</location>
            <body hash="47952ce91db12470a81710a9079ed6f5"><![CDATA[public LogReceivedEventArgs(LogLog loglog)
        {
            this.loglog = loglog;
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="loglog">
          <declaration><![CDATA[private readonly LogLog loglog;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="LogLog">
          <declaration><![CDATA[public LogLog LogLog]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="e);">
      <declaration><![CDATA[public delegate void LogReceivedEventHandler(object source, LogReceivedEventArgs e);]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public extern LogReceivedEventHandler(object @object, IntPtr method);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="BeginInvoke">
          <declaration><![CDATA[public virtual extern IAsyncResult BeginInvoke(object source, LogReceivedEventArgs e, AsyncCallback callback, object @object);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="EndInvoke">
          <declaration><![CDATA[public virtual extern void EndInvoke(IAsyncResult result);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Invoke">
          <declaration><![CDATA[public virtual extern void Invoke(object source, LogReceivedEventArgs e);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="NativeError">
      <declaration><![CDATA[public sealed class NativeError]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private NativeError(int number, string message)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="59" sc="3" el="63" ec="4">log4net\Util\NativeError.cs</location>
            <body hash="2cfbc78206dbc735fa8dbca73397358a"><![CDATA[private NativeError(int number, string message) 
		{
			m_number = number;
			m_message = message;
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="FormatMessage">
          <declaration><![CDATA[private static extern int FormatMessage(int dwFlags, ref IntPtr lpSource, int dwMessageId, int dwLanguageId, ref string lpBuffer, int nSize, IntPtr Arguments);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetError">
          <declaration><![CDATA[public static NativeError GetError(int number)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="143" sc="3" el="145" ec="4">log4net\Util\NativeError.cs</location>
            <body hash="daf553fe791061ba8471827deda29b00"><![CDATA[{
			return new NativeError(number, NativeError.GetErrorMessage(number));
		}]]></body>
          </codeblock>
        </method>
        <method name="GetErrorMessage">
          <declaration><![CDATA[public static string GetErrorMessage(int messageId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="166" sc="3" el="205" ec="4">log4net\Util\NativeError.cs</location>
            <body hash="71a679312524ab973080c9606c8b14f3"><![CDATA[{
			// Win32 constants
			int FORMAT_MESSAGE_ALLOCATE_BUFFER = 0x00000100;	// The function should allocates a buffer large enough to hold the formatted message
			int FORMAT_MESSAGE_IGNORE_INSERTS = 0x00000200;		// Insert sequences in the message definition are to be ignored
			int FORMAT_MESSAGE_FROM_SYSTEM  = 0x00001000;		// The function should search the system message-table resource(s) for the requested message

			string msgBuf = "";				// buffer that will receive the message
			IntPtr sourcePtr = new IntPtr();	// Location of the message definition, will be ignored
			IntPtr argumentsPtr = new IntPtr();	// Pointer to array of values to insert, not supported as it requires unsafe code

			if (messageId != 0) 
			{
				// If the function succeeds, the return value is the number of TCHARs stored in the output buffer, excluding the terminating null character
				int messageSize = FormatMessage(
					FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, 
					ref sourcePtr, 
					messageId, 
					0, 
					ref msgBuf, 
					255, 
					argumentsPtr);

				if (messageSize > 0) 
				{
					// Remove trailing null-terminating characters (\r\n) from the message
					msgBuf = msgBuf.TrimEnd(new char[] {'\r', '\n'});
				}
				else 
				{
					// A message could not be located.
					msgBuf = null;
				}
			} 
			else 
			{
				msgBuf = null;
			}

			return msgBuf;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetLastError">
          <declaration><![CDATA[public static NativeError GetLastError()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="123" sc="3" el="126" ec="4">log4net\Util\NativeError.cs</location>
            <body hash="8e378f99e03df8ca57ddf3f7d078bf2f"><![CDATA[{
			int number = Marshal.GetLastWin32Error();
			return new NativeError(number, NativeError.GetErrorMessage(number));
		}]]></body>
          </codeblock>
        </method>
        <method name="ToString">
          <declaration><![CDATA[public override string ToString()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="221" sc="3" el="223" ec="4">log4net\Util\NativeError.cs</location>
            <body hash="4019df530453916ad3850ab0111bf1ed"><![CDATA[{
			return string.Format(CultureInfo.InvariantCulture, "0x{0:x8}", this.Number) + (this.Message != null ? ": " + this.Message : "");
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_message">
          <declaration><![CDATA[private string m_message;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_number">
          <declaration><![CDATA[private int m_number;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Message">
          <declaration><![CDATA[public string Message]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Number">
          <declaration><![CDATA[public int Number]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="NullDictionaryEnumerator">
      <declaration><![CDATA[public sealed class NullDictionaryEnumerator : IDictionaryEnumerator, IEnumerator]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private NullDictionaryEnumerator()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="48" sc="3" el="50" ec="4">log4net\Util\NullDictionaryEnumerator.cs</location>
            <body hash="2a44ce6d7755a9e349f4427043992ea2"><![CDATA[private NullDictionaryEnumerator()
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static NullDictionaryEnumerator()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="198" sc="3" el="198" ec="96">log4net\Util\NullDictionaryEnumerator.cs</location>
            <body hash="93dbce1888a4c59617caaffab58f9e60"><![CDATA[private readonly static NullDictionaryEnumerator s_instance = new NullDictionaryEnumerator()]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="MoveNext">
          <declaration><![CDATA[public bool MoveNext()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="107" sc="3" el="109" ec="4">log4net\Util\NullDictionaryEnumerator.cs</location>
            <body hash="95329ba72f6d873bf64cd96c35ffa442"><![CDATA[{
			return false;
		}]]></body>
          </codeblock>
        </method>
        <method name="Reset">
          <declaration><![CDATA[public void Reset()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="120" sc="3" el="121" ec="4">log4net\Util\NullDictionaryEnumerator.cs</location>
            <body hash="d2c65ffc45d1c7103cabbde916faf7e7"><![CDATA[{
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="s_instance">
          <declaration><![CDATA[private static readonly NullDictionaryEnumerator s_instance = new NullDictionaryEnumerator();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Current">
          <declaration><![CDATA[public object Current]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Entry">
          <declaration><![CDATA[public DictionaryEntry Entry]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Instance">
          <declaration><![CDATA[public static NullDictionaryEnumerator Instance]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Key">
          <declaration><![CDATA[public object Key]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Value">
          <declaration><![CDATA[public object Value]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="NullEnumerator">
      <declaration><![CDATA[public sealed class NullEnumerator : IEnumerator]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private NullEnumerator()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="48" sc="3" el="50" ec="4">log4net\Util\NullEnumerator.cs</location>
            <body hash="e428e2397c04700d42a6256661b891f9"><![CDATA[private NullEnumerator()
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static NullEnumerator()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="130" sc="3" el="130" ec="76">log4net\Util\NullEnumerator.cs</location>
            <body hash="52f5d726d1ea45b7e21bfc05cb5502ae"><![CDATA[private readonly static NullEnumerator s_instance = new NullEnumerator()]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="MoveNext">
          <declaration><![CDATA[public bool MoveNext()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="107" sc="3" el="109" ec="4">log4net\Util\NullEnumerator.cs</location>
            <body hash="95329ba72f6d873bf64cd96c35ffa442"><![CDATA[{
			return false;
		}]]></body>
          </codeblock>
        </method>
        <method name="Reset">
          <declaration><![CDATA[public void Reset()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="120" sc="3" el="121" ec="4">log4net\Util\NullEnumerator.cs</location>
            <body hash="d2c65ffc45d1c7103cabbde916faf7e7"><![CDATA[{
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="s_instance">
          <declaration><![CDATA[private static readonly NullEnumerator s_instance = new NullEnumerator();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Current">
          <declaration><![CDATA[public object Current]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Instance">
          <declaration><![CDATA[public static NullEnumerator Instance]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="NullSecurityContext">
      <declaration><![CDATA[public sealed class NullSecurityContext : SecurityContext]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private NullSecurityContext()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="57" sc="3" el="59" ec="4">log4net\Util\NullSecurityContext.cs</location>
            <body hash="96f795bd982c77d08fba8c7a197b0897"><![CDATA[private NullSecurityContext()
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static NullSecurityContext()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="47" sc="3" el="47" ec="83">log4net\Util\NullSecurityContext.cs</location>
            <body hash="30cefc280154f66df69da0df42ebced0"><![CDATA[public static readonly NullSecurityContext Instance = new NullSecurityContext()]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Impersonate">
          <declaration><![CDATA[public override IDisposable Impersonate(object state)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="72" sc="3" el="74" ec="4">log4net\Util\NullSecurityContext.cs</location>
            <body hash="8e12546c70955b0b2c7681441c80c1ea"><![CDATA[{
			return null;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="Instance">
          <declaration><![CDATA[public static readonly NullSecurityContext Instance = new NullSecurityContext();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="OnlyOnceErrorHandler">
      <declaration><![CDATA[public class OnlyOnceErrorHandler : IErrorHandler]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private bool m_firstTime = true;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="55" sc="3" el="261" ec="60">log4net\Util\OnlyOnceErrorHandler.cs</location>
            <body hash="75e7f9d3e875bfa3e787662b7583a386"><![CDATA[public OnlyOnceErrorHandler()
		{
			m_prefix = "";
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="prefix">The prefix to use for each message.</param>
		/// <remarks>
		/// <para>
		/// Initializes a new instance of the <see cref="OnlyOnceErrorHandler" /> class
		/// with the specified prefix.
		/// </para>
		/// </remarks>
		public OnlyOnceErrorHandler(string prefix)
		{
			m_prefix = prefix;
		}

		#endregion Public Instance Constructors

		#region Public Instance Methods

		/// <summary>
		/// Reset the error handler back to its initial disabled state.
		/// </summary>
		public void Reset()
		{
			m_enabledDateUtc = DateTime.MinValue;
			m_errorCode = ErrorCode.GenericFailure;
			m_exception = null;
			m_message = null;
			m_firstTime = true;
		}

		#region Implementation of IErrorHandler

		/// <summary>
		/// Log an Error
		/// </summary>
		/// <param name="message">The error message.</param>
		/// <param name="e">The exception.</param>
		/// <param name="errorCode">The internal error code.</param>
		/// <remarks>
		/// <para>
		/// Invokes <see cref="FirstError"/> if and only if this is the first error or the first error after <see cref="Reset"/> has been called.
		/// </para>
		/// </remarks>
		public void Error(string message, Exception e, ErrorCode errorCode) 
		{
			if (m_firstTime)
			{
                FirstError(message, e, errorCode);
			}
		}

        /// <summary>
        /// Log the very first error
        /// </summary>
        /// <param name="message">The error message.</param>
        /// <param name="e">The exception.</param>
        /// <param name="errorCode">The internal error code.</param>
        /// <remarks>
        /// <para>
        /// Sends the error information to <see cref="LogLog"/>'s Error method.
        /// </para>
        /// </remarks>
        public virtual void FirstError(string message, Exception e, ErrorCode errorCode) {
            m_enabledDateUtc = DateTime.UtcNow;
            m_errorCode = errorCode;
            m_exception = e;
            m_message = message;
            m_firstTime = false;

            if (LogLog.InternalDebugging && !LogLog.QuietMode) {
                LogLog.Error(declaringType, "[" + m_prefix + "] ErrorCode: " + errorCode.ToString() + ". " + message, e);
            }
        }

        /// <summary>
		/// Log an Error
		/// </summary>
		/// <param name="message">The error message.</param>
		/// <param name="e">The exception.</param>
		/// <remarks>
        /// <para>
        /// Invokes <see cref="FirstError"/> if and only if this is the first error or the first error after <see cref="Reset"/> has been called.
        /// </para>
        /// </remarks>
		public void Error(string message, Exception e) 
		{
			Error(message, e, ErrorCode.GenericFailure);
		}

		/// <summary>
		/// Log an error
		/// </summary>
		/// <param name="message">The error message.</param>
		/// <remarks>
        /// <para>
        /// Invokes <see cref="FirstError"/> if and only if this is the first error or the first error after <see cref="Reset"/> has been called.
        /// </para>
        /// </remarks>
		public void Error(string message) 
		{
			Error(message, null, ErrorCode.GenericFailure);
		}

		#endregion Implementation of IErrorHandler

		#endregion

		#region Public Instance Properties

		/// <summary>
		/// Is error logging enabled
		/// </summary>
		/// <remarks>
		/// <para>
		/// Is error logging enabled. Logging is only enabled for the
		/// first error delivered to the <see cref="OnlyOnceErrorHandler"/>.
		/// </para>
		/// </remarks>
		public bool IsEnabled
		{
			get { return m_firstTime; }
		}

		/// <summary>
		/// The date the first error that trigged this error handler occurred, or <see cref="DateTime.MinValue"/> if it has not been triggered.
		/// </summary>
		public DateTime EnabledDate
		{
			get 
            {
                if (m_enabledDateUtc == DateTime.MinValue) return DateTime.MinValue;
                return m_enabledDateUtc.ToLocalTime(); 
            }
		}

        /// <summary>
        /// The UTC date the first error that trigged this error handler occured, or <see cref="DateTime.MinValue"/> if it has not been triggered.
        /// </summary>
        public DateTime EnabledDateUtc
        {
            get { return m_enabledDateUtc; }
        }

		/// <summary>
		/// The message from the first error that trigged this error handler.
		/// </summary>
		public string ErrorMessage
		{
			get { return m_message; }
		}

		/// <summary>
		/// The exception from the first error that trigged this error handler.
		/// </summary>
		/// <remarks>
		/// May be <see langword="null" />.
		/// </remarks>
		public Exception Exception
		{
			get { return m_exception; }
		}

		/// <summary>
		/// The error code from the first error that trigged this error handler.
		/// </summary>
		/// <remarks>
		/// Defaults to <see cref="log4net.Core.ErrorCode.GenericFailure"/>
		/// </remarks>
		public ErrorCode ErrorCode
		{
			get { return m_errorCode; }
		}

		#endregion

		#region Private Instance Fields

		/// <summary>
		/// The UTC date the error was recorded.
		/// </summary>
		private DateTime m_enabledDateUtc;

		/// <summary>
		/// Flag to indicate if it is the first error
		/// </summary>
		private bool m_firstTime = true;

		/// <summary>
		/// The message recorded during the first error.
		/// </summary>
		private string m_message = null;

		/// <summary>
		/// The exception recorded during the first error.
		/// </summary>
		private Exception m_exception = null;

		/// <summary>
		/// The error code recorded during the first error.
		/// </summary>
		private ErrorCode m_errorCode = ErrorCode.GenericFailure;]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private bool m_firstTime = true;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="70" sc="3" el="261" ec="60">log4net\Util\OnlyOnceErrorHandler.cs</location>
            <body hash="0a3586b73832550513a2bc5e42b27f01"><![CDATA[public OnlyOnceErrorHandler(string prefix)
		{
			m_prefix = prefix;
		}

		#endregion Public Instance Constructors

		#region Public Instance Methods

		/// <summary>
		/// Reset the error handler back to its initial disabled state.
		/// </summary>
		public void Reset()
		{
			m_enabledDateUtc = DateTime.MinValue;
			m_errorCode = ErrorCode.GenericFailure;
			m_exception = null;
			m_message = null;
			m_firstTime = true;
		}

		#region Implementation of IErrorHandler

		/// <summary>
		/// Log an Error
		/// </summary>
		/// <param name="message">The error message.</param>
		/// <param name="e">The exception.</param>
		/// <param name="errorCode">The internal error code.</param>
		/// <remarks>
		/// <para>
		/// Invokes <see cref="FirstError"/> if and only if this is the first error or the first error after <see cref="Reset"/> has been called.
		/// </para>
		/// </remarks>
		public void Error(string message, Exception e, ErrorCode errorCode) 
		{
			if (m_firstTime)
			{
                FirstError(message, e, errorCode);
			}
		}

        /// <summary>
        /// Log the very first error
        /// </summary>
        /// <param name="message">The error message.</param>
        /// <param name="e">The exception.</param>
        /// <param name="errorCode">The internal error code.</param>
        /// <remarks>
        /// <para>
        /// Sends the error information to <see cref="LogLog"/>'s Error method.
        /// </para>
        /// </remarks>
        public virtual void FirstError(string message, Exception e, ErrorCode errorCode) {
            m_enabledDateUtc = DateTime.UtcNow;
            m_errorCode = errorCode;
            m_exception = e;
            m_message = message;
            m_firstTime = false;

            if (LogLog.InternalDebugging && !LogLog.QuietMode) {
                LogLog.Error(declaringType, "[" + m_prefix + "] ErrorCode: " + errorCode.ToString() + ". " + message, e);
            }
        }

        /// <summary>
		/// Log an Error
		/// </summary>
		/// <param name="message">The error message.</param>
		/// <param name="e">The exception.</param>
		/// <remarks>
        /// <para>
        /// Invokes <see cref="FirstError"/> if and only if this is the first error or the first error after <see cref="Reset"/> has been called.
        /// </para>
        /// </remarks>
		public void Error(string message, Exception e) 
		{
			Error(message, e, ErrorCode.GenericFailure);
		}

		/// <summary>
		/// Log an error
		/// </summary>
		/// <param name="message">The error message.</param>
		/// <remarks>
        /// <para>
        /// Invokes <see cref="FirstError"/> if and only if this is the first error or the first error after <see cref="Reset"/> has been called.
        /// </para>
        /// </remarks>
		public void Error(string message) 
		{
			Error(message, null, ErrorCode.GenericFailure);
		}

		#endregion Implementation of IErrorHandler

		#endregion

		#region Public Instance Properties

		/// <summary>
		/// Is error logging enabled
		/// </summary>
		/// <remarks>
		/// <para>
		/// Is error logging enabled. Logging is only enabled for the
		/// first error delivered to the <see cref="OnlyOnceErrorHandler"/>.
		/// </para>
		/// </remarks>
		public bool IsEnabled
		{
			get { return m_firstTime; }
		}

		/// <summary>
		/// The date the first error that trigged this error handler occurred, or <see cref="DateTime.MinValue"/> if it has not been triggered.
		/// </summary>
		public DateTime EnabledDate
		{
			get 
            {
                if (m_enabledDateUtc == DateTime.MinValue) return DateTime.MinValue;
                return m_enabledDateUtc.ToLocalTime(); 
            }
		}

        /// <summary>
        /// The UTC date the first error that trigged this error handler occured, or <see cref="DateTime.MinValue"/> if it has not been triggered.
        /// </summary>
        public DateTime EnabledDateUtc
        {
            get { return m_enabledDateUtc; }
        }

		/// <summary>
		/// The message from the first error that trigged this error handler.
		/// </summary>
		public string ErrorMessage
		{
			get { return m_message; }
		}

		/// <summary>
		/// The exception from the first error that trigged this error handler.
		/// </summary>
		/// <remarks>
		/// May be <see langword="null" />.
		/// </remarks>
		public Exception Exception
		{
			get { return m_exception; }
		}

		/// <summary>
		/// The error code from the first error that trigged this error handler.
		/// </summary>
		/// <remarks>
		/// Defaults to <see cref="log4net.Core.ErrorCode.GenericFailure"/>
		/// </remarks>
		public ErrorCode ErrorCode
		{
			get { return m_errorCode; }
		}

		#endregion

		#region Private Instance Fields

		/// <summary>
		/// The UTC date the error was recorded.
		/// </summary>
		private DateTime m_enabledDateUtc;

		/// <summary>
		/// Flag to indicate if it is the first error
		/// </summary>
		private bool m_firstTime = true;

		/// <summary>
		/// The message recorded during the first error.
		/// </summary>
		private string m_message = null;

		/// <summary>
		/// The exception recorded during the first error.
		/// </summary>
		private Exception m_exception = null;

		/// <summary>
		/// The error code recorded during the first error.
		/// </summary>
		private ErrorCode m_errorCode = ErrorCode.GenericFailure;]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static OnlyOnceErrorHandler()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="279" sc="3" el="279" ec="77">log4net\Util\OnlyOnceErrorHandler.cs</location>
            <body hash="80aa62feea165f09ce5a958759c79283"><![CDATA[private readonly static Type declaringType = typeof(OnlyOnceErrorHandler)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Error">
          <declaration><![CDATA[public void Error(string message, Exception e, ErrorCode errorCode)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="105" sc="3" el="110" ec="4">log4net\Util\OnlyOnceErrorHandler.cs</location>
            <body hash="bf5e9bba4f9adfb5e493c0d5ea1ee9eb"><![CDATA[{
			if (m_firstTime)
			{
                FirstError(message, e, errorCode);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Error">
          <declaration><![CDATA[public void Error(string message, Exception e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="146" sc="3" el="148" ec="4">log4net\Util\OnlyOnceErrorHandler.cs</location>
            <body hash="c551b1d1e271b20a042c831a26639ae4"><![CDATA[{
			Error(message, e, ErrorCode.GenericFailure);
		}]]></body>
          </codeblock>
        </method>
        <method name="Error">
          <declaration><![CDATA[public void Error(string message)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="160" sc="3" el="162" ec="4">log4net\Util\OnlyOnceErrorHandler.cs</location>
            <body hash="ddd8dc78ec328423d4e8b279d8eb91fd"><![CDATA[{
			Error(message, null, ErrorCode.GenericFailure);
		}]]></body>
          </codeblock>
        </method>
        <method name="FirstError">
          <declaration><![CDATA[public virtual void FirstError(string message, Exception e, ErrorCode errorCode)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="123" sc="90" el="133" ec="10">log4net\Util\OnlyOnceErrorHandler.cs</location>
            <body hash="8472394ad79507cc396f0ab83e25f93e"><![CDATA[{
            m_enabledDateUtc = DateTime.UtcNow;
            m_errorCode = errorCode;
            m_exception = e;
            m_message = message;
            m_firstTime = false;

            if (LogLog.InternalDebugging && !LogLog.QuietMode) {
                LogLog.Error(declaringType, "[" + m_prefix + "] ErrorCode: " + errorCode.ToString() + ". " + message, e);
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="Reset">
          <declaration><![CDATA[public void Reset()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="83" sc="3" el="89" ec="4">log4net\Util\OnlyOnceErrorHandler.cs</location>
            <body hash="6f25bf7d5d00a8fdc95684d284c5d222"><![CDATA[{
			m_enabledDateUtc = DateTime.MinValue;
			m_errorCode = ErrorCode.GenericFailure;
			m_exception = null;
			m_message = null;
			m_firstTime = true;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(OnlyOnceErrorHandler);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_enabledDateUtc">
          <declaration><![CDATA[private DateTime m_enabledDateUtc;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_errorCode">
          <declaration><![CDATA[private ErrorCode m_errorCode = ErrorCode.GenericFailure;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_exception">
          <declaration><![CDATA[private Exception m_exception = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_firstTime">
          <declaration><![CDATA[private bool m_firstTime = true;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_message">
          <declaration><![CDATA[private string m_message = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_prefix">
          <declaration><![CDATA[private readonly string m_prefix;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="EnabledDate">
          <declaration><![CDATA[public DateTime EnabledDate]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="190" sc="13" el="193" ec="14">log4net\Util\OnlyOnceErrorHandler.cs</location>
            <body hash="707f5ca8adb738d8ccffc7bd40718b93"><![CDATA[{
                if (m_enabledDateUtc == DateTime.MinValue) return DateTime.MinValue;
                return m_enabledDateUtc.ToLocalTime(); 
            }]]></body>
          </codeblock>
        </property>
        <property name="EnabledDateUtc">
          <declaration><![CDATA[public DateTime EnabledDateUtc]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="ErrorCode">
          <declaration><![CDATA[public ErrorCode ErrorCode]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="ErrorMessage">
          <declaration><![CDATA[public string ErrorMessage]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Exception">
          <declaration><![CDATA[public Exception Exception]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="IsEnabled">
          <declaration><![CDATA[public bool IsEnabled]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="OptionConverter">
      <declaration><![CDATA[public sealed class OptionConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private OptionConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="53" sc="3" el="55" ec="4">log4net\Util\OptionConverter.cs</location>
            <body hash="acdb0027e22d0bc184251eb7daeffbe3"><![CDATA[private OptionConverter()
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static OptionConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="662" sc="9" el="662" ec="78">log4net\Util\OptionConverter.cs</location>
            <body hash="75263b3efb99fed17f0ce79540bb6644"><![CDATA[private readonly static Type declaringType = typeof(OptionConverter)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CanConvertTypeTo">
          <declaration><![CDATA[public static bool CanConvertTypeTo(Type sourceType, Type targetType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="352" sc="3" el="385" ec="4">log4net\Util\OptionConverter.cs</location>
            <body hash="b72a79562e4778f1a35440fd453e527d"><![CDATA[{
			if (sourceType == null || targetType == null)
			{
				return false;
			}

			// Check if we can assign directly from the source type to the target type
			if (targetType.IsAssignableFrom(sourceType))
			{
				return true;
			}

			// Look for a To converter
			IConvertTo tcSource = ConverterRegistry.GetConvertTo(sourceType, targetType);
			if (tcSource != null)
			{
				if (tcSource.CanConvertTo(targetType))
				{
					return true;
				}
			}

			// Look for a From converter
			IConvertFrom tcTarget = ConverterRegistry.GetConvertFrom(targetType);
			if (tcTarget != null)
			{
				if (tcTarget.CanConvertFrom(sourceType))
				{
					return true;
				}
			}

			return false;
		}]]></body>
          </codeblock>
        </method>
        <method name="ConvertStringTo">
          <declaration><![CDATA[public static object ConvertStringTo(Type target, string txt)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="268" sc="3" el="323" ec="4">log4net\Util\OptionConverter.cs</location>
            <body hash="08acb6d305cdd4f794c28fb1cf4e0250"><![CDATA[{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}

			// If we want a string we already have the correct type
			if (typeof(string) == target || typeof(object) == target)
			{
				return txt;
			}

			// First lets try to find a type converter
			IConvertFrom typeConverter = ConverterRegistry.GetConvertFrom(target);
			if (typeConverter != null && typeConverter.CanConvertFrom(typeof(string)))
			{
				// Found appropriate converter
				return typeConverter.ConvertFrom(txt);
			}
			else
			{
#if NETSTANDARD1_3
				if (target.GetTypeInfo().IsEnum)
#else
				if (target.IsEnum)
#endif
				{
					// Target type is an enum.

					// Use the Enum.Parse(EnumType, string) method to get the enum value
					return ParseEnum(target, txt, true);
				}
				else
				{
					// We essentially make a guess that to convert from a string
					// to an arbitrary type T there will be a static method defined on type T called Parse
					// that will take an argument of type string. i.e. T.Parse(string)->T we call this
					// method to convert the string to the type required by the property.
					System.Reflection.MethodInfo meth = target.GetMethod("Parse", new Type[] {typeof(string)});
					if (meth != null)
					{
						// Call the Parse method
#if NETSTANDARD1_3
						return meth.Invoke(target, new[] { txt });
#else
						return meth.Invoke(null, BindingFlags.InvokeMethod, null, new object[] {txt}, CultureInfo.InvariantCulture);
#endif
					}
					else
					{
						// No Parse() method found.
					}
				}
			}
			return null;
		}]]></body>
          </codeblock>
        </method>
        <method name="ConvertTypeTo">
          <declaration><![CDATA[public static object ConvertTypeTo(object sourceInstance, Type targetType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="399" sc="3" el="429" ec="4">log4net\Util\OptionConverter.cs</location>
            <body hash="4f9ce9f071980ea70f6933f75bdaf62c"><![CDATA[{
			Type sourceType = sourceInstance.GetType();

			// Check if we can assign directly from the source type to the target type
			if (targetType.IsAssignableFrom(sourceType))
			{
				return sourceInstance;
			}

			// Look for a TO converter
			IConvertTo tcSource = ConverterRegistry.GetConvertTo(sourceType, targetType);
			if (tcSource != null)
			{
				if (tcSource.CanConvertTo(targetType))
				{
					return tcSource.ConvertTo(sourceInstance, targetType);
				}
			}

			// Look for a FROM converter
			IConvertFrom tcTarget = ConverterRegistry.GetConvertFrom(targetType);
			if (tcTarget != null)
			{
				if (tcTarget.CanConvertFrom(sourceType))
				{
					return tcTarget.ConvertFrom(sourceInstance);
				}
			}

			throw new ArgumentException("Cannot convert source object [" + sourceInstance.ToString() + "] to target type [" + targetType.Name + "]", "sourceInstance");
		}]]></body>
          </codeblock>
        </method>
        <method name="InstantiateByClassName">
          <declaration><![CDATA[public static object InstantiateByClassName(string className, Type superClass, object defaultValue)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="481" sc="3" el="504" ec="4">log4net\Util\OptionConverter.cs</location>
            <body hash="a283140c3ad8a7929bdeab9a6144c349"><![CDATA[{
			if (className != null) 
			{
				try 
				{
#if NETSTANDARD1_3
					Type classObj = SystemInfo.GetTypeFromString(superClass.GetTypeInfo().Assembly, className, true, true);
#else
					Type classObj = SystemInfo.GetTypeFromString(className, true, true);
#endif
					if (!superClass.IsAssignableFrom(classObj)) 
					{
						LogLog.Error(declaringType, "OptionConverter: A [" + className + "] object is not assignable to a [" + superClass.FullName + "] variable.");
						return defaultValue;	  
					}
					return Activator.CreateInstance(classObj);
				}
				catch (Exception e) 
				{
					LogLog.Error(declaringType, "Could not instantiate class [" + className + "].", e);
				}
			}
			return defaultValue;	
		}]]></body>
          </codeblock>
        </method>
        <method name="ParseEnum">
          <declaration><![CDATA[private static object ParseEnum(Type enumType, string value, bool ignoreCase)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="609" sc="3" el="649" ec="4">log4net\Util\OptionConverter.cs</location>
            <body hash="fabffaa7add68046771c36eec88a1efe"><![CDATA[{
#if !NETCF
			return Enum.Parse(enumType, value, ignoreCase);
#else
			FieldInfo[] fields = enumType.GetFields(BindingFlags.Public | BindingFlags.Static);

			string[] names = value.Split(new char[] {','});
			for (int i = 0; i < names.Length; ++i) 
			{
				names[i] = names [i].Trim();
			}

			long retVal = 0;

			try 
			{
				// Attempt to convert to numeric type
				return Enum.ToObject(enumType, Convert.ChangeType(value, typeof(long), CultureInfo.InvariantCulture));
			} 
			catch {}

			foreach (string name in names) 
			{
				bool found = false;
				foreach(FieldInfo field in fields) 
				{
					if (String.Compare(name, field.Name, ignoreCase) == 0) 
					{
						retVal |= ((IConvertible) field.GetValue(null)).ToInt64(CultureInfo.InvariantCulture);
						found = true;
						break;
					}
				}
				if (!found) 
				{
					throw new ArgumentException("Failed to lookup member [" + name + "] from Enum type [" + enumType.Name + "]");
				}
			}
			return Enum.ToObject(enumType, retVal);
#endif
		}]]></body>
          </codeblock>
        </method>
        <method name="SubstituteVariables">
          <declaration><![CDATA[public static string SubstituteVariables(string value, IDictionary props)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="550" sc="3" el="594" ec="4">log4net\Util\OptionConverter.cs</location>
            <body hash="3370975871e338ac3b5539a8cedd321c"><![CDATA[{
			StringBuilder buf = new StringBuilder();

			int i = 0;
			int j, k;
	
			while(true) 
			{
				j = value.IndexOf(DELIM_START, i);
				if (j == -1) 
				{
					if (i == 0)
					{
						return value;
					}
					else 
					{
						buf.Append(value.Substring(i, value.Length - i));
						return buf.ToString();
					}
				}
				else 
				{
					buf.Append(value.Substring(i, j - i));
					k = value.IndexOf(DELIM_STOP, j);
					if (k == -1) 
					{
						throw new LogException("[" + value + "] has no closing brace. Opening brace at position [" + j + "]");
					}
					else 
					{
						j += DELIM_START_LEN;
						string key = value.Substring(j, k - j);

						string replacement = props[key] as string;

						if (replacement != null) 
						{
							buf.Append(replacement);
						}
						i = k + DELIM_STOP_LEN;		
					}
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ToBoolean">
          <declaration><![CDATA[public static bool ToBoolean(string argValue, bool defaultValue)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="148" sc="3" el="161" ec="4">log4net\Util\OptionConverter.cs</location>
            <body hash="09e9e00f2c8b1c48b9b93beb3d533ccc"><![CDATA[{
			if (argValue != null && argValue.Length > 0)
			{
				try
				{
					return bool.Parse(argValue);
				}
				catch(Exception e)
				{
					LogLog.Error(declaringType, "[" + argValue + "] is not in proper bool form.", e);
				}
			}
			return defaultValue;
		}]]></body>
          </codeblock>
        </method>
        <method name="ToFileSize">
          <declaration><![CDATA[public static long ToFileSize(string argValue, long defaultValue)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="209" sc="3" el="250" ec="4">log4net\Util\OptionConverter.cs</location>
            <body hash="38d88cf57028cf8a7bb761d713794d93"><![CDATA[{
			if (argValue == null)
			{
				return defaultValue;
			}
	
			string s = argValue.Trim().ToUpper(CultureInfo.InvariantCulture);
			long multiplier = 1;
			int index;
	
			if ((index = s.IndexOf("KB")) != -1) 
			{	  
				multiplier = 1024;
				s = s.Substring(0, index);
			}
			else if ((index = s.IndexOf("MB")) != -1) 
			{
				multiplier = 1024 * 1024;
				s = s.Substring(0, index);
			}
			else if ((index = s.IndexOf("GB")) != -1) 
			{
				multiplier = 1024 * 1024 * 1024;
				s = s.Substring(0, index);
			}	
			if (s != null) 
			{
				// Try again to remove whitespace between the number and the size specifier
				s = s.Trim();
				
				long longVal;
				if (SystemInfo.TryParse(s, out longVal))
				{
					return longVal * multiplier;
				}
				else
				{
					LogLog.Error(declaringType, "OptionConverter: ["+ s +"] is not in the correct file size syntax.");
				}
			}
			return defaultValue;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(OptionConverter);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DELIM_START">
          <declaration><![CDATA[private const string DELIM_START = "${";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DELIM_START_LEN">
          <declaration><![CDATA[private const int DELIM_START_LEN = 2;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DELIM_STOP">
          <declaration><![CDATA[private const char DELIM_STOP = '}';]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DELIM_STOP_LEN">
          <declaration><![CDATA[private const int DELIM_STOP_LEN = 1;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="PatternConverter">
      <declaration><![CDATA[public abstract class PatternConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_min = -1;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="54" sc="3" el="263" ec="125">log4net\Util\PatternConverter.cs</location>
            <body hash="b0cd449ccfee2ba3bf77432a34fa0bad"><![CDATA[protected PatternConverter() 
		{  
		}

		#endregion Protected Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Get the next pattern converter in the chain
		/// </summary>
		/// <value>
		/// the next pattern converter in the chain
		/// </value>
		/// <remarks>
		/// <para>
		/// Get the next pattern converter in the chain
		/// </para>
		/// </remarks>
		public virtual PatternConverter Next
		{
			get { return m_next; }
		}

		/// <summary>
		/// Gets or sets the formatting info for this converter
		/// </summary>
		/// <value>
		/// The formatting info for this converter
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets or sets the formatting info for this converter
		/// </para>
		/// </remarks>
		public virtual FormattingInfo FormattingInfo
		{
			get { return new FormattingInfo(m_min, m_max, m_leftAlign); }
			set
			{
				m_min = value.Min;
				m_max = value.Max;
				m_leftAlign = value.LeftAlign;
			}
		}

		/// <summary>
		/// Gets or sets the option value for this converter
		/// </summary>
		/// <summary>
		/// The option for this converter
		/// </summary>
		/// <remarks>
		/// <para>
		/// Gets or sets the option value for this converter
		/// </para>
		/// </remarks>
		public virtual string Option
		{
			get { return m_option; }
			set { m_option = value; }
		}

		#endregion Public Instance Properties

		#region Protected Abstract Methods

		/// <summary>
		/// Evaluate this pattern converter and write the output to a writer.
		/// </summary>
		/// <param name="writer"><see cref="TextWriter" /> that will receive the formatted result.</param>
		/// <param name="state">The state object on which the pattern converter should be executed.</param>
		/// <remarks>
		/// <para>
		/// Derived pattern converters must override this method in order to
		/// convert conversion specifiers in the appropriate way.
		/// </para>
		/// </remarks>
		abstract protected void Convert(TextWriter writer, object state);

		#endregion Protected Abstract Methods

		#region Public Instance Methods

		/// <summary>
		/// Set the next pattern converter in the chains
		/// </summary>
		/// <param name="patternConverter">the pattern converter that should follow this converter in the chain</param>
		/// <returns>the next converter</returns>
		/// <remarks>
		/// <para>
		/// The PatternConverter can merge with its neighbor during this method (or a sub class).
		/// Therefore the return value may or may not be the value of the argument passed in.
		/// </para>
		/// </remarks>
		public virtual PatternConverter SetNext(PatternConverter patternConverter)
		{
			m_next = patternConverter;
			return m_next;
		}

		/// <summary>
		/// Write the pattern converter to the writer with appropriate formatting
		/// </summary>
		/// <param name="writer"><see cref="TextWriter" /> that will receive the formatted result.</param>
		/// <param name="state">The state object on which the pattern converter should be executed.</param>
		/// <remarks>
		/// <para>
		/// This method calls <see cref="Convert"/> to allow the subclass to perform
		/// appropriate conversion of the pattern converter. If formatting options have
		/// been specified via the <see cref="FormattingInfo"/> then this method will
		/// apply those formattings before writing the output.
		/// </para>
		/// </remarks>
		virtual public void Format(TextWriter writer, object state) 
		{
			if (m_min < 0 && m_max == int.MaxValue)
			{
				// Formatting options are not in use
				Convert(writer, state);
			}
			else
			{
                string msg = null;
                int len;
                lock (m_formatWriter)
                {
                    m_formatWriter.Reset(c_renderBufferMaxCapacity, c_renderBufferSize);

                    Convert(m_formatWriter, state);

                    StringBuilder buf = m_formatWriter.GetStringBuilder();
                    len = buf.Length;
                    if (len > m_max)
                    {
                        msg = buf.ToString(len - m_max, m_max);
                        len = m_max;
                    }
                    else
                    {
                        msg = buf.ToString();
                    }
                }

				if (len < m_min) 
				{
					if (m_leftAlign) 
					{	
						writer.Write(msg);
						SpacePad(writer, m_min - len);
					}
					else 
					{
						SpacePad(writer, m_min - len);
						writer.Write(msg);
					}
				}
				else
				{
					writer.Write(msg);
				}
			}
		}	

		private static readonly string[] SPACES = {	" ", "  ", "    ", "        ",			// 1,2,4,8 spaces
													"                ",						// 16 spaces
													"                                " };	// 32 spaces

		/// <summary>
		/// Fast space padding method.
		/// </summary>
		/// <param name="writer"><see cref="TextWriter" /> to which the spaces will be appended.</param>
		/// <param name="length">The number of spaces to be padded.</param>
		/// <remarks>
		/// <para>
		/// Fast space padding method.
		/// </para>
		/// </remarks>
		protected static void SpacePad(TextWriter writer, int length) 
		{
			while(length >= 32) 
			{
				writer.Write(SPACES[5]);
				length -= 32;
			}
    
			for(int i = 4; i >= 0; i--) 
			{	
				if ((length & (1<<i)) != 0) 
				{
					writer.Write(SPACES[i]);
				}
			}
		}	

		#endregion Public Instance Methods

		#region Private Instance Fields

		private PatternConverter m_next;
		private int m_min = -1;
		private int m_max = int.MaxValue;
		private bool m_leftAlign = false;

		/// <summary>
		/// The option string to the converter
		/// </summary>
		private string m_option = null;

		private ReusableStringWriter m_formatWriter = new ReusableStringWriter(System.Globalization.CultureInfo.InvariantCulture);]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static PatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="218" sc="3" el="220" ec="51">log4net\Util\PatternConverter.cs</location>
            <body hash="8f4a17745a64095b1e1d1509ca98a852"><![CDATA[private static readonly string[] SPACES = {	" ", "  ", "    ", "        ",			// 1,2,4,8 spaces
													"                ",						// 16 spaces
													"                                " };]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected abstract void Convert(TextWriter writer, object state);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Format">
          <declaration><![CDATA[public virtual void Format(TextWriter writer, object state)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="169" sc="3" el="216" ec="4">log4net\Util\PatternConverter.cs</location>
            <body hash="3eb80385f44d68ce10647a54dd8630e4"><![CDATA[{
			if (m_min < 0 && m_max == int.MaxValue)
			{
				// Formatting options are not in use
				Convert(writer, state);
			}
			else
			{
                string msg = null;
                int len;
                lock (m_formatWriter)
                {
                    m_formatWriter.Reset(c_renderBufferMaxCapacity, c_renderBufferSize);

                    Convert(m_formatWriter, state);

                    StringBuilder buf = m_formatWriter.GetStringBuilder();
                    len = buf.Length;
                    if (len > m_max)
                    {
                        msg = buf.ToString(len - m_max, m_max);
                        len = m_max;
                    }
                    else
                    {
                        msg = buf.ToString();
                    }
                }

				if (len < m_min) 
				{
					if (m_leftAlign) 
					{	
						writer.Write(msg);
						SpacePad(writer, m_min - len);
					}
					else 
					{
						SpacePad(writer, m_min - len);
						writer.Write(msg);
					}
				}
				else
				{
					writer.Write(msg);
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="SetNext">
          <declaration><![CDATA[public virtual PatternConverter SetNext(PatternConverter patternConverter)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="150" sc="3" el="153" ec="4">log4net\Util\PatternConverter.cs</location>
            <body hash="de835f57abb6fc61055e26c3ce9530bf"><![CDATA[{
			m_next = patternConverter;
			return m_next;
		}]]></body>
          </codeblock>
        </method>
        <method name="SpacePad">
          <declaration><![CDATA[protected static void SpacePad(TextWriter writer, int length)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="233" sc="3" el="247" ec="4">log4net\Util\PatternConverter.cs</location>
            <body hash="06f9ee9160a3a283e8877c8ad58a8d0e"><![CDATA[{
			while(length >= 32) 
			{
				writer.Write(SPACES[5]);
				length -= 32;
			}
    
			for(int i = 4; i >= 0; i--) 
			{	
				if ((length & (1<<i)) != 0) 
				{
					writer.Write(SPACES[i]);
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="WriteDictionary">
          <declaration><![CDATA[protected static void WriteDictionary(TextWriter writer, ILoggerRepository repository, IDictionary value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="303" sc="3" el="305" ec="4">log4net\Util\PatternConverter.cs</location>
            <body hash="08e6c5050c4890eec0d0a0f8d8273469"><![CDATA[{
			WriteDictionary(writer, repository, value.GetEnumerator());
		}]]></body>
          </codeblock>
        </method>
        <method name="WriteDictionary">
          <declaration><![CDATA[protected static void WriteDictionary(TextWriter writer, ILoggerRepository repository, IDictionaryEnumerator value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="327" sc="3" el="349" ec="4">log4net\Util\PatternConverter.cs</location>
            <body hash="353a805eb31ba42ba294d701ed74f740"><![CDATA[{
			writer.Write("{");

			bool first = true;

			// Write out all the dictionary key value pairs
			while (value.MoveNext())
			{
				if (first)
				{
					first = false;
				}
				else
				{
					writer.Write(", ");
				}
				WriteObject(writer, repository, value.Key);
				writer.Write("=");
				WriteObject(writer, repository, value.Value);
			}

			writer.Write("}");
		}]]></body>
          </codeblock>
        </method>
        <method name="WriteObject">
          <declaration><![CDATA[protected static void WriteObject(TextWriter writer, ILoggerRepository repository, object value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="365" sc="3" el="382" ec="4">log4net\Util\PatternConverter.cs</location>
            <body hash="10008be3cce3f1aeea930b6b955f87a3"><![CDATA[{
			if (repository != null)
			{
				repository.RendererMap.FindAndRender(value, writer);
			}
			else
			{
				// Don't have a repository to render with so just have to rely on ToString
				if (value == null)
				{
					writer.Write( SystemInfo.NullText );
				}
				else
				{
					writer.Write( value.ToString() );
				}
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="c_renderBufferMaxCapacity">
          <declaration><![CDATA[private const int c_renderBufferMaxCapacity = 1024;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="c_renderBufferSize">
          <declaration><![CDATA[private const int c_renderBufferSize = 256;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_formatWriter">
          <declaration><![CDATA[private ReusableStringWriter m_formatWriter = new ReusableStringWriter(CultureInfo.InvariantCulture);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_leftAlign">
          <declaration><![CDATA[private bool m_leftAlign = false;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_max">
          <declaration><![CDATA[private int m_max = 2147483647;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_min">
          <declaration><![CDATA[private int m_min = -1;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_next">
          <declaration><![CDATA[private PatternConverter m_next;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_option">
          <declaration><![CDATA[private string m_option = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="properties">
          <declaration><![CDATA[private PropertiesDictionary properties;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="SPACES">
          <declaration><![CDATA[private static readonly string[] SPACES = new string[]]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="FormattingInfo">
          <declaration><![CDATA[public virtual FormattingInfo FormattingInfo]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="93" sc="4" el="97" ec="5">log4net\Util\PatternConverter.cs</location>
            <body hash="0e115d3109cfadd69136e83c3e42bbd6"><![CDATA[{
				m_min = value.Min;
				m_max = value.Max;
				m_leftAlign = value.LeftAlign;
			}]]></body>
          </codeblock>
        </property>
        <property name="Next">
          <declaration><![CDATA[public virtual PatternConverter Next]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Option">
          <declaration><![CDATA[public virtual string Option]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Properties">
          <declaration><![CDATA[public PropertiesDictionary Properties]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="PatternParser">
      <declaration><![CDATA[public sealed class PatternParser]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private Hashtable m_patternConverters = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="55" sc="3" el="418" ec="59">log4net\Util\PatternParser.cs</location>
            <body hash="34951835c001577bb7a37f1942935dc6"><![CDATA[public PatternParser(string pattern) 
		{
			m_pattern = pattern;
		}

		#endregion Public Instance Constructors

		#region Public Instance Methods

		/// <summary>
		/// Parses the pattern into a chain of pattern converters.
		/// </summary>
		/// <returns>The head of a chain of pattern converters.</returns>
		/// <remarks>
		/// <para>
		/// Parses the pattern into a chain of pattern converters.
		/// </para>
		/// </remarks>
		public PatternConverter Parse()
		{
			string[] converterNamesCache = BuildCache();

			ParseInternal(m_pattern, converterNamesCache);

			return m_head;
		}

		#endregion Public Instance Methods

		#region Public Instance Properties

		/// <summary>
		/// Get the converter registry used by this parser
		/// </summary>
		/// <value>
		/// The converter registry used by this parser
		/// </value>
		/// <remarks>
		/// <para>
		/// Get the converter registry used by this parser
		/// </para>
		/// </remarks>
		public Hashtable PatternConverters
		{
			get { return m_patternConverters; }
		}

		#endregion Public Instance Properties

		#region Private Instance Methods

		/// <summary>
		/// Build the unified cache of converters from the static and instance maps
		/// </summary>
		/// <returns>the list of all the converter names</returns>
		/// <remarks>
		/// <para>
		/// Build the unified cache of converters from the static and instance maps
		/// </para>
		/// </remarks>
		private string[] BuildCache()
		{
			string[] converterNamesCache = new string[m_patternConverters.Keys.Count];
			m_patternConverters.Keys.CopyTo(converterNamesCache, 0);

			// sort array so that longer strings come first
			Array.Sort(converterNamesCache, 0, converterNamesCache.Length, StringLengthComparer.Instance);

			return converterNamesCache;
		}

		#region StringLengthComparer

		/// <summary>
		/// Sort strings by length
		/// </summary>
		/// <remarks>
		/// <para>
		/// <see cref="IComparer" /> that orders strings by string length.
		/// The longest strings are placed first
		/// </para>
		/// </remarks>
		private sealed class StringLengthComparer : IComparer
		{
			public static readonly StringLengthComparer Instance = new StringLengthComparer();

			private StringLengthComparer()
			{
			}

			#region Implementation of IComparer

			public int Compare(object x, object y)
			{
				string s1 = x as string;
				string s2 = y as string;

				if (s1 == null && s2 == null)
				{
					return 0;
				}
				if (s1 == null)
				{
					return 1;
				}
				if (s2 == null)
				{
					return -1;
				}

				return s2.Length.CompareTo(s1.Length);
			}
		
			#endregion
		}

		#endregion // StringLengthComparer

		/// <summary>
		/// Internal method to parse the specified pattern to find specified matches
		/// </summary>
		/// <param name="pattern">the pattern to parse</param>
		/// <param name="matches">the converter names to match in the pattern</param>
		/// <remarks>
		/// <para>
		/// The matches param must be sorted such that longer strings come before shorter ones.
		/// </para>
		/// </remarks>
		private void ParseInternal(string pattern, string[] matches)
		{
			int offset = 0;
			while(offset < pattern.Length)
			{
				int i = pattern.IndexOf('%', offset);
				if (i < 0 || i == pattern.Length - 1)
				{
					ProcessLiteral(pattern.Substring(offset));
					offset = pattern.Length;
				}
				else
				{
					if (pattern[i+1] == '%')
					{
						// Escaped
						ProcessLiteral(pattern.Substring(offset, i - offset + 1));
						offset = i + 2;
					}
					else
					{
						ProcessLiteral(pattern.Substring(offset, i - offset));
						offset = i + 1;

						FormattingInfo formattingInfo = new FormattingInfo();

						// Process formatting options

						// Look for the align flag
						if (offset < pattern.Length)
						{
							if (pattern[offset] == '-')
							{
								// Seen align flag
								formattingInfo.LeftAlign = true;
								offset++;
							}
						}
						// Look for the minimum length
						while (offset < pattern.Length && char.IsDigit(pattern[offset]))
						{
							// Seen digit
							if (formattingInfo.Min < 0)
							{
								formattingInfo.Min = 0;
							}

							formattingInfo.Min = (formattingInfo.Min * 10) + int.Parse(pattern[offset].ToString(), NumberFormatInfo.InvariantInfo);

							offset++;
						}
						// Look for the separator between min and max
						if (offset < pattern.Length)
						{
							if (pattern[offset] == '.')
							{
								// Seen separator
								offset++;
							}
						}
						// Look for the maximum length
						while (offset < pattern.Length && char.IsDigit(pattern[offset]))
						{
							// Seen digit
							if (formattingInfo.Max == int.MaxValue)
							{
								formattingInfo.Max = 0;
							}

							formattingInfo.Max = (formattingInfo.Max * 10) + int.Parse(pattern[offset].ToString(), NumberFormatInfo.InvariantInfo);

							offset++;
						}

						int remainingStringLength = pattern.Length - offset;

						// Look for pattern
						for(int m=0; m<matches.Length; m++)
						{
							string key = matches[m];

							if (key.Length <= remainingStringLength)
							{
								if (string.Compare(pattern, offset, key, 0, key.Length) == 0)
								{
									// Found match
									offset = offset + matches[m].Length;

									string option = null;

									// Look for option
									if (offset < pattern.Length)
									{
										if (pattern[offset] == '{')
										{
											// Seen option start
											offset++;
											
											int optEnd = pattern.IndexOf('}', offset);
											if (optEnd < 0)
											{
												// error
											}
											else
											{
												option = pattern.Substring(offset, optEnd - offset);
												offset = optEnd + 1;
											}
										}
									}

									ProcessConverter(matches[m], option, formattingInfo);
									break;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// Process a parsed literal
		/// </summary>
		/// <param name="text">the literal text</param>
		private void ProcessLiteral(string text)
		{
			if (text.Length > 0)
			{
				// Convert into a pattern
				ProcessConverter("literal", text, new FormattingInfo());
			}
		}

		/// <summary>
		/// Process a parsed converter pattern
		/// </summary>
		/// <param name="converterName">the name of the converter</param>
		/// <param name="option">the optional option for the converter</param>
		/// <param name="formattingInfo">the formatting info for the converter</param>
		private void ProcessConverter(string converterName, string option, FormattingInfo formattingInfo)
		{
			LogLog.Debug(declaringType, "Converter ["+converterName+"] Option ["+option+"] Format [min="+formattingInfo.Min+",max="+formattingInfo.Max+",leftAlign="+formattingInfo.LeftAlign+"]");

			// Lookup the converter type
            ConverterInfo converterInfo = (ConverterInfo)m_patternConverters[converterName];
			if (converterInfo == null)
			{
				LogLog.Error(declaringType, "Unknown converter name ["+converterName+"] in conversion pattern.");
			}
			else
			{
				// Create the pattern converter
				PatternConverter pc = null;
				try
				{
                    pc = (PatternConverter)Activator.CreateInstance(converterInfo.Type);
				}
				catch(Exception createInstanceEx)
				{
                    LogLog.Error(declaringType, "Failed to create instance of Type [" + converterInfo.Type.FullName + "] using default constructor. Exception: " + createInstanceEx.ToString());
				}

				// formattingInfo variable is an instance variable, occasionally reset 
				// and used over and over again
				pc.FormattingInfo = formattingInfo;
				pc.Option = option;
                pc.Properties = converterInfo.Properties;

			    IOptionHandler optionHandler = pc as IOptionHandler;
				if (optionHandler != null)
				{
					optionHandler.ActivateOptions();
				}

				AddConverter(pc);
			}
		}

		/// <summary>
		/// Resets the internal state of the parser and adds the specified pattern converter 
		/// to the chain.
		/// </summary>
		/// <param name="pc">The pattern converter to add.</param>
		private void AddConverter(PatternConverter pc) 
		{
			// Add the pattern converter to the list.

			if (m_head == null) 
			{
				m_head = m_tail = pc;
			}
			else 
			{
				// Set the next converter on the tail
				// Update the tail reference
				// note that a converter may combine the 'next' into itself
				// and therefore the tail would not change!
				m_tail = m_tail.SetNext(pc);
			}
		}

		#endregion Protected Instance Methods

		#region Private Constants

		private const char ESCAPE_CHAR = '%';
  
		#endregion Private Constants

		#region Private Instance Fields

		/// <summary>
		/// The first pattern converter in the chain
		/// </summary>
		private PatternConverter m_head;

		/// <summary>
		///  the last pattern converter in the chain
		/// </summary>
		private PatternConverter m_tail;

		/// <summary>
		/// The pattern
		/// </summary>
		private string m_pattern;

		/// <summary>
		/// Internal map of converter identifiers to converter types
		/// </summary>
		/// <remarks>
		/// <para>
		/// This map overrides the static s_globalRulesRegistry map.
		/// </para>
		/// </remarks>
		private Hashtable m_patternConverters = new Hashtable();]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static PatternParser()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="431" sc="6" el="431" ec="73">log4net\Util\PatternParser.cs</location>
            <body hash="516eff460523b854d88b94d93f09f5ca"><![CDATA[private readonly static Type declaringType = typeof(PatternParser)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AddConverter">
          <declaration><![CDATA[private void AddConverter(PatternConverter pc)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="368" sc="3" el="383" ec="4">log4net\Util\PatternParser.cs</location>
            <body hash="f24316c2416622d0a3550b6c9d0ec563"><![CDATA[{
			// Add the pattern converter to the list.

			if (m_head == null) 
			{
				m_head = m_tail = pc;
			}
			else 
			{
				// Set the next converter on the tail
				// Update the tail reference
				// note that a converter may combine the 'next' into itself
				// and therefore the tail would not change!
				m_tail = m_tail.SetNext(pc);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="BuildCache">
          <declaration><![CDATA[private string[] BuildCache()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="116" sc="3" el="124" ec="4">log4net\Util\PatternParser.cs</location>
            <body hash="68b2220be6d5f90eeded4560f7a3e134"><![CDATA[{
			string[] converterNamesCache = new string[m_patternConverters.Keys.Count];
			m_patternConverters.Keys.CopyTo(converterNamesCache, 0);

			// sort array so that longer strings come first
			Array.Sort(converterNamesCache, 0, converterNamesCache.Length, StringLengthComparer.Instance);

			return converterNamesCache;
		}]]></body>
          </codeblock>
        </method>
        <method name="Parse">
          <declaration><![CDATA[public PatternConverter Parse()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="74" sc="3" el="80" ec="4">log4net\Util\PatternParser.cs</location>
            <body hash="8a9571742c461f44ede22e07f90aa0e0"><![CDATA[{
			string[] converterNamesCache = BuildCache();

			ParseInternal(m_pattern, converterNamesCache);

			return m_head;
		}]]></body>
          </codeblock>
        </method>
        <method name="ParseInternal">
          <declaration><![CDATA[private void ParseInternal(string pattern, string[] matches)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="184" sc="3" el="302" ec="4">log4net\Util\PatternParser.cs</location>
            <body hash="2db313492f4b57ee0f1e257bae085904"><![CDATA[{
			int offset = 0;
			while(offset < pattern.Length)
			{
				int i = pattern.IndexOf('%', offset);
				if (i < 0 || i == pattern.Length - 1)
				{
					ProcessLiteral(pattern.Substring(offset));
					offset = pattern.Length;
				}
				else
				{
					if (pattern[i+1] == '%')
					{
						// Escaped
						ProcessLiteral(pattern.Substring(offset, i - offset + 1));
						offset = i + 2;
					}
					else
					{
						ProcessLiteral(pattern.Substring(offset, i - offset));
						offset = i + 1;

						FormattingInfo formattingInfo = new FormattingInfo();

						// Process formatting options

						// Look for the align flag
						if (offset < pattern.Length)
						{
							if (pattern[offset] == '-')
							{
								// Seen align flag
								formattingInfo.LeftAlign = true;
								offset++;
							}
						}
						// Look for the minimum length
						while (offset < pattern.Length && char.IsDigit(pattern[offset]))
						{
							// Seen digit
							if (formattingInfo.Min < 0)
							{
								formattingInfo.Min = 0;
							}

							formattingInfo.Min = (formattingInfo.Min * 10) + int.Parse(pattern[offset].ToString(), NumberFormatInfo.InvariantInfo);

							offset++;
						}
						// Look for the separator between min and max
						if (offset < pattern.Length)
						{
							if (pattern[offset] == '.')
							{
								// Seen separator
								offset++;
							}
						}
						// Look for the maximum length
						while (offset < pattern.Length && char.IsDigit(pattern[offset]))
						{
							// Seen digit
							if (formattingInfo.Max == int.MaxValue)
							{
								formattingInfo.Max = 0;
							}

							formattingInfo.Max = (formattingInfo.Max * 10) + int.Parse(pattern[offset].ToString(), NumberFormatInfo.InvariantInfo);

							offset++;
						}

						int remainingStringLength = pattern.Length - offset;

						// Look for pattern
						for(int m=0; m<matches.Length; m++)
						{
							string key = matches[m];

							if (key.Length <= remainingStringLength)
							{
								if (string.Compare(pattern, offset, key, 0, key.Length) == 0)
								{
									// Found match
									offset = offset + matches[m].Length;

									string option = null;

									// Look for option
									if (offset < pattern.Length)
									{
										if (pattern[offset] == '{')
										{
											// Seen option start
											offset++;
											
											int optEnd = pattern.IndexOf('}', offset);
											if (optEnd < 0)
											{
												// error
											}
											else
											{
												option = pattern.Substring(offset, optEnd - offset);
												offset = optEnd + 1;
											}
										}
									}

									ProcessConverter(matches[m], option, formattingInfo);
									break;
								}
							}
						}
					}
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ProcessConverter">
          <declaration><![CDATA[private void ProcessConverter(string converterName, string option, FormattingInfo formattingInfo)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="324" sc="3" el="360" ec="4">log4net\Util\PatternParser.cs</location>
            <body hash="696431520593e62229391982a93cd770"><![CDATA[{
			LogLog.Debug(declaringType, "Converter ["+converterName+"] Option ["+option+"] Format [min="+formattingInfo.Min+",max="+formattingInfo.Max+",leftAlign="+formattingInfo.LeftAlign+"]");

			// Lookup the converter type
            ConverterInfo converterInfo = (ConverterInfo)m_patternConverters[converterName];
			if (converterInfo == null)
			{
				LogLog.Error(declaringType, "Unknown converter name ["+converterName+"] in conversion pattern.");
			}
			else
			{
				// Create the pattern converter
				PatternConverter pc = null;
				try
				{
                    pc = (PatternConverter)Activator.CreateInstance(converterInfo.Type);
				}
				catch(Exception createInstanceEx)
				{
                    LogLog.Error(declaringType, "Failed to create instance of Type [" + converterInfo.Type.FullName + "] using default constructor. Exception: " + createInstanceEx.ToString());
				}

				// formattingInfo variable is an instance variable, occasionally reset 
				// and used over and over again
				pc.FormattingInfo = formattingInfo;
				pc.Option = option;
                pc.Properties = converterInfo.Properties;

			    IOptionHandler optionHandler = pc as IOptionHandler;
				if (optionHandler != null)
				{
					optionHandler.ActivateOptions();
				}

				AddConverter(pc);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="ProcessLiteral">
          <declaration><![CDATA[private void ProcessLiteral(string text)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="309" sc="3" el="315" ec="4">log4net\Util\PatternParser.cs</location>
            <body hash="719dbfb7f40761eebd36fc656e68d6bb"><![CDATA[{
			if (text.Length > 0)
			{
				// Convert into a pattern
				ProcessConverter("literal", text, new FormattingInfo());
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(PatternParser);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ESCAPE_CHAR">
          <declaration><![CDATA[private const char ESCAPE_CHAR = '%';]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_head">
          <declaration><![CDATA[private PatternConverter m_head;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_pattern">
          <declaration><![CDATA[private string m_pattern;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_patternConverters">
          <declaration><![CDATA[private Hashtable m_patternConverters = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_tail">
          <declaration><![CDATA[private PatternConverter m_tail;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="PatternConverters">
          <declaration><![CDATA[public Hashtable PatternConverters]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="PatternString">
      <declaration><![CDATA[public class PatternString : IOptionHandler]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".cctor">
          <declaration><![CDATA[static PatternString()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="296" sc="3" el="325" ec="4">log4net\Util\PatternString.cs</location>
            <body hash="c6dadfe582f948168ecdf79cf0e5aa03"><![CDATA[{
			s_globalRulesRegistry = new Hashtable(18);

			s_globalRulesRegistry.Add("appdomain", typeof(AppDomainPatternConverter));
			s_globalRulesRegistry.Add("date", typeof(DatePatternConverter));
#if !NETCF
			s_globalRulesRegistry.Add("env", typeof(EnvironmentPatternConverter));
#if !NETSTANDARD1_3 // EnvironmentFolderPathPatternConverter not yet supported
			s_globalRulesRegistry.Add("envFolderPath", typeof(EnvironmentFolderPathPatternConverter));
#endif
#endif
			s_globalRulesRegistry.Add("identity", typeof(IdentityPatternConverter));
			s_globalRulesRegistry.Add("literal", typeof(LiteralPatternConverter));
			s_globalRulesRegistry.Add("newline", typeof(NewLinePatternConverter));
			s_globalRulesRegistry.Add("processid", typeof(ProcessIdPatternConverter));
			s_globalRulesRegistry.Add("property", typeof(PropertyPatternConverter));
			s_globalRulesRegistry.Add("random", typeof(RandomStringPatternConverter));
			s_globalRulesRegistry.Add("username", typeof(UserNamePatternConverter));

			s_globalRulesRegistry.Add("utcdate", typeof(UtcDatePatternConverter));
			s_globalRulesRegistry.Add("utcDate", typeof(UtcDatePatternConverter));
			s_globalRulesRegistry.Add("UtcDate", typeof(UtcDatePatternConverter));
#if !NETCF && !NETSTANDARD1_3
			// TODO - have added common variants of casing like utcdate above.
			// Wouldn't it be better to use a case-insensitive Hashtable?
			s_globalRulesRegistry.Add("appsetting", typeof(AppSettingPatternConverter));
			s_globalRulesRegistry.Add("appSetting", typeof(AppSettingPatternConverter));
			s_globalRulesRegistry.Add("AppSetting", typeof(AppSettingPatternConverter));
#endif
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private Hashtable m_instanceRulesRegistry = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="286" sc="3" el="341" ec="4">log4net\Util\PatternString.cs</location>
            <body hash="0a7c98e9ce6586447a381592397b8fa5"><![CDATA[private Hashtable m_instanceRulesRegistry = new Hashtable();

		#endregion

		#region Static Constructor

		/// <summary>
		/// Initialize the global registry
		/// </summary>
		static PatternString()
		{
			s_globalRulesRegistry = new Hashtable(18);

			s_globalRulesRegistry.Add("appdomain", typeof(AppDomainPatternConverter));
			s_globalRulesRegistry.Add("date", typeof(DatePatternConverter));
#if !NETCF
			s_globalRulesRegistry.Add("env", typeof(EnvironmentPatternConverter));
#if !NETSTANDARD1_3 // EnvironmentFolderPathPatternConverter not yet supported
			s_globalRulesRegistry.Add("envFolderPath", typeof(EnvironmentFolderPathPatternConverter));
#endif
#endif
			s_globalRulesRegistry.Add("identity", typeof(IdentityPatternConverter));
			s_globalRulesRegistry.Add("literal", typeof(LiteralPatternConverter));
			s_globalRulesRegistry.Add("newline", typeof(NewLinePatternConverter));
			s_globalRulesRegistry.Add("processid", typeof(ProcessIdPatternConverter));
			s_globalRulesRegistry.Add("property", typeof(PropertyPatternConverter));
			s_globalRulesRegistry.Add("random", typeof(RandomStringPatternConverter));
			s_globalRulesRegistry.Add("username", typeof(UserNamePatternConverter));

			s_globalRulesRegistry.Add("utcdate", typeof(UtcDatePatternConverter));
			s_globalRulesRegistry.Add("utcDate", typeof(UtcDatePatternConverter));
			s_globalRulesRegistry.Add("UtcDate", typeof(UtcDatePatternConverter));
#if !NETCF && !NETSTANDARD1_3
			// TODO - have added common variants of casing like utcdate above.
			// Wouldn't it be better to use a case-insensitive Hashtable?
			s_globalRulesRegistry.Add("appsetting", typeof(AppSettingPatternConverter));
			s_globalRulesRegistry.Add("appSetting", typeof(AppSettingPatternConverter));
			s_globalRulesRegistry.Add("AppSetting", typeof(AppSettingPatternConverter));
#endif
		}

		#endregion Static Constructor

		#region Constructors

		/// <summary>
		/// Default constructor
		/// </summary>
		/// <remarks>
		/// <para>
		/// Initialize a new instance of <see cref="PatternString"/>
		/// </para>
		/// </remarks>
		public PatternString()
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private Hashtable m_instanceRulesRegistry = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="286" sc="3" el="356" ec="4">log4net\Util\PatternString.cs</location>
            <body hash="ef5be29925c574dbabd783afe016569c"><![CDATA[private Hashtable m_instanceRulesRegistry = new Hashtable();

		#endregion

		#region Static Constructor

		/// <summary>
		/// Initialize the global registry
		/// </summary>
		static PatternString()
		{
			s_globalRulesRegistry = new Hashtable(18);

			s_globalRulesRegistry.Add("appdomain", typeof(AppDomainPatternConverter));
			s_globalRulesRegistry.Add("date", typeof(DatePatternConverter));
#if !NETCF
			s_globalRulesRegistry.Add("env", typeof(EnvironmentPatternConverter));
#if !NETSTANDARD1_3 // EnvironmentFolderPathPatternConverter not yet supported
			s_globalRulesRegistry.Add("envFolderPath", typeof(EnvironmentFolderPathPatternConverter));
#endif
#endif
			s_globalRulesRegistry.Add("identity", typeof(IdentityPatternConverter));
			s_globalRulesRegistry.Add("literal", typeof(LiteralPatternConverter));
			s_globalRulesRegistry.Add("newline", typeof(NewLinePatternConverter));
			s_globalRulesRegistry.Add("processid", typeof(ProcessIdPatternConverter));
			s_globalRulesRegistry.Add("property", typeof(PropertyPatternConverter));
			s_globalRulesRegistry.Add("random", typeof(RandomStringPatternConverter));
			s_globalRulesRegistry.Add("username", typeof(UserNamePatternConverter));

			s_globalRulesRegistry.Add("utcdate", typeof(UtcDatePatternConverter));
			s_globalRulesRegistry.Add("utcDate", typeof(UtcDatePatternConverter));
			s_globalRulesRegistry.Add("UtcDate", typeof(UtcDatePatternConverter));
#if !NETCF && !NETSTANDARD1_3
			// TODO - have added common variants of casing like utcdate above.
			// Wouldn't it be better to use a case-insensitive Hashtable?
			s_globalRulesRegistry.Add("appsetting", typeof(AppSettingPatternConverter));
			s_globalRulesRegistry.Add("appSetting", typeof(AppSettingPatternConverter));
			s_globalRulesRegistry.Add("AppSetting", typeof(AppSettingPatternConverter));
#endif
		}

		#endregion Static Constructor

		#region Constructors

		/// <summary>
		/// Default constructor
		/// </summary>
		/// <remarks>
		/// <para>
		/// Initialize a new instance of <see cref="PatternString"/>
		/// </para>
		/// </remarks>
		public PatternString()
		{
		}

		/// <summary>
		/// Constructs a PatternString
		/// </summary>
		/// <param name="pattern">The pattern to use with this PatternString</param>
		/// <remarks>
		/// <para>
		/// Initialize a new instance of <see cref="PatternString"/> with the pattern specified.
		/// </para>
		/// </remarks>
		public PatternString(string pattern)
		{
			m_pattern = pattern;
			ActivateOptions();
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public virtual void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="398" sc="3" el="400" ec="4">log4net\Util\PatternString.cs</location>
            <body hash="3816545a4921a80ad1d9c7c3da8bda06"><![CDATA[{
			m_head = CreatePatternParser(m_pattern).Parse();
		}]]></body>
          </codeblock>
        </method>
        <method name="AddConverter">
          <declaration><![CDATA[public void AddConverter(ConverterInfo converterInfo)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="490" sc="3" el="498" ec="4">log4net\Util\PatternString.cs</location>
            <body hash="4d78c06f487d26bab6bbddd286a771c4"><![CDATA[{
            if (converterInfo == null) throw new ArgumentNullException("converterInfo");

            if (!typeof(PatternConverter).IsAssignableFrom(converterInfo.Type))
            {
                throw new ArgumentException("The converter type specified [" + converterInfo.Type + "] must be a subclass of log4net.Util.PatternConverter", "converterInfo");
            }
            m_instanceRulesRegistry[converterInfo.Name] = converterInfo;
		}]]></body>
          </codeblock>
        </method>
        <method name="AddConverter">
          <declaration><![CDATA[public void AddConverter(string name, Type type)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="511" sc="3" el="520" ec="4">log4net\Util\PatternString.cs</location>
            <body hash="1146945403eb66de8ad75620079faf72"><![CDATA[{
			if (name == null) throw new ArgumentNullException("name");
			if (type == null) throw new ArgumentNullException("type");

            ConverterInfo converterInfo = new ConverterInfo();
            converterInfo.Name = name;
            converterInfo.Type = type;

            AddConverter(converterInfo);
		}]]></body>
          </codeblock>
        </method>
        <method name="CreatePatternParser">
          <declaration><![CDATA[private PatternParser CreatePatternParser(string pattern)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="417" sc="3" el="435" ec="4">log4net\Util\PatternString.cs</location>
            <body hash="ba525aa4d7fcec0f5a0bd7e27e97d647"><![CDATA[{
			PatternParser patternParser = new PatternParser(pattern);

			// Add all the builtin patterns
			foreach(DictionaryEntry entry in s_globalRulesRegistry)
			{
                ConverterInfo converterInfo = new ConverterInfo();
                converterInfo.Name = (string)entry.Key;
                converterInfo.Type = (Type)entry.Value;
                patternParser.PatternConverters.Add(entry.Key, converterInfo);
			}
			// Add the instance patterns
			foreach(DictionaryEntry entry in m_instanceRulesRegistry)
			{
				patternParser.PatternConverters[entry.Key] = entry.Value;
			}

			return patternParser;
		}]]></body>
          </codeblock>
        </method>
        <method name="Format">
          <declaration><![CDATA[public void Format(TextWriter writer)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="447" sc="3" el="461" ec="4">log4net\Util\PatternString.cs</location>
            <body hash="25d8ba7b0162776ec4330a4d57b33152"><![CDATA[{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}

			PatternConverter c = m_head;

			// loop through the chain of pattern converters
			while(c != null) 
			{
				c.Format(writer, null);
				c = c.Next;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Format">
          <declaration><![CDATA[public string Format()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="473" sc="3" el="477" ec="4">log4net\Util\PatternString.cs</location>
            <body hash="900ac09e7f95a0f7976c7774e5e76765"><![CDATA[{
			StringWriter writer = new StringWriter(System.Globalization.CultureInfo.InvariantCulture);
			Format(writer);
			return writer.ToString();
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_head">
          <declaration><![CDATA[private PatternConverter m_head;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_instanceRulesRegistry">
          <declaration><![CDATA[private Hashtable m_instanceRulesRegistry = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_pattern">
          <declaration><![CDATA[private string m_pattern;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="s_globalRulesRegistry">
          <declaration><![CDATA[private static Hashtable s_globalRulesRegistry;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="ConversionPattern">
          <declaration><![CDATA[public string ConversionPattern]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="PropertiesDictionary">
      <declaration><![CDATA[public sealed class PropertiesDictionary : ReadOnlyPropertiesDictionary, ISerializable, IDictionary, ICollection, IEnumerable]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public PropertiesDictionary()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="57" sc="3" el="59" ec="4">log4net\Util\PropertiesDictionary.cs</location>
            <body hash="261c310a72e4a74838c8f4e82cab7c97"><![CDATA[public PropertiesDictionary()
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public PropertiesDictionary(ReadOnlyPropertiesDictionary propertiesDictionary) : base(propertiesDictionary)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="70" sc="84" el="72" ec="4">log4net\Util\PropertiesDictionary.cs</location>
            <body hash="b30359affa9458ecc4957e19b3cb8c70"><![CDATA[base(propertiesDictionary)
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private PropertiesDictionary(SerializationInfo info, StreamingContext context) : base(info, context)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="90" sc="84" el="92" ec="4">log4net\Util\PropertiesDictionary.cs</location>
            <body hash="7e81226f915c938071654d8da6c462b7"><![CDATA[base(info, context)
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Clear">
          <declaration><![CDATA[public override void Clear()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="193" sc="3" el="195" ec="4">log4net\Util\PropertiesDictionary.cs</location>
            <body hash="f0f891e1577a3563a11868e55d766922"><![CDATA[{
			InnerHashtable.Clear();
		}]]></body>
          </codeblock>
        </method>
        <method name="Remove">
          <declaration><![CDATA[public void Remove(string key)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="133" sc="3" el="135" ec="4">log4net\Util\PropertiesDictionary.cs</location>
            <body hash="c4ba4299dff10ae48ad1c0d6502d327e"><![CDATA[{
			InnerHashtable.Remove(key);
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.ICollection.CopyTo">
          <declaration><![CDATA[void ICollection.CopyTo(Array array, int index)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="300" sc="3" el="302" ec="4">log4net\Util\PropertiesDictionary.cs</location>
            <body hash="e855593aec3a22462da1dde2c98a342e"><![CDATA[{
			InnerHashtable.CopyTo(array, index);
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IDictionary.Add">
          <declaration><![CDATA[void IDictionary.Add(object key, object value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="209" sc="3" el="215" ec="4">log4net\Util\PropertiesDictionary.cs</location>
            <body hash="ab88bdd2cc94ae95997e69e5f1645fe9"><![CDATA[{
			if (!(key is string))
			{
				throw new ArgumentException("key must be a string", "key");
			}
			InnerHashtable.Add(key, value);
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IDictionary.Contains">
          <declaration><![CDATA[bool IDictionary.Contains(object key)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="180" sc="3" el="182" ec="4">log4net\Util\PropertiesDictionary.cs</location>
            <body hash="d0c940cabd0dfbfa722fd0b9d9797f4b"><![CDATA[{
			return InnerHashtable.Contains(key);
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IDictionary.GetEnumerator">
          <declaration><![CDATA[IDictionaryEnumerator IDictionary.GetEnumerator()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="151" sc="3" el="153" ec="4">log4net\Util\PropertiesDictionary.cs</location>
            <body hash="0bda076c264e54d688e381a289ce5520"><![CDATA[{
			return InnerHashtable.GetEnumerator();
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IDictionary.Remove">
          <declaration><![CDATA[void IDictionary.Remove(object key)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="165" sc="3" el="167" ec="4">log4net\Util\PropertiesDictionary.cs</location>
            <body hash="c4ba4299dff10ae48ad1c0d6502d327e"><![CDATA[{
			InnerHashtable.Remove(key);
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IEnumerable.GetEnumerator">
          <declaration><![CDATA[IEnumerator IEnumerable.GetEnumerator()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="328" sc="3" el="330" ec="4">log4net\Util\PropertiesDictionary.cs</location>
            <body hash="d6d09af5e0957f43da80cd87bedbb957"><![CDATA[{
			return ((IEnumerable)InnerHashtable).GetEnumerator();
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Item">
          <declaration><![CDATA[public override object this[string key]]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="System.Collections.ICollection.IsSynchronized">
          <declaration><![CDATA[bool ICollection.IsSynchronized]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="System.Collections.ICollection.SyncRoot">
          <declaration><![CDATA[object ICollection.SyncRoot]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="System.Collections.IDictionary.IsFixedSize">
          <declaration><![CDATA[bool IDictionary.IsFixedSize]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="System.Collections.IDictionary.IsReadOnly">
          <declaration><![CDATA[bool IDictionary.IsReadOnly]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="System.Collections.IDictionary.Item">
          <declaration><![CDATA[object IDictionary.this[object key]]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="249" sc="4" el="255" ec="5">log4net\Util\PropertiesDictionary.cs</location>
            <body hash="d23b95d239f099d51b779ddae5f6d4f6"><![CDATA[{
				if (!(key is string))
				{
					throw new ArgumentException("key must be a string", "key");
				}
				return InnerHashtable[key];
			}]]></body>
          </codeblock>
          <codeblock>
            <location sl="257" sc="4" el="263" ec="5">log4net\Util\PropertiesDictionary.cs</location>
            <body hash="d42f1d969a77ec1a6256a5c088e934d0"><![CDATA[{
				if (!(key is string))
				{
					throw new ArgumentException("key must be a string", "key");
				}
				InnerHashtable[key] = value;
			}]]></body>
          </codeblock>
        </property>
        <property name="System.Collections.IDictionary.Keys">
          <declaration><![CDATA[ICollection IDictionary.Keys]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="System.Collections.IDictionary.Values">
          <declaration><![CDATA[ICollection IDictionary.Values]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="PropertyEntry">
      <declaration><![CDATA[public class PropertyEntry]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private string m_key = null;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="34" sc="9" el="35" ec="39">log4net\Util\PropertyEntry.cs</location>
            <body hash="789597f78d818f6de9805d68add4b315"><![CDATA[private string m_key = null;
        private object m_value = null;]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ToString">
          <declaration><![CDATA[public override string ToString()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="76" sc="9" el="78" ec="10">log4net\Util\PropertyEntry.cs</location>
            <body hash="3ad422208f58f1773252f401860d8ca1"><![CDATA[{
            return "PropertyEntry(Key=" + m_key + ", Value=" + m_value + ")";
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_key">
          <declaration><![CDATA[private string m_key = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_value">
          <declaration><![CDATA[private object m_value = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Key">
          <declaration><![CDATA[public string Key]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Value">
          <declaration><![CDATA[public object Value]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ProtectCloseTextWriter">
      <declaration><![CDATA[public class ProtectCloseTextWriter : TextWriterAdapter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ProtectCloseTextWriter(TextWriter writer) : base(writer)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="51" sc="54" el="53" ec="4">log4net\Util\ProtectCloseTextWriter.cs</location>
            <body hash="9b8ed41a0529c83cada30895d8bb3831"><![CDATA[base(writer)
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Attach">
          <declaration><![CDATA[public void Attach(TextWriter writer)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="69" sc="3" el="71" ec="4">log4net\Util\ProtectCloseTextWriter.cs</location>
            <body hash="ba852aa634d0b6a5868a35adfb98b24f"><![CDATA[{
			this.Writer = writer;
		}]]></body>
          </codeblock>
        </method>
        <method name="Close">
          <declaration><![CDATA[public override void Close()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="87" sc="3" el="89" ec="4">log4net\Util\ProtectCloseTextWriter.cs</location>
            <body hash="75d4485c7a24d496e3930bc9feca37c8"><![CDATA[{
			// do nothing
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="QuietTextWriter">
      <declaration><![CDATA[public class QuietTextWriter : TextWriterAdapter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private bool m_closed = false;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="52" sc="75" el="201" ec="33">log4net\Util\QuietTextWriter.cs</location>
            <body hash="c99c436bd6f2ef838b71aa7979ee2020"><![CDATA[base(writer)
		{
			if (errorHandler == null)
			{
				throw new ArgumentNullException("errorHandler");
			}
			ErrorHandler = errorHandler;
		}

		#endregion Public Instance Constructors

		#region Public Instance Properties

		/// <summary>
		/// Gets or sets the error handler that all errors are passed to.
		/// </summary>
		/// <value>
		/// The error handler that all errors are passed to.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets or sets the error handler that all errors are passed to.
		/// </para>
		/// </remarks>
		public IErrorHandler ErrorHandler
		{
			get { return m_errorHandler; }
			set
			{
				if (value == null)
				{
					// This is a programming error on the part of the enclosing appender.
					throw new ArgumentNullException("value");
				}
				m_errorHandler = value;
			}
		}	

		/// <summary>
		/// Gets a value indicating whether this writer is closed.
		/// </summary>
		/// <value>
		/// <c>true</c> if this writer is closed, otherwise <c>false</c>.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets a value indicating whether this writer is closed.
		/// </para>
		/// </remarks>
		public bool Closed
		{
			get { return m_closed; }
		}

		#endregion Public Instance Properties

		#region Override Implementation of TextWriter

		/// <summary>
		/// Writes a character to the underlying writer
		/// </summary>
		/// <param name="value">the char to write</param>
		/// <remarks>
		/// <para>
		/// Writes a character to the underlying writer
		/// </para>
		/// </remarks>
		public override void Write(char value) 
		{
			try 
			{
				base.Write(value);
			} 
			catch(Exception e) 
			{
				m_errorHandler.Error("Failed to write [" + value + "].", e, ErrorCode.WriteFailure);
			}
		}
    
		/// <summary>
		/// Writes a buffer to the underlying writer
		/// </summary>
		/// <param name="buffer">the buffer to write</param>
		/// <param name="index">the start index to write from</param>
		/// <param name="count">the number of characters to write</param>
		/// <remarks>
		/// <para>
		/// Writes a buffer to the underlying writer
		/// </para>
		/// </remarks>
		public override void Write(char[] buffer, int index, int count) 
		{
			try 
			{
				base.Write(buffer, index, count);
			} 
			catch(Exception e) 
			{
				m_errorHandler.Error("Failed to write buffer.", e, ErrorCode.WriteFailure);
			}
		}
    
		/// <summary>
		/// Writes a string to the output.
		/// </summary>
		/// <param name="value">The string data to write to the output.</param>
		/// <remarks>
		/// <para>
		/// Writes a string to the output.
		/// </para>
		/// </remarks>
		override public void Write(string value) 
		{
			try 
			{
				base.Write(value);
			} 
			catch(Exception e) 
			{
				m_errorHandler.Error("Failed to write [" + value + "].", e, ErrorCode.WriteFailure);
			}
		}

		/// <summary>
		/// Closes the underlying output writer.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Closes the underlying output writer.
		/// </para>
		/// </remarks>
		override public void Close()
		{
			m_closed = true;
			base.Close();
		}

		#endregion Public Instance Methods

		#region Private Instance Fields

		/// <summary>
		/// The error handler instance to pass all errors to
		/// </summary>
		private IErrorHandler m_errorHandler;

		/// <summary>
		/// Flag to indicate if this writer is closed
		/// </summary>
		private bool m_closed = false;]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Close">
          <declaration><![CDATA[public override void Close()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="184" sc="3" el="187" ec="4">log4net\Util\QuietTextWriter.cs</location>
            <body hash="7a0b40ab2a3044552930a4721103ee15"><![CDATA[{
			m_closed = true;
			base.Close();
		}]]></body>
          </codeblock>
        </method>
        <method name="Write">
          <declaration><![CDATA[public override void Write(char value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="120" sc="3" el="129" ec="4">log4net\Util\QuietTextWriter.cs</location>
            <body hash="15dc74a6173aa03a7582d78bf5cd51d8"><![CDATA[{
			try 
			{
				base.Write(value);
			} 
			catch(Exception e) 
			{
				m_errorHandler.Error("Failed to write [" + value + "].", e, ErrorCode.WriteFailure);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Write">
          <declaration><![CDATA[public override void Write(char[] buffer, int index, int count)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="143" sc="3" el="152" ec="4">log4net\Util\QuietTextWriter.cs</location>
            <body hash="8998287ea33b65beed36b847c85cbf81"><![CDATA[{
			try 
			{
				base.Write(buffer, index, count);
			} 
			catch(Exception e) 
			{
				m_errorHandler.Error("Failed to write buffer.", e, ErrorCode.WriteFailure);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Write">
          <declaration><![CDATA[public override void Write(string value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="164" sc="3" el="173" ec="4">log4net\Util\QuietTextWriter.cs</location>
            <body hash="15dc74a6173aa03a7582d78bf5cd51d8"><![CDATA[{
			try 
			{
				base.Write(value);
			} 
			catch(Exception e) 
			{
				m_errorHandler.Error("Failed to write [" + value + "].", e, ErrorCode.WriteFailure);
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_closed">
          <declaration><![CDATA[private bool m_closed = false;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_errorHandler">
          <declaration><![CDATA[private IErrorHandler m_errorHandler;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Closed">
          <declaration><![CDATA[public bool Closed]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="ErrorHandler">
          <declaration><![CDATA[public IErrorHandler ErrorHandler]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="80" sc="4" el="87" ec="5">log4net\Util\QuietTextWriter.cs</location>
            <body hash="8c96e955d5da41547f6a1b1df873057e"><![CDATA[{
				if (value == null)
				{
					// This is a programming error on the part of the enclosing appender.
					throw new ArgumentNullException("value");
				}
				m_errorHandler = value;
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ReaderWriterLock">
      <declaration><![CDATA[public sealed class ReaderWriterLock]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ReaderWriterLock()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="62" sc="3" el="72" ec="4">log4net\Util\ReaderWriterLock.cs</location>
            <body hash="2a9ff34b283dbb609f5b2cc5f3868b82"><![CDATA[public ReaderWriterLock()
		{

#if HAS_READERWRITERLOCK
#if HAS_READERWRITERLOCKSLIM
			m_lock = new System.Threading.ReaderWriterLockSlim(System.Threading.LockRecursionPolicy.SupportsRecursion);
#else
			m_lock = new System.Threading.ReaderWriterLock();
#endif
#endif
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AcquireReaderLock">
          <declaration><![CDATA[public void AcquireReaderLock()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="88" sc="3" el="103" ec="4">log4net\Util\ReaderWriterLock.cs</location>
            <body hash="f99c6e4f37d86a8293a56ce2ff63515d"><![CDATA[{
#if HAS_READERWRITERLOCK
#if HAS_READERWRITERLOCKSLIM
                    // prevent ThreadAbort while updating state, see https://issues.apache.org/jira/browse/LOG4NET-443
                    try { } 
                    finally
                    {
			m_lock.EnterReadLock();
                    }
#else
			m_lock.AcquireReaderLock(-1);
#endif
#else
			System.Threading.Monitor.Enter(this);
#endif
		}]]></body>
          </codeblock>
        </method>
        <method name="AcquireWriterLock">
          <declaration><![CDATA[public void AcquireWriterLock()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="137" sc="3" el="152" ec="4">log4net\Util\ReaderWriterLock.cs</location>
            <body hash="9f86a3c8f7d227e326f4c84f6bd412d6"><![CDATA[{
#if HAS_READERWRITERLOCK
#if HAS_READERWRITERLOCKSLIM
                    // prevent ThreadAbort while updating state, see https://issues.apache.org/jira/browse/LOG4NET-443
                    try { } 
                    finally
                    {
			m_lock.EnterWriteLock();
                    }
#else
			m_lock.AcquireWriterLock(-1);
#endif
#else
			System.Threading.Monitor.Enter(this);
#endif
		}]]></body>
          </codeblock>
        </method>
        <method name="ReleaseReaderLock">
          <declaration><![CDATA[public void ReleaseReaderLock()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="115" sc="3" el="126" ec="4">log4net\Util\ReaderWriterLock.cs</location>
            <body hash="a90473c0dd383bdcb590c89a10ad8103"><![CDATA[{
#if HAS_READERWRITERLOCK
#if HAS_READERWRITERLOCKSLIM
			m_lock.ExitReadLock();
#else
			m_lock.ReleaseReaderLock();

#endif
#else
			System.Threading.Monitor.Exit(this);
#endif
		}]]></body>
          </codeblock>
        </method>
        <method name="ReleaseWriterLock">
          <declaration><![CDATA[public void ReleaseWriterLock()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="164" sc="3" el="174" ec="4">log4net\Util\ReaderWriterLock.cs</location>
            <body hash="0f2b6f4a1f5a919af768b8ac5ccfd09c"><![CDATA[{
#if HAS_READERWRITERLOCK
#if HAS_READERWRITERLOCKSLIM
			m_lock.ExitWriteLock();
#else
			m_lock.ReleaseWriterLock();
#endif
#else
			System.Threading.Monitor.Exit(this);
#endif
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_lock">
          <declaration><![CDATA[private ReaderWriterLockSlim m_lock;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="ReadOnlyPropertiesDictionary">
      <declaration><![CDATA[public class ReadOnlyPropertiesDictionary : ISerializable, IDictionary, ICollection, IEnumerable]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private readonly Hashtable m_hashtable = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="56" sc="3" el="72" ec="4">log4net\Util\ReadOnlyPropertiesDictionary.cs</location>
            <body hash="8f8c5c4fdffc04785b9159f9644fd893"><![CDATA[private readonly Hashtable m_hashtable = new Hashtable();

		#endregion Private Instance Fields

		#region Public Instance Constructors

		/// <summary>
		/// Constructor
		/// </summary>
		/// <remarks>
		/// <para>
		/// Initializes a new instance of the <see cref="ReadOnlyPropertiesDictionary" /> class.
		/// </para>
		/// </remarks>
		public ReadOnlyPropertiesDictionary()
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private readonly Hashtable m_hashtable = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="56" sc="3" el="89" ec="4">log4net\Util\ReadOnlyPropertiesDictionary.cs</location>
            <body hash="e94e3a91daa0cd46051fd1ef004fb8a9"><![CDATA[private readonly Hashtable m_hashtable = new Hashtable();

		#endregion Private Instance Fields

		#region Public Instance Constructors

		/// <summary>
		/// Constructor
		/// </summary>
		/// <remarks>
		/// <para>
		/// Initializes a new instance of the <see cref="ReadOnlyPropertiesDictionary" /> class.
		/// </para>
		/// </remarks>
		public ReadOnlyPropertiesDictionary()
		{
		}

		/// <summary>
		/// Copy Constructor
		/// </summary>
		/// <param name="propertiesDictionary">properties to copy</param>
		/// <remarks>
		/// <para>
		/// Initializes a new instance of the <see cref="ReadOnlyPropertiesDictionary" /> class.
		/// </para>
		/// </remarks>
		public ReadOnlyPropertiesDictionary(ReadOnlyPropertiesDictionary propertiesDictionary)
		{
			foreach(DictionaryEntry entry in propertiesDictionary)
			{
				InnerHashtable.Add(entry.Key, entry.Value);
			}
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private readonly Hashtable m_hashtable = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="56" sc="3" el="114" ec="4">log4net\Util\ReadOnlyPropertiesDictionary.cs</location>
            <body hash="15cea04feacc6e829257ecd780709eb9"><![CDATA[private readonly Hashtable m_hashtable = new Hashtable();

		#endregion Private Instance Fields

		#region Public Instance Constructors

		/// <summary>
		/// Constructor
		/// </summary>
		/// <remarks>
		/// <para>
		/// Initializes a new instance of the <see cref="ReadOnlyPropertiesDictionary" /> class.
		/// </para>
		/// </remarks>
		public ReadOnlyPropertiesDictionary()
		{
		}

		/// <summary>
		/// Copy Constructor
		/// </summary>
		/// <param name="propertiesDictionary">properties to copy</param>
		/// <remarks>
		/// <para>
		/// Initializes a new instance of the <see cref="ReadOnlyPropertiesDictionary" /> class.
		/// </para>
		/// </remarks>
		public ReadOnlyPropertiesDictionary(ReadOnlyPropertiesDictionary propertiesDictionary)
		{
			foreach(DictionaryEntry entry in propertiesDictionary)
			{
				InnerHashtable.Add(entry.Key, entry.Value);
			}
		}

		#endregion Public Instance Constructors

		#region Private Instance Constructors

#if !(NETCF || NETSTANDARD1_3)
		/// <summary>
		/// Deserialization constructor
		/// </summary>
		/// <param name="info">The <see cref="SerializationInfo" /> that holds the serialized object data.</param>
		/// <param name="context">The <see cref="StreamingContext" /> that contains contextual information about the source or destination.</param>
		/// <remarks>
		/// <para>
		/// Initializes a new instance of the <see cref="ReadOnlyPropertiesDictionary" /> class 
		/// with serialized data.
		/// </para>
		/// </remarks>
		protected ReadOnlyPropertiesDictionary(SerializationInfo info, StreamingContext context)
		{
			foreach(SerializationEntry entry in info)
			{
				// The keys are stored as Xml encoded names
				InnerHashtable[XmlConvert.DecodeName(entry.Name)] = entry.Value;
			}
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Clear">
          <declaration><![CDATA[public virtual void Clear()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="272" sc="3" el="273" ec="94">log4net\Util\ReadOnlyPropertiesDictionary.cs</location>
            <body hash="5a8798b78623c5676d2a240e2da0d7f1"><![CDATA[{
			throw new NotSupportedException("This is a Read Only Dictionary and can not be modified");]]></body>
          </codeblock>
        </method>
        <method name="Contains">
          <declaration><![CDATA[public bool Contains(string key)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="172" sc="3" el="174" ec="4">log4net\Util\ReadOnlyPropertiesDictionary.cs</location>
            <body hash="d0c940cabd0dfbfa722fd0b9d9797f4b"><![CDATA[{
			return InnerHashtable.Contains(key);
		}]]></body>
          </codeblock>
        </method>
        <method name="GetKeys">
          <declaration><![CDATA[public string[] GetKeys()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="131" sc="3" el="135" ec="4">log4net\Util\ReadOnlyPropertiesDictionary.cs</location>
            <body hash="9e8edff77aee195c617e6b0841745f27"><![CDATA[{
			string[] keys = new String[InnerHashtable.Count];
			InnerHashtable.Keys.CopyTo(keys, 0);
			return keys;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetObjectData">
          <declaration><![CDATA[public virtual void GetObjectData(SerializationInfo info, StreamingContext context)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="213" sc="3" el="234" ec="4">log4net\Util\ReadOnlyPropertiesDictionary.cs</location>
            <body hash="f9b1c977a70689dd138a7b61a4acc3b3"><![CDATA[{
			foreach(DictionaryEntry entry in InnerHashtable.Clone() as IDictionary)
			{
				string entryKey = entry.Key as string;
				object entryValue = entry.Value;

                // If value is serializable then we add it to the list
#if NETSTANDARD1_3
                bool isSerializable = entryValue.GetType().GetTypeInfo().IsSerializable;
#else
                bool isSerializable = entryValue.GetType().IsSerializable;
#endif
				if (entryKey != null && entryValue != null && isSerializable)
				{
					// Store the keys as an Xml encoded local name as it may contain colons (':') 
					// which are NOT escaped by the Xml Serialization framework.
					// This must be a bug in the serialization framework as we cannot be expected
					// to know the implementation details of all the possible transport layers.
					info.AddValue(XmlConvert.EncodeLocalName(entryKey), entryValue);
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.ICollection.CopyTo">
          <declaration><![CDATA[void ICollection.CopyTo(Array array, int index)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="344" sc="3" el="346" ec="4">log4net\Util\ReadOnlyPropertiesDictionary.cs</location>
            <body hash="e855593aec3a22462da1dde2c98a342e"><![CDATA[{
			InnerHashtable.CopyTo(array, index);
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IDictionary.Add">
          <declaration><![CDATA[void IDictionary.Add(object key, object value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="282" sc="3" el="283" ec="94">log4net\Util\ReadOnlyPropertiesDictionary.cs</location>
            <body hash="5a8798b78623c5676d2a240e2da0d7f1"><![CDATA[{
			throw new NotSupportedException("This is a Read Only Dictionary and can not be modified");]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IDictionary.Contains">
          <declaration><![CDATA[bool IDictionary.Contains(object key)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="264" sc="3" el="266" ec="4">log4net\Util\ReadOnlyPropertiesDictionary.cs</location>
            <body hash="d0c940cabd0dfbfa722fd0b9d9797f4b"><![CDATA[{
			return InnerHashtable.Contains(key);
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IDictionary.GetEnumerator">
          <declaration><![CDATA[IDictionaryEnumerator IDictionary.GetEnumerator()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="245" sc="3" el="247" ec="4">log4net\Util\ReadOnlyPropertiesDictionary.cs</location>
            <body hash="0bda076c264e54d688e381a289ce5520"><![CDATA[{
			return InnerHashtable.GetEnumerator();
		}]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IDictionary.Remove">
          <declaration><![CDATA[void IDictionary.Remove(object key)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="254" sc="3" el="255" ec="94">log4net\Util\ReadOnlyPropertiesDictionary.cs</location>
            <body hash="5a8798b78623c5676d2a240e2da0d7f1"><![CDATA[{
			throw new NotSupportedException("This is a Read Only Dictionary and can not be modified");]]></body>
          </codeblock>
        </method>
        <method name="System.Collections.IEnumerable.GetEnumerator">
          <declaration><![CDATA[IEnumerator IEnumerable.GetEnumerator()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="380" sc="3" el="382" ec="4">log4net\Util\ReadOnlyPropertiesDictionary.cs</location>
            <body hash="d6d09af5e0957f43da80cd87bedbb957"><![CDATA[{
			return ((IEnumerable)InnerHashtable).GetEnumerator();
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_hashtable">
          <declaration><![CDATA[private readonly Hashtable m_hashtable = new Hashtable();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Count">
          <declaration><![CDATA[public int Count]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="InnerHashtable">
          <declaration><![CDATA[protected Hashtable InnerHashtable]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Item">
          <declaration><![CDATA[public virtual object this[string key]]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="System.Collections.ICollection.IsSynchronized">
          <declaration><![CDATA[bool ICollection.IsSynchronized]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="System.Collections.ICollection.SyncRoot">
          <declaration><![CDATA[object ICollection.SyncRoot]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="System.Collections.IDictionary.IsFixedSize">
          <declaration><![CDATA[bool IDictionary.IsFixedSize]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="System.Collections.IDictionary.IsReadOnly">
          <declaration><![CDATA[bool IDictionary.IsReadOnly]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="System.Collections.IDictionary.Item">
          <declaration><![CDATA[object IDictionary.this[object key]]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="300" sc="4" el="303" ec="5">log4net\Util\ReadOnlyPropertiesDictionary.cs</location>
            <body hash="8bbe72e3fe0ef03c528e1fd6a2726faa"><![CDATA[{
				if (!(key is string)) throw new ArgumentException("key must be a string");
				return InnerHashtable[key];
			}]]></body>
          </codeblock>
          <codeblock>
            <location sl="305" sc="4" el="306" ec="95">log4net\Util\ReadOnlyPropertiesDictionary.cs</location>
            <body hash="6e3725e0d5aec0f1350a3960df4642f6"><![CDATA[{
				throw new NotSupportedException("This is a Read Only Dictionary and can not be modified");]]></body>
          </codeblock>
        </property>
        <property name="System.Collections.IDictionary.Keys">
          <declaration><![CDATA[ICollection IDictionary.Keys]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="System.Collections.IDictionary.Values">
          <declaration><![CDATA[ICollection IDictionary.Values]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ReusableStringWriter">
      <declaration><![CDATA[public class ReusableStringWriter : StringWriter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ReusableStringWriter(IFormatProvider formatProvider) : base(formatProvider)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="49" sc="65" el="51" ec="4">log4net\Util\ReusableStringWriter.cs</location>
            <body hash="2778f703b1679d4d41839da306272018"><![CDATA[base(formatProvider) 
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Dispose">
          <declaration><![CDATA[protected override void Dispose(bool disposing)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="65" sc="3" el="67" ec="4">log4net\Util\ReusableStringWriter.cs</location>
            <body hash="ae45c81abb9d76d980cae4aeb6bcbc87"><![CDATA[{
			// Do not close the writer
		}]]></body>
          </codeblock>
        </method>
        <method name="Reset">
          <declaration><![CDATA[public void Reset(int maxCapacity, int defaultSize)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="81" sc="3" el="92" ec="4">log4net\Util\ReusableStringWriter.cs</location>
            <body hash="9be0fc23ae38694743b52f35d14c05e7"><![CDATA[{
			// Reset working string buffer
			StringBuilder sb = this.GetStringBuilder();

			sb.Length = 0;
			
			// Check if over max size
			if (sb.Capacity > maxCapacity) 
			{
				sb.Capacity = defaultSize;
			} 
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="SystemInfo">
      <declaration><![CDATA[public sealed class SystemInfo]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private SystemInfo()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="64" sc="3" el="66" ec="4">log4net\Util\SystemInfo.cs</location>
            <body hash="4eec13d801dd72912b0cc775b9144342"><![CDATA[private SystemInfo() 
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static SystemInfo()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="81" sc="3" el="1203" ec="67">log4net\Util\SystemInfo.cs</location>
            <body hash="08856a760a43908486786ba00f000b6a"><![CDATA[{
			string nullText = DEFAULT_NULL_TEXT;
			string notAvailableText = DEFAULT_NOT_AVAILABLE_TEXT;

#if !NETCF
			// Look for log4net.NullText in AppSettings
			string nullTextAppSettingsKey = SystemInfo.GetAppSetting("log4net.NullText");
			if (nullTextAppSettingsKey != null && nullTextAppSettingsKey.Length > 0)
			{
				LogLog.Debug(declaringType, "Initializing NullText value to [" + nullTextAppSettingsKey + "].");
				nullText = nullTextAppSettingsKey;
			}

			// Look for log4net.NotAvailableText in AppSettings
			string notAvailableTextAppSettingsKey = SystemInfo.GetAppSetting("log4net.NotAvailableText");
			if (notAvailableTextAppSettingsKey != null && notAvailableTextAppSettingsKey.Length > 0)
			{
				LogLog.Debug(declaringType, "Initializing NotAvailableText value to [" + notAvailableTextAppSettingsKey + "].");
				notAvailableText = notAvailableTextAppSettingsKey;
			}
#endif
			s_notAvailableText = notAvailableText;
			s_nullText = nullText;
		}

		#endregion

		#region Public Static Properties

		/// <summary>
		/// Gets the system dependent line terminator.
		/// </summary>
		/// <value>
		/// The system dependent line terminator.
		/// </value>
		/// <remarks>
		/// <para>
		/// Gets the system dependent line terminator.
		/// </para>
		/// </remarks>
		public static string NewLine
		{
			get
			{
#if NETCF
				return "\r\n";
#else
				return System.Environment.NewLine;
#endif
			}
		}

		/// <summary>
		/// Gets the base directory for this <see cref="AppDomain"/>.
		/// </summary>
		/// <value>The base directory path for the current <see cref="AppDomain"/>.</value>
		/// <remarks>
		/// <para>
		/// Gets the base directory for this <see cref="AppDomain"/>.
		/// </para>
		/// <para>
		/// The value returned may be either a local file path or a URI.
		/// </para>
		/// </remarks>
		public static string ApplicationBaseDirectory
		{
			get 
			{
#if NETCF
-				return System.IO.Path.GetDirectoryName(SystemInfo.EntryAssemblyLocation) + System.IO.Path.DirectorySeparatorChar;
#elif NETSTANDARD1_3
				return Directory.GetCurrentDirectory();
#else
				return AppDomain.CurrentDomain.BaseDirectory;
#endif
			}
		}

		/// <summary>
		/// Gets the path to the configuration file for the current <see cref="AppDomain"/>.
		/// </summary>
		/// <value>The path to the configuration file for the current <see cref="AppDomain"/>.</value>
		/// <remarks>
		/// <para>
		/// The .NET Compact Framework 1.0 does not have a concept of a configuration
		/// file. For this runtime, we use the entry assembly location as the root for
		/// the configuration file name.
		/// </para>
		/// <para>
		/// The value returned may be either a local file path or a URI.
		/// </para>
		/// </remarks>
		public static string ConfigurationFileLocation
		{
			get 
			{
#if NETCF || NETSTANDARD1_3
				return SystemInfo.EntryAssemblyLocation+".config";
#else
				return System.AppDomain.CurrentDomain.SetupInformation.ConfigurationFile;
#endif
			}
		}

		/// <summary>
		/// Gets the path to the file that first executed in the current <see cref="AppDomain"/>.
		/// </summary>
		/// <value>The path to the entry assembly.</value>
		/// <remarks>
		/// <para>
		/// Gets the path to the file that first executed in the current <see cref="AppDomain"/>.
		/// </para>
		/// </remarks>
		public static string EntryAssemblyLocation
		{
			get 
			{
#if NETCF
				return SystemInfo.NativeEntryAssemblyLocation;
#elif NETSTANDARD1_3 // TODO GetEntryAssembly is available for netstandard1.5
				return AppContext.BaseDirectory;
#else
				return System.Reflection.Assembly.GetEntryAssembly().Location;
#endif
			}
		}

		/// <summary>
		/// Gets the ID of the current thread.
		/// </summary>
		/// <value>The ID of the current thread.</value>
		/// <remarks>
		/// <para>
		/// On the .NET framework, the <c>AppDomain.GetCurrentThreadId</c> method
		/// is used to obtain the thread ID for the current thread. This is the 
		/// operating system ID for the thread.
		/// </para>
		/// <para>
		/// On the .NET Compact Framework 1.0 it is not possible to get the 
		/// operating system thread ID for the current thread. The native method 
		/// <c>GetCurrentThreadId</c> is implemented inline in a header file
		/// and cannot be called.
		/// </para>
		/// <para>
		/// On the .NET Framework 2.0 the <c>Thread.ManagedThreadId</c> is used as this
		/// gives a stable id unrelated to the operating system thread ID which may 
		/// change if the runtime is using fibers.
		/// </para>
		/// </remarks>
		public static int CurrentThreadId
		{
			get 
			{
#if NETCF_1_0
				return System.Threading.Thread.CurrentThread.GetHashCode();
#elif NET_2_0 || NETCF_2_0 || MONO_2_0 || MONO_3_5 || MONO_4_0 || NETSTANDARD1_3
				return System.Threading.Thread.CurrentThread.ManagedThreadId;
#else
				return AppDomain.GetCurrentThreadId();
#endif
			}
		}

		/// <summary>
		/// Get the host name or machine name for the current machine
		/// </summary>
		/// <value>
		/// The hostname or machine name
		/// </value>
		/// <remarks>
		/// <para>
		/// Get the host name or machine name for the current machine
		/// </para>
		/// <para>
		/// The host name (<see cref="System.Net.Dns.GetHostName"/>) or
		/// the machine name (<c>Environment.MachineName</c>) for
		/// the current machine, or if neither of these are available
		/// then <c>NOT AVAILABLE</c> is returned.
		/// </para>
		/// </remarks>
		public static string HostName
		{
			get
			{
				if (s_hostName == null)
				{

					// Get the DNS host name of the current machine
					try
					{
						// Lookup the host name
						s_hostName = System.Net.Dns.GetHostName();
					}
					catch (System.Net.Sockets.SocketException)
					{
						LogLog.Debug(declaringType, "Socket exception occurred while getting the dns hostname. Error Ignored.");
					}
					catch (System.Security.SecurityException)
					{
						// We may get a security exception looking up the hostname
						// You must have Unrestricted DnsPermission to access resource
						LogLog.Debug(declaringType, "Security exception occurred while getting the dns hostname. Error Ignored.");
					}
					catch (Exception ex)
					{
						LogLog.Debug(declaringType, "Some other exception occurred while getting the dns hostname. Error Ignored.", ex);
					}

					// Get the NETBIOS machine name of the current machine
					if (s_hostName == null || s_hostName.Length == 0)
					{
						try
						{
#if NETSTANDARD1_3
							s_hostName = Environment.GetEnvironmentVariable("COMPUTERNAME");
#elif (!SSCLI && !NETCF)
							s_hostName = Environment.MachineName;
#endif
						}
						catch(InvalidOperationException)
						{
						}
						catch(System.Security.SecurityException)
						{
							// We may get a security exception looking up the machine name
							// You must have Unrestricted EnvironmentPermission to access resource
						}
					}

					// Couldn't find a value
					if (s_hostName == null || s_hostName.Length == 0)
					{
						s_hostName = s_notAvailableText;
						LogLog.Debug(declaringType, "Could not determine the hostname. Error Ignored. Empty host name will be used");
					}
				}
				return s_hostName;
			}
		}

		/// <summary>
		/// Get this application's friendly name
		/// </summary>
		/// <value>
		/// The friendly name of this application as a string
		/// </value>
		/// <remarks>
		/// <para>
		/// If available the name of the application is retrieved from
		/// the <c>AppDomain</c> using <c>AppDomain.CurrentDomain.FriendlyName</c>.
		/// </para>
		/// <para>
		/// Otherwise the file name of the entry assembly is used.
		/// </para>
		/// </remarks>
		public static string ApplicationFriendlyName
		{
			get
			{
				if (s_appFriendlyName == null)
				{
					try
					{
#if !(NETCF || NETSTANDARD1_3)
						s_appFriendlyName = AppDomain.CurrentDomain.FriendlyName;
#endif
					}
					catch(System.Security.SecurityException)
					{
						// This security exception will occur if the caller does not have 
						// some undefined set of SecurityPermission flags.
						LogLog.Debug(declaringType, "Security exception while trying to get current domain friendly name. Error Ignored.");
					}

					if (s_appFriendlyName == null || s_appFriendlyName.Length == 0)
					{
						try
						{
							string assemblyLocation = SystemInfo.EntryAssemblyLocation;
							s_appFriendlyName = System.IO.Path.GetFileName(assemblyLocation);
						}
						catch(System.Security.SecurityException)
						{
							// Caller needs path discovery permission
						}
					}

					if (s_appFriendlyName == null || s_appFriendlyName.Length == 0)
					{
						s_appFriendlyName = s_notAvailableText;
					}
				}
				return s_appFriendlyName;
			}
		}

		/// <summary>
		/// Get the start time for the current process.
		/// </summary>
		/// <remarks>
		/// <para>
		/// This is the time at which the log4net library was loaded into the
		/// AppDomain. Due to reports of a hang in the call to <c>System.Diagnostics.Process.StartTime</c>
		/// this is not the start time for the current process.
		/// </para>
		/// <para>
		/// The log4net library should be loaded by an application early during its
		/// startup, therefore this start time should be a good approximation for
		/// the actual start time.
		/// </para>
		/// <para>
		/// Note that AppDomains may be loaded and unloaded within the
		/// same process without the process terminating, however this start time
		/// will be set per AppDomain.
		/// </para>
		/// </remarks>
        [Obsolete("Use ProcessStartTimeUtc and convert to local time if needed.")]
		public static DateTime ProcessStartTime
		{
			get { return s_processStartTimeUtc.ToLocalTime(); }
		}

        /// <summary>
        /// Get the UTC start time for the current process.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This is the UTC time at which the log4net library was loaded into the
        /// AppDomain. Due to reports of a hang in the call to <c>System.Diagnostics.Process.StartTime</c>
        /// this is not the start time for the current process.
        /// </para>
        /// <para>
        /// The log4net library should be loaded by an application early during its
        /// startup, therefore this start time should be a good approximation for
        /// the actual start time.
        /// </para>
        /// <para>
        /// Note that AppDomains may be loaded and unloaded within the
        /// same process without the process terminating, however this start time
        /// will be set per AppDomain.
        /// </para>
        /// </remarks>
        public static DateTime ProcessStartTimeUtc
        {
            get { return s_processStartTimeUtc; }
		}

		/// <summary>
		/// Text to output when a <c>null</c> is encountered.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Use this value to indicate a <c>null</c> has been encountered while
		/// outputting a string representation of an item.
		/// </para>
		/// <para>
		/// The default value is <c>(null)</c>. This value can be overridden by specifying
		/// a value for the <c>log4net.NullText</c> appSetting in the application's
		/// .config file.
		/// </para>
		/// </remarks>
		public static string NullText
		{
			get { return s_nullText; }
			set { s_nullText = value; }
		}

		/// <summary>
		/// Text to output when an unsupported feature is requested.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Use this value when an unsupported feature is requested.
		/// </para>
		/// <para>
		/// The default value is <c>NOT AVAILABLE</c>. This value can be overridden by specifying
		/// a value for the <c>log4net.NotAvailableText</c> appSetting in the application's
		/// .config file.
		/// </para>
		/// </remarks>
		public static string NotAvailableText
		{
			get { return s_notAvailableText; }
			set { s_notAvailableText = value; }
		}

		#endregion Public Static Properties

		#region Public Static Methods

		/// <summary>
		/// Gets the assembly location path for the specified assembly.
		/// </summary>
		/// <param name="myAssembly">The assembly to get the location for.</param>
		/// <returns>The location of the assembly.</returns>
		/// <remarks>
		/// <para>
		/// This method does not guarantee to return the correct path
		/// to the assembly. If only tries to give an indication as to
		/// where the assembly was loaded from.
		/// </para>
		/// </remarks>
		public static string AssemblyLocationInfo(Assembly myAssembly)
		{
#if NETCF
			return "Not supported on Microsoft .NET Compact Framework";
#elif NETSTANDARD1_3  // TODO Assembly.Location available in netstandard1.5
            return "Not supported on .NET Core";
#else
			if (myAssembly.GlobalAssemblyCache)
			{
				return "Global Assembly Cache";
			}
			else
			{
				try
				{
#if NET_4_0 || MONO_4_0
					if (myAssembly.IsDynamic)
					{
						return "Dynamic Assembly";
					}
#else
					if (myAssembly is System.Reflection.Emit.AssemblyBuilder)
					{
						return "Dynamic Assembly";
					}
					else if(myAssembly.GetType().FullName == "System.Reflection.Emit.InternalAssemblyBuilder")
					{
						return "Dynamic Assembly";
					}
#endif
					else
					{
						// This call requires FileIOPermission for access to the path
						// if we don't have permission then we just ignore it and
						// carry on.
						return myAssembly.Location;
					}
				}
				catch (NotSupportedException)
				{
					// The location information may be unavailable for dynamic assemblies and a NotSupportedException
					// is thrown in those cases. See: http://msdn.microsoft.com/de-de/library/system.reflection.assembly.location.aspx
					return "Dynamic Assembly";
				}
				catch (TargetInvocationException ex)
				{
					return "Location Detect Failed (" + ex.Message + ")";
				}
				catch (ArgumentException ex)
				{
					return "Location Detect Failed (" + ex.Message + ")";
				}
				catch (System.Security.SecurityException)
				{
					return "Location Permission Denied";
				}
			}
#endif
		}

		/// <summary>
		/// Gets the fully qualified name of the <see cref="Type" />, including 
		/// the name of the assembly from which the <see cref="Type" /> was 
		/// loaded.
		/// </summary>
		/// <param name="type">The <see cref="Type" /> to get the fully qualified name for.</param>
		/// <returns>The fully qualified name for the <see cref="Type" />.</returns>
		/// <remarks>
		/// <para>
		/// This is equivalent to the <c>Type.AssemblyQualifiedName</c> property,
		/// but this method works on the .NET Compact Framework 1.0 as well as
		/// the full .NET runtime.
		/// </para>
		/// </remarks>
		public static string AssemblyQualifiedName(Type type)
		{
			return type.FullName + ", "
#if NETSTANDARD1_3
				+ type.GetTypeInfo().Assembly.FullName;
#else
				+ type.Assembly.FullName;
#endif
		}

		/// <summary>
		/// Gets the short name of the <see cref="Assembly" />.
		/// </summary>
		/// <param name="myAssembly">The <see cref="Assembly" /> to get the name for.</param>
		/// <returns>The short name of the <see cref="Assembly" />.</returns>
		/// <remarks>
		/// <para>
		/// The short name of the assembly is the <see cref="Assembly.FullName" /> 
		/// without the version, culture, or public key. i.e. it is just the 
		/// assembly's file name without the extension.
		/// </para>
		/// <para>
		/// Use this rather than <c>Assembly.GetName().Name</c> because that
		/// is not available on the Compact Framework.
		/// </para>
		/// <para>
		/// Because of a FileIOPermission security demand we cannot do
		/// the obvious Assembly.GetName().Name. We are allowed to get
		/// the <see cref="Assembly.FullName" /> of the assembly so we 
		/// start from there and strip out just the assembly name.
		/// </para>
		/// </remarks>
		public static string AssemblyShortName(Assembly myAssembly)
		{
			string name = myAssembly.FullName;
			int offset = name.IndexOf(',');
			if (offset > 0)
			{
				name = name.Substring(0, offset);
			}
			return name.Trim();

			// TODO: Do we need to unescape the assembly name string? 
			// Doc says '\' is an escape char but has this already been 
			// done by the string loader?
		}

		/// <summary>
		/// Gets the file name portion of the <see cref="Assembly" />, including the extension.
		/// </summary>
		/// <param name="myAssembly">The <see cref="Assembly" /> to get the file name for.</param>
		/// <returns>The file name of the assembly.</returns>
		/// <remarks>
		/// <para>
		/// Gets the file name portion of the <see cref="Assembly" />, including the extension.
		/// </para>
		/// </remarks>
		public static string AssemblyFileName(Assembly myAssembly)
		{
#if NETCF || NETSTANDARD1_3 // TODO Assembly.Location is in netstandard1.5 System.Reflection
			// This is not very good because it assumes that only
			// the entry assembly can be an EXE. In fact multiple
			// EXEs can be loaded in to a process.

			string assemblyShortName = SystemInfo.AssemblyShortName(myAssembly);
			string entryAssemblyShortName = System.IO.Path.GetFileNameWithoutExtension(SystemInfo.EntryAssemblyLocation);

			if (string.Compare(assemblyShortName, entryAssemblyShortName, true) == 0)
			{
				// assembly is entry assembly
				return assemblyShortName + ".exe";
			}
			else
			{
				// assembly is not entry assembly
				return assemblyShortName + ".dll";
			}
#else
			return System.IO.Path.GetFileName(myAssembly.Location);
#endif
		}

		/// <summary>
		/// Loads the type specified in the type string.
		/// </summary>
		/// <param name="relativeType">A sibling type to use to load the type.</param>
		/// <param name="typeName">The name of the type to load.</param>
		/// <param name="throwOnError">Flag set to <c>true</c> to throw an exception if the type cannot be loaded.</param>
		/// <param name="ignoreCase"><c>true</c> to ignore the case of the type name; otherwise, <c>false</c></param>
		/// <returns>The type loaded or <c>null</c> if it could not be loaded.</returns>
		/// <remarks>
		/// <para>
		/// If the type name is fully qualified, i.e. if contains an assembly name in 
		/// the type name, the type will be loaded from the system using 
		/// <see cref="M:Type.GetType(string,bool)"/>.
		/// </para>
		/// <para>
		/// If the type name is not fully qualified, it will be loaded from the assembly
		/// containing the specified relative type. If the type is not found in the assembly 
		/// then all the loaded assemblies will be searched for the type.
		/// </para>
		/// </remarks>
		public static Type GetTypeFromString(Type relativeType, string typeName, bool throwOnError, bool ignoreCase)
		{
#if NETSTANDARD1_3
			return GetTypeFromString(relativeType.GetTypeInfo().Assembly, typeName, throwOnError, ignoreCase);
#else
			return GetTypeFromString(relativeType.Assembly, typeName, throwOnError, ignoreCase);
#endif
		}

#if !NETSTANDARD1_3
		/// <summary>
		/// Loads the type specified in the type string.
		/// </summary>
		/// <param name="typeName">The name of the type to load.</param>
		/// <param name="throwOnError">Flag set to <c>true</c> to throw an exception if the type cannot be loaded.</param>
		/// <param name="ignoreCase"><c>true</c> to ignore the case of the type name; otherwise, <c>false</c></param>
		/// <returns>The type loaded or <c>null</c> if it could not be loaded.</returns>		
		/// <remarks>
		/// <para>
		/// If the type name is fully qualified, i.e. if contains an assembly name in 
		/// the type name, the type will be loaded from the system using 
		/// <see cref="M:Type.GetType(string,bool)"/>.
		/// </para>
		/// <para>
		/// If the type name is not fully qualified it will be loaded from the
		/// assembly that is directly calling this method. If the type is not found 
		/// in the assembly then all the loaded assemblies will be searched for the type.
		/// </para>
		/// </remarks>
		public static Type GetTypeFromString(string typeName, bool throwOnError, bool ignoreCase)
		{
			return GetTypeFromString(Assembly.GetCallingAssembly(), typeName, throwOnError, ignoreCase);
		}
#endif

		/// <summary>
		/// Loads the type specified in the type string.
		/// </summary>
		/// <param name="relativeAssembly">An assembly to load the type from.</param>
		/// <param name="typeName">The name of the type to load.</param>
		/// <param name="throwOnError">Flag set to <c>true</c> to throw an exception if the type cannot be loaded.</param>
		/// <param name="ignoreCase"><c>true</c> to ignore the case of the type name; otherwise, <c>false</c></param>
		/// <returns>The type loaded or <c>null</c> if it could not be loaded.</returns>
		/// <remarks>
		/// <para>
		/// If the type name is fully qualified, i.e. if contains an assembly name in 
		/// the type name, the type will be loaded from the system using 
		/// <see cref="M:Type.GetType(string,bool)"/>.
		/// </para>
		/// <para>
		/// If the type name is not fully qualified it will be loaded from the specified
		/// assembly. If the type is not found in the assembly then all the loaded assemblies 
		/// will be searched for the type.
		/// </para>
		/// </remarks>
		public static Type GetTypeFromString(Assembly relativeAssembly, string typeName, bool throwOnError, bool ignoreCase)
		{
			// Check if the type name specifies the assembly name
			if(typeName.IndexOf(',') == -1)
			{
				//LogLog.Debug(declaringType, "SystemInfo: Loading type ["+typeName+"] from assembly ["+relativeAssembly.FullName+"]");
#if NETSTANDARD1_3
				return relativeAssembly.GetType(typeName, throwOnError, ignoreCase);
#elif NETCF
				return relativeAssembly.GetType(typeName, throwOnError);
#else
				// Attempt to lookup the type from the relativeAssembly
				Type type = relativeAssembly.GetType(typeName, false, ignoreCase);
				if (type != null)
				{
					// Found type in relative assembly
					//LogLog.Debug(declaringType, "SystemInfo: Loaded type ["+typeName+"] from assembly ["+relativeAssembly.FullName+"]");
					return type;
				}

				Assembly[] loadedAssemblies = null;
				try
				{
					loadedAssemblies = AppDomain.CurrentDomain.GetAssemblies();
				}
				catch(System.Security.SecurityException)
				{
					// Insufficient permissions to get the list of loaded assemblies
				}

				if (loadedAssemblies != null)
				{
					Type fallback = null;
					// Search the loaded assemblies for the type
					foreach (Assembly assembly in loadedAssemblies) 
					{
						Type t = assembly.GetType(typeName, false, ignoreCase);
						if (t != null)
						{
							// Found type in loaded assembly
							LogLog.Debug(declaringType, "Loaded type ["+typeName+"] from assembly ["+assembly.FullName+"] by searching loaded assemblies.");
                                                        if (assembly.GlobalAssemblyCache)
                                                        {
                                                            fallback = t;
                                                        }
                                                        else
                                                        {
                                                            return t;
                                                        }
						}
					}
                                        if (fallback != null)
                                        {
                                            return fallback;
                                        }
				}

				// Didn't find the type
				if (throwOnError)
				{
					throw new TypeLoadException("Could not load type ["+typeName+"]. Tried assembly ["+relativeAssembly.FullName+"] and all loaded assemblies");
				}
				return null;
#endif
			}
			else
			{
				// Includes explicit assembly name
				//LogLog.Debug(declaringType, "SystemInfo: Loading type ["+typeName+"] from global Type");

#if NETCF
				// In NETCF 2 and 3 arg versions seem to behave differently
				// https://issues.apache.org/jira/browse/LOG4NET-113
				return Type.GetType(typeName, throwOnError);
#else
				return Type.GetType(typeName, throwOnError, ignoreCase);
#endif
			}
		}


		/// <summary>
		/// Generate a new guid
		/// </summary>
		/// <returns>A new Guid</returns>
		/// <remarks>
		/// <para>
		/// Generate a new guid
		/// </para>
		/// </remarks>
		public static Guid NewGuid()
		{
#if NETCF_1_0
			return PocketGuid.NewGuid();
#else
			return Guid.NewGuid();
#endif
		}

		/// <summary>
		/// Create an <see cref="ArgumentOutOfRangeException"/>
		/// </summary>
		/// <param name="parameterName">The name of the parameter that caused the exception</param>
		/// <param name="actualValue">The value of the argument that causes this exception</param>
		/// <param name="message">The message that describes the error</param>
		/// <returns>the ArgumentOutOfRangeException object</returns>
		/// <remarks>
		/// <para>
		/// Create a new instance of the <see cref="ArgumentOutOfRangeException"/> class 
		/// with a specified error message, the parameter name, and the value 
		/// of the argument.
		/// </para>
		/// <para>
		/// The Compact Framework does not support the 3 parameter constructor for the
		/// <see cref="ArgumentOutOfRangeException"/> type. This method provides an
		/// implementation that works for all platforms.
		/// </para>
		/// </remarks>
		public static ArgumentOutOfRangeException CreateArgumentOutOfRangeException(string parameterName, object actualValue, string message)
		{
#if NETCF_1_0
			return new ArgumentOutOfRangeException(message + " [param=" + parameterName + "] [value=" + actualValue + "]");
#elif NETCF_2_0
			return new ArgumentOutOfRangeException(parameterName, message + " [value=" + actualValue + "]");
#else
			return new ArgumentOutOfRangeException(parameterName, actualValue, message);
#endif
		}


		/// <summary>
		/// Parse a string into an <see cref="Int32"/> value
		/// </summary>
		/// <param name="s">the string to parse</param>
		/// <param name="val">out param where the parsed value is placed</param>
		/// <returns><c>true</c> if the string was able to be parsed into an integer</returns>
		/// <remarks>
		/// <para>
		/// Attempts to parse the string into an integer. If the string cannot
		/// be parsed then this method returns <c>false</c>. The method does not throw an exception.
		/// </para>
		/// </remarks>
		public static bool TryParse(string s, out int val)
		{
#if NETCF
			val = 0;
			try
			{
				val = int.Parse(s, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture);
				return true;
			}
			catch
			{
			}

			return false;
#else
			// Initialise out param
			val = 0;

			try
			{
				double doubleVal;
				if (Double.TryParse(s, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out doubleVal))
				{
					val = Convert.ToInt32(doubleVal);
					return true;
				}
			}
			catch
			{
				// Ignore exception, just return false
			}

			return false;
#endif
		}

		/// <summary>
		/// Parse a string into an <see cref="Int64"/> value
		/// </summary>
		/// <param name="s">the string to parse</param>
		/// <param name="val">out param where the parsed value is placed</param>
		/// <returns><c>true</c> if the string was able to be parsed into an integer</returns>
		/// <remarks>
		/// <para>
		/// Attempts to parse the string into an integer. If the string cannot
		/// be parsed then this method returns <c>false</c>. The method does not throw an exception.
		/// </para>
		/// </remarks>
		public static bool TryParse(string s, out long val)
		{
#if NETCF
			val = 0;
			try
			{
				val = long.Parse(s, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture);
				return true;
			}
			catch
			{
			}

			return false;
#else
			// Initialise out param
			val = 0;

			try
			{
				double doubleVal;
				if (Double.TryParse(s, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out doubleVal))
				{
					val = Convert.ToInt64(doubleVal);
					return true;
				}
			}
			catch
			{
				// Ignore exception, just return false
			}

			return false;
#endif
		}

        /// <summary>
        /// Parse a string into an <see cref="Int16"/> value
        /// </summary>
        /// <param name="s">the string to parse</param>
        /// <param name="val">out param where the parsed value is placed</param>
        /// <returns><c>true</c> if the string was able to be parsed into an integer</returns>
        /// <remarks>
        /// <para>
        /// Attempts to parse the string into an integer. If the string cannot
        /// be parsed then this method returns <c>false</c>. The method does not throw an exception.
        /// </para>
        /// </remarks>
        public static bool TryParse(string s, out short val)
        {
#if NETCF
			val = 0;
			try
			{
				val = short.Parse(s, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture);
				return true;
			}
			catch
			{
			}

			return false;
#else
            // Initialise out param
            val = 0;

            try 
            {
                double doubleVal;
                if (Double.TryParse(s, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out doubleVal))
                {
                    val = Convert.ToInt16(doubleVal);
                    return true;
                }
            }
            catch
            {
                // Ignore exception, just return false
            }

            return false;
#endif
        }

        /// <summary>
		/// Lookup an application setting
		/// </summary>
		/// <param name="key">the application settings key to lookup</param>
		/// <returns>the value for the key, or <c>null</c></returns>
		/// <remarks>
		/// <para>
		/// Configuration APIs are not supported under the Compact Framework
		/// </para>
		/// </remarks>
		public static string GetAppSetting(string key)
		{
			try
			{
#if NETCF || NETSTANDARD1_3
				// Configuration APIs are not suported under the Compact Framework
#elif NET_2_0
				return ConfigurationManager.AppSettings[key];
#else
				return ConfigurationSettings.AppSettings[key];
#endif
			}
			catch(Exception ex)
			{
				// If an exception is thrown here then it looks like the config file does not parse correctly.
				LogLog.Error(declaringType, "Exception while reading ConfigurationSettings. Check your .config file is well formed XML.", ex);
			}
			return null;
		}

		/// <summary>
		/// Convert a path into a fully qualified local file path.
		/// </summary>
		/// <param name="path">The path to convert.</param>
		/// <returns>The fully qualified path.</returns>
		/// <remarks>
		/// <para>
		/// Converts the path specified to a fully
		/// qualified path. If the path is relative it is
		/// taken as relative from the application base 
		/// directory.
		/// </para>
		/// <para>
		/// The path specified must be a local file path, a URI is not supported.
		/// </para>
		/// </remarks>
		public static string ConvertToFullPath(string path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}

			string baseDirectory = "";
			try
			{
				string applicationBaseDirectory = SystemInfo.ApplicationBaseDirectory;
				if (applicationBaseDirectory != null)
				{
					// applicationBaseDirectory may be a URI not a local file path
					Uri applicationBaseDirectoryUri = new Uri(applicationBaseDirectory);
					if (applicationBaseDirectoryUri.IsFile)
					{
						baseDirectory = applicationBaseDirectoryUri.LocalPath;
					}
				}
			}
			catch
			{
				// Ignore URI exceptions & SecurityExceptions from SystemInfo.ApplicationBaseDirectory
			}

			if (baseDirectory != null && baseDirectory.Length > 0)
			{
				// Note that Path.Combine will return the second path if it is rooted
				return Path.GetFullPath(Path.Combine(baseDirectory, path));
			}
			return Path.GetFullPath(path);
		}

		/// <summary>
		/// Creates a new case-insensitive instance of the <see cref="Hashtable"/> class with the default initial capacity. 
		/// </summary>
		/// <returns>A new case-insensitive instance of the <see cref="Hashtable"/> class with the default initial capacity</returns>
		/// <remarks>
		/// <para>
		/// The new Hashtable instance uses the default load factor, the CaseInsensitiveHashCodeProvider, and the CaseInsensitiveComparer.
		/// </para>
		/// </remarks>
		public static Hashtable CreateCaseInsensitiveHashtable()
		{
#if NETCF_1_0
			return new Hashtable(CaseInsensitiveHashCodeProvider.Default, CaseInsensitiveComparer.Default);
#elif NETCF_2_0 || NET_2_0 || MONO_2_0 || MONO_3_5 || MONO_4_0
			return new Hashtable(StringComparer.OrdinalIgnoreCase);
#else
			return System.Collections.Specialized.CollectionsUtil.CreateCaseInsensitiveHashtable();
#endif
		}

        /// <summary>
        /// Tests two strings for equality, the ignoring case.
        /// </summary>
        /// <remarks>
        /// If the platform permits, culture information is ignored completely (ordinal comparison).
        /// The aim of this method is to provide a fast comparison that deals with <c>null</c> and ignores different casing.
        /// It is not supposed to deal with various, culture-specific habits.
        /// Use it to compare against pure ASCII constants, like keywords etc.
        /// </remarks>
        /// <param name="a">The one string.</param>
        /// <param name="b">The other string.</param>
        /// <returns><c>true</c> if the strings are equal, <c>false</c> otherwise.</returns>
        public static Boolean EqualsIgnoringCase(String a, String b)
        {
#if NET_1_0 || NET_1_1 || NETCF_1_0
            return string.Compare(a, b, true, System.Globalization.CultureInfo.InvariantCulture) == 0
#elif NETSTANDARD1_3
            return CultureInfo.InvariantCulture.CompareInfo.Compare(a, b, CompareOptions.IgnoreCase) == 0;
#else // >= .NET-2.0
            return String.Equals(a, b, StringComparison.OrdinalIgnoreCase);
#endif
        }

		#endregion Public Static Methods

		#region Private Static Methods

#if NETCF
		private static string NativeEntryAssemblyLocation 
		{
			get 
			{
				StringBuilder moduleName = null;

				IntPtr moduleHandle = GetModuleHandle(IntPtr.Zero);

				if (moduleHandle != IntPtr.Zero) 
				{
					moduleName = new StringBuilder(255);
					if (GetModuleFileName(moduleHandle, moduleName,	moduleName.Capacity) == 0) 
					{
						throw new NotSupportedException(NativeError.GetLastError().ToString());
					}
				} 
				else 
				{
					throw new NotSupportedException(NativeError.GetLastError().ToString());
				}

				return moduleName.ToString();
			}
		}

		[DllImport("CoreDll.dll", SetLastError=true, CharSet=CharSet.Unicode)]
		private static extern IntPtr GetModuleHandle(IntPtr ModuleName);

		[DllImport("CoreDll.dll", SetLastError=true, CharSet=CharSet.Unicode)]
		private static extern Int32 GetModuleFileName(
			IntPtr hModule,
			StringBuilder ModuleName,
			Int32 cch);

#endif

		#endregion Private Static Methods

		#region Public Static Fields

		/// <summary>
		/// Gets an empty array of types.
		/// </summary>
		/// <remarks>
		/// <para>
		/// The <c>Type.EmptyTypes</c> field is not available on
		/// the .NET Compact Framework 1.0.
		/// </para>
		/// </remarks>
		public static readonly Type[] EmptyTypes = new Type[0];

		#endregion Public Static Fields

		#region Private Static Fields

	    /// <summary>
	    /// The fully qualified type of the SystemInfo class.
	    /// </summary>
	    /// <remarks>
	    /// Used by the internal logger to record the Type of the
	    /// log message.
	    /// </remarks>
	    private readonly static Type declaringType = typeof(SystemInfo);

		/// <summary>
		/// Cache the host name for the current machine
		/// </summary>
		private static string s_hostName;

		/// <summary>
		/// Cache the application friendly name
		/// </summary>
		private static string s_appFriendlyName;

		/// <summary>
		/// Text to output when a <c>null</c> is encountered.
		/// </summary>
		private static string s_nullText;

		/// <summary>
		/// Text to output when an unsupported feature is requested.
		/// </summary>
		private static string s_notAvailableText;

		/// <summary>
		/// Start time for the current process.
		/// </summary>
		private static DateTime s_processStartTimeUtc = DateTime.UtcNow;]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AssemblyFileName">
          <declaration><![CDATA[public static string AssemblyFileName(Assembly myAssembly)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="615" sc="3" el="637" ec="4">log4net\Util\SystemInfo.cs</location>
            <body hash="e1ff7190801e0d45d37e5f43a7968d76"><![CDATA[{
#if NETCF || NETSTANDARD1_3 // TODO Assembly.Location is in netstandard1.5 System.Reflection
			// This is not very good because it assumes that only
			// the entry assembly can be an EXE. In fact multiple
			// EXEs can be loaded in to a process.

			string assemblyShortName = SystemInfo.AssemblyShortName(myAssembly);
			string entryAssemblyShortName = System.IO.Path.GetFileNameWithoutExtension(SystemInfo.EntryAssemblyLocation);

			if (string.Compare(assemblyShortName, entryAssemblyShortName, true) == 0)
			{
				// assembly is entry assembly
				return assemblyShortName + ".exe";
			}
			else
			{
				// assembly is not entry assembly
				return assemblyShortName + ".dll";
			}
#else
			return System.IO.Path.GetFileName(myAssembly.Location);
#endif
		}]]></body>
          </codeblock>
        </method>
        <method name="AssemblyLocationInfo">
          <declaration><![CDATA[public static string AssemblyLocationInfo(Assembly myAssembly)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="484" sc="3" el="541" ec="4">log4net\Util\SystemInfo.cs</location>
            <body hash="bd6c2be0e27963c44d26e830ccb52d93"><![CDATA[{
#if NETCF
			return "Not supported on Microsoft .NET Compact Framework";
#elif NETSTANDARD1_3  // TODO Assembly.Location available in netstandard1.5
            return "Not supported on .NET Core";
#else
			if (myAssembly.GlobalAssemblyCache)
			{
				return "Global Assembly Cache";
			}
			else
			{
				try
				{
#if NET_4_0 || MONO_4_0
					if (myAssembly.IsDynamic)
					{
						return "Dynamic Assembly";
					}
#else
					if (myAssembly is System.Reflection.Emit.AssemblyBuilder)
					{
						return "Dynamic Assembly";
					}
					else if(myAssembly.GetType().FullName == "System.Reflection.Emit.InternalAssemblyBuilder")
					{
						return "Dynamic Assembly";
					}
#endif
					else
					{
						// This call requires FileIOPermission for access to the path
						// if we don't have permission then we just ignore it and
						// carry on.
						return myAssembly.Location;
					}
				}
				catch (NotSupportedException)
				{
					// The location information may be unavailable for dynamic assemblies and a NotSupportedException
					// is thrown in those cases. See: http://msdn.microsoft.com/de-de/library/system.reflection.assembly.location.aspx
					return "Dynamic Assembly";
				}
				catch (TargetInvocationException ex)
				{
					return "Location Detect Failed (" + ex.Message + ")";
				}
				catch (ArgumentException ex)
				{
					return "Location Detect Failed (" + ex.Message + ")";
				}
				catch (System.Security.SecurityException)
				{
					return "Location Permission Denied";
				}
			}
#endif
		}]]></body>
          </codeblock>
        </method>
        <method name="AssemblyQualifiedName">
          <declaration><![CDATA[public static string AssemblyQualifiedName(Type type)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="558" sc="3" el="565" ec="4">log4net\Util\SystemInfo.cs</location>
            <body hash="b0ac92030ee2fe19f5752dbcd4c691ba"><![CDATA[{
			return type.FullName + ", "
#if NETSTANDARD1_3
				+ type.GetTypeInfo().Assembly.FullName;
#else
				+ type.Assembly.FullName;
#endif
		}]]></body>
          </codeblock>
        </method>
        <method name="AssemblyShortName">
          <declaration><![CDATA[public static string AssemblyShortName(Assembly myAssembly)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="590" sc="3" el="602" ec="4">log4net\Util\SystemInfo.cs</location>
            <body hash="3ecd3402710350fa5b890e790b321672"><![CDATA[{
			string name = myAssembly.FullName;
			int offset = name.IndexOf(',');
			if (offset > 0)
			{
				name = name.Substring(0, offset);
			}
			return name.Trim();

			// TODO: Do we need to unescape the assembly name string? 
			// Doc says '\' is an escape char but has this already been 
			// done by the string loader?
		}]]></body>
          </codeblock>
        </method>
        <method name="ConvertToFullPath">
          <declaration><![CDATA[public static string ConvertToFullPath(string path)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1035" sc="3" el="1066" ec="4">log4net\Util\SystemInfo.cs</location>
            <body hash="de66c658d41f694296859b57bfe666bc"><![CDATA[{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}

			string baseDirectory = "";
			try
			{
				string applicationBaseDirectory = SystemInfo.ApplicationBaseDirectory;
				if (applicationBaseDirectory != null)
				{
					// applicationBaseDirectory may be a URI not a local file path
					Uri applicationBaseDirectoryUri = new Uri(applicationBaseDirectory);
					if (applicationBaseDirectoryUri.IsFile)
					{
						baseDirectory = applicationBaseDirectoryUri.LocalPath;
					}
				}
			}
			catch
			{
				// Ignore URI exceptions & SecurityExceptions from SystemInfo.ApplicationBaseDirectory
			}

			if (baseDirectory != null && baseDirectory.Length > 0)
			{
				// Note that Path.Combine will return the second path if it is rooted
				return Path.GetFullPath(Path.Combine(baseDirectory, path));
			}
			return Path.GetFullPath(path);
		}]]></body>
          </codeblock>
        </method>
        <method name="CreateArgumentOutOfRangeException">
          <declaration><![CDATA[public static ArgumentOutOfRangeException CreateArgumentOutOfRangeException(string parameterName, object actualValue, string message)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="833" sc="3" el="841" ec="4">log4net\Util\SystemInfo.cs</location>
            <body hash="1b64db9e31f686eae3a78ac535aa5ea8"><![CDATA[{
#if NETCF_1_0
			return new ArgumentOutOfRangeException(message + " [param=" + parameterName + "] [value=" + actualValue + "]");
#elif NETCF_2_0
			return new ArgumentOutOfRangeException(parameterName, message + " [value=" + actualValue + "]");
#else
			return new ArgumentOutOfRangeException(parameterName, actualValue, message);
#endif
		}]]></body>
          </codeblock>
        </method>
        <method name="CreateCaseInsensitiveHashtable">
          <declaration><![CDATA[public static Hashtable CreateCaseInsensitiveHashtable()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1078" sc="3" el="1086" ec="4">log4net\Util\SystemInfo.cs</location>
            <body hash="5a9bd948415e6ba449802b2cbc903856"><![CDATA[{
#if NETCF_1_0
			return new Hashtable(CaseInsensitiveHashCodeProvider.Default, CaseInsensitiveComparer.Default);
#elif NETCF_2_0 || NET_2_0 || MONO_2_0 || MONO_3_5 || MONO_4_0
			return new Hashtable(StringComparer.OrdinalIgnoreCase);
#else
			return System.Collections.Specialized.CollectionsUtil.CreateCaseInsensitiveHashtable();
#endif
		}]]></body>
          </codeblock>
        </method>
        <method name="EqualsIgnoringCase">
          <declaration><![CDATA[public static bool EqualsIgnoringCase(string a, string b)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1101" sc="9" el="1109" ec="10">log4net\Util\SystemInfo.cs</location>
            <body hash="cb7873739cd547cf3968df9c70268891"><![CDATA[{
#if NET_1_0 || NET_1_1 || NETCF_1_0
            return string.Compare(a, b, true, System.Globalization.CultureInfo.InvariantCulture) == 0
#elif NETSTANDARD1_3
            return CultureInfo.InvariantCulture.CompareInfo.Compare(a, b, CompareOptions.IgnoreCase) == 0;
#else // >= .NET-2.0
            return String.Equals(a, b, StringComparison.OrdinalIgnoreCase);
#endif
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAppSetting">
          <declaration><![CDATA[public static string GetAppSetting(string key)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="999" sc="3" el="1016" ec="4">log4net\Util\SystemInfo.cs</location>
            <body hash="d48445423ec4f03e890d70c8c978511b"><![CDATA[{
			try
			{
#if NETCF || NETSTANDARD1_3
				// Configuration APIs are not suported under the Compact Framework
#elif NET_2_0
				return ConfigurationManager.AppSettings[key];
#else
				return ConfigurationSettings.AppSettings[key];
#endif
			}
			catch(Exception ex)
			{
				// If an exception is thrown here then it looks like the config file does not parse correctly.
				LogLog.Error(declaringType, "Exception while reading ConfigurationSettings. Check your .config file is well formed XML.", ex);
			}
			return null;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetTypeFromString">
          <declaration><![CDATA[public static Type GetTypeFromString(Type relativeType, string typeName, bool throwOnError, bool ignoreCase)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="660" sc="3" el="666" ec="4">log4net\Util\SystemInfo.cs</location>
            <body hash="77b2dea815b7d18023ee2afd87680a9c"><![CDATA[{
#if NETSTANDARD1_3
			return GetTypeFromString(relativeType.GetTypeInfo().Assembly, typeName, throwOnError, ignoreCase);
#else
			return GetTypeFromString(relativeType.Assembly, typeName, throwOnError, ignoreCase);
#endif
		}]]></body>
          </codeblock>
        </method>
        <method name="GetTypeFromString">
          <declaration><![CDATA[public static Type GetTypeFromString(string typeName, bool throwOnError, bool ignoreCase)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="689" sc="3" el="691" ec="4">log4net\Util\SystemInfo.cs</location>
            <body hash="534d51a327fd1967060b3934d10e6ce9"><![CDATA[{
			return GetTypeFromString(Assembly.GetCallingAssembly(), typeName, throwOnError, ignoreCase);
		}]]></body>
          </codeblock>
        </method>
        <method name="GetTypeFromString">
          <declaration><![CDATA[public static Type GetTypeFromString(Assembly relativeAssembly, string typeName, bool throwOnError, bool ignoreCase)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="715" sc="3" el="792" ec="4">log4net\Util\SystemInfo.cs</location>
            <body hash="7ced859576f407381f556c21ad41b6c2"><![CDATA[{
			// Check if the type name specifies the assembly name
			if(typeName.IndexOf(',') == -1)
			{
				//LogLog.Debug(declaringType, "SystemInfo: Loading type ["+typeName+"] from assembly ["+relativeAssembly.FullName+"]");
#if NETSTANDARD1_3
				return relativeAssembly.GetType(typeName, throwOnError, ignoreCase);
#elif NETCF
				return relativeAssembly.GetType(typeName, throwOnError);
#else
				// Attempt to lookup the type from the relativeAssembly
				Type type = relativeAssembly.GetType(typeName, false, ignoreCase);
				if (type != null)
				{
					// Found type in relative assembly
					//LogLog.Debug(declaringType, "SystemInfo: Loaded type ["+typeName+"] from assembly ["+relativeAssembly.FullName+"]");
					return type;
				}

				Assembly[] loadedAssemblies = null;
				try
				{
					loadedAssemblies = AppDomain.CurrentDomain.GetAssemblies();
				}
				catch(System.Security.SecurityException)
				{
					// Insufficient permissions to get the list of loaded assemblies
				}

				if (loadedAssemblies != null)
				{
					Type fallback = null;
					// Search the loaded assemblies for the type
					foreach (Assembly assembly in loadedAssemblies) 
					{
						Type t = assembly.GetType(typeName, false, ignoreCase);
						if (t != null)
						{
							// Found type in loaded assembly
							LogLog.Debug(declaringType, "Loaded type ["+typeName+"] from assembly ["+assembly.FullName+"] by searching loaded assemblies.");
                                                        if (assembly.GlobalAssemblyCache)
                                                        {
                                                            fallback = t;
                                                        }
                                                        else
                                                        {
                                                            return t;
                                                        }
						}
					}
                                        if (fallback != null)
                                        {
                                            return fallback;
                                        }
				}

				// Didn't find the type
				if (throwOnError)
				{
					throw new TypeLoadException("Could not load type ["+typeName+"]. Tried assembly ["+relativeAssembly.FullName+"] and all loaded assemblies");
				}
				return null;
#endif
			}
			else
			{
				// Includes explicit assembly name
				//LogLog.Debug(declaringType, "SystemInfo: Loading type ["+typeName+"] from global Type");

#if NETCF
				// In NETCF 2 and 3 arg versions seem to behave differently
				// https://issues.apache.org/jira/browse/LOG4NET-113
				return Type.GetType(typeName, throwOnError);
#else
				return Type.GetType(typeName, throwOnError, ignoreCase);
#endif
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="NewGuid">
          <declaration><![CDATA[public static Guid NewGuid()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="805" sc="3" el="811" ec="4">log4net\Util\SystemInfo.cs</location>
            <body hash="16d29dc2b5e820de03de53da8f1aedd8"><![CDATA[{
#if NETCF_1_0
			return PocketGuid.NewGuid();
#else
			return Guid.NewGuid();
#endif
		}]]></body>
          </codeblock>
        </method>
        <method name="TryParse">
          <declaration><![CDATA[public static bool TryParse(string s, out int val)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="857" sc="3" el="890" ec="4">log4net\Util\SystemInfo.cs</location>
            <body hash="ba3052b2d267cfc455e3d0f2978f162d"><![CDATA[{
#if NETCF
			val = 0;
			try
			{
				val = int.Parse(s, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture);
				return true;
			}
			catch
			{
			}

			return false;
#else
			// Initialise out param
			val = 0;

			try
			{
				double doubleVal;
				if (Double.TryParse(s, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out doubleVal))
				{
					val = Convert.ToInt32(doubleVal);
					return true;
				}
			}
			catch
			{
				// Ignore exception, just return false
			}

			return false;
#endif
		}]]></body>
          </codeblock>
        </method>
        <method name="TryParse">
          <declaration><![CDATA[public static bool TryParse(string s, out long val)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="905" sc="3" el="938" ec="4">log4net\Util\SystemInfo.cs</location>
            <body hash="7e3a8572749b60644faafc2799a71dcd"><![CDATA[{
#if NETCF
			val = 0;
			try
			{
				val = long.Parse(s, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture);
				return true;
			}
			catch
			{
			}

			return false;
#else
			// Initialise out param
			val = 0;

			try
			{
				double doubleVal;
				if (Double.TryParse(s, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out doubleVal))
				{
					val = Convert.ToInt64(doubleVal);
					return true;
				}
			}
			catch
			{
				// Ignore exception, just return false
			}

			return false;
#endif
		}]]></body>
          </codeblock>
        </method>
        <method name="TryParse">
          <declaration><![CDATA[public static bool TryParse(string s, out short val)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="953" sc="9" el="986" ec="10">log4net\Util\SystemInfo.cs</location>
            <body hash="1ac556e0992d64f2094c5bb132b383f9"><![CDATA[{
#if NETCF
			val = 0;
			try
			{
				val = short.Parse(s, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture);
				return true;
			}
			catch
			{
			}

			return false;
#else
            // Initialise out param
            val = 0;

            try 
            {
                double doubleVal;
                if (Double.TryParse(s, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out doubleVal))
                {
                    val = Convert.ToInt16(doubleVal);
                    return true;
                }
            }
            catch
            {
                // Ignore exception, just return false
            }

            return false;
#endif
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DEFAULT_NOT_AVAILABLE_TEXT">
          <declaration><![CDATA[private const string DEFAULT_NOT_AVAILABLE_TEXT = "NOT AVAILABLE";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DEFAULT_NULL_TEXT">
          <declaration><![CDATA[private const string DEFAULT_NULL_TEXT = "(null)";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="EmptyTypes">
          <declaration><![CDATA[public static readonly Type[] EmptyTypes;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="s_appFriendlyName">
          <declaration><![CDATA[private static string s_appFriendlyName;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="s_hostName">
          <declaration><![CDATA[private static string s_hostName;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="s_notAvailableText">
          <declaration><![CDATA[private static string s_notAvailableText;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="s_nullText">
          <declaration><![CDATA[private static string s_nullText;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="s_processStartTimeUtc">
          <declaration><![CDATA[private static DateTime s_processStartTimeUtc;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="ApplicationBaseDirectory">
          <declaration><![CDATA[public static string ApplicationBaseDirectory]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="148" sc="4" el="156" ec="5">log4net\Util\SystemInfo.cs</location>
            <body hash="83017e6c8a6e1f12498f1c06aaf7ae2a"><![CDATA[{
#if NETCF
-				return System.IO.Path.GetDirectoryName(SystemInfo.EntryAssemblyLocation) + System.IO.Path.DirectorySeparatorChar;
#elif NETSTANDARD1_3
				return Directory.GetCurrentDirectory();
#else
				return AppDomain.CurrentDomain.BaseDirectory;
#endif
			}]]></body>
          </codeblock>
        </property>
        <property name="ApplicationFriendlyName">
          <declaration><![CDATA[public static string ApplicationFriendlyName]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="339" sc="4" el="374" ec="5">log4net\Util\SystemInfo.cs</location>
            <body hash="dc2985945d12219030492bacb191c43b"><![CDATA[{
				if (s_appFriendlyName == null)
				{
					try
					{
#if !(NETCF || NETSTANDARD1_3)
						s_appFriendlyName = AppDomain.CurrentDomain.FriendlyName;
#endif
					}
					catch(System.Security.SecurityException)
					{
						// This security exception will occur if the caller does not have 
						// some undefined set of SecurityPermission flags.
						LogLog.Debug(declaringType, "Security exception while trying to get current domain friendly name. Error Ignored.");
					}

					if (s_appFriendlyName == null || s_appFriendlyName.Length == 0)
					{
						try
						{
							string assemblyLocation = SystemInfo.EntryAssemblyLocation;
							s_appFriendlyName = System.IO.Path.GetFileName(assemblyLocation);
						}
						catch(System.Security.SecurityException)
						{
							// Caller needs path discovery permission
						}
					}

					if (s_appFriendlyName == null || s_appFriendlyName.Length == 0)
					{
						s_appFriendlyName = s_notAvailableText;
					}
				}
				return s_appFriendlyName;
			}]]></body>
          </codeblock>
        </property>
        <property name="ConfigurationFileLocation">
          <declaration><![CDATA[public static string ConfigurationFileLocation]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="176" sc="4" el="182" ec="5">log4net\Util\SystemInfo.cs</location>
            <body hash="59887db58aaa8123a20e9f34a7ba7800"><![CDATA[{
#if NETCF || NETSTANDARD1_3
				return SystemInfo.EntryAssemblyLocation+".config";
#else
				return System.AppDomain.CurrentDomain.SetupInformation.ConfigurationFile;
#endif
			}]]></body>
          </codeblock>
        </property>
        <property name="CurrentThreadId">
          <declaration><![CDATA[public static int CurrentThreadId]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="233" sc="4" el="241" ec="5">log4net\Util\SystemInfo.cs</location>
            <body hash="295ecfd365349ef57a290c183ff748e4"><![CDATA[{
#if NETCF_1_0
				return System.Threading.Thread.CurrentThread.GetHashCode();
#elif NET_2_0 || NETCF_2_0 || MONO_2_0 || MONO_3_5 || MONO_4_0 || NETSTANDARD1_3
				return System.Threading.Thread.CurrentThread.ManagedThreadId;
#else
				return AppDomain.GetCurrentThreadId();
#endif
			}]]></body>
          </codeblock>
        </property>
        <property name="EntryAssemblyLocation">
          <declaration><![CDATA[public static string EntryAssemblyLocation]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="197" sc="4" el="205" ec="5">log4net\Util\SystemInfo.cs</location>
            <body hash="53e7f5a25a740094003d5d6f826806a7"><![CDATA[{
#if NETCF
				return SystemInfo.NativeEntryAssemblyLocation;
#elif NETSTANDARD1_3 // TODO GetEntryAssembly is available for netstandard1.5
				return AppContext.BaseDirectory;
#else
				return System.Reflection.Assembly.GetEntryAssembly().Location;
#endif
			}]]></body>
          </codeblock>
        </property>
        <property name="HostName">
          <declaration><![CDATA[public static string HostName]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="264" sc="4" el="318" ec="5">log4net\Util\SystemInfo.cs</location>
            <body hash="db3f1d53025f2f253c817ebebe0fdd46"><![CDATA[{
				if (s_hostName == null)
				{

					// Get the DNS host name of the current machine
					try
					{
						// Lookup the host name
						s_hostName = System.Net.Dns.GetHostName();
					}
					catch (System.Net.Sockets.SocketException)
					{
						LogLog.Debug(declaringType, "Socket exception occurred while getting the dns hostname. Error Ignored.");
					}
					catch (System.Security.SecurityException)
					{
						// We may get a security exception looking up the hostname
						// You must have Unrestricted DnsPermission to access resource
						LogLog.Debug(declaringType, "Security exception occurred while getting the dns hostname. Error Ignored.");
					}
					catch (Exception ex)
					{
						LogLog.Debug(declaringType, "Some other exception occurred while getting the dns hostname. Error Ignored.", ex);
					}

					// Get the NETBIOS machine name of the current machine
					if (s_hostName == null || s_hostName.Length == 0)
					{
						try
						{
#if NETSTANDARD1_3
							s_hostName = Environment.GetEnvironmentVariable("COMPUTERNAME");
#elif (!SSCLI && !NETCF)
							s_hostName = Environment.MachineName;
#endif
						}
						catch(InvalidOperationException)
						{
						}
						catch(System.Security.SecurityException)
						{
							// We may get a security exception looking up the machine name
							// You must have Unrestricted EnvironmentPermission to access resource
						}
					}

					// Couldn't find a value
					if (s_hostName == null || s_hostName.Length == 0)
					{
						s_hostName = s_notAvailableText;
						LogLog.Debug(declaringType, "Could not determine the hostname. Error Ignored. Empty host name will be used");
					}
				}
				return s_hostName;
			}]]></body>
          </codeblock>
        </property>
        <property name="NewLine">
          <declaration><![CDATA[public static string NewLine]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="124" sc="4" el="130" ec="5">log4net\Util\SystemInfo.cs</location>
            <body hash="0c4936fec1c61c292cc292f2268c8eb6"><![CDATA[{
#if NETCF
				return "\r\n";
#else
				return System.Environment.NewLine;
#endif
			}]]></body>
          </codeblock>
        </property>
        <property name="NotAvailableText">
          <declaration><![CDATA[public static string NotAvailableText]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="NullText">
          <declaration><![CDATA[public static string NullText]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="ProcessStartTime">
          <deprecation>Use ProcessStartTimeUtc and convert to local time if needed.</deprecation>
          <declaration><![CDATA[public static DateTime ProcessStartTime]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="ProcessStartTimeUtc">
          <declaration><![CDATA[public static DateTime ProcessStartTimeUtc]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="SystemStringFormat">
      <declaration><![CDATA[public sealed class SystemStringFormat]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public SystemStringFormat(IFormatProvider provider, string format, params object[] args)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="50" sc="3" el="55" ec="4">log4net\Util\SystemStringFormat.cs</location>
            <body hash="ce5d5569bbe7bb664311d8142587bc71"><![CDATA[public SystemStringFormat(IFormatProvider provider, string format, params object[] args)
		{
			m_provider = provider;
			m_format = format;
			m_args = args;
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static SystemStringFormat()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="233" sc="6" el="233" ec="78">log4net\Util\SystemStringFormat.cs</location>
            <body hash="15116e130bf4c85d78ac36e54c2453d3"><![CDATA[private readonly static Type declaringType = typeof(SystemStringFormat)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="RenderArray">
          <declaration><![CDATA[private static void RenderArray(Array array, StringBuilder buffer)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="164" sc="3" el="192" ec="4">log4net\Util\SystemStringFormat.cs</location>
            <body hash="83596337c3753b8d75e8d272f28c0b91"><![CDATA[{
			if (array == null)
			{
				buffer.Append(SystemInfo.NullText);
			}
			else
			{
				if (array.Rank != 1)
				{
					buffer.Append(array.ToString());
				}
				else
				{
					buffer.Append("{");
					int len = array.Length;

					if (len > 0)
					{
						RenderObject(array.GetValue(0), buffer);
						for (int i = 1; i < len; i++)
						{
							buffer.Append(", ");
							RenderObject(array.GetValue(i), buffer);
						}
					}
					buffer.Append("}");
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="RenderObject">
          <declaration><![CDATA[private static void RenderObject(object obj, StringBuilder buffer)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="198" sc="3" el="220" ec="4">log4net\Util\SystemStringFormat.cs</location>
            <body hash="310acf92ab7be87631ed100e10f61fb8"><![CDATA[{
			if (obj == null)
			{
				buffer.Append(SystemInfo.NullText);
			}
			else
			{
				try
				{
					buffer.Append(obj);
				}
				catch(Exception ex)
				{
					buffer.Append("<Exception: ").Append(ex.Message).Append(">");
				}
#if !NET_2_0 && !MONO_2_0 && !MONO_3_5 && !MONO_4_0 && !NETSTANDARD1_3
				catch
				{
					buffer.Append("<Exception>");
				}
#endif
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="StringFormat">
          <declaration><![CDATA[private static string StringFormat(IFormatProvider provider, string format, params object[] args)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="89" sc="3" el="119" ec="4">log4net\Util\SystemStringFormat.cs</location>
            <body hash="88409ed2666c6bfc63193cb1db57f56f"><![CDATA[{
			try
			{
				// The format is missing, log null value
				if (format == null)
				{
					return null;
				}

				// The args are missing - should not happen unless we are called explicitly with a null array
				if (args == null)
				{
					return format;
				}

				// Try to format the string
				return String.Format(provider, format, args);
			}
			catch(Exception ex)
			{
				log4net.Util.LogLog.Warn(declaringType, "Exception while rendering format ["+format+"]", ex);
				return StringFormatError(ex, format, args);
			}
#if !NET_2_0 && !MONO_2_0 && !MONO_3_5 && !MONO_4_0 && !NETSTANDARD1_3
			catch
			{
				log4net.Util.LogLog.Warn(declaringType, "Exception while rendering format ["+format+"]");
				return StringFormatError(null, format, args);
			}
#endif
		}]]></body>
          </codeblock>
        </method>
        <method name="StringFormatError">
          <declaration><![CDATA[private static string StringFormatError(Exception formatException, string format, object[] args)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="125" sc="3" el="158" ec="4">log4net\Util\SystemStringFormat.cs</location>
            <body hash="f3c105f1962c1e92a222312aacdb63f6"><![CDATA[{
			try
			{
				StringBuilder buf = new StringBuilder("<log4net.Error>");

				if (formatException != null)
				{
					buf.Append("Exception during StringFormat: ").Append(formatException.Message);
				}
				else
				{
					buf.Append("Exception during StringFormat");
				}
				buf.Append(" <format>").Append(format).Append("</format>");
				buf.Append("<args>");
				RenderArray(args, buf);
				buf.Append("</args>");
				buf.Append("</log4net.Error>");

				return buf.ToString();
			}
			catch(Exception ex)
			{
				log4net.Util.LogLog.Error(declaringType, "INTERNAL ERROR during StringFormat error handling", ex);
				return "<log4net.Error>Exception during StringFormat. See Internal Log.</log4net.Error>";
			}
#if !NET_2_0 && !MONO_2_0 && !MONO_3_5 && !MONO_4_0 && !NETSTANDARD1_3
			catch
			{
				log4net.Util.LogLog.Error(declaringType, "INTERNAL ERROR during StringFormat error handling");
				return "<log4net.Error>Exception during StringFormat. See Internal Log.</log4net.Error>";
			}
#endif
		}]]></body>
          </codeblock>
        </method>
        <method name="ToString">
          <declaration><![CDATA[public override string ToString()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="64" sc="3" el="66" ec="4">log4net\Util\SystemStringFormat.cs</location>
            <body hash="845e316001e56d58d4d0539473197eae"><![CDATA[{
			return StringFormat(m_provider, m_format, m_args);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(SystemStringFormat);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_args">
          <declaration><![CDATA[private readonly object[] m_args;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_format">
          <declaration><![CDATA[private readonly string m_format;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_provider">
          <declaration><![CDATA[private readonly IFormatProvider m_provider;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="TextWriterAdapter">
      <declaration><![CDATA[public abstract class TextWriterAdapter : TextWriter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[protected TextWriterAdapter(TextWriter writer) : base(CultureInfo.InvariantCulture)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="62" sc="53" el="65" ec="4">log4net\Util\TextWriterAdapter.cs</location>
            <body hash="55326cb8f78b629c625d7ca9ca50e8de"><![CDATA[base(CultureInfo.InvariantCulture)
		{
			m_writer = writer;
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Close">
          <declaration><![CDATA[public override void Close()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="159" sc="3" el="161" ec="4">log4net\Util\TextWriterAdapter.cs</location>
            <body hash="3cd0063041f740da94fed5ad9ff2fa45"><![CDATA[{
			m_writer.Close();
		}]]></body>
          </codeblock>
        </method>
        <method name="Dispose">
          <declaration><![CDATA[protected override void Dispose(bool disposing)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="174" sc="3" el="179" ec="4">log4net\Util\TextWriterAdapter.cs</location>
            <body hash="882dd8367febe9fbaa5a19bf49398b4b"><![CDATA[{
			if (disposing)
			{
				((IDisposable)m_writer).Dispose();
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Flush">
          <declaration><![CDATA[public override void Flush()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="191" sc="3" el="193" ec="4">log4net\Util\TextWriterAdapter.cs</location>
            <body hash="6401cdc6c8e10e85202f4b42c69264a0"><![CDATA[{
			m_writer.Flush();
		}]]></body>
          </codeblock>
        </method>
        <method name="Write">
          <declaration><![CDATA[public override void Write(char value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="205" sc="3" el="207" ec="4">log4net\Util\TextWriterAdapter.cs</location>
            <body hash="63a6e3eda419b9f8b8c18d824ae5842c"><![CDATA[{
			m_writer.Write(value);
		}]]></body>
          </codeblock>
        </method>
        <method name="Write">
          <declaration><![CDATA[public override void Write(char[] buffer, int index, int count)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="221" sc="3" el="223" ec="4">log4net\Util\TextWriterAdapter.cs</location>
            <body hash="ac4d3c8b19c79ed64c9db2022068e4ae"><![CDATA[{
			m_writer.Write(buffer, index, count);
		}]]></body>
          </codeblock>
        </method>
        <method name="Write">
          <declaration><![CDATA[public override void Write(string value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="235" sc="3" el="237" ec="4">log4net\Util\TextWriterAdapter.cs</location>
            <body hash="63a6e3eda419b9f8b8c18d824ae5842c"><![CDATA[{
			m_writer.Write(value);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_writer">
          <declaration><![CDATA[private TextWriter m_writer;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Encoding">
          <declaration><![CDATA[public override Encoding Encoding]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="FormatProvider">
          <declaration><![CDATA[public override IFormatProvider FormatProvider]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="NewLine">
          <declaration><![CDATA[public override string NewLine]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Writer">
          <declaration><![CDATA[protected TextWriter Writer]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ThreadContextProperties">
      <declaration><![CDATA[public sealed class ThreadContextProperties : ContextPropertiesBase]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[internal ThreadContextProperties()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="66" sc="3" el="68" ec="4">log4net\Util\ThreadContextProperties.cs</location>
            <body hash="f1da4f6c93353af13f4effb2de1ddd68"><![CDATA[internal ThreadContextProperties()
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Clear">
          <declaration><![CDATA[public void Clear()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="156" sc="3" el="164" ec="4">log4net\Util\ThreadContextProperties.cs</location>
            <body hash="fdab45bc7769a2161783401595af1ca8"><![CDATA[{
#if NETCF
			PropertiesDictionary _dictionary = GetProperties(false);
#endif
			if (_dictionary != null)
			{
				_dictionary.Clear();
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="GetKeys">
          <declaration><![CDATA[public string[] GetKeys()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="136" sc="3" el="145" ec="4">log4net\Util\ThreadContextProperties.cs</location>
            <body hash="1627c3a2bca48d2e578654e37b79f9ff"><![CDATA[{
#if NETCF
			PropertiesDictionary _dictionary = GetProperties(false);
#endif
			if (_dictionary != null)
			{
				return _dictionary.GetKeys();
			}
			return null;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetProperties">
          <declaration><![CDATA[internal PropertiesDictionary GetProperties(bool create)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="183" sc="3" el="195" ec="4">log4net\Util\ThreadContextProperties.cs</location>
            <body hash="e2e59c49f50b46370c849344f3180192"><![CDATA[{
#if NETCF
			PropertiesDictionary _dictionary = (PropertiesDictionary)System.Threading.Thread.GetData(s_threadLocalSlot);
#endif
			if (_dictionary == null && create)
			{
				_dictionary  = new PropertiesDictionary();
#if NETCF
				System.Threading.Thread.SetData(s_threadLocalSlot, _dictionary);
#endif
			}
			return _dictionary;
		}]]></body>
          </codeblock>
        </method>
        <method name="Remove">
          <declaration><![CDATA[public void Remove(string key)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="118" sc="3" el="126" ec="4">log4net\Util\ThreadContextProperties.cs</location>
            <body hash="514922d244a92c60e6ac5ebf90aa03d1"><![CDATA[{
#if NETCF
			PropertiesDictionary _dictionary = GetProperties(false);
#endif
			if (_dictionary != null)
			{
				_dictionary.Remove(key);
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_dictionary">
          <declaration><![CDATA[private static PropertiesDictionary _dictionary;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Item">
          <declaration><![CDATA[public override object this[string key]]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="88" sc="4" el="97" ec="5">log4net\Util\ThreadContextProperties.cs</location>
            <body hash="259bff25c8a129a37ec236cec5513d11"><![CDATA[{
#if NETCF
				PropertiesDictionary _dictionary = GetProperties(false);
#endif
				if (_dictionary != null)
				{
					return _dictionary[key];
				}
				return null;
			}]]></body>
          </codeblock>
          <codeblock>
            <location sl="99" sc="4" el="101" ec="5">log4net\Util\ThreadContextProperties.cs</location>
            <body hash="9302f5b278e830e2d705d06552795fa8"><![CDATA[{
				GetProperties(true)[key] = value;
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ThreadContextStack">
      <declaration><![CDATA[public sealed class ThreadContextStack : IFixingRequired]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private Stack m_stack = new Stack();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="46" sc="3" el="62" ec="4">log4net\Util\ThreadContextStack.cs</location>
            <body hash="cb247c78a181938d9dd5dc8615644e34"><![CDATA[private Stack m_stack = new Stack();

		#endregion Private Static Fields

		#region Public Instance Constructors

		/// <summary>
		/// Internal constructor
		/// </summary>
		/// <remarks>
		/// <para>
		/// Initializes a new instance of the <see cref="ThreadContextStack" /> class. 
		/// </para>
		/// </remarks>
		internal ThreadContextStack()
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Clear">
          <declaration><![CDATA[public void Clear()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="106" sc="3" el="108" ec="4">log4net\Util\ThreadContextStack.cs</location>
            <body hash="5d7de2ccdcaef6605aed2c3592119494"><![CDATA[{
			m_stack.Clear();
		}]]></body>
          </codeblock>
        </method>
        <method name="GetFullMessage">
          <declaration><![CDATA[internal string GetFullMessage()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="171" sc="3" el="178" ec="4">log4net\Util\ThreadContextStack.cs</location>
            <body hash="c1791539788d46ff3e7fbd075ac7480e"><![CDATA[{
			Stack stack = m_stack;
			if (stack.Count > 0)
			{
				return ((StackFrame)(stack.Peek())).FullMessage;
			}
			return null;
		}]]></body>
          </codeblock>
        </method>
        <method name="log4net.Core.IFixingRequired.GetFixedObject">
          <declaration><![CDATA[object IFixingRequired.GetFixedObject()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="223" sc="3" el="225" ec="4">log4net\Util\ThreadContextStack.cs</location>
            <body hash="2f125b0f35211370a831f85f9e907cbb"><![CDATA[{
			return GetFullMessage();
		}]]></body>
          </codeblock>
        </method>
        <method name="Pop">
          <declaration><![CDATA[public string Pop()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="122" sc="3" el="129" ec="4">log4net\Util\ThreadContextStack.cs</location>
            <body hash="486930fd628ee403193345e2eac87e06"><![CDATA[{
			Stack stack = m_stack;
			if (stack.Count > 0)
			{
				return ((StackFrame)(stack.Pop())).Message;
			}
			return "";
		}]]></body>
          </codeblock>
        </method>
        <method name="Push">
          <declaration><![CDATA[public IDisposable Push(string message)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="155" sc="3" el="160" ec="4">log4net\Util\ThreadContextStack.cs</location>
            <body hash="565d39b04940e427b59cf9e858549832"><![CDATA[{
			Stack stack = m_stack;
			stack.Push(new StackFrame(message, (stack.Count>0) ? (StackFrame)stack.Peek() : null));

			return new AutoPopStackFrame(stack, stack.Count - 1);
		}]]></body>
          </codeblock>
        </method>
        <method name="ToString">
          <declaration><![CDATA[public override string ToString()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="209" sc="3" el="211" ec="4">log4net\Util\ThreadContextStack.cs</location>
            <body hash="2f125b0f35211370a831f85f9e907cbb"><![CDATA[{
			return GetFullMessage();
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_stack">
          <declaration><![CDATA[private Stack m_stack = new Stack();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Count">
          <declaration><![CDATA[public int Count]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="InternalStack">
          <declaration><![CDATA[internal Stack InternalStack]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ThreadContextStacks">
      <declaration><![CDATA[public sealed class ThreadContextStacks]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[internal ThreadContextStacks(ContextPropertiesBase properties)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="48" sc="3" el="51" ec="4">log4net\Util\ThreadContextStacks.cs</location>
            <body hash="5b77a25572ec61b3bb59ccab202e562e"><![CDATA[internal ThreadContextStacks(ContextPropertiesBase properties)
		{
			m_properties = properties;
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static ThreadContextStacks()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="119" sc="6" el="119" ec="79">log4net\Util\ThreadContextStacks.cs</location>
            <body hash="83c4647dbbc2ab20759b333d252dddf7"><![CDATA[private readonly static Type declaringType = typeof(ThreadContextStacks)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(ThreadContextStacks);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_properties">
          <declaration><![CDATA[private readonly ContextPropertiesBase m_properties;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Item">
          <declaration><![CDATA[public ThreadContextStack this[string key]]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="71" sc="4" el="105" ec="5">log4net\Util\ThreadContextStacks.cs</location>
            <body hash="15cd743e3c36da4cb23b112a0a9be90d"><![CDATA[{
				ThreadContextStack stack = null;

				object propertyValue = m_properties[key];
				if (propertyValue == null)
				{
					// Stack does not exist, create
					stack = new ThreadContextStack();
					m_properties[key] = stack;
				}
				else
				{
					// Look for existing stack
					stack = propertyValue as ThreadContextStack;
					if (stack == null)
					{
						// Property is not set to a stack!
						string propertyValueString = SystemInfo.NullText;

						try
						{
							propertyValueString = propertyValue.ToString();
						}
						catch
						{
						}

						LogLog.Error(declaringType, "ThreadContextStacks: Request for stack named ["+key+"] failed because a property with the same name exists which is a ["+propertyValue.GetType().Name+"] with value ["+propertyValueString+"]");

						stack = new ThreadContextStack();
					}
				}

				return stack;
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="Transform">
      <declaration><![CDATA[public sealed class Transform]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private Transform()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="49" sc="3" el="51" ec="4">log4net\Util\Transform.cs</location>
            <body hash="a839aad57cc877580fe58d58fe355e1d"><![CDATA[private Transform()
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static Transform()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="197" sc="3" el="197" ec="113">log4net\Util\Transform.cs</location>
            <body hash="20ff89b85abf2eec80895328256f7a7d"><![CDATA[private static Regex INVALIDCHARS=new Regex(@"[^\x09\x0A\x0D\x20-\uD7FF\uE000-\uFFFD]",RegexOptions.Compiled)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CountSubstrings">
          <declaration><![CDATA[private static int CountSubstrings(string text, string substring)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="157" sc="3" el="185" ec="4">log4net\Util\Transform.cs</location>
            <body hash="590e3ce271f412adab8bea4fe690b10b"><![CDATA[{
			int count = 0;
			int offset = 0;
			int length = text.Length;
			int substringLength = substring.Length;

			if (length == 0)
			{
				return 0;
			}
			if (substringLength == 0)
			{
				return 0;
			}

			while(offset < length)
			{
				int index = text.IndexOf(substring, offset);

				if (index == -1)
				{
					break;
				}

				count++;
				offset = index + substringLength;
			}
			return count;
		}]]></body>
          </codeblock>
        </method>
        <method name="MaskXmlInvalidCharacters">
          <declaration><![CDATA[public static string MaskXmlInvalidCharacters(string textData, string mask)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="137" sc="3" el="139" ec="4">log4net\Util\Transform.cs</location>
            <body hash="7bb8607bd95c2fa09b4d4d0503728507"><![CDATA[{
			return INVALIDCHARS.Replace(textData, mask);
		}]]></body>
          </codeblock>
        </method>
        <method name="WriteEscapedXmlString">
          <declaration><![CDATA[public static void WriteEscapedXmlString(XmlWriter writer, string textData, string invalidCharReplacement)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="70" sc="3" el="118" ec="4">log4net\Util\Transform.cs</location>
            <body hash="f8e29a268bd875fbc34f75f34c155d41"><![CDATA[{
			string stringData = MaskXmlInvalidCharacters(textData, invalidCharReplacement);
			// Write either escaped text or CDATA sections

			int weightCData = 12 * (1 + CountSubstrings(stringData, CDATA_END));
			int weightStringEscapes = 3*(CountSubstrings(stringData, "<") + CountSubstrings(stringData, ">")) + 4*CountSubstrings(stringData, "&");

			if (weightStringEscapes <= weightCData)
			{
				// Write string using string escapes
				writer.WriteString(stringData);
			}
			else
			{
				// Write string using CDATA section

				int end = stringData.IndexOf(CDATA_END);
	
				if (end < 0) 
				{
					writer.WriteCData(stringData);
				}
				else
				{
					int start = 0;
					while (end > -1) 
					{
						writer.WriteCData(stringData.Substring(start, end - start));
						if (end == stringData.Length - 3)
						{
							start = stringData.Length;
							writer.WriteString(CDATA_END);
							break;
						}
						else
						{
							writer.WriteString(CDATA_UNESCAPABLE_TOKEN);
							start = end + 2;
							end = stringData.IndexOf(CDATA_END, start);
						}
					}
	
					if (start < stringData.Length)
					{
						writer.WriteCData(stringData.Substring(start));
					}
				}
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="CDATA_END">
          <declaration><![CDATA[private const string CDATA_END = "";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="CDATA_UNESCAPABLE_TOKEN">
          <declaration><![CDATA[private const string CDATA_UNESCAPABLE_TOKEN = "]]";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="INVALIDCHARS">
          <declaration><![CDATA[private static Regex INVALIDCHARS = new Regex("[^\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD]", RegexOptions.Compiled);]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="t2);">
      <declaration><![CDATA[public delegate void TwoArgAction<T1, T2>(T1 t1, T2 t2);]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public extern TwoArgAction(object @object, IntPtr method);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="BeginInvoke">
          <declaration><![CDATA[public virtual extern IAsyncResult BeginInvoke(T1 t1, T2 t2, AsyncCallback callback, object @object);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="EndInvoke">
          <declaration><![CDATA[public virtual extern void EndInvoke(IAsyncResult result);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Invoke">
          <declaration><![CDATA[public virtual extern void Invoke(T1 t1, T2 t2);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="WindowsSecurityContext">
      <declaration><![CDATA[public class WindowsSecurityContext : log4net.Core.SecurityContext, IOptionHandler]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private WindowsSecurityContext.ImpersonationMode m_impersonationMode = WindowsSecurityContext.ImpersonationMode.User;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="77" sc="3" el="97" ec="4">log4net\Util\WindowsSecurityContext.cs</location>
            <body hash="af0d808a6926b2e53dab991c97a7dfef"><![CDATA[private ImpersonationMode m_impersonationMode = ImpersonationMode.User;
		private string m_userName;
		private string m_domainName = Environment.MachineName;
		private string m_password;
		private WindowsIdentity m_identity;

		#endregion

		#region Constructor

		/// <summary>
		/// Default constructor
		/// </summary>
		/// <remarks>
		/// <para>
		/// Default constructor
		/// </para>
		/// </remarks>
		public WindowsSecurityContext()
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="221" sc="3" el="230" ec="4">log4net\Util\WindowsSecurityContext.cs</location>
            <body hash="8f724ba553a18131cf2aca8435aab7ba"><![CDATA[{
			if (m_impersonationMode == ImpersonationMode.User)
			{
				if (m_userName == null) throw new ArgumentNullException("m_userName");
				if (m_domainName == null) throw new ArgumentNullException("m_domainName");
				if (m_password == null) throw new ArgumentNullException("m_password");

				m_identity = LogonUser(m_userName, m_domainName, m_password);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="CloseHandle">
          <declaration><![CDATA[private static extern bool CloseHandle(IntPtr handle);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="DuplicateToken">
          <declaration><![CDATA[private static extern bool DuplicateToken(IntPtr ExistingTokenHandle, int SECURITY_IMPERSONATION_LEVEL, ref IntPtr DuplicateTokenHandle);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Impersonate">
          <declaration><![CDATA[public override IDisposable Impersonate(object state)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="249" sc="3" el="263" ec="4">log4net\Util\WindowsSecurityContext.cs</location>
            <body hash="7769be4022e88e40872bdab310e4553e"><![CDATA[{
			if (m_impersonationMode == ImpersonationMode.User)
			{
				if (m_identity != null)
				{
					return new DisposableImpersonationContext(m_identity.Impersonate());
				}
			}
			else if (m_impersonationMode == ImpersonationMode.Process)
			{
				// Impersonate(0) will revert to the process credentials
				return new DisposableImpersonationContext(WindowsIdentity.Impersonate(IntPtr.Zero));
			}
			return null;
		}]]></body>
          </codeblock>
        </method>
        <method name="LogonUser">
          <declaration><![CDATA[private static WindowsIdentity LogonUser(string userName, string domainName, string password)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="283" sc="3" el="321" ec="4">log4net\Util\WindowsSecurityContext.cs</location>
            <body hash="610cfcb9709dcab304d3429344c1fde6"><![CDATA[{
			const int LOGON32_PROVIDER_DEFAULT = 0;
			//This parameter causes LogonUser to create a primary token.
			const int LOGON32_LOGON_INTERACTIVE = 2;

			// Call LogonUser to obtain a handle to an access token.
			IntPtr tokenHandle = IntPtr.Zero;
			if(!LogonUser(userName, domainName, password, LOGON32_LOGON_INTERACTIVE, LOGON32_PROVIDER_DEFAULT, ref tokenHandle))
			{
				NativeError error = NativeError.GetLastError();
				throw new Exception("Failed to LogonUser ["+userName+"] in Domain ["+domainName+"]. Error: "+ error.ToString());
			}

			const int SecurityImpersonation = 2;
			IntPtr dupeTokenHandle = IntPtr.Zero;
			if(!DuplicateToken(tokenHandle, SecurityImpersonation, ref dupeTokenHandle))
			{
				NativeError error = NativeError.GetLastError();
				if (tokenHandle != IntPtr.Zero)
				{
					CloseHandle(tokenHandle);
				}
				throw new Exception("Failed to DuplicateToken after LogonUser. Error: " + error.ToString());
			}

			WindowsIdentity identity = new WindowsIdentity(dupeTokenHandle);

			// Free the tokens.
			if (dupeTokenHandle != IntPtr.Zero) 
			{
				CloseHandle(dupeTokenHandle);
			}
			if (tokenHandle != IntPtr.Zero)
			{
				CloseHandle(tokenHandle);
			}

			return identity;
		}]]></body>
          </codeblock>
        </method>
        <method name="LogonUser">
          <declaration><![CDATA[private static extern bool LogonUser(string lpszUsername, string lpszDomain, string lpszPassword, int dwLogonType, int dwLogonProvider, ref IntPtr phToken);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_domainName">
          <declaration><![CDATA[private string m_domainName = Environment.MachineName;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_identity">
          <declaration><![CDATA[private WindowsIdentity m_identity;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_impersonationMode">
          <declaration><![CDATA[private WindowsSecurityContext.ImpersonationMode m_impersonationMode = WindowsSecurityContext.ImpersonationMode.User;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_password">
          <declaration><![CDATA[private string m_password;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_userName">
          <declaration><![CDATA[private string m_userName;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Credentials">
          <declaration><![CDATA[public WindowsSecurityContext.ImpersonationMode Credentials]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="DomainName">
          <declaration><![CDATA[public string DomainName]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Password">
          <declaration><![CDATA[public string Password]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="UserName">
          <declaration><![CDATA[public string UserName]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="log4net.Util.PatternStringConverters">
    <class name="AppDomainPatternConverter">
      <declaration><![CDATA[internal sealed class AppDomainPatternConverter : PatternConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public AppDomainPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, object state)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="50" sc="3" el="52" ec="4">log4net\Util\PatternStringConverters\AppDomainPatternConverter.cs</location>
            <body hash="457de1516cb01ff9cce51b959f781340"><![CDATA[{
			writer.Write( SystemInfo.ApplicationFriendlyName );
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="AppSettingPatternConverter">
      <declaration><![CDATA[internal sealed class AppSettingPatternConverter : PatternConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public AppSettingPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, object state)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="98" sc="9" el="110" ec="10">log4net\Util\PatternStringConverters\AppSettingPatternConverter.cs</location>
            <body hash="15a82311d40b0d25a605703921a4a818"><![CDATA[{

            if (Option != null)
            {
                // Write the value for the specified key
                WriteObject(writer, null, System.Configuration.ConfigurationManager.AppSettings[Option]);
            }
            else
            {
                // Write all the key value pairs
                WriteDictionary(writer, null, AppSettingsDictionary);
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_appSettingsHashTable">
          <declaration><![CDATA[private static Hashtable _appSettingsHashTable;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="AppSettingsDictionary">
          <declaration><![CDATA[private static IDictionary AppSettingsDictionary]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="65" sc="13" el="76" ec="14">log4net\Util\PatternStringConverters\AppSettingPatternConverter.cs</location>
            <body hash="27136b3f5f4a73f4736d97b8c48ca58b"><![CDATA[{
                if (_appSettingsHashTable == null)
                {
                    Hashtable h = new Hashtable();
                    foreach(string key in System.Configuration.ConfigurationManager.AppSettings)
                    {
                        h.Add(key, System.Configuration.ConfigurationManager.AppSettings[key]);
                    }
                    _appSettingsHashTable = h;
                }
                return _appSettingsHashTable;
            }]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="DatePatternConverter">
      <declaration><![CDATA[internal class DatePatternConverter : PatternConverter, IOptionHandler]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public DatePatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static DatePatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="185" sc="6" el="185" ec="80">log4net\Util\PatternStringConverters\DatePatternConverter.cs</location>
            <body hash="0c90379b107c4db7b94a89608b151459"><![CDATA[private readonly static Type declaringType = typeof(DatePatternConverter)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="114" sc="3" el="146" ec="4">log4net\Util\PatternStringConverters\DatePatternConverter.cs</location>
            <body hash="bc2c97c748e98f476eb8d3ba6acc506a"><![CDATA[{
			string dateFormatStr = Option;

			if (dateFormatStr == null)
			{
				dateFormatStr = AbsoluteTimeDateFormatter.Iso8601TimeDateFormat;
			}
			
			if (SystemInfo.EqualsIgnoringCase(dateFormatStr, AbsoluteTimeDateFormatter.Iso8601TimeDateFormat))
			{
				m_dateFormatter = new Iso8601DateFormatter();
			}
			else if (SystemInfo.EqualsIgnoringCase(dateFormatStr, AbsoluteTimeDateFormatter.AbsoluteTimeDateFormat))
			{
				m_dateFormatter = new AbsoluteTimeDateFormatter();
			}
			else if (SystemInfo.EqualsIgnoringCase(dateFormatStr, AbsoluteTimeDateFormatter.DateAndTimeDateFormat))
			{
				m_dateFormatter = new DateTimeDateFormatter();
			}
			else
			{
				try 
				{
					m_dateFormatter = new SimpleDateFormatter(dateFormatStr);
				}
				catch (Exception e) 
				{
					LogLog.Error(declaringType, "Could not instantiate SimpleDateFormatter with ["+dateFormatStr+"]", e);
					m_dateFormatter = new Iso8601DateFormatter();
				}	
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, object state)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="165" sc="3" el="174" ec="4">log4net\Util\PatternStringConverters\DatePatternConverter.cs</location>
            <body hash="50fdffbf587d3bcd99a3cf5bf80a6b01"><![CDATA[{
			try 
			{
				m_dateFormatter.FormatDate(DateTime.Now, writer);
			}
			catch (Exception ex) 
			{
				LogLog.Error(declaringType, "Error occurred while converting date.", ex);
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(DatePatternConverter);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_dateFormatter">
          <declaration><![CDATA[protected IDateFormatter m_dateFormatter;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="EnvironmentFolderPathPatternConverter">
      <declaration><![CDATA[internal sealed class EnvironmentFolderPathPatternConverter : PatternConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public EnvironmentFolderPathPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static EnvironmentFolderPathPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="92" sc="9" el="92" ec="100">log4net\Util\PatternStringConverters\EnvironmentFolderPathPatternConverter.cs</location>
            <body hash="270b16a475e01a83bf5fe061354f77f0"><![CDATA[private readonly static Type declaringType = typeof(EnvironmentFolderPathPatternConverter)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, object state)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="55" sc="9" el="81" ec="10">log4net\Util\PatternStringConverters\EnvironmentFolderPathPatternConverter.cs</location>
            <body hash="8d17ed350e370aab49b5c3509a2687a4"><![CDATA[{
            try
            {
                if (Option != null && Option.Length > 0)
                {
                    Environment.SpecialFolder specialFolder =
                        (Environment.SpecialFolder)Enum.Parse(typeof(Environment.SpecialFolder), Option, true);

                    string envFolderPathValue = Environment.GetFolderPath(specialFolder);
                    if (envFolderPathValue != null && envFolderPathValue.Length > 0)
                    {
                        writer.Write(envFolderPathValue);
                    }
                }
            }
            catch (System.Security.SecurityException secEx)
            {
                // This security exception will occur if the caller does not have 
                // unrestricted environment permission. If this occurs the expansion 
                // will be skipped with the following warning message.
                LogLog.Debug(declaringType, "Security exception while trying to expand environment variables. Error Ignored. No Expansion.", secEx);
            }
            catch (Exception ex)
            {
                LogLog.Error(declaringType, "Error occurred while converting environment variable.", ex);
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(EnvironmentFolderPathPatternConverter);]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="EnvironmentPatternConverter">
      <declaration><![CDATA[internal sealed class EnvironmentPatternConverter : PatternConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public EnvironmentPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static EnvironmentPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="110" sc="6" el="110" ec="87">log4net\Util\PatternStringConverters\EnvironmentPatternConverter.cs</location>
            <body hash="25b26704b23b4a530b3359b2fbeaa5f5"><![CDATA[private readonly static Type declaringType = typeof(EnvironmentPatternConverter)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, object state)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="60" sc="3" el="99" ec="4">log4net\Util\PatternStringConverters\EnvironmentPatternConverter.cs</location>
            <body hash="4561031d523b8a66cd73f8447eb6ab7d"><![CDATA[{
			try 
			{
				if (this.Option != null && this.Option.Length > 0)
				{
					// Lookup the environment variable
					string envValue = Environment.GetEnvironmentVariable(this.Option);

#if NET_2_0					
                    // If we didn't see it for the process, try a user level variable.
				    if (envValue == null)
				    {
				        envValue = Environment.GetEnvironmentVariable(this.Option, EnvironmentVariableTarget.User);
				    }

                    // If we still didn't find it, try a system level one.
				    if (envValue == null)
				    {
				        envValue = Environment.GetEnvironmentVariable(this.Option, EnvironmentVariableTarget.Machine);
				    }
#endif					

					if (envValue != null && envValue.Length > 0)
					{
						writer.Write(envValue);
					}
				}
			}
			catch(System.Security.SecurityException secEx)
			{
				// This security exception will occur if the caller does not have 
				// unrestricted environment permission. If this occurs the expansion 
				// will be skipped with the following warning message.
				LogLog.Debug(declaringType, "Security exception while trying to expand environment variables. Error Ignored. No Expansion.", secEx);
			}
			catch (Exception ex) 
			{
				LogLog.Error(declaringType, "Error occurred while converting environment variable.", ex);
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(EnvironmentPatternConverter);]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="IdentityPatternConverter">
      <declaration><![CDATA[internal sealed class IdentityPatternConverter : PatternConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public IdentityPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static IdentityPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="84" sc="6" el="84" ec="84">log4net\Util\PatternStringConverters\IdentityPatternConverter.cs</location>
            <body hash="be9f27dc2cb857444643fbf6f44f743e"><![CDATA[private readonly static Type declaringType = typeof(IdentityPatternConverter)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, object state)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="50" sc="3" el="73" ec="4">log4net\Util\PatternStringConverters\IdentityPatternConverter.cs</location>
            <body hash="3004fa718932e654c63bf843c7cde8e1"><![CDATA[{
#if (NETCF || SSCLI || NETSTANDARD1_3)
			// On compact framework there's no notion of current thread principals
			writer.Write( SystemInfo.NotAvailableText );
#else
			try
			{
				if (System.Threading.Thread.CurrentPrincipal != null && 
					System.Threading.Thread.CurrentPrincipal.Identity != null &&
					System.Threading.Thread.CurrentPrincipal.Identity.Name != null)
				{
					writer.Write( System.Threading.Thread.CurrentPrincipal.Identity.Name );
				}
			}
			catch(System.Security.SecurityException)
			{
				// This security exception will occur if the caller does not have 
				// some undefined set of SecurityPermission flags.
				LogLog.Debug(declaringType, "Security exception while trying to get current thread principal. Error Ignored.");

				writer.Write( SystemInfo.NotAvailableText );
			}
#endif
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(IdentityPatternConverter);]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="LiteralPatternConverter">
      <declaration><![CDATA[internal class LiteralPatternConverter : PatternConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public LiteralPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, object state)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="103" sc="3" el="104" ec="105">log4net\Util\PatternStringConverters\LiteralPatternConverter.cs</location>
            <body hash="94f2bbb16ad142d06584282ef657a3ea"><![CDATA[{
			throw new InvalidOperationException("Should never get here because of the overridden Format method");]]></body>
          </codeblock>
        </method>
        <method name="Format">
          <declaration><![CDATA[public override void Format(TextWriter writer, object state)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="88" sc="3" el="90" ec="4">log4net\Util\PatternStringConverters\LiteralPatternConverter.cs</location>
            <body hash="c4ba1afb2fc1343a8755cf8556c51d10"><![CDATA[{
			writer.Write(Option);
		}]]></body>
          </codeblock>
        </method>
        <method name="SetNext">
          <declaration><![CDATA[public override PatternConverter SetNext(PatternConverter pc)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="58" sc="3" el="70" ec="4">log4net\Util\PatternStringConverters\LiteralPatternConverter.cs</location>
            <body hash="ea657845484ddb8ca3f85f82d5706f84"><![CDATA[{
			LiteralPatternConverter literalPc = pc as LiteralPatternConverter;
			if (literalPc != null)
			{
				// Combine the two adjacent literals together
				Option = Option + literalPc.Option;

				// We are the next converter now
				return this;
			}

			return base.SetNext(pc);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="NewLinePatternConverter">
      <declaration><![CDATA[internal sealed class NewLinePatternConverter : LiteralPatternConverter, IOptionHandler]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public NewLinePatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="69" sc="3" el="82" ec="4">log4net\Util\PatternStringConverters\NewLinePatternConverter.cs</location>
            <body hash="13550ebfa37fa7e2eb3f921f16475953"><![CDATA[{
			if (SystemInfo.EqualsIgnoringCase(Option, "DOS"))
			{
				Option = "\r\n";
			}
			else if (SystemInfo.EqualsIgnoringCase(Option, "UNIX"))
			{
				Option = "\n";
			}
			else
			{
				Option = SystemInfo.NewLine;
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="ProcessIdPatternConverter">
      <declaration><![CDATA[internal sealed class ProcessIdPatternConverter : PatternConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ProcessIdPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static ProcessIdPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="82" sc="6" el="82" ec="85">log4net\Util\PatternStringConverters\ProcessIdPatternConverter.cs</location>
            <body hash="1a1b11adf1e350fd1b60452c6f2925b3"><![CDATA[private readonly static Type declaringType = typeof(ProcessIdPatternConverter)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, object state)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="53" sc="3" el="71" ec="4">log4net\Util\PatternStringConverters\ProcessIdPatternConverter.cs</location>
            <body hash="01b6e198f4f7fd4cc8a1370b19807613"><![CDATA[{
#if (NETCF || SSCLI)
			// On compact framework there is no System.Diagnostics.Process class
			writer.Write( SystemInfo.NotAvailableText );
#else
			try
			{
				writer.Write( System.Diagnostics.Process.GetCurrentProcess().Id );
			}
			catch(System.Security.SecurityException)
			{
				// This security exception will occur if the caller does not have 
				// some undefined set of SecurityPermission flags.
				LogLog.Debug(declaringType, "Security exception while trying to get current process id. Error Ignored.");

				writer.Write( SystemInfo.NotAvailableText );
			}
#endif
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(ProcessIdPatternConverter);]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="PropertyPatternConverter">
      <declaration><![CDATA[internal sealed class PropertyPatternConverter : PatternConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public PropertyPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, object state)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="68" sc="3" el="97" ec="4">log4net\Util\PatternStringConverters\PropertyPatternConverter.cs</location>
            <body hash="44d9280f1f27ffb48a8c92dfd1ce17df"><![CDATA[{
			CompositeProperties compositeProperties = new CompositeProperties();

#if !(NETCF || NETSTANDARD1_3)
			PropertiesDictionary logicalThreadProperties = LogicalThreadContext.Properties.GetProperties(false);
			if (logicalThreadProperties != null)
			{
				compositeProperties.Add(logicalThreadProperties);
			}
#endif
			PropertiesDictionary threadProperties = ThreadContext.Properties.GetProperties(false);
			if (threadProperties != null)
			{
				compositeProperties.Add(threadProperties);
			}

			// TODO: Add Repository Properties
			compositeProperties.Add(GlobalContext.Properties.GetReadOnlyProperties());

			if (Option != null)
			{
				// Write the value for the specified key
				WriteObject(writer, null, compositeProperties[Option]);
			}
			else
			{
				// Write all the key value pairs
				WriteDictionary(writer, null, compositeProperties.Flatten());
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="RandomStringPatternConverter">
      <declaration><![CDATA[internal sealed class RandomStringPatternConverter : PatternConverter, IOptionHandler]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private int m_length = 4;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="58" sc="3" el="58" ec="28">log4net\Util\PatternStringConverters\RandomStringPatternConverter.cs</location>
            <body hash="b8c3bfbca84f15757748ac2ec2200fb3"><![CDATA[private int m_length = 4]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static RandomStringPatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="53" sc="3" el="152" ec="88">log4net\Util\PatternStringConverters\RandomStringPatternConverter.cs</location>
            <body hash="a9861495cbf50de789a4c1e7a6e29ad2"><![CDATA[private static readonly Random s_random = new Random();

		/// <summary>
		/// Length of random string to generate. Default length 4.
		/// </summary>
		private int m_length = 4;

		#region Implementation of IOptionHandler

		/// <summary>
		/// Initialize the converter options
		/// </summary>
		/// <remarks>
		/// <para>
		/// This is part of the <see cref="IOptionHandler"/> delayed object
		/// activation scheme. The <see cref="ActivateOptions"/> method must 
		/// be called on this object after the configuration properties have
		/// been set. Until <see cref="ActivateOptions"/> is called this
		/// object is in an undefined state and must not be used. 
		/// </para>
		/// <para>
		/// If any of the configuration properties are modified then 
		/// <see cref="ActivateOptions"/> must be called again.
		/// </para>
		/// </remarks>
		public void ActivateOptions()
		{
			string optionStr = Option;
			if (optionStr != null && optionStr.Length > 0)
			{
				int lengthVal;
				if (SystemInfo.TryParse(optionStr, out lengthVal))
				{
					m_length = lengthVal;
				}
				else
				{
					LogLog.Error(declaringType, "RandomStringPatternConverter: Could not convert Option ["+optionStr+"] to Length Int32");
				}	
			}
		}

		#endregion

		/// <summary>
		/// Write a randoim string to the output
		/// </summary>
		/// <param name="writer">the writer to write to</param>
		/// <param name="state">null, state is not set</param>
		/// <remarks>
		/// <para>
		/// Write a randoim string to the output <paramref name="writer"/>.
		/// </para>
		/// </remarks>
		override protected void Convert(TextWriter writer, object state) 
		{
			try 
			{
				lock(s_random)
				{
					for(int i=0; i<m_length; i++)
					{
						int randValue = s_random.Next(36);

						if (randValue < 26)
						{
							// Letter
							char ch = (char)('A' + randValue);
							writer.Write(ch);
						}
						else if (randValue < 36)
						{
							// Number
							char ch = (char)('0' + (randValue - 26));
							writer.Write(ch);
						}
						else
						{
							// Should not get here
							writer.Write('X');
						}
					}
				}
			}
			catch (Exception ex) 
			{
				LogLog.Error(declaringType, "Error occurred while converting.", ex);
			}
		}

	    #region Private Static Fields

	    /// <summary>
	    /// The fully qualified type of the RandomStringPatternConverter class.
	    /// </summary>
	    /// <remarks>
	    /// Used by the internal logger to record the Type of the
	    /// log message.
	    /// </remarks>
	    private readonly static Type declaringType = typeof(RandomStringPatternConverter);]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ActivateOptions">
          <declaration><![CDATA[public void ActivateOptions()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="79" sc="3" el="93" ec="4">log4net\Util\PatternStringConverters\RandomStringPatternConverter.cs</location>
            <body hash="bd84d1d2076733312e86f267923c0162"><![CDATA[{
			string optionStr = Option;
			if (optionStr != null && optionStr.Length > 0)
			{
				int lengthVal;
				if (SystemInfo.TryParse(optionStr, out lengthVal))
				{
					m_length = lengthVal;
				}
				else
				{
					LogLog.Error(declaringType, "RandomStringPatternConverter: Could not convert Option ["+optionStr+"] to Length Int32");
				}	
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, object state)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="108" sc="3" el="141" ec="4">log4net\Util\PatternStringConverters\RandomStringPatternConverter.cs</location>
            <body hash="01bd3057fe9e163ed2072e58653a6874"><![CDATA[{
			try 
			{
				lock(s_random)
				{
					for(int i=0; i<m_length; i++)
					{
						int randValue = s_random.Next(36);

						if (randValue < 26)
						{
							// Letter
							char ch = (char)('A' + randValue);
							writer.Write(ch);
						}
						else if (randValue < 36)
						{
							// Number
							char ch = (char)('0' + (randValue - 26));
							writer.Write(ch);
						}
						else
						{
							// Should not get here
							writer.Write('X');
						}
					}
				}
			}
			catch (Exception ex) 
			{
				LogLog.Error(declaringType, "Error occurred while converting.", ex);
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(RandomStringPatternConverter);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_length">
          <declaration><![CDATA[private int m_length = 4;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="s_random">
          <declaration><![CDATA[private static readonly Random s_random = new Random();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="UserNamePatternConverter">
      <declaration><![CDATA[internal sealed class UserNamePatternConverter : PatternConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public UserNamePatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static UserNamePatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="84" sc="6" el="84" ec="84">log4net\Util\PatternStringConverters\UserNamePatternConverter.cs</location>
            <body hash="09a97c2895228b826b9d8bc51556c5f1"><![CDATA[private readonly static Type declaringType = typeof(UserNamePatternConverter)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, object state)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="50" sc="3" el="73" ec="4">log4net\Util\PatternStringConverters\UserNamePatternConverter.cs</location>
            <body hash="2db73001508bce19c1704c733ba1e785"><![CDATA[{
#if (NETCF || SSCLI || NETSTANDARD1_3)
			// On compact framework there's no notion of current Windows user
			writer.Write( SystemInfo.NotAvailableText );
#else
			try
			{
				System.Security.Principal.WindowsIdentity windowsIdentity = null;
				windowsIdentity = System.Security.Principal.WindowsIdentity.GetCurrent();
				if (windowsIdentity != null && windowsIdentity.Name != null)
				{
					writer.Write( windowsIdentity.Name );
				}
			}
			catch(System.Security.SecurityException)
			{
				// This security exception will occur if the caller does not have 
				// some undefined set of SecurityPermission flags.
				LogLog.Debug(declaringType, "Security exception while trying to get current windows identity. Error Ignored.");

				writer.Write( SystemInfo.NotAvailableText );
			}
#endif
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(UserNamePatternConverter);]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="UtcDatePatternConverter">
      <declaration><![CDATA[internal class UtcDatePatternConverter : DatePatternConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public UtcDatePatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static UtcDatePatternConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="82" sc="6" el="82" ec="83">log4net\Util\PatternStringConverters\UtcDatePatternConverter.cs</location>
            <body hash="e6142569c1e175afd5b75dc61c839d62"><![CDATA[private readonly static Type declaringType = typeof(UtcDatePatternConverter)]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Convert">
          <declaration><![CDATA[protected override void Convert(TextWriter writer, object state)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="62" sc="3" el="71" ec="4">log4net\Util\PatternStringConverters\UtcDatePatternConverter.cs</location>
            <body hash="be12063fbb2f568d40690502f9437b89"><![CDATA[{
			try 
			{
				m_dateFormatter.FormatDate(DateTime.UtcNow, writer);
			}
			catch (Exception ex) 
			{
				LogLog.Error(declaringType, "Error occurred while converting date.", ex);
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType = typeof(UtcDatePatternConverter);]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="log4net.Util.TypeConverters">
    <class name="BooleanConverter">
      <declaration><![CDATA[internal class BooleanConverter : IConvertFrom]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public BooleanConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CanConvertFrom">
          <declaration><![CDATA[public bool CanConvertFrom(Type sourceType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="53" sc="3" el="55" ec="4">log4net\Util\TypeConverters\BooleanConverter.cs</location>
            <body hash="9799dc099b63091587707e065d77ea21"><![CDATA[{
			return (sourceType == typeof(string));
		}]]></body>
          </codeblock>
        </method>
        <method name="ConvertFrom">
          <declaration><![CDATA[public object ConvertFrom(object source)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="74" sc="3" el="81" ec="4">log4net\Util\TypeConverters\BooleanConverter.cs</location>
            <body hash="9f569f80797273df3100b07ebdf518b2"><![CDATA[{
			string str = source as string;
			if (str != null)
			{
				return bool.Parse(str);
			}
			throw ConversionNotSupportedException.Create(typeof(bool), source);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="ConversionNotSupportedException">
      <declaration><![CDATA[public class ConversionNotSupportedException : ApplicationException]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ConversionNotSupportedException()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="58" sc="3" el="60" ec="4">log4net\Util\TypeConverters\ConversionNotSupportedException.cs</location>
            <body hash="802cfb6301ac44207f547584bc2cbfc4"><![CDATA[public ConversionNotSupportedException()
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public ConversionNotSupportedException(string message) : base(message)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="72" sc="60" el="74" ec="4">log4net\Util\TypeConverters\ConversionNotSupportedException.cs</location>
            <body hash="e61467aad6c9bdbf17f18adbd74c1180"><![CDATA[base(message) 
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public ConversionNotSupportedException(string message, Exception innerException) : base(message, innerException)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="87" sc="86" el="89" ec="4">log4net\Util\TypeConverters\ConversionNotSupportedException.cs</location>
            <body hash="adee082fc541698d386a0906598818b0"><![CDATA[base(message, innerException) 
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[protected ConversionNotSupportedException(SerializationInfo info, StreamingContext context) : base(info, context)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="107" sc="97" el="109" ec="4">log4net\Util\TypeConverters\ConversionNotSupportedException.cs</location>
            <body hash="59699d51c1ad68f31a363ee6e3b56629"><![CDATA[base(info, context) 
		{
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Create">
          <declaration><![CDATA[public static ConversionNotSupportedException Create(Type destinationType, object sourceValue)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="128" sc="3" el="130" ec="4">log4net\Util\TypeConverters\ConversionNotSupportedException.cs</location>
            <body hash="d8dd84f516c870499df405453a4711e2"><![CDATA[{
			return Create(destinationType, sourceValue, null);
		}]]></body>
          </codeblock>
        </method>
        <method name="Create">
          <declaration><![CDATA[public static ConversionNotSupportedException Create(Type destinationType, object sourceValue, Exception innerException)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="145" sc="3" el="154" ec="4">log4net\Util\TypeConverters\ConversionNotSupportedException.cs</location>
            <body hash="75b58778ce66985babcb923ddf46b8a1"><![CDATA[{
			if (sourceValue == null)
			{
				return new ConversionNotSupportedException("Cannot convert value [null] to type ["+destinationType+"]", innerException);
			}
			else
			{
				return new ConversionNotSupportedException("Cannot convert from type ["+sourceValue.GetType()+"] value ["+sourceValue+"] to type ["+destinationType+"]", innerException);
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="ConverterRegistry">
      <declaration><![CDATA[public sealed class ConverterRegistry]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private ConverterRegistry()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="59" sc="3" el="61" ec="4">log4net\Util\TypeConverters\ConverterRegistry.cs</location>
            <body hash="77b0a2933b76422a3736decdb0c33592"><![CDATA[private ConverterRegistry() 
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static ConverterRegistry()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="76" sc="3" el="292" ec="63">log4net\Util\TypeConverters\ConverterRegistry.cs</location>
            <body hash="00ccd806c61e8ea7171064bab362d407"><![CDATA[{
			// Add predefined converters here
			AddConverter(typeof(bool), typeof(BooleanConverter));
			AddConverter(typeof(System.Text.Encoding), typeof(EncodingConverter));
			AddConverter(typeof(System.Type), typeof(TypeConverter));
			AddConverter(typeof(log4net.Layout.PatternLayout), typeof(PatternLayoutConverter));
			AddConverter(typeof(log4net.Util.PatternString), typeof(PatternStringConverter));
			AddConverter(typeof(System.Net.IPAddress), typeof(IPAddressConverter));
		}

		#endregion Static Constructor

		#region Public Static Methods

		/// <summary>
		/// Adds a converter for a specific type.
		/// </summary>
		/// <param name="destinationType">The type being converted to.</param>
		/// <param name="converter">The type converter to use to convert to the destination type.</param>
		/// <remarks>
		/// <para>
		/// Adds a converter instance for a specific type.
		/// </para>
		/// </remarks>
		public static void AddConverter(Type destinationType, object converter)
		{
			if (destinationType != null && converter != null)
			{
				lock(s_type2converter)
				{
					s_type2converter[destinationType] = converter;
				}
			}
		}

		/// <summary>
		/// Adds a converter for a specific type.
		/// </summary>
		/// <param name="destinationType">The type being converted to.</param>
		/// <param name="converterType">The type of the type converter to use to convert to the destination type.</param>
		/// <remarks>
		/// <para>
		/// Adds a converter <see cref="Type"/> for a specific type.
		/// </para>
		/// </remarks>
		public static void AddConverter(Type destinationType, Type converterType)
		{
			AddConverter(destinationType, CreateConverterInstance(converterType));
		}

		/// <summary>
		/// Gets the type converter to use to convert values to the destination type.
		/// </summary>
		/// <param name="sourceType">The type being converted from.</param>
		/// <param name="destinationType">The type being converted to.</param>
		/// <returns>
		/// The type converter instance to use for type conversions or <c>null</c> 
		/// if no type converter is found.
		/// </returns>
		/// <remarks>
		/// <para>
		/// Gets the type converter to use to convert values to the destination type.
		/// </para>
		/// </remarks>
		public static IConvertTo GetConvertTo(Type sourceType, Type destinationType)
		{
			// TODO: Support inheriting type converters.
			// i.e. getting a type converter for a base of sourceType

			// TODO: Is destinationType required? We don't use it for anything.

			lock(s_type2converter)
			{
				// Lookup in the static registry
				IConvertTo converter = s_type2converter[sourceType] as IConvertTo;

				if (converter == null)
				{
					// Lookup using attributes
					converter = GetConverterFromAttribute(sourceType) as IConvertTo;

					if (converter != null)
					{
						// Store in registry
						s_type2converter[sourceType] = converter;
					}
				}

				return converter;
			}
		}

		/// <summary>
		/// Gets the type converter to use to convert values to the destination type.
		/// </summary>
		/// <param name="destinationType">The type being converted to.</param>
		/// <returns>
		/// The type converter instance to use for type conversions or <c>null</c> 
		/// if no type converter is found.
		/// </returns>
		/// <remarks>
		/// <para>
		/// Gets the type converter to use to convert values to the destination type.
		/// </para>
		/// </remarks>
		public static IConvertFrom GetConvertFrom(Type destinationType)
		{
			// TODO: Support inheriting type converters.
			// i.e. getting a type converter for a base of destinationType

			lock(s_type2converter)
			{
				// Lookup in the static registry
				IConvertFrom converter = s_type2converter[destinationType] as IConvertFrom;

				if (converter == null)
				{
					// Lookup using attributes
					converter = GetConverterFromAttribute(destinationType) as IConvertFrom;

					if (converter != null)
					{
						// Store in registry
						s_type2converter[destinationType] = converter;
					}
				}

				return converter;
			}
		}
		
		/// <summary>
		/// Lookups the type converter to use as specified by the attributes on the 
		/// destination type.
		/// </summary>
		/// <param name="destinationType">The type being converted to.</param>
		/// <returns>
		/// The type converter instance to use for type conversions or <c>null</c> 
		/// if no type converter is found.
		/// </returns>
		private static object GetConverterFromAttribute(Type destinationType)
		{
			// Look for an attribute on the destination type
			object[] attributes = destinationType.GetCustomAttributes(typeof(TypeConverterAttribute), true);
			if (attributes != null && attributes.Length > 0)
			{
				TypeConverterAttribute tcAttr = attributes[0] as TypeConverterAttribute;
				if (tcAttr != null)
				{
					Type converterType = SystemInfo.GetTypeFromString(destinationType, tcAttr.ConverterTypeName, false, true);
					return CreateConverterInstance(converterType);
				}
			}

			// Not found converter using attributes
			return null;
		}

		/// <summary>
		/// Creates the instance of the type converter.
		/// </summary>
		/// <param name="converterType">The type of the type converter.</param>
		/// <returns>
		/// The type converter instance to use for type conversions or <c>null</c> 
		/// if no type converter is found.
		/// </returns>
		/// <remarks>
		/// <para>
		/// The type specified for the type converter must implement 
		/// the <see cref="IConvertFrom"/> or <see cref="IConvertTo"/> interfaces 
		/// and must have a public default (no argument) constructor.
		/// </para>
		/// </remarks>
		private static object CreateConverterInstance(Type converterType)
		{
			if (converterType == null)
			{
				throw new ArgumentNullException("converterType", "CreateConverterInstance cannot create instance, converterType is null");
			}

			// Check type is a converter
			if (typeof(IConvertFrom).IsAssignableFrom(converterType) || typeof(IConvertTo).IsAssignableFrom(converterType))
			{
				try
				{
					// Create the type converter
					return Activator.CreateInstance(converterType);
				}
				catch(Exception ex)
				{
					LogLog.Error(declaringType, "Cannot CreateConverterInstance of type ["+converterType.FullName+"], Exception in call to Activator.CreateInstance", ex);
				}
			}
			else
			{
				LogLog.Error(declaringType, "Cannot CreateConverterInstance of type ["+converterType.FullName+"], type does not implement IConvertFrom or IConvertTo");
			}
			return null;
		}

		#endregion Public Static Methods

		#region Private Static Fields

	    /// <summary>
	    /// The fully qualified type of the ConverterRegistry class.
	    /// </summary>
	    /// <remarks>
	    /// Used by the internal logger to record the Type of the
	    /// log message.
	    /// </remarks>
	    private readonly static Type declaringType = typeof(ConverterRegistry);

		/// <summary>
		/// Mapping from <see cref="Type" /> to type converter.
		/// </summary>
		private static Hashtable s_type2converter = new Hashtable();]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AddConverter">
          <declaration><![CDATA[public static void AddConverter(Type destinationType, object converter)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="101" sc="3" el="109" ec="4">log4net\Util\TypeConverters\ConverterRegistry.cs</location>
            <body hash="8f21a076a9ccad1945c69698fa279611"><![CDATA[{
			if (destinationType != null && converter != null)
			{
				lock(s_type2converter)
				{
					s_type2converter[destinationType] = converter;
				}
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="AddConverter">
          <declaration><![CDATA[public static void AddConverter(Type destinationType, Type converterType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="122" sc="3" el="124" ec="4">log4net\Util\TypeConverters\ConverterRegistry.cs</location>
            <body hash="80a972462078c6e066a84e3e71012f94"><![CDATA[{
			AddConverter(destinationType, CreateConverterInstance(converterType));
		}]]></body>
          </codeblock>
        </method>
        <method name="CreateConverterInstance">
          <declaration><![CDATA[private static object CreateConverterInstance(Type converterType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="250" sc="3" el="274" ec="4">log4net\Util\TypeConverters\ConverterRegistry.cs</location>
            <body hash="cd6ec097682c35c02f3d7903fd98dd11"><![CDATA[{
			if (converterType == null)
			{
				throw new ArgumentNullException("converterType", "CreateConverterInstance cannot create instance, converterType is null");
			}

			// Check type is a converter
			if (typeof(IConvertFrom).IsAssignableFrom(converterType) || typeof(IConvertTo).IsAssignableFrom(converterType))
			{
				try
				{
					// Create the type converter
					return Activator.CreateInstance(converterType);
				}
				catch(Exception ex)
				{
					LogLog.Error(declaringType, "Cannot CreateConverterInstance of type ["+converterType.FullName+"], Exception in call to Activator.CreateInstance", ex);
				}
			}
			else
			{
				LogLog.Error(declaringType, "Cannot CreateConverterInstance of type ["+converterType.FullName+"], type does not implement IConvertFrom or IConvertTo");
			}
			return null;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetConverterFromAttribute">
          <declaration><![CDATA[private static object GetConverterFromAttribute(Type destinationType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="217" sc="3" el="232" ec="4">log4net\Util\TypeConverters\ConverterRegistry.cs</location>
            <body hash="92cdf595fb0af601a22d845eefe0d914"><![CDATA[{
			// Look for an attribute on the destination type
			object[] attributes = destinationType.GetCustomAttributes(typeof(TypeConverterAttribute), true);
			if (attributes != null && attributes.Length > 0)
			{
				TypeConverterAttribute tcAttr = attributes[0] as TypeConverterAttribute;
				if (tcAttr != null)
				{
					Type converterType = SystemInfo.GetTypeFromString(destinationType, tcAttr.ConverterTypeName, false, true);
					return CreateConverterInstance(converterType);
				}
			}

			// Not found converter using attributes
			return null;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetConvertFrom">
          <declaration><![CDATA[public static IConvertFrom GetConvertFrom(Type destinationType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="182" sc="3" el="205" ec="4">log4net\Util\TypeConverters\ConverterRegistry.cs</location>
            <body hash="d1904073535e13602ea2b0ec19ae8801"><![CDATA[{
			// TODO: Support inheriting type converters.
			// i.e. getting a type converter for a base of destinationType

			lock(s_type2converter)
			{
				// Lookup in the static registry
				IConvertFrom converter = s_type2converter[destinationType] as IConvertFrom;

				if (converter == null)
				{
					// Lookup using attributes
					converter = GetConverterFromAttribute(destinationType) as IConvertFrom;

					if (converter != null)
					{
						// Store in registry
						s_type2converter[destinationType] = converter;
					}
				}

				return converter;
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="GetConvertTo">
          <declaration><![CDATA[public static IConvertTo GetConvertTo(Type sourceType, Type destinationType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="141" sc="3" el="166" ec="4">log4net\Util\TypeConverters\ConverterRegistry.cs</location>
            <body hash="3cb1c100ebae91c19035db76c5c2ab52"><![CDATA[{
			// TODO: Support inheriting type converters.
			// i.e. getting a type converter for a base of sourceType

			// TODO: Is destinationType required? We don't use it for anything.

			lock(s_type2converter)
			{
				// Lookup in the static registry
				IConvertTo converter = s_type2converter[sourceType] as IConvertTo;

				if (converter == null)
				{
					// Lookup using attributes
					converter = GetConverterFromAttribute(sourceType) as IConvertTo;

					if (converter != null)
					{
						// Store in registry
						s_type2converter[sourceType] = converter;
					}
				}

				return converter;
			}
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="declaringType">
          <declaration><![CDATA[private static readonly Type declaringType;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="s_type2converter">
          <declaration><![CDATA[private static Hashtable s_type2converter;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="EncodingConverter">
      <declaration><![CDATA[internal class EncodingConverter : IConvertFrom]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public EncodingConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CanConvertFrom">
          <declaration><![CDATA[public bool CanConvertFrom(Type sourceType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="54" sc="3" el="56" ec="4">log4net\Util\TypeConverters\EncodingConverter.cs</location>
            <body hash="9799dc099b63091587707e065d77ea21"><![CDATA[{
			return (sourceType == typeof(string));
		}]]></body>
          </codeblock>
        </method>
        <method name="ConvertFrom">
          <declaration><![CDATA[public object ConvertFrom(object source)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="75" sc="3" el="82" ec="4">log4net\Util\TypeConverters\EncodingConverter.cs</location>
            <body hash="f58b9e21cbb46c2dd0a44af8d9217424"><![CDATA[{
			string str = source as string;
			if (str != null) 
			{
				return Encoding.GetEncoding(str);
			}
			throw ConversionNotSupportedException.Create(typeof(Encoding), source);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="IConvertFrom">
      <declaration><![CDATA[public interface IConvertFrom]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="CanConvertFrom">
          <declaration><![CDATA[bool CanConvertFrom(Type sourceType);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="ConvertFrom">
          <declaration><![CDATA[object ConvertFrom(object source);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="IConvertTo">
      <declaration><![CDATA[public interface IConvertTo]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="CanConvertTo">
          <declaration><![CDATA[bool CanConvertTo(Type targetType);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="ConvertTo">
          <declaration><![CDATA[object ConvertTo(object source, Type targetType);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="IPAddressConverter">
      <declaration><![CDATA[internal class IPAddressConverter : IConvertFrom]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public IPAddressConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static IPAddressConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="146" sc="3" el="146" ec="166">log4net\Util\TypeConverters\IPAddressConverter.cs</location>
            <body hash="8ea90f20790df59e6e5bfe38b54035f7"><![CDATA[private static readonly char[] validIpAddressChars = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f','A','B','C','D','E','F','x','X','.',':','%'}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CanConvertFrom">
          <declaration><![CDATA[public bool CanConvertFrom(Type sourceType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="52" sc="3" el="54" ec="4">log4net\Util\TypeConverters\IPAddressConverter.cs</location>
            <body hash="9799dc099b63091587707e065d77ea21"><![CDATA[{
			return (sourceType == typeof(string));
		}]]></body>
          </codeblock>
        </method>
        <method name="ConvertFrom">
          <declaration><![CDATA[public object ConvertFrom(object source)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="74" sc="3" el="139" ec="4">log4net\Util\TypeConverters\IPAddressConverter.cs</location>
            <body hash="73313d3d1d161e9213b0622eed806749"><![CDATA[{
			string str = source as string;
			if (str != null && str.Length > 0) 
			{
				try
				{
#if NET_2_0 || NETCF_2_0

#if !NETCF_2_0
					// Try an explicit parse of string representation of an IPAddress (v4 or v6)
					IPAddress result;
					if (IPAddress.TryParse(str, out result))
					{
						return result;
					}
#endif

					// Try to resolve via DNS. This is a blocking call. 
					// GetHostEntry works with either an IPAddress string or a host name
					IPHostEntry host = Dns.GetHostEntry(str);
					if (host != null && 
						host.AddressList != null && 
						host.AddressList.Length > 0 &&
						host.AddressList[0] != null)
					{
						return host.AddressList[0];
					}
#else
					// Before .NET 2 we need to try to parse the IPAddress from the string first

					// Check if the string only contains IP address valid chars
					if (str.Trim(validIpAddressChars).Length == 0)
					{
						try
						{
							// try to parse the string as an IP address
							return IPAddress.Parse(str);
						}
						catch(FormatException)
						{
							// Ignore a FormatException, try to resolve via DNS
						}
					}

					// Try to resolve via DNS. This is a blocking call.
#if NETSTANDARD1_3
					IPHostEntry host = Dns.GetHostEntryAsync(str).GetAwaiter().GetResult();
#else
					IPHostEntry host = Dns.GetHostByName(str);
#endif
					if (host != null && 
						host.AddressList != null && 
						host.AddressList.Length > 0 &&
						host.AddressList[0] != null)
					{
						return host.AddressList[0];
					}
#endif
				}
				catch(Exception ex)
				{
					throw ConversionNotSupportedException.Create(typeof(IPAddress), source, ex);
				}
			}
			throw ConversionNotSupportedException.Create(typeof(IPAddress), source);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="validIpAddressChars">
          <declaration><![CDATA[private static readonly char[] validIpAddressChars = new char[]]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="PatternLayoutConverter">
      <declaration><![CDATA[internal class PatternLayoutConverter : IConvertFrom]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public PatternLayoutConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CanConvertFrom">
          <declaration><![CDATA[public bool CanConvertFrom(Type sourceType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="59" sc="3" el="61" ec="4">log4net\Util\TypeConverters\PatternLayoutConverter.cs</location>
            <body hash="9799dc099b63091587707e065d77ea21"><![CDATA[{
			return (sourceType == typeof(string));
		}]]></body>
          </codeblock>
        </method>
        <method name="ConvertFrom">
          <declaration><![CDATA[public object ConvertFrom(object source)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="81" sc="3" el="88" ec="4">log4net\Util\TypeConverters\PatternLayoutConverter.cs</location>
            <body hash="1d2626cd34d91ecb3cd365a116234970"><![CDATA[{
			string str = source as string;
			if (str != null)
			{
				return new PatternLayout(str);
			}
			throw ConversionNotSupportedException.Create(typeof(PatternLayout), source);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="PatternStringConverter">
      <declaration><![CDATA[internal class PatternStringConverter : IConvertTo, IConvertFrom]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public PatternStringConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CanConvertFrom">
          <declaration><![CDATA[public bool CanConvertFrom(Type sourceType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="110" sc="3" el="112" ec="4">log4net\Util\TypeConverters\PatternStringConverter.cs</location>
            <body hash="9799dc099b63091587707e065d77ea21"><![CDATA[{
			return (sourceType == typeof(string));
		}]]></body>
          </codeblock>
        </method>
        <method name="CanConvertTo">
          <declaration><![CDATA[public bool CanConvertTo(Type targetType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="63" sc="3" el="65" ec="4">log4net\Util\TypeConverters\PatternStringConverter.cs</location>
            <body hash="72613321bb3b5b924b1929d55bfedf50"><![CDATA[{
			return (typeof(string).IsAssignableFrom(targetType));
		}]]></body>
          </codeblock>
        </method>
        <method name="ConvertFrom">
          <declaration><![CDATA[public object ConvertFrom(object source)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="132" sc="3" el="139" ec="4">log4net\Util\TypeConverters\PatternStringConverter.cs</location>
            <body hash="f1c47ce4b0ec76d54a65fa73cca8bf29"><![CDATA[{
			string str = source as string;
			if (str != null)
			{
				return new PatternString(str);
			}
			throw ConversionNotSupportedException.Create(typeof(PatternString), source);
		}]]></body>
          </codeblock>
        </method>
        <method name="ConvertTo">
          <declaration><![CDATA[public object ConvertTo(object source, Type targetType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="85" sc="3" el="92" ec="4">log4net\Util\TypeConverters\PatternStringConverter.cs</location>
            <body hash="85ff675f4341979765a1dcb4cbb35675"><![CDATA[{
			PatternString patternString = source as PatternString;
			if (patternString != null && CanConvertTo(targetType))
			{
				return patternString.Format();
			}
			throw ConversionNotSupportedException.Create(targetType, source);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="TypeConverter">
      <declaration><![CDATA[internal class TypeConverter : IConvertFrom]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public TypeConverter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CanConvertFrom">
          <declaration><![CDATA[public bool CanConvertFrom(Type sourceType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="56" sc="3" el="58" ec="4">log4net\Util\TypeConverters\TypeConverter.cs</location>
            <body hash="9799dc099b63091587707e065d77ea21"><![CDATA[{
			return (sourceType == typeof(string));
		}]]></body>
          </codeblock>
        </method>
        <method name="ConvertFrom">
          <declaration><![CDATA[public object ConvertFrom(object source)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="79" sc="3" el="90" ec="4">log4net\Util\TypeConverters\TypeConverter.cs</location>
            <body hash="8275359e204ced661bb91e901a481849"><![CDATA[{
			string str = source as string;
			if (str != null)
			{
#if NETSTANDARD1_3 // TODO can we use ComponentModel here?
				return SystemInfo.GetTypeFromString(GetType().GetTypeInfo().Assembly, str, true, true);
#else
				return SystemInfo.GetTypeFromString(str, true, true);
#endif
			}
			throw ConversionNotSupportedException.Create(typeof(Type), source);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="TypeConverterAttribute">
      <declaration><![CDATA[public sealed class TypeConverterAttribute : Attribute]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private string m_typeName = null;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="48" sc="3" el="64" ec="4">log4net\Util\TypeConverters\TypeConverterAttribute.cs</location>
            <body hash="8814fe121f86b7ec4e8527e32d9a477c"><![CDATA[private string m_typeName = null;

		#endregion

		#region Constructors

		/// <summary>
		/// Default constructor
		/// </summary>
		/// <remarks>
		/// <para>
		/// Default constructor
		/// </para>
		/// </remarks>
		public TypeConverterAttribute()
		{
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private string m_typeName = null;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="48" sc="3" el="79" ec="4">log4net\Util\TypeConverters\TypeConverterAttribute.cs</location>
            <body hash="9c969e1d87050d1c5ed39854bd5ddacf"><![CDATA[private string m_typeName = null;

		#endregion

		#region Constructors

		/// <summary>
		/// Default constructor
		/// </summary>
		/// <remarks>
		/// <para>
		/// Default constructor
		/// </para>
		/// </remarks>
		public TypeConverterAttribute()
		{
		}

		/// <summary>
		/// Create a new type converter attribute for the specified type name
		/// </summary>
		/// <param name="typeName">The string type name of the type converter</param>
		/// <remarks>
		/// <para>
		/// The type specified must implement the <see cref="IConvertFrom"/> 
		/// or the <see cref="IConvertTo"/> interfaces.
		/// </para>
		/// </remarks>
		public TypeConverterAttribute(string typeName)
		{
			m_typeName = typeName;
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private string m_typeName = null;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="48" sc="3" el="94" ec="4">log4net\Util\TypeConverters\TypeConverterAttribute.cs</location>
            <body hash="e253e8bcd82acec70ade9fa3646e059a"><![CDATA[private string m_typeName = null;

		#endregion

		#region Constructors

		/// <summary>
		/// Default constructor
		/// </summary>
		/// <remarks>
		/// <para>
		/// Default constructor
		/// </para>
		/// </remarks>
		public TypeConverterAttribute()
		{
		}

		/// <summary>
		/// Create a new type converter attribute for the specified type name
		/// </summary>
		/// <param name="typeName">The string type name of the type converter</param>
		/// <remarks>
		/// <para>
		/// The type specified must implement the <see cref="IConvertFrom"/> 
		/// or the <see cref="IConvertTo"/> interfaces.
		/// </para>
		/// </remarks>
		public TypeConverterAttribute(string typeName)
		{
			m_typeName = typeName;
		}

		/// <summary>
		/// Create a new type converter attribute for the specified type
		/// </summary>
		/// <param name="converterType">The type of the type converter</param>
		/// <remarks>
		/// <para>
		/// The type specified must implement the <see cref="IConvertFrom"/> 
		/// or the <see cref="IConvertTo"/> interfaces.
		/// </para>
		/// </remarks>
		public TypeConverterAttribute(Type converterType)
		{
			m_typeName = log4net.Util.SystemInfo.AssemblyQualifiedName(converterType);
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="m_typeName">
          <declaration><![CDATA[private string m_typeName = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="ConverterTypeName">
          <declaration><![CDATA[public string ConverterTypeName]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
</root>