<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<root file="DotNetNuke.SiteExportImport.dll" version="09.01.00" generated="2017-08-10 13:18:40Z" generationTime="16.9981431">
  <namespace name="Dnn.ExportImport.App_LocalResources">
    <class name="ExportImport">
      <declaration><![CDATA[internal class ExportImport]]></declaration>
      <documentation>
        <summary>
   A strongly-typed resource class, for looking up localized strings, etc.
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[internal ExportImport()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="32" sc="9" el="33" ec="10">App_LocalResources\ExportImport.Designer.cs</location>
            <body hash="ef9c43bd2b0a5dfc5c916c21bb9307f0"><![CDATA[internal ExportImport() {
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="resourceCulture">
          <declaration><![CDATA[private static CultureInfo resourceCulture;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="resourceMan">
          <declaration><![CDATA[private static ResourceManager resourceMan;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Culture">
          <declaration><![CDATA[internal static CultureInfo Culture]]></declaration>
          <documentation>
            <summary>
   Overrides the current thread's CurrentUICulture property for all
   resource lookups using this strongly typed resource class.
 </summary>
          </documentation>
          <codeblock>
            <location sl="55" sc="17" el="57" ec="14">App_LocalResources\ExportImport.Designer.cs</location>
            <body hash="ffab7f5c6a8fb3ff038df65602d1d13e"><![CDATA[{
                return resourceCulture;
            }]]></body>
          </codeblock>
          <codeblock>
            <location sl="58" sc="17" el="60" ec="14">App_LocalResources\ExportImport.Designer.cs</location>
            <body hash="6aa27ee5d41f1c4d2ffa5e3ac14a4009"><![CDATA[{
                resourceCulture = value;
            }]]></body>
          </codeblock>
        </property>
        <property name="InvalidPortal_Text">
          <declaration><![CDATA[internal static string InvalidPortal_Text]]></declaration>
          <documentation>
            <summary>
   Looks up a localized string similar to Invalid portal..
 </summary>
          </documentation>
          <codeblock>
            <location sl="67" sc="17" el="69" ec="14">App_LocalResources\ExportImport.Designer.cs</location>
            <body hash="7b93cb1f308ee20fe96eab01367d328f"><![CDATA[{
                return ResourceManager.GetString("InvalidPortal.Text", resourceCulture);
            }]]></body>
          </codeblock>
        </property>
        <property name="JobNotExist_Text">
          <declaration><![CDATA[internal static string JobNotExist_Text]]></declaration>
          <documentation>
            <summary>
   Looks up a localized string similar to No such job!.
 </summary>
          </documentation>
          <codeblock>
            <location sl="76" sc="17" el="78" ec="14">App_LocalResources\ExportImport.Designer.cs</location>
            <body hash="98d088277e0ef906ccb3a37a6727633c"><![CDATA[{
                return ResourceManager.GetString("JobNotExist.Text", resourceCulture);
            }]]></body>
          </codeblock>
        </property>
        <property name="JobStatus_Cancelled_Text">
          <declaration><![CDATA[internal static string JobStatus_Cancelled_Text]]></declaration>
          <documentation>
            <summary>
   Looks up a localized string similar to Cancelled.
 </summary>
          </documentation>
          <codeblock>
            <location sl="85" sc="17" el="87" ec="14">App_LocalResources\ExportImport.Designer.cs</location>
            <body hash="6ed70f45fdf0819ac9685b6ceadc40e2"><![CDATA[{
                return ResourceManager.GetString("JobStatus_Cancelled.Text", resourceCulture);
            }]]></body>
          </codeblock>
        </property>
        <property name="JobStatus_DoneFailure_Text">
          <declaration><![CDATA[internal static string JobStatus_DoneFailure_Text]]></declaration>
          <documentation>
            <summary>
   Looks up a localized string similar to Failed.
 </summary>
          </documentation>
          <codeblock>
            <location sl="94" sc="17" el="96" ec="14">App_LocalResources\ExportImport.Designer.cs</location>
            <body hash="2db0cb8a6b5f80e00540c7fda107c36c"><![CDATA[{
                return ResourceManager.GetString("JobStatus_DoneFailure.Text", resourceCulture);
            }]]></body>
          </codeblock>
        </property>
        <property name="JobStatus_DoneSuccess_Text">
          <declaration><![CDATA[internal static string JobStatus_DoneSuccess_Text]]></declaration>
          <documentation>
            <summary>
   Looks up a localized string similar to Successful.
 </summary>
          </documentation>
          <codeblock>
            <location sl="103" sc="17" el="105" ec="14">App_LocalResources\ExportImport.Designer.cs</location>
            <body hash="fd84b8faec57a9ad60b6286399774337"><![CDATA[{
                return ResourceManager.GetString("JobStatus_DoneSuccess.Text", resourceCulture);
            }]]></body>
          </codeblock>
        </property>
        <property name="JobStatus_InProgress_Text">
          <declaration><![CDATA[internal static string JobStatus_InProgress_Text]]></declaration>
          <documentation>
            <summary>
   Looks up a localized string similar to In Progress.
 </summary>
          </documentation>
          <codeblock>
            <location sl="112" sc="17" el="114" ec="14">App_LocalResources\ExportImport.Designer.cs</location>
            <body hash="5ab5b22d6815a848e1dc1b365ad1aa88"><![CDATA[{
                return ResourceManager.GetString("JobStatus_InProgress.Text", resourceCulture);
            }]]></body>
          </codeblock>
        </property>
        <property name="JobStatus_Submitted_Text">
          <declaration><![CDATA[internal static string JobStatus_Submitted_Text]]></declaration>
          <documentation>
            <summary>
   Looks up a localized string similar to Submitted.
 </summary>
          </documentation>
          <codeblock>
            <location sl="121" sc="17" el="123" ec="14">App_LocalResources\ExportImport.Designer.cs</location>
            <body hash="fe88ba5bad76aa3d21d65de57ab6f226"><![CDATA[{
                return ResourceManager.GetString("JobStatus_Submitted.Text", resourceCulture);
            }]]></body>
          </codeblock>
        </property>
        <property name="JobType_Export_Text">
          <declaration><![CDATA[internal static string JobType_Export_Text]]></declaration>
          <documentation>
            <summary>
   Looks up a localized string similar to Site Export.
 </summary>
          </documentation>
          <codeblock>
            <location sl="130" sc="17" el="132" ec="14">App_LocalResources\ExportImport.Designer.cs</location>
            <body hash="1f1394cfc488aac7476207dfe863d687"><![CDATA[{
                return ResourceManager.GetString("JobType_Export.Text", resourceCulture);
            }]]></body>
          </codeblock>
        </property>
        <property name="JobType_Import_Text">
          <declaration><![CDATA[internal static string JobType_Import_Text]]></declaration>
          <documentation>
            <summary>
   Looks up a localized string similar to Site Import.
 </summary>
          </documentation>
          <codeblock>
            <location sl="139" sc="17" el="141" ec="14">App_LocalResources\ExportImport.Designer.cs</location>
            <body hash="f381c3ba0835bd18808b1c2d7d89283d"><![CDATA[{
                return ResourceManager.GetString("JobType_Import.Text", resourceCulture);
            }]]></body>
          </codeblock>
        </property>
        <property name="NotPortalAdmin_Text">
          <declaration><![CDATA[internal static string NotPortalAdmin_Text]]></declaration>
          <documentation>
            <summary>
   Looks up a localized string similar to User is not a portal administrator.
 </summary>
          </documentation>
          <codeblock>
            <location sl="148" sc="17" el="150" ec="14">App_LocalResources\ExportImport.Designer.cs</location>
            <body hash="e1ab31fd6104b4f64c61ff6cc65288e9"><![CDATA[{
                return ResourceManager.GetString("NotPortalAdmin.Text", resourceCulture);
            }]]></body>
          </codeblock>
        </property>
        <property name="ResourceManager">
          <declaration><![CDATA[internal static ResourceManager ResourceManager]]></declaration>
          <documentation>
            <summary>
   Returns the cached ResourceManager instance used by this class.
 </summary>
          </documentation>
          <codeblock>
            <location sl="40" sc="17" el="46" ec="14">App_LocalResources\ExportImport.Designer.cs</location>
            <body hash="8857d219796d10d0a35b618ab6ae683d"><![CDATA[{
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Dnn.ExportImport.App_LocalResources.ExportImport", typeof(ExportImport).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="Dnn.ExportImport.Components.Common">
    <class name="CollisionResolution">
      <declaration><![CDATA[public enum CollisionResolution]]></declaration>
      <documentation>
        <summary>
 Specifies what to do when there is a collision during the import process.
 </summary>
      </documentation>
      <constructors>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="Ignore">
          <declaration><![CDATA[public const CollisionResolution Ignore = 0;]]></declaration>
          <documentation>
            <summary>
 Ignore the imported item and continue.
 </summary>
          </documentation>
        </field>
        <field name="Overwrite">
          <declaration><![CDATA[public const CollisionResolution Overwrite = 1;]]></declaration>
          <documentation>
            <summary>
 Overwrites the existing item upon importing.
 </summary>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="CompressionUtil">
      <declaration><![CDATA[public static class CompressionUtil]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="AddFilesToArchive">
          <declaration><![CDATA[public static void AddFilesToArchive(ZipArchive archive, IEnumerable<string> files, int folderOffset, string folder = null)]]></declaration>
          <documentation>
            <summary>
 Add files to an archive. If no archive exists, new one is created.
 </summary>
 <param name="archive">Source archive to write the files to</param>
 <param name="files">List containing path of files to add to archive.</param>
 <param name="folderOffset">Starting index(Index in file url) of the root folder in archive based on what the folder structure starts in archive.
 e.g. if file url is c:\\dnn\files\archived\foldername\1\file.jpg and we want to add all files in foldername folder
 then the folder offset would be starting index of foldername</param>
 <param name="folder">Additional root folder to be added into archive.</param></documentation>
          <codeblock>
            <location sl="129" sc="9" el="136" ec="10">Components\Common\CompressionUtil.cs</location>
            <body hash="8abfa910f1a40a1859064689d3bce398"><![CDATA[{
            var enumerable = files as IList<string> ?? files.ToList();
            if (!enumerable.Any()) return;
            foreach (var file in enumerable.Where(File.Exists))
            {
                AddFileToArchive(archive, file, folderOffset, folder);
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="AddFileToArchive">
          <declaration><![CDATA[public static bool AddFileToArchive(string file, string archivePath, int folderOffset, string folder = null)]]></declaration>
          <documentation>
            <summary>
 Add single file to an archive. If no archive exists, new one is created.
 </summary>
 <param name="file">Full path of file to add</param>
 <param name="archivePath">Full path of archive file</param>
 <param name="folderOffset">Starting index(Index in file url) of the root folder in archive based on what the folder structure starts in archive.
 e.g. if file url is c:\\dnn\files\archived\foldername\1\file.jpg and we want to add all files in foldername folder
 then the folder offset would be starting index of foldername</param>
 <param name="folder">Additional root folder to be added into archive.</param></documentation>
          <codeblock>
            <location sl="148" sc="9" el="157" ec="10">Components\Common\CompressionUtil.cs</location>
            <body hash="d08609a61e699a70fccf7279fde28be2"><![CDATA[{
            using (var archive = OpenCreate(archivePath))
            {
                if (File.Exists(file))
                {
                    return AddFileToArchive(archive, file, folderOffset, folder);
                }
            }
            return false;
        }]]></body>
          </codeblock>
        </method>
        <method name="AddFileToArchive">
          <declaration><![CDATA[private static bool AddFileToArchive(ZipArchive archive, string file, int folderOffset, string folder = null)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="162" sc="9" el="179" ec="10">Components\Common\CompressionUtil.cs</location>
            <body hash="d42a02eb203153b02912ca8812be3c73"><![CDATA[{
            var entryName = file.Substring(folderOffset); // Makes the name in zip based on the folder
            ZipArchiveEntry existingEntry;
            //Deletes if the entry already exists in archive.
            if ((existingEntry = archive.GetEntry(entryName)) != null)
            {
                existingEntry.Delete();
            }

            var fileInfo = new FileInfo(file);
            if (fileInfo.Length < 1610612736)
            {
                archive.CreateEntryFromFile(file,
                    string.IsNullOrEmpty(folder) ? entryName : Path.Combine(folder, entryName), CompressionLevel.Fastest);
                return true;
            }
            return false;
        }]]></body>
          </codeblock>
        </method>
        <method name="OpenCreate">
          <declaration><![CDATA[public static ZipArchive OpenCreate(string archiveFileName)]]></declaration>
          <documentation>
            <summary>
 Open the archive file for read and write.
 </summary>
 <param name="archiveFileName"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="187" sc="9" el="191" ec="10">Components\Common\CompressionUtil.cs</location>
            <body hash="e65bdd309d98ff676ad099aa18404e55"><![CDATA[{
            return File.Exists(archiveFileName)
                ? ZipFile.Open(archiveFileName, ZipArchiveMode.Update, Encoding.UTF8)
                : new ZipArchive(new FileStream(archiveFileName, FileMode.Create), ZipArchiveMode.Update);
        }]]></body>
          </codeblock>
        </method>
        <method name="UnZipArchive">
          <declaration><![CDATA[public static void UnZipArchive(string archivePath, string extractFolder, bool overwrite = true)]]></declaration>
          <documentation>
            <summary>
 Unzip compressed file to a folder.
 </summary>
 <param name="archivePath">Full path to archive with name</param>
 <param name="extractFolder">Full path to the target folder</param>
 <param name="overwrite">Overwrites the files on target if true.</param></documentation>
          <codeblock>
            <location sl="54" sc="9" el="56" ec="10">Components\Common\CompressionUtil.cs</location>
            <body hash="629eddfb57d59e7955749b080b434b7f"><![CDATA[{
            UnZipArchiveExcept(archivePath, extractFolder, overwrite);
        }]]></body>
          </codeblock>
        </method>
        <method name="UnZipArchiveExcept">
          <declaration><![CDATA[public static void UnZipArchiveExcept(string archivePath, string extractFolder, bool overwrite = true, IEnumerable<string> exceptionList = null, bool deleteFromSoure = false)]]></declaration>
          <documentation>
            <summary>
 Unzip compressed file to a folder.
 </summary>
 <param name="archivePath">Full path to archive with name</param>
 <param name="extractFolder">Full path to the target folder</param>
 <param name="overwrite">Overwrites the files on target if true.</param>
 <param name="exceptionList">List of files to exlude from extraction.</param>
 <param name="deleteFromSoure">Delete the files from the archive after extraction</param></documentation>
          <codeblock>
            <location sl="68" sc="9" el="90" ec="10">Components\Common\CompressionUtil.cs</location>
            <body hash="8a5fa615b3a0409279c6394d1295050e"><![CDATA[{
            if (!File.Exists(archivePath)) return;
            using (var archive = OpenCreate(archivePath))
            {
                foreach (
                    var entry in
                        archive.Entries.Where(
                            entry =>
                                ((exceptionList != null && !exceptionList.Contains(entry.FullName)) ||
                                 exceptionList == null) &&
                                !entry.FullName.EndsWith("\\") && !entry.FullName.EndsWith("/") && entry.Length > 0)
                    )
                {
                    var path = Path.GetDirectoryName(Path.Combine(extractFolder, entry.FullName));
                    if (!string.IsNullOrEmpty(path) && !Directory.Exists(path))
                        Directory.CreateDirectory(path);
                    if (!File.Exists(Path.Combine(extractFolder, entry.FullName)) || overwrite)
                        entry.ExtractToFile(Path.Combine(extractFolder, entry.FullName), overwrite);
                    if (deleteFromSoure)
                        entry.Delete();
                }
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="UnZipFileFromArchive">
          <declaration><![CDATA[public static void UnZipFileFromArchive(string fileName, string archivePath, string extractFolder, bool overwrite = true, bool deleteFromSoure = false)]]></declaration>
          <documentation>
            <summary>
 Unzip a single file from an archive.
 </summary>
 <param name="fileName">Name of the file to extract. This name should match the entry name in the archive. i.e. it should include complete folder structure inside the archive.</param>
 <param name="archivePath">Full path to archive with name</param>
 <param name="extractFolder">Full path to the target folder</param>
 <param name="overwrite">Overwrites the file on target if true.</param>
 <param name="deleteFromSoure">Delete the file from the archive after extraction</param></documentation>
          <codeblock>
            <location sl="102" sc="9" el="116" ec="10">Components\Common\CompressionUtil.cs</location>
            <body hash="9367927db193a904c753985ebb60246d"><![CDATA[{
            if (!File.Exists(archivePath)) return;
            using (var archive = OpenCreate(archivePath))
            {
                var fileUnzipFullName = Path.Combine(extractFolder, fileName);
                if (File.Exists(fileUnzipFullName) && !overwrite)
                    return;

                var fileEntry = archive.GetEntry(fileName);
                if (!File.Exists(Path.Combine(extractFolder, fileEntry.FullName)) || overwrite)
                    fileEntry?.ExtractToFile(Path.Combine(extractFolder, fileName), overwrite);
                if (deleteFromSoure)
                    fileEntry?.Delete();
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="ZipFolder">
          <declaration><![CDATA[public static void ZipFolder(string folderPath, string archivePath)]]></declaration>
          <documentation>
            <summary>
 Compress a full folder.
 </summary>
 <param name="folderPath">Full path of folder to compress</param>
 <param name="archivePath">Full path of the archived file</param></documentation>
          <codeblock>
            <location sl="41" sc="9" el="45" ec="10">Components\Common\CompressionUtil.cs</location>
            <body hash="48019182db50e965a3ceecc6789637f4"><![CDATA[{
            if (File.Exists(archivePath))
                File.Delete(archivePath);
            ZipFile.CreateFromDirectory(folderPath, archivePath, CompressionLevel.Fastest, false);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="Constants">
      <declaration><![CDATA[public class Constants]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public Constants()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static Constants()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="56" sc="9" el="58" ec="59">Components\Common\Constants.cs</location>
            <body hash="bf6d051bd8a4edb543ce6bca385c4070"><![CDATA[internal static DateTime MinDbTime = new DateTime(1980, 1, 1, 0, 0, 0, DateTimeKind.Utc);
        internal static DateTime MaxDbTime = new DateTime(3000, 1, 1, 0, 0, 0, DateTimeKind.Utc);
        internal static int MaxZipFilesMemory = 104857600;]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="Category_Assets">
          <declaration><![CDATA[public const string Category_Assets = "ASSETS";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Category_Content">
          <declaration><![CDATA[public const string Category_Content = "CONTENT";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Category_Packages">
          <declaration><![CDATA[public const string Category_Packages = "PACKAGES";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Category_Pages">
          <declaration><![CDATA[internal const string Category_Pages = "PAGES";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Category_Portal">
          <declaration><![CDATA[internal const string Category_Portal = "PORTAL";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Category_ProfileProps">
          <declaration><![CDATA[public const string Category_ProfileProps = "PROFILE_PROPERTIES";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Category_Roles">
          <declaration><![CDATA[public const string Category_Roles = "ROLES";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Category_Templates">
          <declaration><![CDATA[public const string Category_Templates = "TEMPLATES";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Category_Themes">
          <declaration><![CDATA[public const string Category_Themes = "THEMES";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Category_Users">
          <declaration><![CDATA[public const string Category_Users = "USERS";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Category_UsersData">
          <declaration><![CDATA[internal const string Category_UsersData = "USERS_DATA";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Category_Vocabularies">
          <declaration><![CDATA[public const string Category_Vocabularies = "VOCABULARIES";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Category_Workflows">
          <declaration><![CDATA[public const string Category_Workflows = "WORKFLOW";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="CurrentSchemaVersion">
          <declaration><![CDATA[public const string CurrentSchemaVersion = "1.0.0";]]></declaration>
          <documentation>
            <summary>
 This is the currently supported schema version support as of this release.
 In future releases thi must be updated to be compatible wiht th e
 </summary>
          </documentation>
        </field>
        <field name="DefaultPageSize">
          <declaration><![CDATA[internal const int DefaultPageSize = 1000;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ExportDbName">
          <declaration><![CDATA[internal const string ExportDbName = "export.dnndb";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ExportFolder">
          <declaration><![CDATA[internal const string ExportFolder = "\\App_Data\\ExportImport\\";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ExportManifestName">
          <declaration><![CDATA[internal const string ExportManifestName = "export.json";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ExportZipDbName">
          <declaration><![CDATA[internal const string ExportZipDbName = "export_db.zip";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ExportZipFiles">
          <declaration><![CDATA[internal const string ExportZipFiles = "export_files.zip";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ExportZipPackages">
          <declaration><![CDATA[internal const string ExportZipPackages = "export_packages.zip";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ExportZipTemplates">
          <declaration><![CDATA[internal const string ExportZipTemplates = "export_templates.zip";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ExportZipThemes">
          <declaration><![CDATA[internal const string ExportZipThemes = "export_themes.zip";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="JobRunDateTimeFormat">
          <declaration><![CDATA[internal const string JobRunDateTimeFormat = "yyyy-MM-dd HH:mm:ss.fff";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="LastJobStartTimeKey">
          <declaration><![CDATA[internal const string LastJobStartTimeKey = "EXPORT_LastJobStartTime";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="LogColumnLength">
          <declaration><![CDATA[internal const int LogColumnLength = 255;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="LogTypeSiteExport">
          <declaration><![CDATA[internal const string LogTypeSiteExport = "SITE_EXPORT";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="LogTypeSiteImport">
          <declaration><![CDATA[internal const string LogTypeSiteImport = "SITE_IMPORT";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="MaxDbTime">
          <declaration><![CDATA[internal static DateTime MaxDbTime = new DateTime(3000, 1, 1, 0, 0, 0, DateTimeKind.Utc);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="MaxSecondsToRunJobKey">
          <declaration><![CDATA[internal const string MaxSecondsToRunJobKey = "MaxSecondsToRunJob";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="MaxZipFilesMemory">
          <declaration><![CDATA[internal static int MaxZipFilesMemory = 104857600;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="MinDbTime">
          <declaration><![CDATA[internal static DateTime MinDbTime = new DateTime(1980, 1, 1, 0, 0, 0, DateTimeKind.Utc);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="PortalSettingExportKey">
          <declaration><![CDATA[internal const string PortalSettingExportKey = "PortalSettingExportList";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="SharedResources">
          <declaration><![CDATA[internal const string SharedResources = "/DesktopModules/SiteExportImport/App_LocalResources/ExportImport.resx";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="TemplatesExtension">
          <declaration><![CDATA[internal const string TemplatesExtension = "template";]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="ExportMode">
      <declaration><![CDATA[public enum ExportMode]]></declaration>
      <documentation>
        <summary>
 Mode for export job.
 </summary>
      </documentation>
      <constructors>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="Differential">
          <declaration><![CDATA[public const ExportMode Differential = 1;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Full">
          <declaration><![CDATA[public const ExportMode Full = 0;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="JobStatus">
      <declaration><![CDATA[public enum JobStatus]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="Cancelled">
          <declaration><![CDATA[public const JobStatus Cancelled = 4;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Failed">
          <declaration><![CDATA[public const JobStatus Failed = 3;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="InProgress">
          <declaration><![CDATA[public const JobStatus InProgress = 1;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Submitted">
          <declaration><![CDATA[public const JobStatus Submitted = 0;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Successful">
          <declaration><![CDATA[public const JobStatus Successful = 2;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="JobType">
      <declaration><![CDATA[public enum JobType]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="Export">
          <declaration><![CDATA[public const JobType Export = 0;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Import">
          <declaration><![CDATA[public const JobType Import = 1;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="ReportLevel">
      <declaration><![CDATA[public enum ReportLevel]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="Error">
          <declaration><![CDATA[public const ReportLevel Error = 3;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Info">
          <declaration><![CDATA[public const ReportLevel Info = 1;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Verbose">
          <declaration><![CDATA[public const ReportLevel Verbose = 0;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Warn">
          <declaration><![CDATA[public const ReportLevel Warn = 2;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="SummaryList">
      <declaration><![CDATA[public class SummaryList : List<SummaryItem>]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public SummaryList()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Add">
          <declaration><![CDATA[public new void Add(SummaryItem item)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="10" sc="9" el="20" ec="10">Components\Common\SummaryList.cs</location>
            <body hash="917fa6bd41df596ffdeb627f35a4a1e0"><![CDATA[{
            if (this.Any(x => x.Category == item.Category))
            {
                this.First(x => x.Category == item.Category).TotalItems += item.TotalItems;
                this.First(x => x.Category == item.Category).ProcessedItems += item.ProcessedItems;
            }
            else
            {
                base.Add(item);
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="AddRange">
          <declaration><![CDATA[public new void AddRange(IEnumerable<SummaryItem> items)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="23" sc="9" el="29" ec="10">Components\Common\SummaryList.cs</location>
            <body hash="30b7a8a8457b08cde875378c4d39da4a"><![CDATA[{
            var summaryItems = items as IList<SummaryItem> ?? items.ToList();
            foreach (var summaryItem in summaryItems.OrderBy(x => x.Order))
            {
                Add(summaryItem);
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="Util">
      <declaration><![CDATA[public static class Util]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".cctor">
          <declaration><![CDATA[static Util()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="45" sc="9" el="46" ec="78">Components\Common\Util.cs</location>
            <body hash="0a50e67ac472743c1c9f5eb82cecdafa"><![CDATA[private static readonly ILog Logger = LoggerSource.Instance.GetLogger(typeof(Util));
        private static int _noRole = Convert.ToInt32(Globals.glbRoleNothing);]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CalculateTotalPages">
          <declaration><![CDATA[public static int CalculateTotalPages(int totalRecords, int pageSize)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="153" sc="9" el="155" ec="10">Components\Common\Util.cs</location>
            <body hash="3bf207aa98f7b261192d5990926a4a3b"><![CDATA[{
            return totalRecords % pageSize == 0 ? totalRecords / pageSize : totalRecords / pageSize + 1;
        }]]></body>
          </codeblock>
        </method>
        <method name="ConvertToDbLocalTime">
          <declaration><![CDATA[public static DateTime? ConvertToDbLocalTime(DateTime? dateTime)]]></declaration>
          <documentation>
            <summary>
 Convert the UTC time to Database local time.
 </summary>
 <param name="dateTime"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="212" sc="9" el="219" ec="10">Components\Common\Util.cs</location>
            <body hash="954e188e486c2ea66e1c0049de5f2d5b"><![CDATA[{
            if (dateTime == null) return null;
            if (dateTime.Value.Kind != DateTimeKind.Utc) return dateTime;
            var differenceInUtcTimes =
                TimeZone.CurrentTimeZone.GetUtcOffset(DateUtils.GetDatabaseUtcTime()).TotalMilliseconds;
            var d = dateTime.Value.ToLocalTime().AddMilliseconds(differenceInUtcTimes);
            return new DateTime(d.Year, d.Month, d.Day, d.Hour, d.Minute, d.Second, d.Millisecond, DateTimeKind.Local);
        }]]></body>
          </codeblock>
        </method>
        <method name="ConvertToDbUtcTime">
          <declaration><![CDATA[public static DateTime? ConvertToDbUtcTime(DateTime? dateTime)]]></declaration>
          <documentation>
            <summary>
 Convert the Local time to Database Utc time.
 </summary>
 <param name="dateTime"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="227" sc="9" el="234" ec="10">Components\Common\Util.cs</location>
            <body hash="a43e86a0c267e311b09f512fb7b3f7a3"><![CDATA[{
            if (dateTime == null) return null;
            if (dateTime.Value.Kind == DateTimeKind.Utc) return dateTime;
            var differenceInUtcTimes =
                TimeZone.CurrentTimeZone.GetUtcOffset(DateUtils.GetDatabaseUtcTime()).TotalMilliseconds;
            var d = dateTime.Value.ToUniversalTime().AddMilliseconds(differenceInUtcTimes);
            return new DateTime(d.Year, d.Month, d.Day, d.Hour, d.Minute, d.Second, d.Millisecond, DateTimeKind.Utc);
        }]]></body>
          </codeblock>
        </method>
        <method name="FixDateTime">
          <declaration><![CDATA[public static void FixDateTime<T>(T item)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="174" sc="9" el="184" ec="10">Components\Common\Util.cs</location>
            <body hash="997fe46690049f1c44ddf893c654b6bc"><![CDATA[{
            var properties = item.GetType().GetRuntimeProperties();
            foreach (var property in properties)
            {
                if ((property.PropertyType == typeof(DateTime) || property.PropertyType == typeof(DateTime?)) &&
                    (property.GetValue(item) as DateTime?) == DateTime.MinValue)
                {
                    property.SetValue(item, Constants.MinDbTime);
                }
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="FormatNumber">
          <declaration><![CDATA[public static string FormatNumber(int? number)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="242" sc="9" el="244" ec="10">Components\Common\Util.cs</location>
            <body hash="855d779abf3f18b942f8118ba106969f"><![CDATA[{
            return number?.ToString("n0", Thread.CurrentThread.CurrentUICulture);
        }]]></body>
          </codeblock>
        </method>
        <method name="FormatSize">
          <declaration><![CDATA[public static string FormatSize(long bytes, byte decimals = 1)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="81" sc="9" el="90" ec="10">Components\Common\Util.cs</location>
            <body hash="d1ac7920e21fa4bce6fb4fb69b01e655"><![CDATA[{
            const long kb = 1024;
            const long mb = kb * kb;
            const long gb = mb * kb;

            if (bytes < kb) return bytes + " B";
            if (bytes < mb) return (1.0 * bytes / kb).ToString("F" + decimals) + " KB";
            if (bytes < gb) return (1.0 * bytes / mb).ToString("F" + decimals) + " MB";
            return (1.0 * bytes / gb).ToString("F" + decimals) + " GB";
        }]]></body>
          </codeblock>
        </method>
        <method name="GeModuleDefIdByFriendltName">
          <declaration><![CDATA[public static int? GeModuleDefIdByFriendltName(string friendlyName)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="124" sc="9" el="129" ec="10">Components\Common\Util.cs</location>
            <body hash="2c13adf6b0c301a545d319e00025e151"><![CDATA[{
            if (string.IsNullOrEmpty(friendlyName)) return null;

            var moduleDefInfo = ModuleDefinitionController.GetModuleDefinitionByFriendlyName(friendlyName);
            return moduleDefInfo?.ModuleDefID;
        }]]></body>
          </codeblock>
        </method>
        <method name="GePermissionIdByName">
          <declaration><![CDATA[public static int? GePermissionIdByName(string permissionCode, string permissionKey, string permissionName)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="132" sc="9" el="140" ec="10">Components\Common\Util.cs</location>
            <body hash="a27c35c9ab398d144ec8e9c61a37dee9"><![CDATA[{
            if (string.IsNullOrEmpty(permissionCode) ||
                string.IsNullOrEmpty(permissionKey) ||
                string.IsNullOrEmpty(permissionName))
                return null;

            var permission = EntitiesController.Instance.GetPermissionInfo(permissionCode, permissionKey, permissionName);
            return permission?.PermissionID;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetDateTimeString">
          <declaration><![CDATA[public static string GetDateTimeString(DateTime? dateTime)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="237" sc="9" el="239" ec="10">Components\Common\Util.cs</location>
            <body hash="075c3b3a085c0db695e6758b10d41efa"><![CDATA[{
            return dateTime?.ToString(Thread.CurrentThread.CurrentUICulture) ?? "";
        }]]></body>
          </codeblock>
        </method>
        <method name="GetExpImpJobCacheKey">
          <declaration><![CDATA[public static string GetExpImpJobCacheKey(ExportImportJob job)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="93" sc="9" el="95" ec="10">Components\Common\Util.cs</location>
            <body hash="3c9ec6ed3ccd72a6dbac6715553f8eee"><![CDATA[{
            return string.Join(":", "ExpImpKey", job.PortalId.ToString(), job.JobId.ToString());
        }]]></body>
          </codeblock>
        </method>
        <method name="GetPortableImplementors">
          <declaration><![CDATA[public static IEnumerable<BasePortableService> GetPortableImplementors()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetProfilePropertyId">
          <declaration><![CDATA[public static int? GetProfilePropertyId(int portalId, int? exportedProfilePropertyId, string exportProfilePropertyname)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="144" sc="9" el="150" ec="10">Components\Common\Util.cs</location>
            <body hash="21dd50d7ffc912428cb2928d1194cf4b"><![CDATA[{
            if (!exportedProfilePropertyId.HasValue || exportedProfilePropertyId <= 0)
                return -1;

            var property = ProfileController.GetPropertyDefinitionByName(portalId, exportProfilePropertyname);
            return property?.PropertyDefinitionId;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetRoleIdByName">
          <declaration><![CDATA[public static int? GetRoleIdByName(int portalId, int exportRoleId, string exportRolename)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="116" sc="9" el="121" ec="10">Components\Common\Util.cs</location>
            <body hash="eca0102e3c7a4631e3185b94a0677700"><![CDATA[{
            if (string.IsNullOrEmpty(exportRolename)) return null;

            var roleId = DataProvider.Instance().GetRoleIdByName(exportRoleId >= 0 ? portalId : -1, exportRolename);
            return roleId == _noRole ? null : (int?)roleId;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetUserIdByName">
          <declaration><![CDATA[public static int GetUserIdByName(ExportImportJob importJob, int? exportedUserId, string exportUsername)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="98" sc="9" el="113" ec="10">Components\Common\Util.cs</location>
            <body hash="c050a5b0143ae58123dae4886ea6e2a2"><![CDATA[{
            if (!exportedUserId.HasValue || exportedUserId <= 0)
                return -1;

            if (exportedUserId == 1)
                return 1; // default HOST user

            if (string.IsNullOrEmpty(exportUsername))
                return -1;

            var user = UserController.GetUserByName(importJob.PortalId, exportUsername);
            if (user == null)
                return -1;

            return user.UserID < 0 ? importJob.CreatedByUserId : user.UserID;
        }]]></body>
          </codeblock>
        </method>
        <method name="HasValue">
          <declaration><![CDATA[public static bool HasValue(this string s)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="50" sc="55" el="50" ec="79">Components\Common\Util.cs</location>
            <body hash="b861f1e2cbdb88e8cb8d0f1c7baa3b92"><![CDATA[!string.IsNullOrEmpty(s]]></body>
          </codeblock>
        </method>
        <method name="IsNullOrEmpty">
          <declaration><![CDATA[public static bool IsNullOrEmpty(this string s)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="48" sc="60" el="48" ec="83">Components\Common\Util.cs</location>
            <body hash="4c45699cc346eeed12e37fe6a59df4eb"><![CDATA[string.IsNullOrEmpty(s]]></body>
          </codeblock>
        </method>
        <method name="IsNullOrWhiteSpace">
          <declaration><![CDATA[public static bool IsNullOrWhiteSpace(this string s)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="49" sc="65" el="49" ec="93">Components\Common\Util.cs</location>
            <body hash="52ba528581974b2b6d2e3d97c9a4c763"><![CDATA[string.IsNullOrWhiteSpace(s]]></body>
          </codeblock>
        </method>
        <method name="ReadJson">
          <declaration><![CDATA[public static void ReadJson<T>(string filePath, ref T item)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="164" sc="9" el="171" ec="10">Components\Common\Util.cs</location>
            <body hash="045be858e9748ed78baf8bfec6494fa7"><![CDATA[{
            if (File.Exists(filePath))
            {
                var content = File.ReadAllText(filePath);
                //TODO: This might throw error if file is corrupt. Should we handle error here?
                item = JsonConvert.DeserializeObject<T>(content);
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="ToLocalDateTime">
          <declaration><![CDATA[public static DateTime ToLocalDateTime(DateTime dateTime, UserInfo userInfo)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="187" sc="9" el="197" ec="10">Components\Common\Util.cs</location>
            <body hash="f2670ce9745b8cd9f910c49d3658bbb2"><![CDATA[{
            if (dateTime.Kind != DateTimeKind.Local)
            {
                dateTime = new DateTime(
                    dateTime.Year, dateTime.Month, dateTime.Day,
                    dateTime.Hour, dateTime.Minute, dateTime.Second,
                    dateTime.Millisecond, DateTimeKind.Utc);
                return userInfo.LocalTime(dateTime);
            }
            return dateTime;
        }]]></body>
          </codeblock>
        </method>
        <method name="ToLocalDateTime">
          <declaration><![CDATA[public static DateTime? ToLocalDateTime(DateTime? dateTime, UserInfo userInfo)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="200" sc="9" el="204" ec="10">Components\Common\Util.cs</location>
            <body hash="bcc3a6464bc4882826751a1d12b76e5d"><![CDATA[{
            if (dateTime != null && dateTime.Value.Kind != DateTimeKind.Local)
                return userInfo.LocalTime(dateTime.Value);
            return dateTime;
        }]]></body>
          </codeblock>
        </method>
        <method name="WriteJson">
          <declaration><![CDATA[public static void WriteJson<T>(string filePath, T item)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="158" sc="9" el="161" ec="10">Components\Common\Util.cs</location>
            <body hash="3db6831ac1388bfdaac09c7cc65f0e03"><![CDATA[{
            var content = JsonConvert.SerializeObject(item);
            File.WriteAllText(filePath, content, Encoding.UTF8);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_noRole">
          <declaration><![CDATA[private static int _noRole = Convert.ToInt32("-4");]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Logger">
          <declaration><![CDATA[private static readonly ILog Logger = LoggerSource.Instance.GetLogger(typeof(Util));]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="Dnn.ExportImport.Components.Controllers">
    <class name="BaseController">
      <declaration><![CDATA[public class BaseController]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".cctor">
          <declaration><![CDATA[static BaseController()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="45" sc="9" el="56" ec="10">Components\Controllers\BaseController.cs</location>
            <body hash="eecc4326b59b0aece2dae5e14e327d63"><![CDATA[private static readonly ILog Logger = LoggerSource.Instance.GetLogger(typeof(BaseController));

        public static readonly string ExportFolder;

        static BaseController()
        {
            ExportFolder = Globals.ApplicationMapPath + Constants.ExportFolder;
            if (!Directory.Exists(ExportFolder))
            {
                Directory.CreateDirectory(ExportFolder);
            }
        }]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public BaseController()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AddEventLog">
          <declaration><![CDATA[protected void AddEventLog(int portalId, int userId, int jobId, string logTypeKey)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="59" sc="9" el="77" ec="10">Components\Controllers\BaseController.cs</location>
            <body hash="6de6d7b7cafb661910b0b6c77cfbacaf"><![CDATA[{
            var objSecurity = new PortalSecurity();
            var portalInfo = PortalController.Instance.GetPortal(portalId);
            var userInfo = UserController.Instance.GetUser(portalId, userId);
            var username = objSecurity.InputFilter(userInfo.Username,
                PortalSecurity.FilterFlag.NoScripting | PortalSecurity.FilterFlag.NoAngleBrackets | PortalSecurity.FilterFlag.NoMarkup);

            var log = new LogInfo
            {
                LogTypeKey = logTypeKey,
                LogPortalID = portalId,
                LogPortalName = portalInfo.PortalName,
                LogUserName = username,
                LogUserID = userId,
            };

            log.AddProperty("JobID", jobId.ToString());
            LogController.Instance.AddLog(log);
        }]]></body>
          </codeblock>
        </method>
        <method name="BuildJobSummary">
          <declaration><![CDATA[protected static ImportExportSummary BuildJobSummary(int jobId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="155" sc="9" el="193" ec="10">Components\Controllers\BaseController.cs</location>
            <body hash="9b69ba35c733a26a495592a1fcc131cf"><![CDATA[{
            var summaryItems = new SummaryList();
            var controller = EntitiesController.Instance;
            var job = controller.GetJobById(jobId);
            var exportDto = job.JobType == JobType.Export
                ? JsonConvert.DeserializeObject<ExportDto>(job.JobObject)
                : JsonConvert.DeserializeObject<ImportDto>(job.JobObject).ExportDto;

            var importExportSummary = new ImportExportSummary
            {
                IncludeDeletions = exportDto.IncludeDeletions,
                IncludeExtensions = exportDto.IncludeExtensions,
                IncludePermissions = exportDto.IncludePermissions,
                IncludeProfileProperties = exportDto.IncludeProperfileProperties,
                IncludeContent = exportDto.IncludeContent,
                FromDate = exportDto.FromDateUtc,
                ToDate = exportDto.ToDateUtc,
                ExportMode = exportDto.ExportMode,
                ExportFileInfo = job.JobType == JobType.Export
                    ? GetExportFileInfo(Path.Combine(ExportFolder, job.Directory, Constants.ExportManifestName))
                    : JsonConvert.DeserializeObject<ImportDto>(job.JobObject).ExportFileInfo
            };

            var checkpoints = EntitiesController.Instance.GetJobChekpoints(jobId);
            if (!checkpoints.Any()) return importExportSummary;
            var implementors = Util.GetPortableImplementors();

            summaryItems.AddRange(checkpoints.Select(checkpoint => new SummaryItem
            {
                TotalItems = checkpoint.TotalItems,
                ProcessedItems = checkpoint.ProcessedItems,
                ProgressPercentage = Convert.ToInt32(checkpoint.Progress),
                Category = checkpoint.Category,
                Order = implementors.FirstOrDefault(x => x.Category == checkpoint.Category)?.Priority ?? 0,
                Completed = checkpoint.Completed
            }));
            importExportSummary.SummaryItems = summaryItems;
            return importExportSummary;
        }]]></body>
          </codeblock>
        </method>
        <method name="BuildJobSummary">
          <declaration><![CDATA[protected internal static void BuildJobSummary(string packageId, IExportImportRepository repository, ImportExportSummary summary)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="196" sc="9" el="222" ec="10">Components\Controllers\BaseController.cs</location>
            <body hash="770279e83a0ed6544a978676db64c251"><![CDATA[{
            var summaryItems = new SummaryList();
            var implementors = Util.GetPortableImplementors();
            var exportDto = repository.GetSingleItem<ExportDto>();

            foreach (var implementor in implementors)
            {
                implementor.Repository = repository;
                summaryItems.Add(new SummaryItem
                {
                    TotalItems = implementor.GetImportTotal(),
                    Category = implementor.Category,
                    Order = implementor.Priority
                });
            }

            summary.ExportFileInfo = GetExportFileInfo(Path.Combine(ExportFolder, packageId, Constants.ExportManifestName));
            summary.FromDate = exportDto.FromDateUtc;
            summary.ToDate = exportDto.ToDateUtc;
            summary.SummaryItems = summaryItems;
            summary.IncludeDeletions = exportDto.IncludeDeletions;
            summary.IncludeContent = exportDto.IncludeContent;
            summary.IncludeExtensions = exportDto.IncludeExtensions;
            summary.IncludePermissions = exportDto.IncludePermissions;
            summary.IncludeProfileProperties = exportDto.IncludeProperfileProperties;
            summary.ExportMode = exportDto.ExportMode;
        }]]></body>
          </codeblock>
        </method>
        <method name="CancelJob">
          <declaration><![CDATA[public bool CancelJob(int portalId, int jobId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="80" sc="9" el="89" ec="10">Components\Controllers\BaseController.cs</location>
            <body hash="4451fe48fbb0991536a03eb6be0467e3"><![CDATA[{
            var controller = EntitiesController.Instance;
            var job = controller.GetJobById(jobId);
            if (job == null || (job.PortalId != portalId && portalId != -1))
                return false;

            controller.SetJobCancelled(job);
            CachingProvider.Instance().Remove(Util.GetExpImpJobCacheKey(job));
            return true;
        }]]></body>
          </codeblock>
        </method>
        <method name="DeleteJobData">
          <declaration><![CDATA[private static void DeleteJobData(ExportImportJob job)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="261" sc="9" el="276" ec="10">Components\Controllers\BaseController.cs</location>
            <body hash="99fd356e7756a8b235304c897e0c2573"><![CDATA[{
            if (job.JobType != JobType.Export) return;
            var jobFolder = Path.Combine(ExportFolder, job.Directory);
            try
            {
                if (Directory.Exists(jobFolder))
                {
                    Directory.Delete(jobFolder, true);
                }
            }
            catch (Exception ex)
            {
                Logger.Error(
                    $"Failed to delete the job data. Error:{ex.Message}. It will need to be deleted manually. Folder Path:{jobFolder}");
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllJobs">
          <declaration><![CDATA[public AllJobsResult GetAllJobs(int portalId, int currentPortalId, int? pageSize, int? pageIndex, int? jobType, string keywords)]]></declaration>
          <documentation>
            <summary>
 Retrieves one page of paginated proceessed jobs
 </summary>
          </documentation>
          <codeblock>
            <location sl="109" sc="9" el="129" ec="10">Components\Controllers\BaseController.cs</location>
            <body hash="b339687b64d59090ec95f9d3a7115c2d"><![CDATA[{
            if (pageIndex < 0) pageIndex = 0;
            if (pageSize < 1) pageSize = 1;
            else if (pageSize > 100) pageSize = 100;

            var count = EntitiesController.Instance.GetAllJobsCount(portalId, jobType, keywords);
            var jobs = count <= 0
                ? null
                : EntitiesController.Instance.GetAllJobs(portalId, pageSize, pageIndex, jobType, keywords);

            var portal = PortalController.Instance.GetPortal(currentPortalId);
            return new AllJobsResult
            {
                LastExportTime = portalId > -1 ? EntitiesController.Instance.GetLastJobTime(portalId, JobType.Export) : null,
                LastImportTime = portalId > -1 ? EntitiesController.Instance.GetLastJobTime(portalId, JobType.Import) : null,
                PortalId = portalId,
                PortalName = portal.PortalName,
                TotalJobs = count,
                Jobs = jobs?.Select(ToJobItem)
            };
        }]]></body>
          </codeblock>
        </method>
        <method name="GetExportFileInfo">
          <declaration><![CDATA[protected static ExportFileInfo GetExportFileInfo(string manifestPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="225" sc="9" el="229" ec="10">Components\Controllers\BaseController.cs</location>
            <body hash="a5be9072550c8e5408dc797d7c8909d4"><![CDATA[{
            ImportPackageInfo packageInfo = null;
            Util.ReadJson(manifestPath, ref packageInfo);
            return packageInfo?.Summary.ExportFileInfo;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetJobDetails">
          <declaration><![CDATA[public JobItem GetJobDetails(int portalId, int jobId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="132" sc="9" el="141" ec="10">Components\Controllers\BaseController.cs</location>
            <body hash="a527f90ec51bc26c83369ceba034ed10"><![CDATA[{
            var controller = EntitiesController.Instance;
            var job = controller.GetJobById(jobId);
            if (portalId != -1 && job?.PortalId != portalId)
                return null;

            var jobItem = ToJobItem(job);
            jobItem.Summary = BuildJobSummary(jobId);
            return jobItem;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetLastJobTime">
          <declaration><![CDATA[public DateTime? GetLastJobTime(int portalId, JobType jobType)]]></declaration>
          <documentation>
            <summary>
 Get the last time a successful export job has started.
 This date/time is in uts and can be used to set the next
 differntial date/time to start the job from.
 </summary>
 <returns></returns></documentation>
          <codeblock>
            <location sl="150" sc="9" el="152" ec="10">Components\Controllers\BaseController.cs</location>
            <body hash="231e14de2c781b31d4323283c076ad25"><![CDATA[{
            return EntitiesController.Instance.GetLastJobTime(portalId, jobType);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetPackageInfo">
          <declaration><![CDATA[protected static ImportPackageInfo GetPackageInfo(string manifestPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="232" sc="9" el="236" ec="10">Components\Controllers\BaseController.cs</location>
            <body hash="9846e95ec1f4a54471331be4c20d71f7"><![CDATA[{
            ImportPackageInfo packageInfo = null;
            Util.ReadJson(manifestPath, ref packageInfo);
            return packageInfo;
        }]]></body>
          </codeblock>
        </method>
        <method name="RemoveJob">
          <declaration><![CDATA[public bool RemoveJob(int portalId, int jobId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="92" sc="9" el="103" ec="10">Components\Controllers\BaseController.cs</location>
            <body hash="3f38d26ad5955b04361f2965ab1da906"><![CDATA[{
            var controller = EntitiesController.Instance;
            var job = controller.GetJobById(jobId);
            if (job == null || (job.PortalId != portalId && portalId != -1))
                return false;

            CachingProvider.Instance().Remove(Util.GetExpImpJobCacheKey(job));
            // if the job is running; then it will create few exceptions in the log file
            controller.RemoveJob(job);
            DeleteJobData(job);
            return true;
        }]]></body>
          </codeblock>
        </method>
        <method name="ToJobItem">
          <declaration><![CDATA[private static JobItem ToJobItem(ExportImportJob job)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="239" sc="9" el="258" ec="10">Components\Controllers\BaseController.cs</location>
            <body hash="8184ae6911b175bb6283bafb0b339db7"><![CDATA[{
            var user = UserController.Instance.GetUserById(job.PortalId, job.CreatedByUserId);
            var name = job.JobType == JobType.Import ? JsonConvert.DeserializeObject<ImportDto>(job.JobObject)?.ExportDto?.ExportName : job.Name;

            return new JobItem
            {
                JobId = job.JobId,
                PortalId = job.PortalId,
                User = user?.DisplayName ?? user?.Username ?? job.CreatedByUserId.ToString(),
                JobType = Localization.GetString("JobType_" + job.JobType, Constants.SharedResources),
                Status = (int)job.JobStatus,
                Cancelled = job.IsCancelled,
                JobStatus = Localization.GetString("JobStatus_" + job.JobStatus, Constants.SharedResources),
                Name = name,
                Description = job.Description,
                CreatedOn = job.CreatedOnDate,
                CompletedOn = job.CompletedOnDate,
                ExportFile = job.CompletedOnDate.HasValue ? job.Directory : null
            };
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="ExportFolder">
          <declaration><![CDATA[public static readonly string ExportFolder;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Logger">
          <declaration><![CDATA[private static readonly ILog Logger;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="BusinessController">
      <declaration><![CDATA[public class BusinessController : IUpgradeable]]></declaration>
      <documentation>
        <summary>

 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public BusinessController()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="UpgradeModule">
          <declaration><![CDATA[public string UpgradeModule(string version)]]></declaration>
          <documentation>
            <summary>

 </summary>
 <param name="version"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="38" sc="9" el="53" ec="10">Components\Controllers\BusinessController.cs</location>
            <body hash="f708888d392fae9e4db777305263af13"><![CDATA[{
            try
            {
                switch (version)
                {
                    case "09.01.00":
                        //AddNewLogTypes(); // moved to SQL migration script
                        break;
                }
                return "Success";
            }
            catch (Exception)
            {
                return "Failed";
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="EntitiesController">
      <declaration><![CDATA[public class EntitiesController : ServiceLocator<IEntitiesController, EntitiesController>, IEntitiesController]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private readonly DataProvider _dataProvider = DataProvider.Instance();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="41" sc="9" el="41" ec="79">Components\Controllers\EntitiesController.cs</location>
            <body hash="b2b979bdbf66254c4eacb8a493b4402b"><![CDATA[private readonly DataProvider _dataProvider = DataProvider.Instance()]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="GetAllJobs">
          <declaration><![CDATA[public IList<ExportImportJob> GetAllJobs(int? portalId, int? pageSize, int? pageIndex, int? jobType, string keywords)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="76" sc="9" el="79" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="65905f685dffcd8e8c3a6b97b1200670"><![CDATA[{
            return CBO.Instance.FillCollection<ExportImportJob>(
                _dataProvider.GetAllJobs(portalId, pageSize, pageIndex, jobType, keywords));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllJobsCount">
          <declaration><![CDATA[public int GetAllJobsCount(int? portalId, int? jobType, string keywords)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="71" sc="9" el="73" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="19fded77707ebc92796c03172074313c"><![CDATA[{
            return _dataProvider.GetAllJobsCount(portalId, jobType, keywords);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetFactory">
          <declaration><![CDATA[protected override Func<IEntitiesController> GetFactory()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="44" sc="9" el="46" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="046c540ca7bbfbc57b64e2fb8ffd3590"><![CDATA[{
            return () => new EntitiesController();
        }]]></body>
          </codeblock>
        </method>
        <method name="GetFirstActiveJob">
          <declaration><![CDATA[public ExportImportJob GetFirstActiveJob()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="49" sc="9" el="51" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="d8de3fcf3a9fb7fb9dc27e91ea6fc5d7"><![CDATA[{
            return CBO.Instance.FillObject<ExportImportJob>(_dataProvider.GetFirstActiveJob());
        }]]></body>
          </codeblock>
        </method>
        <method name="GetJobById">
          <declaration><![CDATA[public ExportImportJob GetJobById(int jobId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="54" sc="9" el="58" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="34f2c269fd7245e6d55f6f5a5c5c81a9"><![CDATA[{
            var job = CBO.Instance.FillObject<ExportImportJob>(_dataProvider.GetJobById(jobId));
            //System.Diagnostics.Trace.WriteLine($"xxxxxxxxx job id={job?.JobId} IsCancelled={job?.IsCancelled} xxxxxxxxx");
            return job;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetJobChekpoints">
          <declaration><![CDATA[public IList<ExportImportChekpoint> GetJobChekpoints(int jobId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="107" sc="9" el="109" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="6ec5d759965e6df58928a72f01bb0219"><![CDATA[{
            return CBO.Instance.FillCollection<ExportImportChekpoint>(_dataProvider.GetJobChekpoints(jobId));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetJobFullLog">
          <declaration><![CDATA[public IList<ExportImportJobLog> GetJobFullLog(int jobId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="66" sc="9" el="68" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="ac6cbc6545669dd6e71d939c3938dd33"><![CDATA[{
            return CBO.Instance.FillCollection<ExportImportJobLog>(_dataProvider.GetJobFullLog(jobId));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetJobSummaryLog">
          <declaration><![CDATA[public IList<ExportImportJobLog> GetJobSummaryLog(int jobId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="61" sc="9" el="63" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="77c682c1e79c42cd1249ad326de2c665"><![CDATA[{
            return CBO.Instance.FillCollection<ExportImportJobLog>(_dataProvider.GetJobSummaryLog(jobId));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetLastJobTime">
          <declaration><![CDATA[public DateTime? GetLastJobTime(int portalId, JobType jobType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="82" sc="9" el="84" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="5f9918a5468f2c00aeaf4caec24e75de"><![CDATA[{
            return _dataProvider.GetLastJobTime(portalId, jobType);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetModulePermissions">
          <declaration><![CDATA[public IList<ExportModulePermission> GetModulePermissions(int moduleId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="153" sc="9" el="156" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="b213273e977f9fc0a12d18a3441209dc"><![CDATA[{
            return CBO.Instance.FillCollection<ExportModulePermission>(
                _dataProvider.GetAllModulePermissions(moduleId, toDate, fromDate));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetModules">
          <declaration><![CDATA[public IList<ExportModule> GetModules(int tabId, bool includeDeleted, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="141" sc="9" el="144" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="a3c3382f44b76501d2ec00114217ee7d"><![CDATA[{
            return CBO.Instance.FillCollection<ExportModule>(
                _dataProvider.GetAllModules(tabId, includeDeleted, toDate, fromDate));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetModuleSettings">
          <declaration><![CDATA[public IList<ExportModuleSetting> GetModuleSettings(int moduleId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="147" sc="9" el="150" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="2d2848b5c636c9f6fb9fde1df5ca4afa"><![CDATA[{
            return CBO.Instance.FillCollection<ExportModuleSetting>(
                _dataProvider.GetAllModuleSettings(moduleId, toDate, fromDate));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetPermissionInfo">
          <declaration><![CDATA[public PermissionInfo GetPermissionInfo(string permissionCode, string permissionKey, string permissionName)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="171" sc="9" el="174" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="2c97833613273d0cfafe64d4fd9cd5bf"><![CDATA[{
            return CBO.Instance.FillObject<PermissionInfo>(
                _dataProvider.GetPermissionInfo(permissionCode, permissionKey, permissionName));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetPortalTabs">
          <declaration><![CDATA[public IList<ExportTabInfo> GetPortalTabs(int portalId, bool includeDeleted, bool includeSystem, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="117" sc="9" el="120" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="3c285cadd81e79adad43876b5dc188a8"><![CDATA[{
            return CBO.Instance.FillCollection<ExportTabInfo>(
                _dataProvider.GetAllPortalTabs(portalId, includeDeleted, includeSystem, toDate, fromDate));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetSchedulerTypeFullName">
          <declaration><![CDATA[private string GetSchedulerTypeFullName()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="208" sc="9" el="211" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="e6fb1d37dfbbc243d9e7916e19c04db3"><![CDATA[{
            var type = typeof (ExportImportScheduler);
            return $"{type.FullName}, {type.Assembly.GetName().Name}";
        }]]></body>
          </codeblock>
        </method>
        <method name="GetTabModules">
          <declaration><![CDATA[public IList<ExportTabModule> GetTabModules(int tabId, bool includeDeleted, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="159" sc="9" el="162" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="ebeb2816dcbb15a42338de44f3dc65ae"><![CDATA[{
            return CBO.Instance.FillCollection<ExportTabModule>(
                _dataProvider.GetAllTabModules(tabId, includeDeleted, toDate, fromDate));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetTabModuleSettings">
          <declaration><![CDATA[public IList<ExportTabModuleSetting> GetTabModuleSettings(int tabId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="165" sc="9" el="168" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="ce184d334e42ebf7ee6c42f952e5a01b"><![CDATA[{
            return CBO.Instance.FillCollection<ExportTabModuleSetting>(
                _dataProvider.GetAllTabModuleSettings(tabId, toDate, fromDate));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetTabPermissions">
          <declaration><![CDATA[public IList<ExportTabPermission> GetTabPermissions(int tabId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="129" sc="9" el="132" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="4301bb3702c40ee7c044d5bb44a643c5"><![CDATA[{
            return CBO.Instance.FillCollection<ExportTabPermission>(
                _dataProvider.GetAllTabPermissions(tabId, toDate, fromDate));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetTabSettings">
          <declaration><![CDATA[public IList<ExportTabSetting> GetTabSettings(int tabId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="123" sc="9" el="126" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="b69228e02c7adb2c474b833e0ab0b208"><![CDATA[{
            return CBO.Instance.FillCollection<ExportTabSetting>(
                _dataProvider.GetAllTabSettings(tabId, toDate, fromDate));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetTabUrls">
          <declaration><![CDATA[public IList<ExportTabUrl> GetTabUrls(int tabId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="135" sc="9" el="138" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="3adcfffd173e13a6604fdac5d46c0ee4"><![CDATA[{
            return CBO.Instance.FillCollection<ExportTabUrl>(
                _dataProvider.GetAllTabUrls(tabId, toDate, fromDate));
        }]]></body>
          </codeblock>
        </method>
        <method name="RemoveJob">
          <declaration><![CDATA[public void RemoveJob(ExportImportJob job)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="102" sc="9" el="104" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="8259dd32a74f11c9f0ed65e186a3073a"><![CDATA[{
            _dataProvider.RemoveJob(job.JobId);
        }]]></body>
          </codeblock>
        </method>
        <method name="RunSchedule">
          <declaration><![CDATA[public void RunSchedule()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="192" sc="9" el="205" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="42cb78bf31be24f4ac75caf2574987b6"><![CDATA[{
            var executingServer = ServerController.GetExecutingServerName();

            var scheduleItem = SchedulingController.GetSchedule(GetSchedulerTypeFullName(), executingServer);
            if (scheduleItem != null)
            {
                SchedulingProvider.Instance().RunScheduleItemNow(scheduleItem, true);

                if (SchedulingProvider.SchedulerMode == SchedulerMode.TIMER_METHOD)
                {
                    SchedulingProvider.Instance().ReStart("Change made to schedule.");
                }
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="SetJobCancelled">
          <declaration><![CDATA[public void SetJobCancelled(ExportImportJob job)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="97" sc="9" el="99" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="f57cde30348761b51f009883316bcd14"><![CDATA[{
            _dataProvider.SetJobCancelled(job.JobId);
        }]]></body>
          </codeblock>
        </method>
        <method name="SetTabModuleDeleted">
          <declaration><![CDATA[public void SetTabModuleDeleted(int tabModuleId, bool isDeleted)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="182" sc="9" el="184" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="9721eb010b560a344669644d62510caa"><![CDATA[{
            _dataProvider.SetTabModuleDeleted(tabModuleId, isDeleted);
        }]]></body>
          </codeblock>
        </method>
        <method name="SetTabSpecificData">
          <declaration><![CDATA[public void SetTabSpecificData(int tabId, bool isDeleted, bool isVisible)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="177" sc="9" el="179" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="d0a4b6845e0fff8603f67b44dbd22c33"><![CDATA[{
            _dataProvider.SetTabSpecificData(tabId, isDeleted, isVisible);
        }]]></body>
          </codeblock>
        </method>
        <method name="SetUserDeleted">
          <declaration><![CDATA[public void SetUserDeleted(int portalId, int userId, bool isDeleted)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="187" sc="9" el="189" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="34d968d4c5e867f87c4ee6c54c1cbc23"><![CDATA[{
            _dataProvider.SetUserDeleted(portalId, userId, isDeleted);
        }]]></body>
          </codeblock>
        </method>
        <method name="UpdateJobChekpoint">
          <declaration><![CDATA[public void UpdateJobChekpoint(ExportImportChekpoint checkpoint)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="112" sc="9" el="114" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="963c10042a516a34615a92bc056b8d85"><![CDATA[{
            _dataProvider.UpsertJobChekpoint(checkpoint);
        }]]></body>
          </codeblock>
        </method>
        <method name="UpdateJobInfo">
          <declaration><![CDATA[public void UpdateJobInfo(ExportImportJob job)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="87" sc="9" el="89" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="16147dc847d8909d8fd9fa7e6129f233"><![CDATA[{
            _dataProvider.UpdateJobInfo(job.JobId, job.Name, job.Description);
        }]]></body>
          </codeblock>
        </method>
        <method name="UpdateJobStatus">
          <declaration><![CDATA[public void UpdateJobStatus(ExportImportJob job)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="92" sc="9" el="94" ec="10">Components\Controllers\EntitiesController.cs</location>
            <body hash="0d710dbd0deeaea76c5867f701e05e7f"><![CDATA[{
            _dataProvider.UpdateJobStatus(job.JobId, job.JobStatus);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_dataProvider">
          <declaration><![CDATA[private readonly DataProvider _dataProvider = DataProvider.Instance();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="ExportController">
      <declaration><![CDATA[public class ExportController : BaseController]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ExportController()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CreatePackageManifest">
          <declaration><![CDATA[public void CreatePackageManifest(ExportImportJob exportJob, ExportFileInfo exportFileInfo, ImportExportSummary summary)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="63" sc="9" el="76" ec="10">Components\Controllers\ExportController.cs</location>
            <body hash="60f6a196bd2395df44324e5bd986f6d4"><![CDATA[{
            var filePath = Path.Combine(ExportFolder, exportJob.Directory, Constants.ExportManifestName);
            var portal = PortalController.Instance.GetPortal(exportJob.PortalId);
            var packageInfo = new ImportPackageInfo
            {
                Summary = summary,
                PackageId = exportJob.Directory,
                Name = exportJob.Name,
                Description = exportJob.Description,
                ExporTime = exportJob.CreatedOnDate,
                PortalName = portal?.PortalName
            };
            Util.WriteJson(filePath, packageInfo);
        }]]></body>
          </codeblock>
        </method>
        <method name="QueueOperation">
          <declaration><![CDATA[public int QueueOperation(int userId, ExportDto exportDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="38" sc="9" el="59" ec="10">Components\Controllers\ExportController.cs</location>
            <body hash="ddeb3ec531c1160dbe5ee4468d56bea1"><![CDATA[{
            exportDto.ProductSku = DotNetNuke.Application.DotNetNukeContext.Current.Application.SKU;
            exportDto.ProductVersion = Globals.FormatVersion(DotNetNuke.Application.DotNetNukeContext.Current.Application.Version, true);
            var dbTime = DateUtils.GetDatabaseUtcTime();
            exportDto.ToDateUtc = dbTime.AddMilliseconds(-dbTime.Millisecond);
            var directory = dbTime.ToString("yyyy-MM-dd_HH-mm-ss");
            if (exportDto.ExportMode == ExportMode.Differential)
            {
                exportDto.FromDateUtc = GetLastJobTime(exportDto.PortalId, JobType.Export);
            }
            var dataObject = JsonConvert.SerializeObject(exportDto);
            exportDto.IsDirty = false;//This should be set to false for new job.
            var jobId = DataProvider.Instance().AddNewJob(exportDto.PortalId, userId,
                JobType.Export, exportDto.ExportName, exportDto.ExportDescription, directory, dataObject);
            //Run the scheduler if required.
            if (exportDto.RunNow)
            {
                EntitiesController.Instance.RunSchedule();
            }
            AddEventLog(exportDto.PortalId, userId, jobId, Constants.LogTypeSiteExport);
            return jobId;
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="ImportController">
      <declaration><![CDATA[public class ImportController : BaseController]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ImportController()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="GetImportPackageFilterFunc">
          <declaration><![CDATA[private Func<ImportPackageInfo, bool> GetImportPackageFilterFunc(string keyword)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="140" sc="9" el="146" ec="10">Components\Controllers\ImportController.cs</location>
            <body hash="67d2cc792e436c23b357cd0de13becc3"><![CDATA[{
            Func<ImportPackageInfo, bool> keywordFunc =
                packageInfo =>
                    packageInfo.Name.ToLowerInvariant().Contains(keyword.ToLowerInvariant()) ||
                    packageInfo.Description.ToLowerInvariant().Contains(keyword.ToLowerInvariant());
            return keywordFunc;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetImportPackageOrderByFunc">
          <declaration><![CDATA[private Func<ImportPackageInfo, object> GetImportPackageOrderByFunc(string orderBy, out string order)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="149" sc="9" el="163" ec="10">Components\Controllers\ImportController.cs</location>
            <body hash="7ddfd6d2c2569794f9055acc1f0714ab"><![CDATA[{
            orderBy = orderBy.ToLowerInvariant();
            order = orderBy == "newest" ? "desc" : "asc";
            Func<ImportPackageInfo, object> sortFunc;
            switch (orderBy)
            {
                case "name":
                    sortFunc = packageInfo => packageInfo.Name;
                    break;
                default:
                    sortFunc = packageInfo => packageInfo.ExporTime;
                    break;
            }
            return sortFunc;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetImportPackages">
          <declaration><![CDATA[public IEnumerable<ImportPackageInfo> GetImportPackages(out int total, string keyword, string order = "newest", int pageIndex = 0, int pageSize = 10)]]></declaration>
          <documentation>
            <summary>
 Get list of packages to import
 </summary>
 <param name="total">Total number of packages</param>
 <param name="keyword">Keyword to search the import package. This will look into the package name and description</param>
 <param name="order">Order by which the packages list should be sorted. Allowed values: newest, oldest, name</param>
 <param name="pageIndex">Page index to get</param>
 <param name="pageSize">Page size. Should not be more than 100.</param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="70" sc="9" el="89" ec="10">Components\Controllers\ImportController.cs</location>
            <body hash="8237b9519a3c603d266b2dec69947a6c"><![CDATA[{
            pageSize = pageSize > 100 ? 100 : pageSize;
            var directories = Directory.GetDirectories(ExportFolder);
            var importPackages = from directory in directories.Where(IsValidImportFolder)
                                 select GetPackageInfo(Path.Combine(directory, Constants.ExportManifestName));

            var importPackagesList = importPackages as IList<ImportPackageInfo> ?? importPackages.ToList();

            importPackages = !string.IsNullOrEmpty(keyword)
                ? importPackagesList.Where(GetImportPackageFilterFunc(keyword))
                : importPackagesList;

            total = importPackages.Count();
            string sortOrder;
            var orderByFunc = GetImportPackageOrderByFunc(order, out sortOrder);
            importPackages = sortOrder == "asc"
                ? importPackages.OrderBy(orderByFunc)
                : importPackages.OrderByDescending(orderByFunc);
            return importPackages.Skip(pageIndex * pageSize).Take(pageSize);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetPackageDbPath">
          <declaration><![CDATA[private static string GetPackageDbPath(string packageId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="116" sc="9" el="121" ec="10">Components\Controllers\ImportController.cs</location>
            <body hash="9f2b7e358347fb354e484f1131cc8ead"><![CDATA[{
            var importFolder = Path.Combine(ExportFolder, packageId);
            if (!IsValidImportFolder(importFolder)) return null;
            var dbPath = UnPackDatabase(importFolder);
            return dbPath;
        }]]></body>
          </codeblock>
        </method>
        <method name="IsValidImportFolder">
          <declaration><![CDATA[private static bool IsValidImportFolder(string folderPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="134" sc="9" el="137" ec="10">Components\Controllers\ImportController.cs</location>
            <body hash="ea44b3940103f298d49c73ee9e4e3402"><![CDATA[{
            return File.Exists(Path.Combine(folderPath, Constants.ExportManifestName)) && (File.Exists(Path.Combine(folderPath, Constants.ExportDbName)) ||
                   File.Exists(Path.Combine(folderPath, Constants.ExportZipDbName)));
        }]]></body>
          </codeblock>
        </method>
        <method name="QueueOperation">
          <declaration><![CDATA[public int QueueOperation(int userId, ImportDto importDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="38" sc="9" el="57" ec="10">Components\Controllers\ImportController.cs</location>
            <body hash="6291766a92608cff77a00517948b72cf"><![CDATA[{
            using (var repository = new ExportImportRepository(GetPackageDbPath(importDto.PackageId)))
            {
                var exportDto = repository.GetSingleItem<ExportDto>();
                importDto.ExportDto = exportDto;
            }

            importDto.ExportFileInfo =
                GetExportFileInfo(Path.Combine(ExportFolder, importDto.PackageId, Constants.ExportManifestName));
            var dataObject = JsonConvert.SerializeObject(importDto);
            var jobId = DataProvider.Instance().AddNewJob(
                importDto.PortalId, userId, JobType.Import, null, null, importDto.PackageId, dataObject);
            //Run the scheduler if required.
            if (importDto.RunNow)
            {
                EntitiesController.Instance.RunSchedule();
            }
            AddEventLog(importDto.PortalId, userId, jobId, Constants.LogTypeSiteImport);
            return jobId;
        }]]></body>
          </codeblock>
        </method>
        <method name="UnPackDatabase">
          <declaration><![CDATA[private static string UnPackDatabase(string folderPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="124" sc="9" el="131" ec="10">Components\Controllers\ImportController.cs</location>
            <body hash="5ae2896a2bbc3e14a561ff96d221126e"><![CDATA[{
            var dbName = Path.Combine(folderPath, Constants.ExportDbName);
            if (File.Exists(dbName))
                return dbName;
            var zipDbName = Path.Combine(folderPath, Constants.ExportZipDbName);
            CompressionUtil.UnZipFileFromArchive(Constants.ExportDbName, zipDbName, folderPath, false);
            return dbName;
        }]]></body>
          </codeblock>
        </method>
        <method name="VerifyImportPackage">
          <declaration><![CDATA[public bool VerifyImportPackage(string packageId, ImportExportSummary summary, out string errorMessage)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="92" sc="9" el="113" ec="10">Components\Controllers\ImportController.cs</location>
            <body hash="61901a61523463e3394027385642a525"><![CDATA[{
            bool isValid;
            errorMessage = string.Empty;
            var importFolder = Path.Combine(ExportFolder, packageId);
            if (!IsValidImportFolder(importFolder)) return false;
            var dbPath = UnPackDatabase(importFolder);
            try
            {
                using (var ctx = new ExportImportRepository(dbPath))
                {
                    if (summary != null)
                        BuildJobSummary(packageId, ctx, summary);
                    isValid = true;
                }
            }
            catch (Exception ex)
            {
                isValid = false;
                errorMessage = "Package is not valid. Technical Details:" + ex.Message;
            }
            return isValid;
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="SettingsController">
      <declaration><![CDATA[public class SettingsController : ServiceLocator<ISettingsController, SettingsController>, ISettingsController]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public SettingsController()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AddSetting">
          <declaration><![CDATA[public void AddSetting(ExportImportSetting exportImportSetting)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="34" sc="9" el="37" ec="10">Components\Controllers\SettingsController.cs</location>
            <body hash="8c8cd0f2c5fc0398a228f37282a74b43"><![CDATA[{
            DataProvider.Instance().AddExportImportSetting(exportImportSetting);
            DataCache.RemoveCache(CacheKey);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllSettings">
          <declaration><![CDATA[public IEnumerable<ExportImportSetting> GetAllSettings()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="23" sc="9" el="26" ec="10">Components\Controllers\SettingsController.cs</location>
            <body hash="d877b4106afe9a8101f199f29034095d"><![CDATA[{
            return CBO.GetCachedObject<List<ExportImportSetting>>(new CacheItemArgs(CacheKey, CacheDuration, CacheItemPriority.Normal),
                                                                c => CBO.FillQueryable<ExportImportSetting>(DataProvider.Instance().GetExportImportSettings()).ToList());
        }]]></body>
          </codeblock>
        </method>
        <method name="GetFactory">
          <declaration><![CDATA[protected override Func<ISettingsController> GetFactory()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="18" sc="9" el="20" ec="10">Components\Controllers\SettingsController.cs</location>
            <body hash="a454b002bddba4dac2b4dbdc37a147a6"><![CDATA[{
            return () => new SettingsController();
        }]]></body>
          </codeblock>
        </method>
        <method name="GetSetting">
          <declaration><![CDATA[public ExportImportSetting GetSetting(string settingName)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="29" sc="9" el="31" ec="10">Components\Controllers\SettingsController.cs</location>
            <body hash="91c45acca39a4fb4cad7d7f5b0593f1c"><![CDATA[{
            return GetAllSettings().ToList().FirstOrDefault(x => x.SettingName == settingName);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="CacheDuration">
          <declaration><![CDATA[private const int CacheDuration = 120;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="CacheKey">
          <declaration><![CDATA[private const string CacheKey = "ExportImport_Settings";]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="Dnn.ExportImport.Components.Dto">
    <class name="ExportDto">
      <declaration><![CDATA[public class ExportDto]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private string <SchemaVersion>k__BackingField = "1.0.0";]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="35" sc="53" el="35" ec="83">Components\Dto\ExportDto.cs</location>
            <body hash="9b9befb106155a7024bbb85f0f2b2d20"><![CDATA[Constants.CurrentSchemaVersio]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="ExportDescription">
          <declaration><![CDATA[public string ExportDescription]]></declaration>
          <documentation>
            <summary>
 Description of export job.
 </summary>
          </documentation>
          <codeblock>
            <location sl="60" sc="43" el="60" ec="47">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="60" sc="48" el="60" ec="52">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ExportMode">
          <declaration><![CDATA[public ExportMode ExportMode]]></declaration>
          <documentation>
            <summary>
 Export mode. Differential or Complete.
 </summary>
          </documentation>
          <codeblock>
            <location sl="129" sc="40" el="129" ec="44">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="129" sc="45" el="129" ec="49">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ExportName">
          <declaration><![CDATA[public string ExportName]]></declaration>
          <documentation>
            <summary>
 Name of export job.
 </summary>
          </documentation>
          <codeblock>
            <location sl="55" sc="36" el="55" ec="40">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="55" sc="41" el="55" ec="45">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="FromDate">
          <declaration><![CDATA[public DateTime? FromDate]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="147" sc="38" el="147" ec="49">Components\Dto\ExportDto.cs</location>
            <body hash="5655ed1cef38bd0a7d6d28c13068cf09"><![CDATA[FromDateUt]]></body>
          </codeblock>
        </property>
        <property name="FromDateUtc">
          <declaration><![CDATA[public DateTime? FromDateUtc]]></declaration>
          <documentation>
            <summary>
 Items' last modified on or created on for the items which need to be exported.
 This time format should be local time with offset in order to bae sure to export
 items properly and reduce the possibility of export issues.
 </summary>
          </documentation>
          <codeblock>
            <location sl="137" sc="40" el="137" ec="44">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="137" sc="45" el="137" ec="49">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Id">
          <declaration><![CDATA[public int Id]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="31" sc="25" el="31" ec="29">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="31" sc="30" el="31" ec="34">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="IncludeContent">
          <declaration><![CDATA[public bool IncludeContent]]></declaration>
          <documentation>
            <summary>
  Whether to include the content items in the exported file.
 This applies to items such as pages/tabs and the content of their modules.
 </summary>
          </documentation>
          <codeblock>
            <location sl="78" sc="38" el="78" ec="42">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="78" sc="43" el="78" ec="47">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="IncludeDeletions">
          <declaration><![CDATA[public bool IncludeDeletions]]></declaration>
          <documentation>
            <summary>
 Whether to include deleted items in the export.
 Note that these will be deleted on the imported site.
 </summary>
          </documentation>
          <codeblock>
            <location sl="72" sc="40" el="72" ec="44">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="72" sc="45" el="72" ec="49">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="IncludeExtensions">
          <declaration><![CDATA[public bool IncludeExtensions]]></declaration>
          <documentation>
            <summary>
 Whether to include modules packages in exported file.
 </summary>
          </documentation>
          <codeblock>
            <location sl="112" sc="41" el="112" ec="45">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="112" sc="46" el="112" ec="50">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="IncludeFiles">
          <declaration><![CDATA[public bool IncludeFiles]]></declaration>
          <documentation>
            <summary>
 Whether to include item files in the exported file.
 This applies for user files and content files.
 In case the folder's and files were included in the
 <see cref="P:Dnn.ExportImport.Components.Dto.ExportDto.ItemsToExport" /> then, this flag will be set to false.
 </summary>
          </documentation>
          <codeblock>
            <location sl="86" sc="36" el="86" ec="40">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="86" sc="41" el="86" ec="45">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="IncludePermissions">
          <declaration><![CDATA[public bool IncludePermissions]]></declaration>
          <documentation>
            <summary>
 Whether to incldue permissions with each entity in export file or not.
 </summary>
          </documentation>
          <codeblock>
            <location sl="124" sc="42" el="124" ec="46">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="124" sc="47" el="124" ec="51">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="IncludeProperfileProperties">
          <declaration><![CDATA[public bool IncludeProperfileProperties]]></declaration>
          <documentation>
            <summary>
 Whether to include profile properties in exported file.
 When this flag is enabled only then userprofile would be exported.
 </summary>
          </documentation>
          <codeblock>
            <location sl="107" sc="51" el="107" ec="55">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="107" sc="56" el="107" ec="60">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="IncludeRoles">
          <declaration><![CDATA[public bool IncludeRoles]]></declaration>
          <documentation>
            <summary>
 Whether to include roles or not in export file.
 If this flag is disabled, User Roles won't be exported.
 If this flag is disabled, Assets permissions won't be exported.
 </summary>
          </documentation>
          <codeblock>
            <location sl="119" sc="36" el="119" ec="40">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="119" sc="41" el="119" ec="45">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="IncludeTemplates">
          <declaration><![CDATA[public bool IncludeTemplates]]></declaration>
          <documentation>
            <summary>
 Whether to include page templates in export file or not.
 </summary>
          </documentation>
          <codeblock>
            <location sl="101" sc="40" el="101" ec="44">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="101" sc="45" el="101" ec="49">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="IncludeUsers">
          <declaration><![CDATA[public bool IncludeUsers]]></declaration>
          <documentation>
            <summary>
 Whether to include users in the export file or not.
 </summary>
          </documentation>
          <codeblock>
            <location sl="91" sc="36" el="91" ec="40">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="91" sc="41" el="91" ec="45">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="IncludeVocabularies">
          <declaration><![CDATA[public bool IncludeVocabularies]]></declaration>
          <documentation>
            <summary>
 Whether to include vocabularies in the export file or not.
 </summary>
          </documentation>
          <codeblock>
            <location sl="96" sc="43" el="96" ec="47">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="96" sc="48" el="96" ec="52">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="IsDirty">
          <declaration><![CDATA[public bool IsDirty]]></declaration>
          <documentation>
            <summary>
 Used to determine if the DB file needs cleanup before starting import or not.
 </summary>
          </documentation>
          <codeblock>
            <location sl="166" sc="31" el="166" ec="35">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="166" sc="36" el="166" ec="40">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ItemsToExport">
          <declaration><![CDATA[public string[] ItemsToExport]]></declaration>
          <documentation>
            <summary>
 Names of items to export
 </summary>
 <example>["Content", "Assets", "Users"]</example></documentation>
          <codeblock>
            <location sl="66" sc="41" el="66" ec="45">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="66" sc="46" el="66" ec="50">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Pages">
          <declaration><![CDATA[public PageToExport[] Pages]]></declaration>
          <documentation>
            <summary>
 The pages to be exported. These are the ID's (plus other information)
 of all checked items but not their children when a parent is checked.
 If the 'TabId=-1' is included in the list, it means all site pages.
 </summary>
          </documentation>
          <codeblock>
            <location sl="156" sc="39" el="156" ec="43">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="156" sc="44" el="156" ec="48">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="PortalId">
          <declaration><![CDATA[public int PortalId]]></declaration>
          <documentation>
            <summary>
 ID of portal to export items from.
 </summary>
          </documentation>
          <codeblock>
            <location sl="40" sc="31" el="40" ec="35">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="40" sc="36" el="40" ec="40">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ProductSku">
          <declaration><![CDATA[public string ProductSku]]></declaration>
          <documentation>
            <summary>
 SKU of the product from which the export is done.
 </summary>
          </documentation>
          <codeblock>
            <location sl="45" sc="36" el="45" ec="40">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="45" sc="41" el="45" ec="45">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ProductVersion">
          <declaration><![CDATA[public string ProductVersion]]></declaration>
          <documentation>
            <summary>
 Version of the product from which the export is done.
 </summary>
          </documentation>
          <codeblock>
            <location sl="50" sc="40" el="50" ec="44">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="50" sc="45" el="50" ec="49">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="RunNow">
          <declaration><![CDATA[public bool RunNow]]></declaration>
          <documentation>
            <summary>
 Whether to run the job immediately or not.
 </summary>
          </documentation>
          <codeblock>
            <location sl="161" sc="30" el="161" ec="34">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="161" sc="35" el="161" ec="39">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="SchemaVersion">
          <declaration><![CDATA[public string SchemaVersion]]></declaration>
          <documentation>
            <summary>
 Specifies the version of the exportes schema.
 </summary>
          </documentation>
          <codeblock>
            <location sl="35" sc="39" el="35" ec="43">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="35" sc="44" el="35" ec="48">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ToDate">
          <declaration><![CDATA[public DateTime ToDate]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="149" sc="35" el="149" ec="44">Components\Dto\ExportDto.cs</location>
            <body hash="a646d7a6bc0a4b2f0375be5bf832eba0"><![CDATA[ToDateUt]]></body>
          </codeblock>
        </property>
        <property name="ToDateUtc">
          <declaration><![CDATA[public DateTime ToDateUtc]]></declaration>
          <documentation>
            <summary>
 Date when job was created.
 NOTE: This will be set internally only by the engine and not by the UI
 </summary>
          </documentation>
          <codeblock>
            <location sl="144" sc="37" el="144" ec="41">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="144" sc="42" el="144" ec="46">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ExportFileInfo">
      <declaration><![CDATA[public class ExportFileInfo : IDateTimeConverter]]></declaration>
      <documentation>
        <summary>
 Export file(s) info.
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ExportFileInfo()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ConvertToLocal">
          <declaration><![CDATA[public void ConvertToLocal(UserInfo userInfo)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="44" sc="9" el="46" ec="10">Components\Dto\ExportFileInfo.cs</location>
            <body hash="0fab39b7e380b29fc6b152e26da58508"><![CDATA[{
            //Nothing to convert.
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="ExportPath">
          <declaration><![CDATA[public string ExportPath]]></declaration>
          <documentation>
            <summary>
 Path for exported files.
 </summary>
          </documentation>
          <codeblock>
            <location sl="37" sc="36" el="37" ec="40">Components\Dto\ExportFileInfo.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="37" sc="41" el="37" ec="45">Components\Dto\ExportFileInfo.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ExportSize">
          <declaration><![CDATA[public string ExportSize]]></declaration>
          <documentation>
            <summary>
 Formatted size of export file
 </summary>
          </documentation>
          <codeblock>
            <location sl="41" sc="36" el="41" ec="40">Components\Dto\ExportFileInfo.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="41" sc="41" el="41" ec="45">Components\Dto\ExportFileInfo.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ImportDto">
      <declaration><![CDATA[public class ImportDto]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private string <SchemaVersion>k__BackingField = "1.0.0";]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="33" sc="53" el="54" ec="98">Components\Dto\ImportDto.cs</location>
            <body hash="319db468f413618622a4d69815c68ddf"><![CDATA[Constants.CurrentSchemaVersion;

        /// <summary>
        /// ID of portal to import items to.
        /// </summary>
        public int PortalId { get; set; }

        /// <summary>
        /// Id of exported package to be imported
        /// </summary>
        /// <remarks>
        /// For security reasons, this name does not have a folder or extension name.
        /// These will be used by convention and picked from a very specific location
        /// in the portal (<see cref="Constants.ExportFolder"/>)
        /// </remarks>
        public string PackageId { get; set; }

        /// <summary>
        /// Specifies what to do when there is a collision during the import process.
        /// See <see cref="CollisionResolution"/>
        /// </summary>
        public CollisionResolution CollisionResolution { get; set; } = CollisionResolution.Ignore]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="CollisionResolution">
          <declaration><![CDATA[public CollisionResolution CollisionResolution]]></declaration>
          <documentation>
            <summary>
 Specifies what to do when there is a collision during the import process.
 See <see cref="P:Dnn.ExportImport.Components.Dto.ImportDto.CollisionResolution" />
 </summary>
          </documentation>
          <codeblock>
            <location sl="54" sc="58" el="54" ec="62">Components\Dto\ImportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="54" sc="63" el="54" ec="67">Components\Dto\ImportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ExportDto">
          <declaration><![CDATA[public ExportDto ExportDto]]></declaration>
          <documentation>
            <summary>
 Snapshot of the export dto from the import package
 </summary>
          </documentation>
          <codeblock>
            <location sl="59" sc="38" el="59" ec="42">Components\Dto\ImportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="59" sc="43" el="59" ec="47">Components\Dto\ImportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ExportFileInfo">
          <declaration><![CDATA[public ExportFileInfo ExportFileInfo]]></declaration>
          <documentation>
            <summary>
 Snapshot of the import file into.
 </summary>
          </documentation>
          <codeblock>
            <location sl="64" sc="48" el="64" ec="52">Components\Dto\ImportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="64" sc="53" el="64" ec="57">Components\Dto\ImportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="PackageId">
          <declaration><![CDATA[public string PackageId]]></declaration>
          <documentation>
            <summary>
 Id of exported package to be imported
 </summary>
 <remarks>
 For security reasons, this name does not have a folder or extension name.
 These will be used by convention and picked from a very specific location
 in the portal (<see cref="F:Dnn.ExportImport.Components.Common.Constants.ExportFolder" />)
 </remarks></documentation>
          <codeblock>
            <location sl="48" sc="35" el="48" ec="39">Components\Dto\ImportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="48" sc="40" el="48" ec="44">Components\Dto\ImportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="PortalId">
          <declaration><![CDATA[public int PortalId]]></declaration>
          <documentation>
            <summary>
 ID of portal to import items to.
 </summary>
          </documentation>
          <codeblock>
            <location sl="38" sc="31" el="38" ec="35">Components\Dto\ImportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="38" sc="36" el="38" ec="40">Components\Dto\ImportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="RunNow">
          <declaration><![CDATA[public bool RunNow]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="66" sc="30" el="66" ec="34">Components\Dto\ImportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="66" sc="35" el="66" ec="39">Components\Dto\ImportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="SchemaVersion">
          <declaration><![CDATA[public string SchemaVersion]]></declaration>
          <documentation>
            <summary>
 Specifies the version of the exportes schema.
 </summary>
          </documentation>
          <codeblock>
            <location sl="33" sc="39" el="33" ec="43">Components\Dto\ImportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="33" sc="44" el="33" ec="48">Components\Dto\ImportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ImportExportSummary">
      <declaration><![CDATA[public class ImportExportSummary : IDateTimeConverter]]></declaration>
      <documentation>
        <summary>
 Import/Export summary class to provide information about what will happen with this job.
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ImportExportSummary()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="37" sc="9" el="40" ec="10">Components\Dto\ImportExportSummary.cs</location>
            <body hash="58e9da71f96dc8f4d02d4f6de9dfe272"><![CDATA[public ImportExportSummary()
        {
            SummaryItems = new SummaryList();
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ConvertToLocal">
          <declaration><![CDATA[public void ConvertToLocal(UserInfo userInfo)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="98" sc="9" el="113" ec="10">Components\Dto\ImportExportSummary.cs</location>
            <body hash="cab32cee28e33b93a07009770a91ad81"><![CDATA[{
            if (userInfo == null) return;
            ToDate = Util.ToLocalDateTime(ToDate, userInfo);
            if (FromDate != null)
                FromDate = Util.ToLocalDateTime(FromDate.Value, userInfo);
            ExportFileInfo?.ConvertToLocal(userInfo);

            if (SummaryItems == null) return;
            var tempSummaryItems = new SummaryList();
            foreach (var summaryItem in SummaryItems)
            {
                summaryItem.ConvertToLocal(userInfo);
                tempSummaryItems.Add(summaryItem);
            }
            SummaryItems = tempSummaryItems;
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="ExportFileInfo">
          <declaration><![CDATA[public ExportFileInfo ExportFileInfo]]></declaration>
          <documentation>
            <summary>
 Exported file information.
 </summary>
          </documentation>
          <codeblock>
            <location sl="95" sc="48" el="95" ec="52">Components\Dto\ImportExportSummary.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="95" sc="53" el="95" ec="57">Components\Dto\ImportExportSummary.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ExportMode">
          <declaration><![CDATA[public ExportMode ExportMode]]></declaration>
          <documentation>
            <summary>
 Export mode. Differential or complete.
 </summary>
          </documentation>
          <codeblock>
            <location sl="66" sc="40" el="66" ec="44">Components\Dto\ImportExportSummary.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="66" sc="45" el="66" ec="49">Components\Dto\ImportExportSummary.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="FromDate">
          <declaration><![CDATA[public DateTime? FromDate]]></declaration>
          <documentation>
            <summary>
 Date from which data was taken to perform export.
 </summary>
          </documentation>
          <codeblock>
            <location sl="71" sc="37" el="71" ec="41">Components\Dto\ImportExportSummary.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="71" sc="42" el="71" ec="46">Components\Dto\ImportExportSummary.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="FromDateString">
          <declaration><![CDATA[public string FromDateString]]></declaration>
          <documentation>
            <summary>
 Formatted Date from which data was taken to perform export.
 </summary>
          </documentation>
          <codeblock>
            <location sl="76" sc="41" el="76" ec="73">Components\Dto\ImportExportSummary.cs</location>
            <body hash="d1d89845a3e01957c9ab62c45721a0b6"><![CDATA[Util.GetDateTimeString(FromDate]]></body>
          </codeblock>
        </property>
        <property name="IncludeContent">
          <declaration><![CDATA[public bool IncludeContent]]></declaration>
          <documentation>
            <summary>
 Does this import/export includes content or not.
 </summary>
          </documentation>
          <codeblock>
            <location sl="61" sc="38" el="61" ec="42">Components\Dto\ImportExportSummary.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="61" sc="43" el="61" ec="47">Components\Dto\ImportExportSummary.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="IncludeDeletions">
          <declaration><![CDATA[public bool IncludeDeletions]]></declaration>
          <documentation>
            <summary>
 Does this import/export includes the deleted items or not.
 </summary>
          </documentation>
          <codeblock>
            <location sl="56" sc="40" el="56" ec="44">Components\Dto\ImportExportSummary.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="56" sc="45" el="56" ec="49">Components\Dto\ImportExportSummary.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="IncludeExtensions">
          <declaration><![CDATA[public bool IncludeExtensions]]></declaration>
          <documentation>
            <summary>
 Does this import/export includes the modules or not.
 </summary>
          </documentation>
          <codeblock>
            <location sl="52" sc="41" el="52" ec="45">Components\Dto\ImportExportSummary.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="52" sc="46" el="52" ec="50">Components\Dto\ImportExportSummary.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="IncludePermissions">
          <declaration><![CDATA[public bool IncludePermissions]]></declaration>
          <documentation>
            <summary>
 Does this import/export includes the permission or not.
 </summary>
          </documentation>
          <codeblock>
            <location sl="48" sc="42" el="48" ec="46">Components\Dto\ImportExportSummary.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="48" sc="47" el="48" ec="51">Components\Dto\ImportExportSummary.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="IncludeProfileProperties">
          <declaration><![CDATA[public bool IncludeProfileProperties]]></declaration>
          <documentation>
            <summary>
 Does this import/export includes the properties definitions or not.
 </summary>
          </documentation>
          <codeblock>
            <location sl="44" sc="48" el="44" ec="52">Components\Dto\ImportExportSummary.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="44" sc="53" el="44" ec="57">Components\Dto\ImportExportSummary.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="SummaryItems">
          <declaration><![CDATA[public IEnumerable<SummaryItem> SummaryItems]]></declaration>
          <documentation>
            <summary>
 Summary of each item export.
 </summary>
          </documentation>
          <codeblock>
            <location sl="91" sc="56" el="91" ec="60">Components\Dto\ImportExportSummary.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="91" sc="61" el="91" ec="65">Components\Dto\ImportExportSummary.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ToDate">
          <declaration><![CDATA[public DateTime ToDate]]></declaration>
          <documentation>
            <summary>
 Date till which data was taken to perform export.
 </summary>
          </documentation>
          <codeblock>
            <location sl="81" sc="34" el="81" ec="38">Components\Dto\ImportExportSummary.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="81" sc="39" el="81" ec="43">Components\Dto\ImportExportSummary.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ToDateString">
          <declaration><![CDATA[public string ToDateString]]></declaration>
          <documentation>
            <summary>
 Formatted Date till which data was taken to perform export.
 </summary>
          </documentation>
          <codeblock>
            <location sl="86" sc="39" el="86" ec="69">Components\Dto\ImportExportSummary.cs</location>
            <body hash="a6fb88783c7e7fb4b50b307f45508b44"><![CDATA[Util.GetDateTimeString(ToDate]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ImportPackageInfo">
      <declaration><![CDATA[public class ImportPackageInfo : IDateTimeConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ImportPackageInfo()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ConvertToLocal">
          <declaration><![CDATA[public void ConvertToLocal(UserInfo userInfo)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="79" sc="9" el="83" ec="10">Components\Dto\ImportPackageInfo.cs</location>
            <body hash="c70c89dda13c31b7fac74a4b50e5ec68"><![CDATA[{
            if (userInfo == null) return;
            ExporTime = Util.ToLocalDateTime(ExporTime, userInfo);
            Summary?.ConvertToLocal(userInfo);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Description">
          <declaration><![CDATA[public string Description]]></declaration>
          <documentation>
            <summary>
 Package description
 </summary>
          </documentation>
          <codeblock>
            <location sl="66" sc="37" el="66" ec="41">Components\Dto\ImportPackageInfo.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="66" sc="42" el="66" ec="46">Components\Dto\ImportPackageInfo.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ExporTime">
          <declaration><![CDATA[public DateTime ExporTime]]></declaration>
          <documentation>
            <summary>
 DateTime when the package was exported.
 </summary>
          </documentation>
          <codeblock>
            <location sl="51" sc="37" el="51" ec="41">Components\Dto\ImportPackageInfo.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="51" sc="42" el="51" ec="46">Components\Dto\ImportPackageInfo.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ExporTimeString">
          <declaration><![CDATA[public string ExporTimeString]]></declaration>
          <documentation>
            <summary>
 Formatted DateTime when the package was exported.
 </summary>
          </documentation>
          <codeblock>
            <location sl="56" sc="42" el="56" ec="75">Components\Dto\ImportPackageInfo.cs</location>
            <body hash="3b571ee0fc2ecad420712a5b32f50d18"><![CDATA[Util.GetDateTimeString(ExporTime]]></body>
          </codeblock>
        </property>
        <property name="FileName">
          <declaration><![CDATA[public string FileName]]></declaration>
          <documentation>
            <summary>
 Package file name. It is just fake name for UI representation
 </summary>
          </documentation>
          <codeblock>
            <location sl="46" sc="35" el="46" ec="44">Components\Dto\ImportPackageInfo.cs</location>
            <body hash="0d561ca06e5f25547fa3c1b261c1f698"><![CDATA[PackageI]]></body>
          </codeblock>
        </property>
        <property name="Name">
          <declaration><![CDATA[public string Name]]></declaration>
          <documentation>
            <summary>
 Name of the package.
 </summary>
          </documentation>
          <codeblock>
            <location sl="41" sc="30" el="41" ec="34">Components\Dto\ImportPackageInfo.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="41" sc="35" el="41" ec="39">Components\Dto\ImportPackageInfo.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="PackageId">
          <declaration><![CDATA[public string PackageId]]></declaration>
          <documentation>
            <summary>
 Package Id. Used to identify the package and path.
 </summary>
          </documentation>
          <codeblock>
            <location sl="36" sc="35" el="36" ec="39">Components\Dto\ImportPackageInfo.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="36" sc="40" el="36" ec="44">Components\Dto\ImportPackageInfo.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="PortalName">
          <declaration><![CDATA[public string PortalName]]></declaration>
          <documentation>
            <summary>
 The portal from which the exported package was created
 </summary>
          </documentation>
          <codeblock>
            <location sl="61" sc="36" el="61" ec="40">Components\Dto\ImportPackageInfo.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="61" sc="41" el="61" ec="45">Components\Dto\ImportPackageInfo.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Summary">
          <declaration><![CDATA[public ImportExportSummary Summary]]></declaration>
          <documentation>
            <summary>
 Complete summary of import package
 </summary>
          </documentation>
          <codeblock>
            <location sl="76" sc="46" el="76" ec="50">Components\Dto\ImportPackageInfo.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="76" sc="51" el="76" ec="55">Components\Dto\ImportPackageInfo.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Thumb">
          <declaration><![CDATA[public string Thumb]]></declaration>
          <documentation>
            <summary>
 Path to the thumbnail image for the package.
 </summary>
          </documentation>
          <codeblock>
            <location sl="71" sc="32" el="71" ec="50">Components\Dto\ImportPackageInfo.cs</location>
            <body hash="4e22941827a5c8c77d82c2c98f6eebef"><![CDATA[PackageId + ".jpg]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="PageToExport">
      <declaration><![CDATA[public class PageToExport]]></declaration>
      <documentation>
        <summary>
  Spercifies page to be exported.
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public PageToExport()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="CheckedState">
          <declaration><![CDATA[public TriCheckedState CheckedState]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="177" sc="47" el="177" ec="51">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="177" sc="52" el="177" ec="56">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ParentTabId">
          <declaration><![CDATA[public int ParentTabId]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="176" sc="34" el="176" ec="38">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="176" sc="39" el="176" ec="43">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="TabId">
          <declaration><![CDATA[public int TabId]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="175" sc="28" el="175" ec="32">Components\Dto\ExportDto.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="175" sc="33" el="175" ec="37">Components\Dto\ExportDto.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="SummaryItem">
      <declaration><![CDATA[public class SummaryItem : IDateTimeConverter]]></declaration>
      <documentation>
        <summary>
 Details of the summary item to show in the export/import summary and progress.
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public SummaryItem()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ConvertToLocal">
          <declaration><![CDATA[public void ConvertToLocal(UserInfo userInfo)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="77" sc="9" el="79" ec="10">Components\Dto\SummaryItem.cs</location>
            <body hash="0fab39b7e380b29fc6b152e26da58508"><![CDATA[{
            //Nothing to convert.
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Category">
          <declaration><![CDATA[public string Category]]></declaration>
          <documentation>
            <summary>
 Category of the import/export. Also identifier for localization
 </summary>
          </documentation>
          <codeblock>
            <location sl="39" sc="34" el="39" ec="38">Components\Dto\SummaryItem.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="39" sc="39" el="39" ec="43">Components\Dto\SummaryItem.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Completed">
          <declaration><![CDATA[public bool Completed]]></declaration>
          <documentation>
            <summary>
 Is job finished or not yet.
 </summary>
          </documentation>
          <codeblock>
            <location sl="59" sc="33" el="59" ec="37">Components\Dto\SummaryItem.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="59" sc="38" el="59" ec="42">Components\Dto\SummaryItem.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Order">
          <declaration><![CDATA[public uint Order]]></declaration>
          <documentation>
            <summary>
 Order to show on UI.
 </summary>
          </documentation>
          <codeblock>
            <location sl="74" sc="29" el="74" ec="33">Components\Dto\SummaryItem.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="74" sc="34" el="74" ec="38">Components\Dto\SummaryItem.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ProcessedItems">
          <declaration><![CDATA[public int ProcessedItems]]></declaration>
          <documentation>
            <summary>
 Items processed.
 </summary>
          </documentation>
          <codeblock>
            <location sl="54" sc="37" el="54" ec="41">Components\Dto\SummaryItem.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="54" sc="42" el="54" ec="46">Components\Dto\SummaryItem.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ProcessedItemsString">
          <declaration><![CDATA[public string ProcessedItemsString]]></declaration>
          <documentation>
            <summary>
 Formatted processed items.
 </summary>
          </documentation>
          <codeblock>
            <location sl="64" sc="47" el="64" ec="80">Components\Dto\SummaryItem.cs</location>
            <body hash="cd48d92d85715531f0ff55aae60d53eb"><![CDATA[Util.FormatNumber(ProcessedItems]]></body>
          </codeblock>
        </property>
        <property name="ProgressPercentage">
          <declaration><![CDATA[public int ProgressPercentage]]></declaration>
          <documentation>
            <summary>
 Progress in percentage.
 </summary>
          </documentation>
          <codeblock>
            <location sl="69" sc="41" el="69" ec="45">Components\Dto\SummaryItem.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="69" sc="46" el="69" ec="50">Components\Dto\SummaryItem.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="TotalItems">
          <declaration><![CDATA[public int TotalItems]]></declaration>
          <documentation>
            <summary>
 Total items to import/export.
 </summary>
          </documentation>
          <codeblock>
            <location sl="44" sc="33" el="44" ec="37">Components\Dto\SummaryItem.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="44" sc="38" el="44" ec="42">Components\Dto\SummaryItem.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="TotalItemsString">
          <declaration><![CDATA[public string TotalItemsString]]></declaration>
          <documentation>
            <summary>
 Formatted total items.
 </summary>
          </documentation>
          <codeblock>
            <location sl="49" sc="43" el="49" ec="72">Components\Dto\SummaryItem.cs</location>
            <body hash="45d0ec3b87546e04ad185deab1b854b1"><![CDATA[Util.FormatNumber(TotalItems]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="TriCheckedState">
      <declaration><![CDATA[public enum TriCheckedState]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="Checked">
          <declaration><![CDATA[public const TriCheckedState Checked = 0;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Partial">
          <declaration><![CDATA[public const TriCheckedState Partial = 2;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="UnChecked">
          <declaration><![CDATA[public const TriCheckedState UnChecked = 1;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="Dnn.ExportImport.Components.Dto.Jobs">
    <class name="AllJobsResult">
      <declaration><![CDATA[public class AllJobsResult : IDateTimeConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public AllJobsResult()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ConvertToLocal">
          <declaration><![CDATA[public void ConvertToLocal(UserInfo userInfo)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="49" sc="9" el="63" ec="10">Components\Dto\Jobs\AllJobsResult.cs</location>
            <body hash="1788f8672f5643396390d704d1472a96"><![CDATA[{
            LastExportTime = Util.ToLocalDateTime(LastExportTime, userInfo);
            LastImportTime = Util.ToLocalDateTime(LastImportTime, userInfo);

            if (userInfo == null) return;
            if (Jobs == null) return;
            var tempJobs = new List<JobItem>();

            foreach (var job in Jobs)
            {
                job.ConvertToLocal(userInfo);
                tempJobs.Add(job);
            }
            Jobs = tempJobs;
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Jobs">
          <declaration><![CDATA[public IEnumerable<JobItem> Jobs]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="46" sc="44" el="46" ec="48">Components\Dto\Jobs\AllJobsResult.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="46" sc="49" el="46" ec="53">Components\Dto\Jobs\AllJobsResult.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="LastExportTime">
          <declaration><![CDATA[public DateTime? LastExportTime]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="39" sc="43" el="39" ec="47">Components\Dto\Jobs\AllJobsResult.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="39" sc="48" el="39" ec="52">Components\Dto\Jobs\AllJobsResult.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="LastExportTimeString">
          <declaration><![CDATA[public string LastExportTimeString]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="42" sc="47" el="42" ec="85">Components\Dto\Jobs\AllJobsResult.cs</location>
            <body hash="f03a1ab9ab550aeb211a653c65d85bf2"><![CDATA[Util.GetDateTimeString(LastExportTime]]></body>
          </codeblock>
        </property>
        <property name="LastImportTime">
          <declaration><![CDATA[public DateTime? LastImportTime]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="40" sc="43" el="40" ec="47">Components\Dto\Jobs\AllJobsResult.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="40" sc="48" el="40" ec="52">Components\Dto\Jobs\AllJobsResult.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="LastImportTimeString">
          <declaration><![CDATA[public string LastImportTimeString]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="44" sc="47" el="44" ec="85">Components\Dto\Jobs\AllJobsResult.cs</location>
            <body hash="aa85adb2a147d2ef3ea37f5b76015ddd"><![CDATA[Util.GetDateTimeString(LastImportTime]]></body>
          </codeblock>
        </property>
        <property name="PortalId">
          <declaration><![CDATA[public int PortalId]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="34" sc="31" el="34" ec="35">Components\Dto\Jobs\AllJobsResult.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="34" sc="36" el="34" ec="40">Components\Dto\Jobs\AllJobsResult.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="PortalName">
          <declaration><![CDATA[public string PortalName]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="35" sc="36" el="35" ec="40">Components\Dto\Jobs\AllJobsResult.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="35" sc="41" el="35" ec="45">Components\Dto\Jobs\AllJobsResult.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="TotalJobs">
          <declaration><![CDATA[public int TotalJobs]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="36" sc="32" el="36" ec="36">Components\Dto\Jobs\AllJobsResult.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="36" sc="37" el="36" ec="41">Components\Dto\Jobs\AllJobsResult.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="TotalJobsString">
          <declaration><![CDATA[public string TotalJobsString]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="37" sc="42" el="37" ec="70">Components\Dto\Jobs\AllJobsResult.cs</location>
            <body hash="828e69a24d2083fbc17a0b31dcd870fe"><![CDATA[Util.FormatNumber(TotalJobs]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="JobItem">
      <declaration><![CDATA[public class JobItem : IDateTimeConverter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public JobItem()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ConvertToLocal">
          <declaration><![CDATA[public void ConvertToLocal(UserInfo userInfo)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="52" sc="9" el="58" ec="10">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="56f65bf0b1c37ad0840d2ecf0b0eefbc"><![CDATA[{
            if (userInfo == null) return;
            Summary?.ConvertToLocal(userInfo);
            CreatedOn = Util.ToLocalDateTime(CreatedOn, userInfo);
            if (CompletedOn != null)
                CompletedOn = Util.ToLocalDateTime(CompletedOn.Value, userInfo);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Cancelled">
          <declaration><![CDATA[public bool Cancelled]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="38" sc="33" el="38" ec="37">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="38" sc="38" el="38" ec="42">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="CompletedOn">
          <declaration><![CDATA[public DateTime? CompletedOn]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="44" sc="40" el="44" ec="44">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="44" sc="45" el="44" ec="49">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="CompletedOnString">
          <declaration><![CDATA[public string CompletedOnString]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="45" sc="44" el="45" ec="79">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="ed34632780aeb67769f76d1b1b48d16a"><![CDATA[Util.GetDateTimeString(CompletedOn]]></body>
          </codeblock>
        </property>
        <property name="CreatedOn">
          <declaration><![CDATA[public DateTime CreatedOn]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="42" sc="37" el="42" ec="41">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="42" sc="42" el="42" ec="46">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="CreatedOnString">
          <declaration><![CDATA[public string CreatedOnString]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="43" sc="42" el="43" ec="75">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="03ab1e21fbf622916a16a10d20e45cf3"><![CDATA[Util.GetDateTimeString(CreatedOn]]></body>
          </codeblock>
        </property>
        <property name="Description">
          <declaration><![CDATA[public string Description]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="41" sc="37" el="41" ec="41">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="41" sc="42" el="41" ec="46">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ExportFile">
          <declaration><![CDATA[public string ExportFile]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="47" sc="36" el="47" ec="40">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="47" sc="41" el="47" ec="45">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="JobId">
          <declaration><![CDATA[public int JobId]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="33" sc="28" el="33" ec="32">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="33" sc="33" el="33" ec="37">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="JobStatus">
          <declaration><![CDATA[public string JobStatus]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="39" sc="35" el="39" ec="39">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="39" sc="40" el="39" ec="44">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="JobType">
          <declaration><![CDATA[public string JobType]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="36" sc="33" el="36" ec="37">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="36" sc="38" el="36" ec="42">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Name">
          <declaration><![CDATA[public string Name]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="40" sc="30" el="40" ec="34">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="40" sc="35" el="40" ec="39">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="PortalId">
          <declaration><![CDATA[public int PortalId]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="34" sc="31" el="34" ec="35">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="34" sc="36" el="34" ec="40">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Status">
          <declaration><![CDATA[public int Status]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="37" sc="29" el="37" ec="33">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="37" sc="34" el="37" ec="38">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Summary">
          <declaration><![CDATA[public ImportExportSummary Summary]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="49" sc="46" el="49" ec="50">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="49" sc="51" el="49" ec="55">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="User">
          <declaration><![CDATA[public string User]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="35" sc="30" el="35" ec="34">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="35" sc="35" el="35" ec="39">Components\Dto\Jobs\JobItem.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="LogItem">
      <declaration><![CDATA[public class LogItem]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public LogItem()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="CreatedOnDate">
          <declaration><![CDATA[public DateTime CreatedOnDate]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="31" sc="41" el="31" ec="45">Components\Dto\Jobs\LogItem.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="31" sc="46" el="31" ec="50">Components\Dto\Jobs\LogItem.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Name">
          <declaration><![CDATA[public string Name]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="32" sc="30" el="32" ec="34">Components\Dto\Jobs\LogItem.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="32" sc="35" el="32" ec="39">Components\Dto\Jobs\LogItem.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ReportLevel">
          <declaration><![CDATA[public ReportLevel ReportLevel]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="34" sc="42" el="34" ec="46">Components\Dto\Jobs\LogItem.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="34" sc="47" el="34" ec="51">Components\Dto\Jobs\LogItem.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Value">
          <declaration><![CDATA[public string Value]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="33" sc="31" el="33" ec="35">Components\Dto\Jobs\LogItem.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="33" sc="36" el="33" ec="40">Components\Dto\Jobs\LogItem.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="Dnn.ExportImport.Components.Engines">
    <class name="ExportImportEngine">
      <declaration><![CDATA[public class ExportImportEngine]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".cctor">
          <declaration><![CDATA[static ExportImportEngine()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="56" sc="9" el="727" ec="11">Components\Engines\ExportImportEngine.cs</location>
            <body hash="ea40ba1cd9d578dce2c570ef5c6a45e5"><![CDATA[private static readonly ILog Logger = LoggerSource.Instance.GetLogger(typeof(ExportImportEngine));

        private const StringComparison IgnoreCaseComp = StringComparison.InvariantCultureIgnoreCase;

        private static readonly string ExportFolder;

        static ExportImportEngine()
        {
            ExportFolder = Globals.ApplicationMapPath + Constants.ExportFolder;
            if (!Directory.Exists(ExportFolder))
            {
                Directory.CreateDirectory(ExportFolder);
            }
        }

        private readonly Stopwatch _stopWatch = Stopwatch.StartNew();
        private int _timeoutSeconds;

        public void Export(ExportImportJob exportJob, ExportImportResult result, ScheduleHistoryItem scheduleHistoryItem)
        {
            var exportDto = JsonConvert.DeserializeObject<ExportDto>(exportJob.JobObject);
            if (exportDto == null)
            {
                exportJob.CompletedOnDate = DateUtils.GetDatabaseUtcTime();
                exportJob.JobStatus = JobStatus.Failed;
                return;
            }

            _timeoutSeconds = GetTimeoutPerSlot();
            var dbName = Path.Combine(ExportFolder, exportJob.Directory, Constants.ExportDbName);
            var finfo = new FileInfo(dbName);
            dbName = finfo.FullName;


            var checkpoints = EntitiesController.Instance.GetJobChekpoints(exportJob.JobId);

            //Delete so we start a fresh export database; only if there is no previous checkpoint exists
            if (checkpoints.Count == 0)
            {
                if (finfo.Directory != null && finfo.Directory.Exists)
                {
                    finfo.Directory.Delete(true);
                }
                //Clear all the files in finfo.Directory. Create if doesn't exists.
                finfo.Directory?.Create();
                result.AddSummary("Starting Exporting Repository", finfo.Name);
            }
            else
            {
                if (finfo.Directory != null && finfo.Directory.Exists)
                {
                    result.AddSummary("Resuming Exporting Repository", finfo.Name);
                }
                else
                {
                    scheduleHistoryItem.AddLogNote("Resuming data not found.");
                    result.AddSummary("Resuming data not found.", finfo.Name);
                    return;
                }
            }

            exportJob.JobStatus = JobStatus.InProgress;

            // there must be one parent implementor at least for this to work
            var implementors = Util.GetPortableImplementors().ToList();
            var parentServices = implementors.Where(imp => string.IsNullOrEmpty(imp.ParentCategory)).ToList();
            implementors = implementors.Except(parentServices).ToList();
            var nextLevelServices = new List<BasePortableService>();
            var includedItems = GetAllCategoriesToInclude(exportDto, implementors);

            if (includedItems.Count == 0)
            {
                scheduleHistoryItem.AddLogNote("Export NOT Possible");
                scheduleHistoryItem.AddLogNote("<br/>No items selected for exporting");
                result.AddSummary("Export NOT Possible", "No items selected for exporting");
                exportJob.CompletedOnDate = DateUtils.GetDatabaseUtcTime();
                exportJob.JobStatus = JobStatus.Failed;
                return;
            }
            scheduleHistoryItem.AddLogNote($"<br/><b>SITE EXPORT Preparing Check Points. JOB #{exportJob.JobId}: {exportJob.Name}</b>");
            PrepareCheckPoints(exportJob.JobId, parentServices, implementors, includedItems, checkpoints);

            scheduleHistoryItem.AddLogNote($"<br/><b>SITE EXPORT Started. JOB #{exportJob.JobId}: {exportJob.Name}</b>");
            scheduleHistoryItem.AddLogNote($"<br/>Between [{exportDto.FromDateUtc ?? Constants.MinDbTime}] and [{exportDto.ToDateUtc:g}]");
            var firstIteration = true;
            AddJobToCache(exportJob);

            using (var ctx = new ExportImportRepository(dbName))
            {
                ctx.AddSingleItem(exportDto);
                do
                {
                    foreach (var service in parentServices.OrderBy(x => x.Priority))
                    {
                        if (exportJob.IsCancelled)
                        {
                            exportJob.JobStatus = JobStatus.Cancelled;
                            break;
                        }

                        if (implementors.Count > 0)
                        {
                            // collect children for next iteration
                            var children =
                                implementors.Where(imp => service.Category.Equals(imp.ParentCategory, IgnoreCaseComp));
                            nextLevelServices.AddRange(children);
                            implementors = implementors.Except(nextLevelServices).ToList();
                        }

                        if ((firstIteration && includedItems.Any(x => x.Equals(service.Category, IgnoreCaseComp))) ||
                            (!firstIteration && includedItems.Any(x => x.Equals(service.ParentCategory, IgnoreCaseComp))))
                        {
                            var serviceAssembly = service.GetType().Assembly.GetName().Name;
                            service.Result = result;
                            service.Repository = ctx;
                            service.CheckCancelled = CheckCancelledCallBack;
                            service.CheckPointStageCallback = CheckpointCallback;
                            service.CheckPoint = checkpoints.FirstOrDefault(cp => cp.Category == service.Category && cp.AssemblyName == serviceAssembly);

                            if (service.CheckPoint == null)
                            {
                                service.CheckPoint = new ExportImportChekpoint
                                {
                                    JobId = exportJob.JobId,
                                    Category = service.Category,
                                    AssemblyName = serviceAssembly,
                                    StartDate = DateUtils.GetDatabaseUtcTime()
                                };

                                // persist the record in db
                                CheckpointCallback(service);
                            }
                            else if (service.CheckPoint.StartDate == Null.NullDate)
                                service.CheckPoint.StartDate = DateUtils.GetDatabaseUtcTime();

                            try
                            {
                                service.ExportData(exportJob, exportDto);

                            }
                            finally
                            {
                                AddLogsToDatabase(exportJob.JobId, result.CompleteLog);
                            }
                            scheduleHistoryItem.AddLogNote("<br/>Exported: " + service.Category);
                        }
                    }

                    firstIteration = false;
                    parentServices = new List<BasePortableService>(nextLevelServices);
                    nextLevelServices.Clear();
                    if (implementors.Count > 0 && parentServices.Count == 0)
                    {
                        //WARN: this is a case where there is a broken parent-children hierarchy
                        //      and/or there are BasePortableService implementations without a known parent.
                        parentServices = implementors;
                        implementors.Clear();
                        scheduleHistoryItem.AddLogNote(
                            "<br/><b>Orphaned services:</b> " + string.Join(",", parentServices.Select(x => x.Category)));
                    }
                } while (parentServices.Count > 0 && !TimeIsUp);

                RemoveTokenFromCache(exportJob);
            }

            if (TimeIsUp)
            {
                result.AddSummary($"Job time slot ({_timeoutSeconds} sec) expired",
                    "Job will resume in the next scheduler iteration");
            }
            else if (exportJob.JobStatus == JobStatus.InProgress)
            {
                //Create Export Summary for manifest file.
                var summary = new ImportExportSummary();
                using (var ctx = new ExportImportRepository(dbName))
                {
                    BaseController.BuildJobSummary(exportJob.Directory, ctx, summary);
                }
                DoPacking(exportJob, dbName);
                //Complete the job.
                exportJob.JobStatus = JobStatus.Successful;
                SetLastJobStartTime(scheduleHistoryItem.ScheduleID, exportJob.CreatedOnDate);

                var exportController = new ExportController();
                var exportFileInfo = new ExportFileInfo
                {
                    ExportPath = exportJob.Directory,
                    ExportSize = Util.FormatSize(GetExportSize(Path.Combine(ExportFolder, exportJob.Directory)))
                };

                summary.ExportFileInfo = exportFileInfo;
                exportController.CreatePackageManifest(exportJob, exportFileInfo, summary);
            }
        }

        public void Import(ExportImportJob importJob, ExportImportResult result, ScheduleHistoryItem scheduleHistoryItem)
        {
            scheduleHistoryItem.AddLogNote($"<br/><b>SITE IMPORT Started. JOB #{importJob.JobId}</b>");
            _timeoutSeconds = GetTimeoutPerSlot();
            var importDto = JsonConvert.DeserializeObject<ImportDto>(importJob.JobObject);
            if (importDto == null)
            {
                importJob.CompletedOnDate = DateUtils.GetDatabaseUtcTime();
                importJob.JobStatus = JobStatus.Failed;
                return;
            }

            var dbName = Path.Combine(ExportFolder, importJob.Directory, Constants.ExportDbName);
            var finfo = new FileInfo(dbName);

            if (!finfo.Exists)
            {
                DoUnPacking(importJob);
                finfo = new FileInfo(dbName);
            }

            if (!finfo.Exists)
            {
                scheduleHistoryItem.AddLogNote("<br/>Import file not found. Name: " + dbName);
                importJob.CompletedOnDate = DateUtils.GetDatabaseUtcTime();
                importJob.JobStatus = JobStatus.Failed;
                return;
            }

            using (var ctx = new ExportImportRepository(dbName))
            {
                var exportedDto = ctx.GetSingleItem<ExportDto>();
                var exportVersion = new Version(exportedDto.SchemaVersion);
                var importVersion = new Version(importDto.SchemaVersion);
                if (importVersion < exportVersion)
                {
                    importJob.CompletedOnDate = DateUtils.GetDatabaseUtcTime();
                    importJob.JobStatus = JobStatus.Failed;
                    scheduleHistoryItem.AddLogNote("Import NOT Possible");
                    var msg =
                        $"Exported version ({exportedDto.SchemaVersion}) is newer than import engine version ({importDto.SchemaVersion})";
                    result.AddSummary("Import NOT Possible", msg);
                    return;
                }

                var checkpoints = EntitiesController.Instance.GetJobChekpoints(importJob.JobId);
                if (checkpoints.Count == 0)
                {
                    result.AddSummary("Starting Importing Repository", finfo.Name);
                    result.AddSummary("Importing File Size", Util.FormatSize(finfo.Length));
                    CleanupDatabaseIfDirty(ctx);
                }
                else
                {
                    result.AddSummary("Resuming Importing Repository", finfo.Name);
                }

                var implementors = Util.GetPortableImplementors().ToList();
                var parentServices = implementors.Where(imp => string.IsNullOrEmpty(imp.ParentCategory)).ToList();

                importJob.Name = exportedDto.ExportName;
                importJob.Description = exportedDto.ExportDescription;
                importJob.JobStatus = JobStatus.InProgress;

                // there must be one parent implementor at least for this to work
                implementors = implementors.Except(parentServices).ToList();
                var nextLevelServices = new List<BasePortableService>();
                var includedItems = GetAllCategoriesToInclude(exportedDto, implementors);

                scheduleHistoryItem.AddLogNote($"<br/><b>SITE IMPORT Preparing Check Points. JOB #{importJob.JobId}: {importJob.Name}</b>");
                PrepareCheckPoints(importJob.JobId, parentServices, implementors, includedItems, checkpoints);

                var firstIteration = true;
                AddJobToCache(importJob);

                do
                {
                    foreach (var service in parentServices.OrderBy(x => x.Priority))
                    {
                        if (importJob.IsCancelled)
                        {
                            importJob.JobStatus = JobStatus.Cancelled;
                            break;
                        }

                        if (implementors.Count > 0)
                        {
                            // collect children for next iteration
                            var children =
                                implementors.Where(imp => service.Category.Equals(imp.ParentCategory, IgnoreCaseComp));
                            nextLevelServices.AddRange(children);
                            implementors = implementors.Except(nextLevelServices).ToList();
                        }

                        if ((firstIteration && includedItems.Any(x => x.Equals(service.Category, IgnoreCaseComp))) ||
                            (!firstIteration && includedItems.Any(x => x.Equals(service.ParentCategory, IgnoreCaseComp))))
                        {
                            var serviceAssembly = service.GetType().Assembly.GetName().Name;

                            service.Result = result;
                            service.Repository = ctx;
                            service.CheckCancelled = CheckCancelledCallBack;
                            service.CheckPointStageCallback = CheckpointCallback;
                            service.CheckPoint = checkpoints.FirstOrDefault(cp => cp.Category == service.Category && cp.AssemblyName == serviceAssembly)
                                                 ?? new ExportImportChekpoint
                                                 {
                                                     JobId = importJob.JobId,
                                                     AssemblyName = serviceAssembly,
                                                     Category = service.Category,
                                                     Progress = 0,
                                                     StartDate = DateUtils.GetDatabaseUtcTime()
                                                 };
                            if (service.CheckPoint.StartDate == Null.NullDate)
                                service.CheckPoint.StartDate = DateUtils.GetDatabaseUtcTime();
                            CheckpointCallback(service);

                            try
                            {
                                service.ImportData(importJob, importDto);
                            }
                            finally
                            {
                                AddLogsToDatabase(importJob.JobId, result.CompleteLog);
                            }
                            scheduleHistoryItem.AddLogNote("<br/>Imported: " + service.Category);
                        }
                    }

                    firstIteration = false;
                    parentServices = new List<BasePortableService>(nextLevelServices);
                    nextLevelServices.Clear();
                    if (implementors.Count > 0 && parentServices.Count == 0)
                    {
                        //WARN: this is a case where there is a broken parent-children hierarchy
                        //      and/or there are BasePortableService implementations without a known parent.
                        parentServices = implementors;
                        implementors.Clear();
                        scheduleHistoryItem.AddLogNote(
                            "<br/><b>Orphaned services:</b> " + string.Join(",", parentServices.Select(x => x.Category)));
                    }
                } while (parentServices.Count > 0 && !TimeIsUp);

                RemoveTokenFromCache(importJob);
                if (TimeIsUp)
                {
                    result.AddSummary($"Job time slot ({_timeoutSeconds} sec) expired",
                        "Job will resume in the next scheduler iteration");
                }
                else if (importJob.JobStatus == JobStatus.InProgress)
                {
                    importJob.JobStatus = JobStatus.Successful;
                    if (importDto.ExportDto.IncludeContent)
                    {
                        PagesExportService.ResetContentsFlag(ctx);
                    }
                }
            }
        }

        private void PrepareCheckPoints(int jobId, List<BasePortableService> parentServices, List<BasePortableService> implementors,
            HashSet<string> includedItems, IList<ExportImportChekpoint> checkpoints)
        {
            // there must be one parent implementor at least for this to work
            var nextLevelServices = new List<BasePortableService>();
            var firstIteration = true;
            if (checkpoints.Any()) return;
            do
            {
                foreach (var service in parentServices.OrderBy(x => x.Priority))
                {
                    if (implementors.Count > 0)
                    {
                        // collect children for next iteration
                        var children =
                            implementors.Where(imp => service.Category.Equals(imp.ParentCategory, IgnoreCaseComp));
                        nextLevelServices.AddRange(children);
                        implementors = implementors.Except(nextLevelServices).ToList();
                    }

                    if ((firstIteration && includedItems.Any(x => x.Equals(service.Category, IgnoreCaseComp))) ||
                        (!firstIteration && includedItems.Any(x => x.Equals(service.ParentCategory, IgnoreCaseComp))))
                    {
                        var serviceAssembly = service.GetType().Assembly.GetName().Name;

                        service.CheckPoint = checkpoints.FirstOrDefault(cp => cp.Category == service.Category && cp.AssemblyName == serviceAssembly);

                        if (service.CheckPoint != null) continue;

                        service.CheckPoint = new ExportImportChekpoint
                        {
                            JobId = jobId,
                            AssemblyName = serviceAssembly,
                            Category = service.Category,
                            Progress = 0
                        };

                        // persist the record in db
                        CheckpointCallback(service);
                    }
                }

                firstIteration = false;
                parentServices = new List<BasePortableService>(nextLevelServices);
                nextLevelServices.Clear();
            } while (parentServices.Count > 0);
        }

        private static bool CheckCancelledCallBack(ExportImportJob job)
        {
            var job2 = CachingProvider.Instance().GetItem(Util.GetExpImpJobCacheKey(job)) as ExportImportJob;
            if (job2 == null)
            {
                job2 = EntitiesController.Instance.GetJobById(job.JobId);
                job.IsCancelled = job2.IsCancelled;
                AddJobToCache(job2);
            }

            return job2.IsCancelled;
        }

        /// <summary>
        /// Callback function to provide a checkpoint mechanism for an <see cref="BasePortableService"/> implementation.
        /// </summary>
        /// <param name="service">The <see cref="BasePortableService"/> implementation</param>
        /// <returns>Treu to stop further <see cref="BasePortableService"/> processing; false otherwise</returns>
        private bool CheckpointCallback(BasePortableService service)
        {
            EntitiesController.Instance.UpdateJobChekpoint(service.CheckPoint);
            return TimeIsUp;
        }

        private bool TimeIsUp => _stopWatch.Elapsed.TotalSeconds > _timeoutSeconds;

        private static void AddJobToCache(ExportImportJob job)
        {
            CachingProvider.Instance().Insert(Util.GetExpImpJobCacheKey(job), job);
        }

        private static void RemoveTokenFromCache(ExportImportJob job)
        {
            CachingProvider.Instance().Remove(Util.GetExpImpJobCacheKey(job));
        }

        private static HashSet<string> GetAllCategoriesToInclude(ExportDto exportDto,
            List<BasePortableService> implementors)
        {
            // add all child items
            var includedItems = new HashSet<string>(StringComparer.InvariantCultureIgnoreCase);
            if (exportDto.ItemsToExport != null)
            {
                foreach (
                    var name in
                        exportDto.ItemsToExport.Where(
                            x => !NotAllowedCategoriesinRequestArray.Contains(x.ToUpperInvariant())))
                {
                    includedItems.Add(name);
                }
            }

            includedItems.Remove(Constants.Category_Content);

            if (exportDto.Pages.Length > 0)
            {
                includedItems.Add(Constants.Category_Pages);
                includedItems.Add(Constants.Category_Workflows);
            }

            if (exportDto.IncludeContent)
                includedItems.Add(Constants.Category_Content);

            if (exportDto.IncludeFiles)
                includedItems.Add(Constants.Category_Assets);

            if (exportDto.IncludeUsers)
                includedItems.Add(Constants.Category_Users);

            if (exportDto.IncludeRoles)
                includedItems.Add(Constants.Category_Roles);

            if (exportDto.IncludeVocabularies)
                includedItems.Add(Constants.Category_Vocabularies);

            if (exportDto.IncludeTemplates)
            {
                includedItems.Add(Constants.Category_Templates);
            }

            if (exportDto.IncludeProperfileProperties)
                includedItems.Add(Constants.Category_ProfileProps);

            //This might be added always.
            if (exportDto.IncludeExtensions)
                includedItems.Add(Constants.Category_Packages);

            var additionalItems = new List<string>();
            foreach (var includedItem in includedItems)
            {
                BasePortableService basePortableService;
                if (
                    (basePortableService =
                        implementors.FirstOrDefault(x => x.ParentCategory.Equals(includedItem, IgnoreCaseComp))) != null)
                {
                    additionalItems.Add(basePortableService.Category);
                }
            }
            additionalItems.ForEach(i => includedItems.Add(i));

            // must be included always when there is at least one other object to process
            if (includedItems.Any())
                includedItems.Add(Constants.Category_Portal);

            return includedItems;
        }

        private static int GetTimeoutPerSlot()
        {
            var value = 0;
            var setting = SettingsController.Instance.GetSetting(Constants.MaxSecondsToRunJobKey);
            if (setting != null && !int.TryParse(setting.SettingValue, out value))
            {
                // default max time to run a job is 8 hours
                value = (int)TimeSpan.FromHours(8).TotalSeconds;
            }

            // enforce minimum/maximum of 10 minutes/12 hours per slot
            if (value < 600)
            {
                value = 600;
            }
            else if (value > 12 * 60 * 60)
            {
                value = 12 * 60 * 60;
            }
            return value;
        }

        private static void SetLastJobStartTime(int scheduleId, DateTimeOffset time)
        {
            SchedulingProvider.Instance().AddScheduleItemSetting(
                scheduleId, Constants.LastJobStartTimeKey,
                time.ToUniversalTime().DateTime.ToString(Constants.JobRunDateTimeFormat));
        }

        private static void DoPacking(ExportImportJob exportJob, string dbName)
        {
            var exportFileArchive = Path.Combine(ExportFolder, exportJob.Directory, Constants.ExportZipDbName);
            var folderOffset = exportFileArchive.IndexOf(Constants.ExportZipDbName, StringComparison.Ordinal);
            File.Delete(CompressionUtil.AddFileToArchive(dbName, exportFileArchive, folderOffset)
                ? dbName
                : exportFileArchive);
        }

        private static void DoUnPacking(ExportImportJob importJob)
        {
            var extractFolder = Path.Combine(ExportFolder, importJob.Directory);
            var dbName = Path.Combine(extractFolder, Constants.ExportDbName);
            if (File.Exists(dbName))
                return;
            var zipDbName = Path.Combine(extractFolder, Constants.ExportZipDbName);
            CompressionUtil.UnZipFileFromArchive(Constants.ExportDbName, zipDbName, extractFolder, false);
        }

        private static long GetExportSize(string exportFolder)
        {
            var files = Directory.GetFiles(exportFolder);
            return files.Sum(file => new FileInfo(file).Length);
        }

        private static void CleanupDatabaseIfDirty(IExportImportRepository repository)
        {
            var exportDto = repository.GetSingleItem<ExportDto>();
            var isDirty = exportDto.IsDirty;
            exportDto.IsDirty = true;
            repository.UpdateSingleItem(exportDto);
            if (!isDirty) return;
            var typeLocator = new TypeLocator();
            var types = typeLocator.GetAllMatchingTypes(
                t => t != null && t.IsClass && !t.IsAbstract && t.IsVisible &&
                     typeof(BasicExportImportDto).IsAssignableFrom(t));

            foreach (var type in from type in types
                                 let typeName = type.Name
                                 where !CleanUpIgnoredClasses.Contains(typeName)
                                 select type)
            {
                try
                {
                    repository.CleanUpLocal(type.Name);
                }
                catch (Exception e)
                {
                    Logger.ErrorFormat("Unable to clear {0} while calling CleanupDatabaseIfDirty. Error: {1}",
                        type.Name,
                        e.Message);
                }
            }

        }

        private static string[] NotAllowedCategoriesinRequestArray => new[]
        {
            Constants.Category_Content,
            Constants.Category_Pages,
            Constants.Category_Portal,
            Constants.Category_Content,
            Constants.Category_Assets,
            Constants.Category_Users,
            Constants.Category_UsersData,
            Constants.Category_Roles,
            Constants.Category_Vocabularies,
            Constants.Category_Templates,
            Constants.Category_ProfileProps,
            Constants.Category_Packages,
            Constants.Category_Workflows,
        };

        private static string[] CleanUpIgnoredClasses => new[]
        {
            typeof (ExportFile).Name,
            typeof (ExportFolder).Name,
            typeof (ExportFolderMapping).Name,
            typeof (ExportFolderPermission).Name,
            typeof (ExportPageTemplate).Name,
            typeof (ExportPortalSetting).Name,
            typeof (ExportPortalLanguage).Name,
            typeof (ExportProfileProperty).Name,
            typeof (ExportUser).Name,
            typeof (ExportAspnetUser).Name,
            typeof (ExportAspnetMembership).Name,
            typeof (ExportUserAuthentication).Name,
            typeof (ExportUserPortal).Name,
            typeof (ExportUserProfile).Name,
            typeof (ExportUserRole).Name
        };

        public void AddLogsToDatabase(int jobId, ICollection<LogItem> completeLog)
        {
            if (completeLog == null || completeLog.Count == 0) return;

            using (var table = new DataTable("ExportImportJobLogs"))
            {
                // must create the columns from scratch with each iteration
                table.Columns.AddRange(DatasetColumns.Select(
                    column => new DataColumn(column.Item1, column.Item2)).ToArray());

                // batch specific amount of record each time
                const int batchSize = 500;
                var toSkip = 0;
                while (toSkip < completeLog.Count)
                {
                    foreach (var item in completeLog.Skip(toSkip).Take(batchSize))
                    {
                        var row = table.NewRow();
                        row["JobId"] = jobId;
                        row["Name"] = item.Name.TrimToLength(Constants.LogColumnLength);
                        row["Value"] = item.Value.TrimToLength(Constants.LogColumnLength);
                        row["Level"] = (int)item.ReportLevel;
                        row["CreatedOnDate"] = item.CreatedOnDate;
                        table.Rows.Add(row);
                    }

                    PlatformDataProvider.Instance().BulkInsert("ExportImportJobLogs_AddBulk", "@DataTable", table);
                    toSkip += batchSize;
                    table.Rows.Clear();
                }
            }
            completeLog.Clear();
        }

        private static readonly Tuple<string, Type>[] DatasetColumns =
        {
            new Tuple<string,Type>("JobId", typeof(int)),
            new Tuple<string,Type>("Name" , typeof(string)),
            new Tuple<string,Type>("Value", typeof(string)),
            new Tuple<string,Type>("Level", typeof(int)),
            new Tuple<string,Type>("CreatedOnDate", typeof(DateTime)),
        };]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private readonly Stopwatch _stopWatch = Stopwatch.StartNew();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="71" sc="9" el="71" ec="70">Components\Engines\ExportImportEngine.cs</location>
            <body hash="bf2eefdacbc98dd8a7b9f248e6865cd5"><![CDATA[private readonly Stopwatch _stopWatch = Stopwatch.StartNew()]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AddJobToCache">
          <declaration><![CDATA[private static void AddJobToCache(ExportImportJob job)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="485" sc="9" el="487" ec="10">Components\Engines\ExportImportEngine.cs</location>
            <body hash="59ea0cc8ae641d6894474eb57ee5f3a4"><![CDATA[{
            CachingProvider.Instance().Insert(Util.GetExpImpJobCacheKey(job), job);
        }]]></body>
          </codeblock>
        </method>
        <method name="AddLogsToDatabase">
          <declaration><![CDATA[public void AddLogsToDatabase(int jobId, ICollection<LogItem> completeLog)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="687" sc="9" el="718" ec="10">Components\Engines\ExportImportEngine.cs</location>
            <body hash="0650c10389575f3e1096bc492b1f6008"><![CDATA[{
            if (completeLog == null || completeLog.Count == 0) return;

            using (var table = new DataTable("ExportImportJobLogs"))
            {
                // must create the columns from scratch with each iteration
                table.Columns.AddRange(DatasetColumns.Select(
                    column => new DataColumn(column.Item1, column.Item2)).ToArray());

                // batch specific amount of record each time
                const int batchSize = 500;
                var toSkip = 0;
                while (toSkip < completeLog.Count)
                {
                    foreach (var item in completeLog.Skip(toSkip).Take(batchSize))
                    {
                        var row = table.NewRow();
                        row["JobId"] = jobId;
                        row["Name"] = item.Name.TrimToLength(Constants.LogColumnLength);
                        row["Value"] = item.Value.TrimToLength(Constants.LogColumnLength);
                        row["Level"] = (int)item.ReportLevel;
                        row["CreatedOnDate"] = item.CreatedOnDate;
                        table.Rows.Add(row);
                    }

                    PlatformDataProvider.Instance().BulkInsert("ExportImportJobLogs_AddBulk", "@DataTable", table);
                    toSkip += batchSize;
                    table.Rows.Clear();
                }
            }
            completeLog.Clear();
        }]]></body>
          </codeblock>
        </method>
        <method name="CheckCancelledCallBack">
          <declaration><![CDATA[private static bool CheckCancelledCallBack(ExportImportJob job)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="459" sc="9" el="469" ec="10">Components\Engines\ExportImportEngine.cs</location>
            <body hash="7902afad03ee8db77b8cbaf89141dfae"><![CDATA[{
            var job2 = CachingProvider.Instance().GetItem(Util.GetExpImpJobCacheKey(job)) as ExportImportJob;
            if (job2 == null)
            {
                job2 = EntitiesController.Instance.GetJobById(job.JobId);
                job.IsCancelled = job2.IsCancelled;
                AddJobToCache(job2);
            }

            return job2.IsCancelled;
        }]]></body>
          </codeblock>
        </method>
        <method name="CheckpointCallback">
          <declaration><![CDATA[private bool CheckpointCallback(BasePortableService service)]]></declaration>
          <documentation>
            <summary>
 Callback function to provide a checkpoint mechanism for an <see cref="T:Dnn.ExportImport.Components.Services.BasePortableService" /> implementation.
 </summary>
 <param name="service">The <see cref="T:Dnn.ExportImport.Components.Services.BasePortableService" /> implementation</param>
 <returns>Treu to stop further <see cref="T:Dnn.ExportImport.Components.Services.BasePortableService" /> processing; false otherwise</returns></documentation>
          <codeblock>
            <location sl="477" sc="9" el="480" ec="10">Components\Engines\ExportImportEngine.cs</location>
            <body hash="71cca4ea59150a31ccab75dab65eed6d"><![CDATA[{
            EntitiesController.Instance.UpdateJobChekpoint(service.CheckPoint);
            return TimeIsUp;
        }]]></body>
          </codeblock>
        </method>
        <method name="CleanupDatabaseIfDirty">
          <declaration><![CDATA[private static void CleanupDatabaseIfDirty(IExportImportRepository repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="620" sc="9" el="648" ec="10">Components\Engines\ExportImportEngine.cs</location>
            <body hash="c00a64924e56fb356d7802a673dfde05"><![CDATA[{
            var exportDto = repository.GetSingleItem<ExportDto>();
            var isDirty = exportDto.IsDirty;
            exportDto.IsDirty = true;
            repository.UpdateSingleItem(exportDto);
            if (!isDirty) return;
            var typeLocator = new TypeLocator();
            var types = typeLocator.GetAllMatchingTypes(
                t => t != null && t.IsClass && !t.IsAbstract && t.IsVisible &&
                     typeof(BasicExportImportDto).IsAssignableFrom(t));

            foreach (var type in from type in types
                                 let typeName = type.Name
                                 where !CleanUpIgnoredClasses.Contains(typeName)
                                 select type)
            {
                try
                {
                    repository.CleanUpLocal(type.Name);
                }
                catch (Exception e)
                {
                    Logger.ErrorFormat("Unable to clear {0} while calling CleanupDatabaseIfDirty. Error: {1}",
                        type.Name,
                        e.Message);
                }
            }

        }]]></body>
          </codeblock>
        </method>
        <method name="DoPacking">
          <declaration><![CDATA[private static void DoPacking(ExportImportJob exportJob, string dbName)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="595" sc="9" el="601" ec="10">Components\Engines\ExportImportEngine.cs</location>
            <body hash="23aebbe19be472b17a19a3dd153b32fa"><![CDATA[{
            var exportFileArchive = Path.Combine(ExportFolder, exportJob.Directory, Constants.ExportZipDbName);
            var folderOffset = exportFileArchive.IndexOf(Constants.ExportZipDbName, StringComparison.Ordinal);
            File.Delete(CompressionUtil.AddFileToArchive(dbName, exportFileArchive, folderOffset)
                ? dbName
                : exportFileArchive);
        }]]></body>
          </codeblock>
        </method>
        <method name="DoUnPacking">
          <declaration><![CDATA[private static void DoUnPacking(ExportImportJob importJob)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="604" sc="9" el="611" ec="10">Components\Engines\ExportImportEngine.cs</location>
            <body hash="11844851f1b4410716cb7905632489e9"><![CDATA[{
            var extractFolder = Path.Combine(ExportFolder, importJob.Directory);
            var dbName = Path.Combine(extractFolder, Constants.ExportDbName);
            if (File.Exists(dbName))
                return;
            var zipDbName = Path.Combine(extractFolder, Constants.ExportZipDbName);
            CompressionUtil.UnZipFileFromArchive(Constants.ExportDbName, zipDbName, extractFolder, false);
        }]]></body>
          </codeblock>
        </method>
        <method name="Export">
          <declaration><![CDATA[public void Export(ExportImportJob exportJob, ExportImportResult result, ScheduleHistoryItem scheduleHistoryItem)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="75" sc="9" el="249" ec="10">Components\Engines\ExportImportEngine.cs</location>
            <body hash="f24b0a39502c24359d8b1e6890dc2a3f"><![CDATA[{
            var exportDto = JsonConvert.DeserializeObject<ExportDto>(exportJob.JobObject);
            if (exportDto == null)
            {
                exportJob.CompletedOnDate = DateUtils.GetDatabaseUtcTime();
                exportJob.JobStatus = JobStatus.Failed;
                return;
            }

            _timeoutSeconds = GetTimeoutPerSlot();
            var dbName = Path.Combine(ExportFolder, exportJob.Directory, Constants.ExportDbName);
            var finfo = new FileInfo(dbName);
            dbName = finfo.FullName;


            var checkpoints = EntitiesController.Instance.GetJobChekpoints(exportJob.JobId);

            //Delete so we start a fresh export database; only if there is no previous checkpoint exists
            if (checkpoints.Count == 0)
            {
                if (finfo.Directory != null && finfo.Directory.Exists)
                {
                    finfo.Directory.Delete(true);
                }
                //Clear all the files in finfo.Directory. Create if doesn't exists.
                finfo.Directory?.Create();
                result.AddSummary("Starting Exporting Repository", finfo.Name);
            }
            else
            {
                if (finfo.Directory != null && finfo.Directory.Exists)
                {
                    result.AddSummary("Resuming Exporting Repository", finfo.Name);
                }
                else
                {
                    scheduleHistoryItem.AddLogNote("Resuming data not found.");
                    result.AddSummary("Resuming data not found.", finfo.Name);
                    return;
                }
            }

            exportJob.JobStatus = JobStatus.InProgress;

            // there must be one parent implementor at least for this to work
            var implementors = Util.GetPortableImplementors().ToList();
            var parentServices = implementors.Where(imp => string.IsNullOrEmpty(imp.ParentCategory)).ToList();
            implementors = implementors.Except(parentServices).ToList();
            var nextLevelServices = new List<BasePortableService>();
            var includedItems = GetAllCategoriesToInclude(exportDto, implementors);

            if (includedItems.Count == 0)
            {
                scheduleHistoryItem.AddLogNote("Export NOT Possible");
                scheduleHistoryItem.AddLogNote("<br/>No items selected for exporting");
                result.AddSummary("Export NOT Possible", "No items selected for exporting");
                exportJob.CompletedOnDate = DateUtils.GetDatabaseUtcTime();
                exportJob.JobStatus = JobStatus.Failed;
                return;
            }
            scheduleHistoryItem.AddLogNote($"<br/><b>SITE EXPORT Preparing Check Points. JOB #{exportJob.JobId}: {exportJob.Name}</b>");
            PrepareCheckPoints(exportJob.JobId, parentServices, implementors, includedItems, checkpoints);

            scheduleHistoryItem.AddLogNote($"<br/><b>SITE EXPORT Started. JOB #{exportJob.JobId}: {exportJob.Name}</b>");
            scheduleHistoryItem.AddLogNote($"<br/>Between [{exportDto.FromDateUtc ?? Constants.MinDbTime}] and [{exportDto.ToDateUtc:g}]");
            var firstIteration = true;
            AddJobToCache(exportJob);

            using (var ctx = new ExportImportRepository(dbName))
            {
                ctx.AddSingleItem(exportDto);
                do
                {
                    foreach (var service in parentServices.OrderBy(x => x.Priority))
                    {
                        if (exportJob.IsCancelled)
                        {
                            exportJob.JobStatus = JobStatus.Cancelled;
                            break;
                        }

                        if (implementors.Count > 0)
                        {
                            // collect children for next iteration
                            var children =
                                implementors.Where(imp => service.Category.Equals(imp.ParentCategory, IgnoreCaseComp));
                            nextLevelServices.AddRange(children);
                            implementors = implementors.Except(nextLevelServices).ToList();
                        }

                        if ((firstIteration && includedItems.Any(x => x.Equals(service.Category, IgnoreCaseComp))) ||
                            (!firstIteration && includedItems.Any(x => x.Equals(service.ParentCategory, IgnoreCaseComp))))
                        {
                            var serviceAssembly = service.GetType().Assembly.GetName().Name;
                            service.Result = result;
                            service.Repository = ctx;
                            service.CheckCancelled = CheckCancelledCallBack;
                            service.CheckPointStageCallback = CheckpointCallback;
                            service.CheckPoint = checkpoints.FirstOrDefault(cp => cp.Category == service.Category && cp.AssemblyName == serviceAssembly);

                            if (service.CheckPoint == null)
                            {
                                service.CheckPoint = new ExportImportChekpoint
                                {
                                    JobId = exportJob.JobId,
                                    Category = service.Category,
                                    AssemblyName = serviceAssembly,
                                    StartDate = DateUtils.GetDatabaseUtcTime()
                                };

                                // persist the record in db
                                CheckpointCallback(service);
                            }
                            else if (service.CheckPoint.StartDate == Null.NullDate)
                                service.CheckPoint.StartDate = DateUtils.GetDatabaseUtcTime();

                            try
                            {
                                service.ExportData(exportJob, exportDto);

                            }
                            finally
                            {
                                AddLogsToDatabase(exportJob.JobId, result.CompleteLog);
                            }
                            scheduleHistoryItem.AddLogNote("<br/>Exported: " + service.Category);
                        }
                    }

                    firstIteration = false;
                    parentServices = new List<BasePortableService>(nextLevelServices);
                    nextLevelServices.Clear();
                    if (implementors.Count > 0 && parentServices.Count == 0)
                    {
                        //WARN: this is a case where there is a broken parent-children hierarchy
                        //      and/or there are BasePortableService implementations without a known parent.
                        parentServices = implementors;
                        implementors.Clear();
                        scheduleHistoryItem.AddLogNote(
                            "<br/><b>Orphaned services:</b> " + string.Join(",", parentServices.Select(x => x.Category)));
                    }
                } while (parentServices.Count > 0 && !TimeIsUp);

                RemoveTokenFromCache(exportJob);
            }

            if (TimeIsUp)
            {
                result.AddSummary($"Job time slot ({_timeoutSeconds} sec) expired",
                    "Job will resume in the next scheduler iteration");
            }
            else if (exportJob.JobStatus == JobStatus.InProgress)
            {
                //Create Export Summary for manifest file.
                var summary = new ImportExportSummary();
                using (var ctx = new ExportImportRepository(dbName))
                {
                    BaseController.BuildJobSummary(exportJob.Directory, ctx, summary);
                }
                DoPacking(exportJob, dbName);
                //Complete the job.
                exportJob.JobStatus = JobStatus.Successful;
                SetLastJobStartTime(scheduleHistoryItem.ScheduleID, exportJob.CreatedOnDate);

                var exportController = new ExportController();
                var exportFileInfo = new ExportFileInfo
                {
                    ExportPath = exportJob.Directory,
                    ExportSize = Util.FormatSize(GetExportSize(Path.Combine(ExportFolder, exportJob.Directory)))
                };

                summary.ExportFileInfo = exportFileInfo;
                exportController.CreatePackageManifest(exportJob, exportFileInfo, summary);
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllCategoriesToInclude">
          <declaration><![CDATA[private static HashSet<string> GetAllCategoriesToInclude(ExportDto exportDto, List<BasePortableService> implementors)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="496" sc="9" el="563" ec="10">Components\Engines\ExportImportEngine.cs</location>
            <body hash="4a497121b8517da95b26b60e08787faa"><![CDATA[{
            // add all child items
            var includedItems = new HashSet<string>(StringComparer.InvariantCultureIgnoreCase);
            if (exportDto.ItemsToExport != null)
            {
                foreach (
                    var name in
                        exportDto.ItemsToExport.Where(
                            x => !NotAllowedCategoriesinRequestArray.Contains(x.ToUpperInvariant())))
                {
                    includedItems.Add(name);
                }
            }

            includedItems.Remove(Constants.Category_Content);

            if (exportDto.Pages.Length > 0)
            {
                includedItems.Add(Constants.Category_Pages);
                includedItems.Add(Constants.Category_Workflows);
            }

            if (exportDto.IncludeContent)
                includedItems.Add(Constants.Category_Content);

            if (exportDto.IncludeFiles)
                includedItems.Add(Constants.Category_Assets);

            if (exportDto.IncludeUsers)
                includedItems.Add(Constants.Category_Users);

            if (exportDto.IncludeRoles)
                includedItems.Add(Constants.Category_Roles);

            if (exportDto.IncludeVocabularies)
                includedItems.Add(Constants.Category_Vocabularies);

            if (exportDto.IncludeTemplates)
            {
                includedItems.Add(Constants.Category_Templates);
            }

            if (exportDto.IncludeProperfileProperties)
                includedItems.Add(Constants.Category_ProfileProps);

            //This might be added always.
            if (exportDto.IncludeExtensions)
                includedItems.Add(Constants.Category_Packages);

            var additionalItems = new List<string>();
            foreach (var includedItem in includedItems)
            {
                BasePortableService basePortableService;
                if (
                    (basePortableService =
                        implementors.FirstOrDefault(x => x.ParentCategory.Equals(includedItem, IgnoreCaseComp))) != null)
                {
                    additionalItems.Add(basePortableService.Category);
                }
            }
            additionalItems.ForEach(i => includedItems.Add(i));

            // must be included always when there is at least one other object to process
            if (includedItems.Any())
                includedItems.Add(Constants.Category_Portal);

            return includedItems;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetExportSize">
          <declaration><![CDATA[private static long GetExportSize(string exportFolder)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="614" sc="9" el="617" ec="10">Components\Engines\ExportImportEngine.cs</location>
            <body hash="577a2eb173fdab805b4a0cebcbc5fbd6"><![CDATA[{
            var files = Directory.GetFiles(exportFolder);
            return files.Sum(file => new FileInfo(file).Length);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetTimeoutPerSlot">
          <declaration><![CDATA[private static int GetTimeoutPerSlot()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="566" sc="9" el="585" ec="10">Components\Engines\ExportImportEngine.cs</location>
            <body hash="c992a294ce77eee206bd0684fbc27aa7"><![CDATA[{
            var value = 0;
            var setting = SettingsController.Instance.GetSetting(Constants.MaxSecondsToRunJobKey);
            if (setting != null && !int.TryParse(setting.SettingValue, out value))
            {
                // default max time to run a job is 8 hours
                value = (int)TimeSpan.FromHours(8).TotalSeconds;
            }

            // enforce minimum/maximum of 10 minutes/12 hours per slot
            if (value < 600)
            {
                value = 600;
            }
            else if (value > 12 * 60 * 60)
            {
                value = 12 * 60 * 60;
            }
            return value;
        }]]></body>
          </codeblock>
        </method>
        <method name="Import">
          <declaration><![CDATA[public void Import(ExportImportJob importJob, ExportImportResult result, ScheduleHistoryItem scheduleHistoryItem)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="252" sc="9" el="408" ec="10">Components\Engines\ExportImportEngine.cs</location>
            <body hash="427b035e2b380fd67989621ca50d11ba"><![CDATA[{
            scheduleHistoryItem.AddLogNote($"<br/><b>SITE IMPORT Started. JOB #{importJob.JobId}</b>");
            _timeoutSeconds = GetTimeoutPerSlot();
            var importDto = JsonConvert.DeserializeObject<ImportDto>(importJob.JobObject);
            if (importDto == null)
            {
                importJob.CompletedOnDate = DateUtils.GetDatabaseUtcTime();
                importJob.JobStatus = JobStatus.Failed;
                return;
            }

            var dbName = Path.Combine(ExportFolder, importJob.Directory, Constants.ExportDbName);
            var finfo = new FileInfo(dbName);

            if (!finfo.Exists)
            {
                DoUnPacking(importJob);
                finfo = new FileInfo(dbName);
            }

            if (!finfo.Exists)
            {
                scheduleHistoryItem.AddLogNote("<br/>Import file not found. Name: " + dbName);
                importJob.CompletedOnDate = DateUtils.GetDatabaseUtcTime();
                importJob.JobStatus = JobStatus.Failed;
                return;
            }

            using (var ctx = new ExportImportRepository(dbName))
            {
                var exportedDto = ctx.GetSingleItem<ExportDto>();
                var exportVersion = new Version(exportedDto.SchemaVersion);
                var importVersion = new Version(importDto.SchemaVersion);
                if (importVersion < exportVersion)
                {
                    importJob.CompletedOnDate = DateUtils.GetDatabaseUtcTime();
                    importJob.JobStatus = JobStatus.Failed;
                    scheduleHistoryItem.AddLogNote("Import NOT Possible");
                    var msg =
                        $"Exported version ({exportedDto.SchemaVersion}) is newer than import engine version ({importDto.SchemaVersion})";
                    result.AddSummary("Import NOT Possible", msg);
                    return;
                }

                var checkpoints = EntitiesController.Instance.GetJobChekpoints(importJob.JobId);
                if (checkpoints.Count == 0)
                {
                    result.AddSummary("Starting Importing Repository", finfo.Name);
                    result.AddSummary("Importing File Size", Util.FormatSize(finfo.Length));
                    CleanupDatabaseIfDirty(ctx);
                }
                else
                {
                    result.AddSummary("Resuming Importing Repository", finfo.Name);
                }

                var implementors = Util.GetPortableImplementors().ToList();
                var parentServices = implementors.Where(imp => string.IsNullOrEmpty(imp.ParentCategory)).ToList();

                importJob.Name = exportedDto.ExportName;
                importJob.Description = exportedDto.ExportDescription;
                importJob.JobStatus = JobStatus.InProgress;

                // there must be one parent implementor at least for this to work
                implementors = implementors.Except(parentServices).ToList();
                var nextLevelServices = new List<BasePortableService>();
                var includedItems = GetAllCategoriesToInclude(exportedDto, implementors);

                scheduleHistoryItem.AddLogNote($"<br/><b>SITE IMPORT Preparing Check Points. JOB #{importJob.JobId}: {importJob.Name}</b>");
                PrepareCheckPoints(importJob.JobId, parentServices, implementors, includedItems, checkpoints);

                var firstIteration = true;
                AddJobToCache(importJob);

                do
                {
                    foreach (var service in parentServices.OrderBy(x => x.Priority))
                    {
                        if (importJob.IsCancelled)
                        {
                            importJob.JobStatus = JobStatus.Cancelled;
                            break;
                        }

                        if (implementors.Count > 0)
                        {
                            // collect children for next iteration
                            var children =
                                implementors.Where(imp => service.Category.Equals(imp.ParentCategory, IgnoreCaseComp));
                            nextLevelServices.AddRange(children);
                            implementors = implementors.Except(nextLevelServices).ToList();
                        }

                        if ((firstIteration && includedItems.Any(x => x.Equals(service.Category, IgnoreCaseComp))) ||
                            (!firstIteration && includedItems.Any(x => x.Equals(service.ParentCategory, IgnoreCaseComp))))
                        {
                            var serviceAssembly = service.GetType().Assembly.GetName().Name;

                            service.Result = result;
                            service.Repository = ctx;
                            service.CheckCancelled = CheckCancelledCallBack;
                            service.CheckPointStageCallback = CheckpointCallback;
                            service.CheckPoint = checkpoints.FirstOrDefault(cp => cp.Category == service.Category && cp.AssemblyName == serviceAssembly)
                                                 ?? new ExportImportChekpoint
                                                 {
                                                     JobId = importJob.JobId,
                                                     AssemblyName = serviceAssembly,
                                                     Category = service.Category,
                                                     Progress = 0,
                                                     StartDate = DateUtils.GetDatabaseUtcTime()
                                                 };
                            if (service.CheckPoint.StartDate == Null.NullDate)
                                service.CheckPoint.StartDate = DateUtils.GetDatabaseUtcTime();
                            CheckpointCallback(service);

                            try
                            {
                                service.ImportData(importJob, importDto);
                            }
                            finally
                            {
                                AddLogsToDatabase(importJob.JobId, result.CompleteLog);
                            }
                            scheduleHistoryItem.AddLogNote("<br/>Imported: " + service.Category);
                        }
                    }

                    firstIteration = false;
                    parentServices = new List<BasePortableService>(nextLevelServices);
                    nextLevelServices.Clear();
                    if (implementors.Count > 0 && parentServices.Count == 0)
                    {
                        //WARN: this is a case where there is a broken parent-children hierarchy
                        //      and/or there are BasePortableService implementations without a known parent.
                        parentServices = implementors;
                        implementors.Clear();
                        scheduleHistoryItem.AddLogNote(
                            "<br/><b>Orphaned services:</b> " + string.Join(",", parentServices.Select(x => x.Category)));
                    }
                } while (parentServices.Count > 0 && !TimeIsUp);

                RemoveTokenFromCache(importJob);
                if (TimeIsUp)
                {
                    result.AddSummary($"Job time slot ({_timeoutSeconds} sec) expired",
                        "Job will resume in the next scheduler iteration");
                }
                else if (importJob.JobStatus == JobStatus.InProgress)
                {
                    importJob.JobStatus = JobStatus.Successful;
                    if (importDto.ExportDto.IncludeContent)
                    {
                        PagesExportService.ResetContentsFlag(ctx);
                    }
                }
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="PrepareCheckPoints">
          <declaration><![CDATA[private void PrepareCheckPoints(int jobId, List<BasePortableService> parentServices, List<BasePortableService> implementors, HashSet<string> includedItems, IList<ExportImportChekpoint> checkpoints)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="412" sc="9" el="456" ec="10">Components\Engines\ExportImportEngine.cs</location>
            <body hash="63ee436828acbfd70d27a3d0d14d5571"><![CDATA[{
            // there must be one parent implementor at least for this to work
            var nextLevelServices = new List<BasePortableService>();
            var firstIteration = true;
            if (checkpoints.Any()) return;
            do
            {
                foreach (var service in parentServices.OrderBy(x => x.Priority))
                {
                    if (implementors.Count > 0)
                    {
                        // collect children for next iteration
                        var children =
                            implementors.Where(imp => service.Category.Equals(imp.ParentCategory, IgnoreCaseComp));
                        nextLevelServices.AddRange(children);
                        implementors = implementors.Except(nextLevelServices).ToList();
                    }

                    if ((firstIteration && includedItems.Any(x => x.Equals(service.Category, IgnoreCaseComp))) ||
                        (!firstIteration && includedItems.Any(x => x.Equals(service.ParentCategory, IgnoreCaseComp))))
                    {
                        var serviceAssembly = service.GetType().Assembly.GetName().Name;

                        service.CheckPoint = checkpoints.FirstOrDefault(cp => cp.Category == service.Category && cp.AssemblyName == serviceAssembly);

                        if (service.CheckPoint != null) continue;

                        service.CheckPoint = new ExportImportChekpoint
                        {
                            JobId = jobId,
                            AssemblyName = serviceAssembly,
                            Category = service.Category,
                            Progress = 0
                        };

                        // persist the record in db
                        CheckpointCallback(service);
                    }
                }

                firstIteration = false;
                parentServices = new List<BasePortableService>(nextLevelServices);
                nextLevelServices.Clear();
            } while (parentServices.Count > 0);
        }]]></body>
          </codeblock>
        </method>
        <method name="RemoveTokenFromCache">
          <declaration><![CDATA[private static void RemoveTokenFromCache(ExportImportJob job)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="490" sc="9" el="492" ec="10">Components\Engines\ExportImportEngine.cs</location>
            <body hash="5a802510d03b943092900f3bb9f0922c"><![CDATA[{
            CachingProvider.Instance().Remove(Util.GetExpImpJobCacheKey(job));
        }]]></body>
          </codeblock>
        </method>
        <method name="SetLastJobStartTime">
          <declaration><![CDATA[private static void SetLastJobStartTime(int scheduleId, DateTimeOffset time)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="588" sc="9" el="592" ec="10">Components\Engines\ExportImportEngine.cs</location>
            <body hash="7721c1fab55ae9184071359605cb90b4"><![CDATA[{
            SchedulingProvider.Instance().AddScheduleItemSetting(
                scheduleId, Constants.LastJobStartTimeKey,
                time.ToUniversalTime().DateTime.ToString(Constants.JobRunDateTimeFormat));
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_stopWatch">
          <declaration><![CDATA[private readonly Stopwatch _stopWatch = Stopwatch.StartNew();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_timeoutSeconds">
          <declaration><![CDATA[private int _timeoutSeconds;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DatasetColumns">
          <declaration><![CDATA[private static readonly Tuple<string, Type>[] DatasetColumns;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ExportFolder">
          <declaration><![CDATA[private static readonly string ExportFolder;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="IgnoreCaseComp">
          <declaration><![CDATA[private const StringComparison IgnoreCaseComp = StringComparison.InvariantCultureIgnoreCase;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Logger">
          <declaration><![CDATA[private static readonly ILog Logger;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="CleanUpIgnoredClasses">
          <declaration><![CDATA[private static string[] CleanUpIgnoredClasses]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="667" sc="58" el="684" ec="10">Components\Engines\ExportImportEngine.cs</location>
            <body hash="21a2f997f150bb2447a214811d552d2a"><![CDATA[new[]
        {
            typeof (ExportFile).Name,
            typeof (ExportFolder).Name,
            typeof (ExportFolderMapping).Name,
            typeof (ExportFolderPermission).Name,
            typeof (ExportPageTemplate).Name,
            typeof (ExportPortalSetting).Name,
            typeof (ExportPortalLanguage).Name,
            typeof (ExportProfileProperty).Name,
            typeof (ExportUser).Name,
            typeof (ExportAspnetUser).Name,
            typeof (ExportAspnetMembership).Name,
            typeof (ExportUserAuthentication).Name,
            typeof (ExportUserPortal).Name,
            typeof (ExportUserProfile).Name,
            typeof (ExportUserRole).Name
        }]]></body>
          </codeblock>
        </property>
        <property name="NotAllowedCategoriesinRequestArray">
          <declaration><![CDATA[private static string[] NotAllowedCategoriesinRequestArray]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="650" sc="71" el="665" ec="10">Components\Engines\ExportImportEngine.cs</location>
            <body hash="3e38dc9c9bdaa56e6dd890f9e95b7762"><![CDATA[new[]
        {
            Constants.Category_Content,
            Constants.Category_Pages,
            Constants.Category_Portal,
            Constants.Category_Content,
            Constants.Category_Assets,
            Constants.Category_Users,
            Constants.Category_UsersData,
            Constants.Category_Roles,
            Constants.Category_Vocabularies,
            Constants.Category_Templates,
            Constants.Category_ProfileProps,
            Constants.Category_Packages,
            Constants.Category_Workflows,
        }]]></body>
          </codeblock>
        </property>
        <property name="TimeIsUp">
          <declaration><![CDATA[private bool TimeIsUp]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="482" sc="34" el="482" ec="83">Components\Engines\ExportImportEngine.cs</location>
            <body hash="e376a1dacedb5c93c136d416842f5c66"><![CDATA[_stopWatch.Elapsed.TotalSeconds > _timeoutSecond]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="Dnn.ExportImport.Components.Entities">
    <class name="ExportImportChekpoint">
      <declaration><![CDATA[public class ExportImportChekpoint : IHydratable]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ExportImportChekpoint()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Fill">
          <declaration><![CDATA[public void Fill(IDataReader dr)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="69" sc="9" el="82" ec="10">Components\Entities\ExportImportChekpoint.cs</location>
            <body hash="c601d06f975462f9867cb797830ae44e"><![CDATA[{
            CheckpointId = Null.SetNullInteger(dr[nameof(CheckpointId)]);
            JobId = Null.SetNullInteger(dr[nameof(JobId)]);
            AssemblyName = Null.SetNullString(dr[nameof(AssemblyName)]);
            Category = Null.SetNullString(dr[nameof(Category)]);
            Stage = Null.SetNullInteger(dr[nameof(Stage)]);
            StageData = Null.SetNullString(dr[nameof(StageData)]);
            Progress = Null.SetNullInteger(dr[nameof(Progress)]);
            TotalItems = Null.SetNullInteger(dr[nameof(TotalItems)]);
            ProcessedItems = Null.SetNullInteger(dr[nameof(ProcessedItems)]);
            StartDate = Null.SetNullDateTime(dr[nameof(StartDate)]);
            LastUpdateDate = Null.SetNullDateTime(dr[nameof(LastUpdateDate)]);
            Completed = Null.SetNullBoolean(dr[nameof(Completed)]);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_progress">
          <declaration><![CDATA[private double _progress;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="AssemblyName">
          <declaration><![CDATA[public string AssemblyName]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="39" sc="38" el="39" ec="42">Components\Entities\ExportImportChekpoint.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="39" sc="43" el="39" ec="47">Components\Entities\ExportImportChekpoint.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Category">
          <declaration><![CDATA[public string Category]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="40" sc="34" el="40" ec="38">Components\Entities\ExportImportChekpoint.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="40" sc="39" el="40" ec="43">Components\Entities\ExportImportChekpoint.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="CheckpointId">
          <declaration><![CDATA[public int CheckpointId]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="37" sc="35" el="37" ec="39">Components\Entities\ExportImportChekpoint.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="37" sc="40" el="37" ec="44">Components\Entities\ExportImportChekpoint.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Completed">
          <declaration><![CDATA[public bool Completed]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="46" sc="33" el="46" ec="37">Components\Entities\ExportImportChekpoint.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="46" sc="38" el="46" ec="42">Components\Entities\ExportImportChekpoint.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="JobId">
          <declaration><![CDATA[public int JobId]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="38" sc="28" el="38" ec="32">Components\Entities\ExportImportChekpoint.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="38" sc="33" el="38" ec="37">Components\Entities\ExportImportChekpoint.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="KeyID">
          <declaration><![CDATA[public int KeyID]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="LastUpdateDate">
          <declaration><![CDATA[public DateTime LastUpdateDate]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="44" sc="42" el="44" ec="46">Components\Entities\ExportImportChekpoint.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="44" sc="47" el="44" ec="51">Components\Entities\ExportImportChekpoint.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ProcessedItems">
          <declaration><![CDATA[public int ProcessedItems]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="60" sc="37" el="60" ec="41">Components\Entities\ExportImportChekpoint.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="60" sc="42" el="60" ec="46">Components\Entities\ExportImportChekpoint.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Progress">
          <declaration><![CDATA[public double Progress]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="52" sc="13" el="56" ec="14">Components\Entities\ExportImportChekpoint.cs</location>
            <body hash="956350a04c54e573e4a0ccc632538e38"><![CDATA[{
                if (value < 0) value = 0;
                else if (value > 100) value = 100;
                _progress = value;
            }]]></body>
          </codeblock>
        </property>
        <property name="Stage">
          <declaration><![CDATA[public int Stage]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="41" sc="28" el="41" ec="32">Components\Entities\ExportImportChekpoint.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="41" sc="33" el="41" ec="37">Components\Entities\ExportImportChekpoint.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="StageData">
          <declaration><![CDATA[public string StageData]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="42" sc="35" el="42" ec="39">Components\Entities\ExportImportChekpoint.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="42" sc="40" el="42" ec="44">Components\Entities\ExportImportChekpoint.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="StartDate">
          <declaration><![CDATA[public DateTime StartDate]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="43" sc="37" el="43" ec="41">Components\Entities\ExportImportChekpoint.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="43" sc="42" el="43" ec="46">Components\Entities\ExportImportChekpoint.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="TotalItems">
          <declaration><![CDATA[public int TotalItems]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="59" sc="33" el="59" ec="37">Components\Entities\ExportImportChekpoint.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="59" sc="38" el="59" ec="42">Components\Entities\ExportImportChekpoint.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ExportImportJob">
      <declaration><![CDATA[public class ExportImportJob : IHydratable]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ExportImportJob()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Fill">
          <declaration><![CDATA[public void Fill(IDataReader dr)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="57" sc="9" el="86" ec="10">Components\Entities\ExportImportJob.cs</location>
            <body hash="67dad71f6464d870e51bc41c80ec7597"><![CDATA[{
            JobId = Null.SetNullInteger(dr[nameof(JobId)]);
            PortalId = Null.SetNullInteger(dr[nameof(PortalId)]);
            JobType = (JobType)Null.SetNullInteger(dr[nameof(JobType)]);
            JobStatus = (JobStatus)Null.SetNullInteger(dr[nameof(JobStatus)]);
            IsCancelled = Null.SetNullBoolean(dr[nameof(IsCancelled)]);
            Name = Null.SetNullString(dr[nameof(Name)]);
            Description = Null.SetNullString(dr[nameof(Description)]);
            CreatedByUserId = Null.SetNullInteger(dr[nameof(CreatedByUserId)]);
            CreatedOnDate = Null.SetNullDateTime(dr[nameof(CreatedOnDate)]);
            LastModifiedOnDate = Null.SetNullDateTime(dr[nameof(LastModifiedOnDate)]);
            CompletedOnDate = Null.SetNullDateTime(dr[nameof(CompletedOnDate)]);
            Directory = Null.SetNullString(dr[nameof(Directory)]);
            JobObject = Null.SetNullString(dr[nameof(JobObject)]);

            if (CreatedOnDate.Kind != DateTimeKind.Utc)
            {
                CreatedOnDate = new DateTime(
                    CreatedOnDate.Year, CreatedOnDate.Month, CreatedOnDate.Day,
                    CreatedOnDate.Hour, CreatedOnDate.Minute, CreatedOnDate.Second,
                    CreatedOnDate.Millisecond, DateTimeKind.Utc);
            }
            if (LastModifiedOnDate.Kind != DateTimeKind.Utc)
            {
                LastModifiedOnDate = new DateTime(
                    LastModifiedOnDate.Year, LastModifiedOnDate.Month, LastModifiedOnDate.Day,
                    LastModifiedOnDate.Hour, LastModifiedOnDate.Minute, LastModifiedOnDate.Second,
                    LastModifiedOnDate.Millisecond, DateTimeKind.Utc);
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="CompletedOnDate">
          <declaration><![CDATA[public DateTime? CompletedOnDate]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="46" sc="44" el="46" ec="48">Components\Entities\ExportImportJob.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="46" sc="49" el="46" ec="53">Components\Entities\ExportImportJob.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="CreatedByUserId">
          <declaration><![CDATA[public int CreatedByUserId]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="43" sc="38" el="43" ec="42">Components\Entities\ExportImportJob.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="43" sc="43" el="43" ec="47">Components\Entities\ExportImportJob.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="CreatedOnDate">
          <declaration><![CDATA[public DateTime CreatedOnDate]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="44" sc="41" el="44" ec="45">Components\Entities\ExportImportJob.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="44" sc="46" el="44" ec="50">Components\Entities\ExportImportJob.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Description">
          <declaration><![CDATA[public string Description]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="42" sc="37" el="42" ec="41">Components\Entities\ExportImportJob.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="42" sc="42" el="42" ec="46">Components\Entities\ExportImportJob.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Directory">
          <declaration><![CDATA[public string Directory]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="47" sc="35" el="47" ec="39">Components\Entities\ExportImportJob.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="47" sc="40" el="47" ec="44">Components\Entities\ExportImportJob.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="IsCancelled">
          <declaration><![CDATA[public bool IsCancelled]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="40" sc="35" el="40" ec="39">Components\Entities\ExportImportJob.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="40" sc="40" el="40" ec="44">Components\Entities\ExportImportJob.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="JobId">
          <declaration><![CDATA[public int JobId]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="36" sc="28" el="36" ec="32">Components\Entities\ExportImportJob.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="36" sc="33" el="36" ec="37">Components\Entities\ExportImportJob.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="JobObject">
          <declaration><![CDATA[public string JobObject]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="48" sc="35" el="48" ec="39">Components\Entities\ExportImportJob.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="48" sc="40" el="48" ec="44">Components\Entities\ExportImportJob.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="JobStatus">
          <declaration><![CDATA[public JobStatus JobStatus]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="39" sc="38" el="39" ec="42">Components\Entities\ExportImportJob.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="39" sc="43" el="39" ec="47">Components\Entities\ExportImportJob.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="JobType">
          <declaration><![CDATA[public JobType JobType]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="38" sc="34" el="38" ec="38">Components\Entities\ExportImportJob.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="38" sc="39" el="38" ec="43">Components\Entities\ExportImportJob.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="KeyID">
          <declaration><![CDATA[public int KeyID]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="LastModifiedOnDate">
          <declaration><![CDATA[public DateTime LastModifiedOnDate]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="45" sc="46" el="45" ec="50">Components\Entities\ExportImportJob.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="45" sc="51" el="45" ec="55">Components\Entities\ExportImportJob.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Name">
          <declaration><![CDATA[public string Name]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="41" sc="30" el="41" ec="34">Components\Entities\ExportImportJob.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="41" sc="35" el="41" ec="39">Components\Entities\ExportImportJob.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="PortalId">
          <declaration><![CDATA[public int PortalId]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="37" sc="31" el="37" ec="35">Components\Entities\ExportImportJob.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="37" sc="36" el="37" ec="40">Components\Entities\ExportImportJob.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ExportImportJobLog">
      <declaration><![CDATA[public class ExportImportJobLog : IHydratable]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ExportImportJobLog()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Fill">
          <declaration><![CDATA[public void Fill(IDataReader dr)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="49" sc="9" el="56" ec="10">Components\Entities\ExportImportJobLog.cs</location>
            <body hash="db7c83da56d35ac0e0318cfbcb47682d"><![CDATA[{
            JobLogId = Null.SetNullInteger(dr[nameof(JobLogId)]);
            JobId = Null.SetNullInteger(dr[nameof(JobId)]);
            Name = Null.SetNullString(dr[nameof(Name)]);
            Value = Null.SetNullString(dr[nameof(Value)]);
            Level = Null.SetNullInteger(dr[nameof(Level)]);
            CreatedOnDate = Null.SetNullDateTime(dr[nameof(CreatedOnDate)]);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="CreatedOnDate">
          <declaration><![CDATA[public DateTime CreatedOnDate]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="40" sc="41" el="40" ec="45">Components\Entities\ExportImportJobLog.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="40" sc="46" el="40" ec="50">Components\Entities\ExportImportJobLog.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="JobId">
          <declaration><![CDATA[public int JobId]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="36" sc="28" el="36" ec="32">Components\Entities\ExportImportJobLog.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="36" sc="33" el="36" ec="37">Components\Entities\ExportImportJobLog.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="JobLogId">
          <declaration><![CDATA[public int JobLogId]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="35" sc="31" el="35" ec="35">Components\Entities\ExportImportJobLog.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="35" sc="36" el="35" ec="40">Components\Entities\ExportImportJobLog.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="KeyID">
          <declaration><![CDATA[public int KeyID]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Level">
          <declaration><![CDATA[public int Level]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="39" sc="28" el="39" ec="32">Components\Entities\ExportImportJobLog.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="39" sc="33" el="39" ec="37">Components\Entities\ExportImportJobLog.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Name">
          <declaration><![CDATA[public string Name]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="37" sc="30" el="37" ec="34">Components\Entities\ExportImportJobLog.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="37" sc="35" el="37" ec="39">Components\Entities\ExportImportJobLog.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Value">
          <declaration><![CDATA[public string Value]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="38" sc="31" el="38" ec="35">Components\Entities\ExportImportJobLog.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="38" sc="36" el="38" ec="40">Components\Entities\ExportImportJobLog.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ExportImportSetting">
      <declaration><![CDATA[public class ExportImportSetting]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ExportImportSetting()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="CreatedByUserId">
          <declaration><![CDATA[public int CreatedByUserId]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="11" sc="38" el="11" ec="42">Components\Entities\ExportImportSetting.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="11" sc="43" el="11" ec="47">Components\Entities\ExportImportSetting.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="SettingIsSecure">
          <declaration><![CDATA[public bool SettingIsSecure]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="10" sc="39" el="10" ec="43">Components\Entities\ExportImportSetting.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="10" sc="44" el="10" ec="48">Components\Entities\ExportImportSetting.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="SettingName">
          <declaration><![CDATA[public string SettingName]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="8" sc="37" el="8" ec="41">Components\Entities\ExportImportSetting.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="8" sc="42" el="8" ec="46">Components\Entities\ExportImportSetting.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="SettingValue">
          <declaration><![CDATA[public string SettingValue]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="9" sc="38" el="9" ec="42">Components\Entities\ExportImportSetting.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="9" sc="43" el="9" ec="47">Components\Entities\ExportImportSetting.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="Dnn.ExportImport.Components.Interfaces">
    <class name="IDateTimeConverter">
      <declaration><![CDATA[internal interface IDateTimeConverter]]></declaration>
      <documentation>
        <summary>
 Contract to convert all the datetiem properties in the class to User's local time
 </summary>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="ConvertToLocal">
          <declaration><![CDATA[void ConvertToLocal(UserInfo userInfo);]]></declaration>
          <documentation>
            <summary>
 Converts the datetime properties to user locale.
 </summary>
 <param name="userInfo"></param></documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="IEntitiesController">
      <declaration><![CDATA[public interface IEntitiesController]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="GetAllJobs">
          <declaration><![CDATA[IList<ExportImportJob> GetAllJobs(int? portalId, int? pageSize, int? pageIndex, int? jobType, string keywords);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetAllJobsCount">
          <declaration><![CDATA[int GetAllJobsCount(int? portalId, int? jobType, string keywords);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetFirstActiveJob">
          <declaration><![CDATA[ExportImportJob GetFirstActiveJob();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetJobById">
          <declaration><![CDATA[ExportImportJob GetJobById(int jobId);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetJobChekpoints">
          <declaration><![CDATA[IList<ExportImportChekpoint> GetJobChekpoints(int jobId);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetJobFullLog">
          <declaration><![CDATA[IList<ExportImportJobLog> GetJobFullLog(int jobId);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetJobSummaryLog">
          <declaration><![CDATA[IList<ExportImportJobLog> GetJobSummaryLog(int jobId);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetLastJobTime">
          <declaration><![CDATA[DateTime? GetLastJobTime(int portalId, JobType jobType);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetModulePermissions">
          <declaration><![CDATA[IList<ExportModulePermission> GetModulePermissions(int moduleId, DateTime toDate, DateTime? fromDate);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetModules">
          <declaration><![CDATA[IList<ExportModule> GetModules(int tabId, bool includeDeleted, DateTime toDate, DateTime? fromDate);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetModuleSettings">
          <declaration><![CDATA[IList<ExportModuleSetting> GetModuleSettings(int moduleId, DateTime toDate, DateTime? fromDate);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetPermissionInfo">
          <declaration><![CDATA[PermissionInfo GetPermissionInfo(string permissionCode, string permissionKey, string permissionName);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetPortalTabs">
          <declaration><![CDATA[IList<ExportTabInfo> GetPortalTabs(int portalId, bool includeDeleted, bool includeSystem, DateTime toDate, DateTime? fromDate);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetTabModules">
          <declaration><![CDATA[IList<ExportTabModule> GetTabModules(int tabId, bool includeDeleted, DateTime toDate, DateTime? fromDate);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetTabModuleSettings">
          <declaration><![CDATA[IList<ExportTabModuleSetting> GetTabModuleSettings(int tabId, DateTime toDate, DateTime? fromDate);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetTabPermissions">
          <declaration><![CDATA[IList<ExportTabPermission> GetTabPermissions(int tabId, DateTime toDate, DateTime? fromDate);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetTabSettings">
          <declaration><![CDATA[IList<ExportTabSetting> GetTabSettings(int tabId, DateTime toDate, DateTime? fromDate);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetTabUrls">
          <declaration><![CDATA[IList<ExportTabUrl> GetTabUrls(int tabId, DateTime toDate, DateTime? fromDate);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="RemoveJob">
          <declaration><![CDATA[void RemoveJob(ExportImportJob job);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="RunSchedule">
          <declaration><![CDATA[void RunSchedule();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="SetJobCancelled">
          <declaration><![CDATA[void SetJobCancelled(ExportImportJob job);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="SetTabModuleDeleted">
          <declaration><![CDATA[void SetTabModuleDeleted(int tabModuleId, bool isDeleted);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="SetTabSpecificData">
          <declaration><![CDATA[void SetTabSpecificData(int tabId, bool isDeleted, bool isVisible);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="SetUserDeleted">
          <declaration><![CDATA[void SetUserDeleted(int portalId, int userId, bool isDeleted);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="UpdateJobChekpoint">
          <declaration><![CDATA[void UpdateJobChekpoint(ExportImportChekpoint checkpoint);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="UpdateJobInfo">
          <declaration><![CDATA[void UpdateJobInfo(ExportImportJob job);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="UpdateJobStatus">
          <declaration><![CDATA[void UpdateJobStatus(ExportImportJob job);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="ISettingsController">
      <declaration><![CDATA[public interface ISettingsController]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="AddSetting">
          <declaration><![CDATA[void AddSetting(ExportImportSetting exportImportSetting);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetAllSettings">
          <declaration><![CDATA[IEnumerable<ExportImportSetting> GetAllSettings();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetSetting">
          <declaration><![CDATA[ExportImportSetting GetSetting(string settingName);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="Dnn.ExportImport.Components.Models">
    <class name="ExportImportResult">
      <declaration><![CDATA[public class ExportImportResult]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ExportImportResult()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="40" sc="9" el="43" ec="10">Components\Models\ExportImportResult.cs</location>
            <body hash="46152f3eec1cf936b21bf88a9aadb0d3"><![CDATA[public ExportImportResult()
        {
            CompleteLog = CompleteLog = new List<LogItem>();
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AddLogEntry">
          <declaration><![CDATA[public LogItem AddLogEntry(string name, string value, ReportLevel level = ReportLevel.Verbose)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="51" sc="9" el="62" ec="10">Components\Models\ExportImportResult.cs</location>
            <body hash="4d64c188d88d5c56136d177351ec7a7c"><![CDATA[{
            var item = new LogItem
            {
                Name = name,
                Value = value,
                ReportLevel = level,
                CreatedOnDate = DateUtils.GetDatabaseUtcTime(),
            };

            CompleteLog.Add(item);
            return item;
        }]]></body>
          </codeblock>
        </method>
        <method name="AddSummary">
          <declaration><![CDATA[public LogItem AddSummary(string name, string value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="46" sc="9" el="48" ec="10">Components\Models\ExportImportResult.cs</location>
            <body hash="519fe5c49a6c5a68f7c4725b98995cac"><![CDATA[{
            return AddLogEntry(name, value, ReportLevel.Info);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="CompleteLog">
          <declaration><![CDATA[public IList<LogItem> CompleteLog]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="33" sc="45" el="33" ec="49">Components\Models\ExportImportResult.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="33" sc="50" el="33" ec="62">Components\Models\ExportImportResult.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
        <property name="JobId">
          <declaration><![CDATA[public int JobId]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="32" sc="28" el="32" ec="32">Components\Models\ExportImportResult.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="32" sc="33" el="32" ec="37">Components\Models\ExportImportResult.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Summary">
          <declaration><![CDATA[public IList<LogItem> Summary]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ProgressToken">
      <declaration><![CDATA[public class ProgressToken]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ProgressToken()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="ContinuationKey">
          <declaration><![CDATA[public string ContinuationKey]]></declaration>
          <documentation>
            <summary>
 This can be used as a continuation token for the operation. It
 is an identifier for next operation/step in import/export process.
 </summary>
          </documentation>
          <codeblock>
            <location sl="30" sc="41" el="30" ec="45">Components\Models\ProgressToken.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="30" sc="46" el="30" ec="50">Components\Models\ProgressToken.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Progress">
          <declaration><![CDATA[public uint Progress]]></declaration>
          <documentation>
            <summary>
  Indicates the completed percentage progress of export/import operation.
 </summary>
          </documentation>
          <codeblock>
            <location sl="35" sc="32" el="35" ec="36">Components\Models\ProgressToken.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="35" sc="37" el="35" ec="41">Components\Models\ProgressToken.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="Dnn.ExportImport.Components.Providers">
    <class name="DataProvider">
      <declaration><![CDATA[internal class DataProvider]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".cctor">
          <declaration><![CDATA[static DataProvider()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="42" sc="9" el="44" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="250b8c65c16f0d6c6f5b8606f472a80a"><![CDATA[{
            Provider = new DataProvider();
        }]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[private readonly DataProvider _dataProvider = DataProvider.Instance();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="39" sc="9" el="54" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="855de615f15ad6e59970cc8300c7afd0"><![CDATA[private readonly DotNetNuke.Data.DataProvider _dataProvider = DotNetNuke.Data.DataProvider.Instance();

        static DataProvider()
        {
            Provider = new DataProvider();
        }

        public static DataProvider Instance()
        {
            return Provider;
        }

        private DataProvider()
        {
            // so it can't be instantiated outside this class
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AddExportImportSetting">
          <declaration><![CDATA[public void AddExportImportSetting(ExportImportSetting exportImportSetting)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="108" sc="9" el="112" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="762ad7e5c17ba722ef6169914a82f4d4"><![CDATA[{
            _dataProvider.ExecuteNonQuery("ExportImport_AddSetting", exportImportSetting.SettingName,
                exportImportSetting.SettingValue, exportImportSetting.SettingIsSecure,
                exportImportSetting.CreatedByUserId);
        }]]></body>
          </codeblock>
        </method>
        <method name="AddNewJob">
          <declaration><![CDATA[public int AddNewJob(int portalId, int userId, JobType jobType, string jobName, string jobDescription, string directory, string serializedObject)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="72" sc="9" el="75" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="dc9935c9d82303b15ec966b711b17219"><![CDATA[{
            return _dataProvider.ExecuteScalar<int>("ExportImportJobs_Add", portalId,
                (int)jobType, userId, jobName, jobDescription, directory, serializedObject);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllJobs">
          <declaration><![CDATA[public IDataReader GetAllJobs(int? portalId, int? pageSize, int? pageIndex, int? jobType, string keywords)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="140" sc="9" el="143" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="1db045c55601d8c92ca53b55111faeda"><![CDATA[{
            return _dataProvider.ExecuteReader(
                "ExportImportJobs_GetAll", portalId, pageSize, pageIndex, jobType, keywords);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllJobsCount">
          <declaration><![CDATA[public int GetAllJobsCount(int? portalId, int? jobType, string keywords)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="135" sc="9" el="137" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="006d4fa51a7cb877e06e96119ac628e6"><![CDATA[{
            return _dataProvider.ExecuteScalar<int>("ExportImport_GetJobsCount", portalId, jobType, keywords);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllModulePermissions">
          <declaration><![CDATA[public IDataReader GetAllModulePermissions(int moduleId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="320" sc="9" el="322" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="1d3df192ba04aaec13d16e6c2b7e4821"><![CDATA[{
            return _dataProvider.ExecuteReader("Export_ModulePermissions", moduleId, toDate, fromDate);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllModules">
          <declaration><![CDATA[public IDataReader GetAllModules(int tabId, bool includeDeleted, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="310" sc="9" el="312" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="d800ac9d6ee931d6810cb7e65aea2b5d"><![CDATA[{
            return _dataProvider.ExecuteReader("Export_Modules", tabId, includeDeleted, toDate, fromDate);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllModuleSettings">
          <declaration><![CDATA[public IDataReader GetAllModuleSettings(int moduleId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="315" sc="9" el="317" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="54d5a3d0b97f81be08036095d5e89988"><![CDATA[{
            return _dataProvider.ExecuteReader("Export_ModuleSettings", moduleId, toDate, fromDate);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllPortalTabs">
          <declaration><![CDATA[public IDataReader GetAllPortalTabs(int portalId, bool includeDeleted, bool includeSystem, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="290" sc="9" el="292" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="16d53c403146d5c26e87c860aef8dbfe"><![CDATA[{
            return _dataProvider.ExecuteReader("Export_Tabs", portalId, includeDeleted, includeSystem, toDate, fromDate);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllRoleGroups">
          <declaration><![CDATA[public IDataReader GetAllRoleGroups(int portalId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="189" sc="9" el="191" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="8654b4664b99d219b31ecc5901a9455a"><![CDATA[{
            return _dataProvider.ExecuteReader("Export_RoleGroups", portalId, toDate, _dataProvider.GetNull(fromDate));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllRoles">
          <declaration><![CDATA[public IDataReader GetAllRoles(int portalId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="194" sc="9" el="196" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="2ad65cac527c0c4f86278d251b57c4e6"><![CDATA[{
            return _dataProvider.ExecuteReader("Export_Roles", portalId, toDate, _dataProvider.GetNull(fromDate));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllRoleSettings">
          <declaration><![CDATA[public IDataReader GetAllRoleSettings(int portalId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="199" sc="9" el="201" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="35ffb14b6c1ea026dd4612b5d7ef8ef3"><![CDATA[{
            return _dataProvider.ExecuteReader("Export_RoleSettings", portalId, toDate, _dataProvider.GetNull(fromDate));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllScopeTypes">
          <declaration><![CDATA[public IDataReader GetAllScopeTypes()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="169" sc="9" el="171" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="21fb9efe76497924b8ee9f318aa8bbe1"><![CDATA[{
            return _dataProvider.ExecuteReader("ExportTaxonomy_ScopeTypes");
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllTabModules">
          <declaration><![CDATA[public IDataReader GetAllTabModules(int tabId, bool includeDeleted, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="325" sc="9" el="327" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="aacfdb4e0870a11afdb377023b7d32cd"><![CDATA[{
            return _dataProvider.ExecuteReader("Export_TabModules", tabId, includeDeleted, toDate, fromDate);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllTabModuleSettings">
          <declaration><![CDATA[public IDataReader GetAllTabModuleSettings(int tabId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="330" sc="9" el="332" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="75f16651b67a425e4775d1641c96394b"><![CDATA[{
            return _dataProvider.ExecuteReader("Export_TabModuleSettings", tabId, toDate, fromDate);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllTabPermissions">
          <declaration><![CDATA[public IDataReader GetAllTabPermissions(int tabId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="300" sc="9" el="302" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="5cb56200c1cc26526927e0c5022f8dfb"><![CDATA[{
            return _dataProvider.ExecuteReader("Export_TabPermissions", tabId, toDate, fromDate);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllTabSettings">
          <declaration><![CDATA[public IDataReader GetAllTabSettings(int tabId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="295" sc="9" el="297" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="5ef32f583fd761999af0394c25148870"><![CDATA[{
            return _dataProvider.ExecuteReader("Export_TabSettings", tabId, toDate, fromDate);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllTabUrls">
          <declaration><![CDATA[public IDataReader GetAllTabUrls(int tabId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="305" sc="9" el="307" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="f52b87685066481cf00ca54c4f8897f5"><![CDATA[{
            return _dataProvider.ExecuteReader("Export_TabUrls", tabId, toDate, fromDate);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllTerms">
          <declaration><![CDATA[public IDataReader GetAllTerms(int portalId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="179" sc="9" el="181" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="9798996bc78b03b4c7a275603bb4bd87"><![CDATA[{
            return _dataProvider.ExecuteReader("ExportTaxonomy_Terms", portalId, toDate, _dataProvider.GetNull(fromDate));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllUsers">
          <declaration><![CDATA[public IDataReader GetAllUsers(int portalId, int pageIndex, int pageSize, bool includeDeleted, DateTime toDateUtc, DateTime? fromDateUtc)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="221" sc="9" el="225" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="80f6f3d4f63794fe69075977b88c5903"><![CDATA[{
            return _dataProvider
                .ExecuteReader("Export_GetAllUsers", portalId, pageIndex, pageSize, includeDeleted, toDateUtc,
                    _dataProvider.GetNull(fromDateUtc), false);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllVocabularies">
          <declaration><![CDATA[public IDataReader GetAllVocabularies(int portalId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="184" sc="9" el="186" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="5e3892ae7ab3e02fc425ce075231ef24"><![CDATA[{
            return _dataProvider.ExecuteReader("ExportTaxonomy_Vocabularies", portalId, toDate, _dataProvider.GetNull(fromDate));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllVocabularyTypes">
          <declaration><![CDATA[public IDataReader GetAllVocabularyTypes()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="174" sc="9" el="176" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="010e1034d305ab422cdba5bc311c0f96"><![CDATA[{
            return _dataProvider.ExecuteReader("ExportTaxonomy_VocabularyTypes");
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllWorkflows">
          <declaration><![CDATA[public IDataReader GetAllWorkflows(int portalId, bool includeDeleted)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="360" sc="9" el="362" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="f3c4b6c569980739db545c319f305abb"><![CDATA[{
            return _dataProvider.ExecuteReader("Export_ContentWorkflows", portalId, includeDeleted);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllWorkflowSources">
          <declaration><![CDATA[public IDataReader GetAllWorkflowSources(int workflowId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="365" sc="9" el="367" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="43156daf52b2d3c3d7cd4a11f92e2a2e"><![CDATA[{
            return _dataProvider.ExecuteReader("Export_ContentWorkflowSources", workflowId);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllWorkflowStatePermissions">
          <declaration><![CDATA[public IDataReader GetAllWorkflowStatePermissions(int workflowStateId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="375" sc="9" el="377" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="fa47da1e77f065bb32c4fb3e91e2a678"><![CDATA[{
            return _dataProvider.ExecuteReader("Export_ContentWorkflowStatePermissions", workflowStateId, toDate, fromDate);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetAllWorkflowStates">
          <declaration><![CDATA[public IDataReader GetAllWorkflowStates(int workflowId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="370" sc="9" el="372" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="cc713a386d9ed7cbc5a040d99a62f358"><![CDATA[{
            return _dataProvider.ExecuteReader("Export_ContentWorkflowStates", workflowId);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetExportImportSettings">
          <declaration><![CDATA[public IDataReader GetExportImportSettings()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="104" sc="9" el="106" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="dbf823f5112de4bd4b4d35a61c19ccd0"><![CDATA[{
            return _dataProvider.ExecuteReader("ExportImport_Settings");
        }]]></body>
          </codeblock>
        </method>
        <method name="GetFiles">
          <declaration><![CDATA[public IDataReader GetFiles(int portalId, int? folderId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="271" sc="9" el="273" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="0201942d937b842d066f5472e36dfae3"><![CDATA[{
            return _dataProvider.ExecuteReader("Export_GetFiles", portalId, folderId, toDate, _dataProvider.GetNull(fromDate));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetFirstActiveJob">
          <declaration><![CDATA[public IDataReader GetFirstActiveJob()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="115" sc="9" el="117" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="a87304e02366e66c0f759e531af86ade"><![CDATA[{
            return _dataProvider.ExecuteReader("ExportImportJobs_FirstActive");
        }]]></body>
          </codeblock>
        </method>
        <method name="GetFolderMappings">
          <declaration><![CDATA[public IDataReader GetFolderMappings(int portalId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="266" sc="9" el="268" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="c17b2188c2b588a07869c58232b7fca4"><![CDATA[{
            return _dataProvider.ExecuteReader("Export_GetFolderMappings", portalId, toDate, _dataProvider.GetNull(fromDate));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetFolderPermissionsByPath">
          <declaration><![CDATA[public IDataReader GetFolderPermissionsByPath(int portalId, string folderPath, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="260" sc="9" el="263" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="4c7d8e70713a5e68b20efb29cfbab7c1"><![CDATA[{
            return _dataProvider
                .ExecuteReader("Export_GetFolderPermissionsByPath", portalId, folderPath, toDate, _dataProvider.GetNull(fromDate));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetFolders">
          <declaration><![CDATA[public IDataReader GetFolders(int portalId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="255" sc="9" el="257" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="091c6a353892c7318b61e13008643f53"><![CDATA[{
            return _dataProvider.ExecuteReader("Export_GetFolders", portalId, toDate, _dataProvider.GetNull(fromDate));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetJobById">
          <declaration><![CDATA[public IDataReader GetJobById(int jobId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="120" sc="9" el="122" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="5d01d6a3eb70f706cf215e7a9b9a35ae"><![CDATA[{
            return _dataProvider.ExecuteReader("ExportImportJobs_GetById", jobId);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetJobChekpoints">
          <declaration><![CDATA[public IDataReader GetJobChekpoints(int jobId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="146" sc="9" el="148" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="e752b1b34b90e3f1fdae4cc02a0fd358"><![CDATA[{
            return _dataProvider.ExecuteReader("ExportImportCheckpoints_GetByJob", jobId);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetJobFullLog">
          <declaration><![CDATA[public IDataReader GetJobFullLog(int jobId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="130" sc="9" el="132" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="c33433476dcef94ae95a621f643f189f"><![CDATA[{
            return _dataProvider.ExecuteReader("ExportImportJobLogs_Full", jobId);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetJobSummaryLog">
          <declaration><![CDATA[public IDataReader GetJobSummaryLog(int jobId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="125" sc="9" el="127" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="7b30fa5b76416a5b4f86f4b498fe1331"><![CDATA[{
            return _dataProvider.ExecuteReader("ExportImportJobLogs_Summary", jobId);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetLastJobTime">
          <declaration><![CDATA[public DateTime? GetLastJobTime(int portalId, JobType jobType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="151" sc="9" el="159" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="128a9eaf70ecfcbe6b61c76f35f6d0e1"><![CDATA[{
            var datim = _dataProvider.ExecuteScalar<DateTime?>("ExportImportJobLogs_LastJobTime", portalId, jobType);
            if (datim.HasValue)
            {
                var d = datim.Value;
                datim = new DateTime(d.Year, d.Month, d.Day, d.Hour, d.Minute, d.Second, d.Millisecond, DateTimeKind.Utc);
            }
            return datim;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetPermissionId">
          <declaration><![CDATA[public int? GetPermissionId(string permissionCode, string permissionKey, string permissionName)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="276" sc="9" el="287" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="7ebe8dcc8ad74e0786adee06b248f43a"><![CDATA[{
            return
                CBO.GetCachedObject<IEnumerable<PermissionInfo>>(new CacheItemArgs(DataCache.PermissionsCacheKey,
                    DataCache.PermissionsCacheTimeout,
                    DataCache.PermissionsCachePriority),
                    c =>
                        CBO.FillCollection<PermissionInfo>(
                            _dataProvider.ExecuteReader("GetPermissions")))
                    .FirstOrDefault(x => x.PermissionCode == permissionCode &&
                                         x.PermissionKey == permissionKey
                                         && x.PermissionName == permissionName)?.PermissionID;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetPermissionInfo">
          <declaration><![CDATA[public IDataReader GetPermissionInfo(string permissionCode, string permissionKey, string permissionName)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="350" sc="9" el="352" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="64dee3cef75fb62c7152cefb4dbaeed4"><![CDATA[{
            return _dataProvider.ExecuteReader("Export_GetPermissionInfo", permissionCode, permissionKey, permissionName);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetPortalLanguages">
          <declaration><![CDATA[public IDataReader GetPortalLanguages(int portalId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="245" sc="9" el="247" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="3081df39284ab444c1d7a87b28d701f4"><![CDATA[{
            return _dataProvider.ExecuteReader("Export_GetPortalLanguages", portalId, toDate, _dataProvider.GetNull(fromDate));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetPortalLocalizations">
          <declaration><![CDATA[public IDataReader GetPortalLocalizations(int portalId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="250" sc="9" el="252" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="640f5d2e1c9673d2c5ab86c069807b68"><![CDATA[{
            return _dataProvider.ExecuteReader("Export_GetPortalLocalizations", portalId, toDate, _dataProvider.GetNull(fromDate));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetPortalSettings">
          <declaration><![CDATA[public IDataReader GetPortalSettings(int portalId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="240" sc="9" el="242" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="0c38cf53d1403155b9188ee901a08430"><![CDATA[{
            return _dataProvider.ExecuteReader("Export_GetPortalSettings", portalId, toDate, _dataProvider.GetNull(fromDate));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetPropertyDefinitionsByPortal">
          <declaration><![CDATA[public IDataReader GetPropertyDefinitionsByPortal(int portalId, bool includeDeleted, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="215" sc="9" el="218" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="a65be796ed0840d0f0ae0164b30b205b"><![CDATA[{
            return _dataProvider
                .ExecuteReader("Export_GetPropertyDefinitionsByPortal", portalId, includeDeleted, toDate, _dataProvider.GetNull(fromDate));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetRoleIdByName">
          <declaration><![CDATA[public int GetRoleIdByName(int portalId, string roleName)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="204" sc="9" el="206" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="f332f23f1b194f84b3b57098878b9d7e"><![CDATA[{
            return _dataProvider.ExecuteScalar<int>("Export_RoleIdByName", _dataProvider.GetNull(portalId), roleName);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetUsersCount">
          <declaration><![CDATA[public int GetUsersCount(int portalId, bool includeDeleted, DateTime toDateUtc, DateTime? fromDateUtc)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="228" sc="9" el="231" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="d89831de1638ebdd25a276a7267340fd"><![CDATA[{
            return _dataProvider
                .ExecuteScalar<int>("Export_GetAllUsers", portalId, 0, 0, includeDeleted, toDateUtc, _dataProvider.GetNull(fromDateUtc), true);
        }]]></body>
          </codeblock>
        </method>
        <method name="Instance">
          <declaration><![CDATA[public static DataProvider Instance()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="47" sc="9" el="49" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="51b53ee2089f08c42f548695c1b330a5"><![CDATA[{
            return Provider;
        }]]></body>
          </codeblock>
        </method>
        <method name="RemoveJob">
          <declaration><![CDATA[public void RemoveJob(int jobId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="98" sc="9" el="101" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="f2acbd7510e8f2a2fe378afaa7dbcd50"><![CDATA[{
            // using 60 sec timeout because cascading deletes in logs might take a lot of time
            _dataProvider.ExecuteNonQuery(60, "ExportImportJobs_Remove", jobId);
        }]]></body>
          </codeblock>
        </method>
        <method name="SetJobCancelled">
          <declaration><![CDATA[public void SetJobCancelled(int jobId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="93" sc="9" el="95" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="74f2e03b3ba22409f398e5b39657a723"><![CDATA[{
            _dataProvider.ExecuteNonQuery("ExportImportJobs_SetCancelled", jobId);
        }]]></body>
          </codeblock>
        </method>
        <method name="SetRoleAutoAssign">
          <declaration><![CDATA[public void SetRoleAutoAssign(int roleId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="210" sc="9" el="212" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="5c4d7b14cb2b48caa35ab7bc4cde5989"><![CDATA[{
            _dataProvider.ExecuteNonQuery("Export_RoleSetAutoAssign", roleId);
        }]]></body>
          </codeblock>
        </method>
        <method name="SetTabModuleDeleted">
          <declaration><![CDATA[public void SetTabModuleDeleted(int tabModuleId, bool isDeleted)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="340" sc="9" el="342" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="dee46bec9e7f828c85f1497b68d3906a"><![CDATA[{
            _dataProvider.ExecuteNonQuery("Export_SetTabModuleDeleted", tabModuleId, isDeleted);
        }]]></body>
          </codeblock>
        </method>
        <method name="SetTabSpecificData">
          <declaration><![CDATA[public void SetTabSpecificData(int tabId, bool isDeleted, bool isVisible)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="335" sc="9" el="337" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="f82cde2ae7777d27a8fb2b070a679d35"><![CDATA[{
            _dataProvider.ExecuteNonQuery("Export_SetTabSpecificData", tabId, isDeleted, isVisible);
        }]]></body>
          </codeblock>
        </method>
        <method name="SetUserDeleted">
          <declaration><![CDATA[public void SetUserDeleted(int portalId, int userId, bool isDeleted)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="345" sc="9" el="347" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="37b1ec0eaacda40e8da85dc4cc0949e5"><![CDATA[{
            _dataProvider.ExecuteNonQuery("Export_SetUserDeleted", portalId, userId, isDeleted);
        }]]></body>
          </codeblock>
        </method>
        <method name="UpdateJobInfo">
          <declaration><![CDATA[public void UpdateJobInfo(int jobId, string name, string description)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="78" sc="9" el="80" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="42f3a5777f3e62debe71b7698d7c187f"><![CDATA[{
            _dataProvider.ExecuteNonQuery("ExportImportJobs_UpdateInfo", jobId, name, description);
        }]]></body>
          </codeblock>
        </method>
        <method name="UpdateJobStatus">
          <declaration><![CDATA[public void UpdateJobStatus(int jobId, JobStatus jobStatus)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="83" sc="9" el="90" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="586b293bf7c92fab350d84e80787f2f4"><![CDATA[{
            DateTime? completeDate = null;
            if (jobStatus == JobStatus.Failed || jobStatus == JobStatus.Successful)
                completeDate = DateUtils.GetDatabaseUtcTime();

            _dataProvider.ExecuteNonQuery(
                "ExportImportJobs_UpdateStatus", jobId, jobStatus, completeDate);
        }]]></body>
          </codeblock>
        </method>
        <method name="UpdateRecordChangers">
          <declaration><![CDATA[public void UpdateRecordChangers(string tableName, string primaryKeyName, int primaryKeyId, int? createdBy, int? modifiedBy)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="59" sc="9" el="62" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="97c4a2d44b315d081d957c3050dbc085"><![CDATA[{
            _dataProvider.ExecuteNonQuery(
                "Export_GenericUpdateRecordChangers", tableName, primaryKeyName, primaryKeyId, createdBy, modifiedBy);
        }]]></body>
          </codeblock>
        </method>
        <method name="UpdateSettingRecordChangers">
          <declaration><![CDATA[public void UpdateSettingRecordChangers(string tableName, string primaryKeyName, int parentKeyId, string settingName, int? createdBy, int? modifiedBy)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="65" sc="9" el="68" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="c91c127b0966ef30b7b6c0d6ffda9869"><![CDATA[{
            _dataProvider.ExecuteNonQuery(
                "Export_GenedicUpdateSettingsRecordChangers", tableName, primaryKeyName, parentKeyId, settingName, createdBy, modifiedBy);
        }]]></body>
          </codeblock>
        </method>
        <method name="UpdateTabUrlChangers">
          <declaration><![CDATA[public void UpdateTabUrlChangers(int tabId, int seqNum, int? createdBy, int? modifiedBy)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="355" sc="9" el="357" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="77675c8eb1bf7305af83edce89128272"><![CDATA[{
            _dataProvider.ExecuteNonQuery("Export_UpdateTabUrlChangers", tabId, seqNum, createdBy, modifiedBy);
        }]]></body>
          </codeblock>
        </method>
        <method name="UpdateUserChangers">
          <declaration><![CDATA[public void UpdateUserChangers(int userId, string createdByUserName, string modifiedByUserName)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="234" sc="9" el="237" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="af578656cbcd70012a3462afccd3d3e1"><![CDATA[{
            _dataProvider.ExecuteNonQuery(
                "Export_UpdateUsersChangers", userId, createdByUserName, modifiedByUserName);
        }]]></body>
          </codeblock>
        </method>
        <method name="UpsertJobChekpoint">
          <declaration><![CDATA[public void UpsertJobChekpoint(ExportImportChekpoint checkpoint)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="162" sc="9" el="166" ec="10">Components\Providers\DataProvider.cs</location>
            <body hash="ee9eede8835f4e3fabce2b5533659941"><![CDATA[{
            _dataProvider.ExecuteNonQuery("ExportImportCheckpoints_Upsert",
                checkpoint.JobId, checkpoint.AssemblyName, checkpoint.Category, checkpoint.Stage, checkpoint.StageData,
                Null.SetNullInteger(Math.Floor(checkpoint.Progress)), checkpoint.TotalItems, checkpoint.ProcessedItems, _dataProvider.GetNull(checkpoint.StartDate), checkpoint.Completed);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_dataProvider">
          <declaration><![CDATA[private readonly DataProvider _dataProvider = DataProvider.Instance();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Provider">
          <declaration><![CDATA[private static readonly DataProvider Provider;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="Dnn.ExportImport.Components.Scheduler">
    <class name="ExportImportScheduler">
      <declaration><![CDATA[public class ExportImportScheduler : SchedulerClient]]></declaration>
      <documentation>
        <summary>
 Implements a SchedulerClient for the Exporting/Importing of site items.
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ExportImportScheduler(ScheduleHistoryItem objScheduleHistoryItem)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="57" sc="9" el="60" ec="10">Components\Scheduler\ExportImportScheduler.cs</location>
            <body hash="77eb83cc7dd9fd645cc627bf7d22ee6d"><![CDATA[public ExportImportScheduler(ScheduleHistoryItem objScheduleHistoryItem)
        {
            ScheduleHistoryItem = objScheduleHistoryItem;
        }]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static ExportImportScheduler()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="41" sc="9" el="41" ec="110">Components\Scheduler\ExportImportScheduler.cs</location>
            <body hash="bfc586624cccfe6aac97bfd96bff4fe3"><![CDATA[private static readonly ILog Logger = LoggerSource.Instance.GetLogger(typeof(ExportImportScheduler))]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="DoWork">
          <declaration><![CDATA[public override void DoWork()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="63" sc="9" el="193" ec="10">Components\Scheduler\ExportImportScheduler.cs</location>
            <body hash="5028b81c052f984d997f4574e25ccf63"><![CDATA[{
            try
            {
                //TODO: do some clean-up for very old import/export jobs/logs

                var job = EntitiesController.Instance.GetFirstActiveJob();
                if (job == null)
                {
                    ScheduleHistoryItem.Succeeded = true;
                    ScheduleHistoryItem.AddLogNote("<br/>No Site Export/Import jobs queued for processing.");
                }
                else if (job.IsCancelled)
                {
                    job.JobStatus = JobStatus.Cancelled;
                    EntitiesController.Instance.UpdateJobStatus(job);
                    ScheduleHistoryItem.Succeeded = true;
                    ScheduleHistoryItem.AddLogNote("<br/>Site Export/Import jobs was previously cancelled.");
                }
                else
                {
                    job.JobStatus = JobStatus.InProgress;
                    EntitiesController.Instance.UpdateJobStatus(job);
                    var result = new ExportImportResult
                    {
                        JobId = job.JobId,
                    };
                    var engine = new ExportImportEngine();
                    var succeeded = true;

                    switch (job.JobType)
                    {
                        case JobType.Export:
                            try
                            {
                                engine.Export(job, result, ScheduleHistoryItem);
                            }
                            catch (Exception ex)
                            {
                                result.AddLogEntry("EXCEPTION exporting job #" + job.JobId, ex.Message, ReportLevel.Error);
                                engine.AddLogsToDatabase(job.JobId, result.CompleteLog);
                                throw;
                            }
                            EntitiesController.Instance.UpdateJobStatus(job);
                            break;
                        case JobType.Import:
                            try
                            {
                                engine.Import(job, result, ScheduleHistoryItem);
                            }
                            catch (ThreadAbortException)
                            {
                                ScheduleHistoryItem.TimeLapse = EmergencyScheduleFrequency;
                                ScheduleHistoryItem.TimeLapseMeasurement = EmergencyScheduleFrequencyUnit;
                                ScheduleHistoryItem.RetryTimeLapse = EmergencyScheduleRetry;
                                ScheduleHistoryItem.RetryTimeLapseMeasurement = EmergencyScheduleRetryUnit;
                                ScheduleHistoryItem.RetainHistoryNum = EmergencyHistoryNumber;

                                SchedulingController.UpdateSchedule(ScheduleHistoryItem);

                                SchedulingController.PurgeScheduleHistory();

                                Logger.Error("The Schduler item stopped because main thread stopped, set schedule into emergency mode so it will start after app restart.");
                                succeeded = false;
                            }
                            catch (Exception ex)
                            {
                                result.AddLogEntry("EXCEPTION importing job #" + job.JobId, ex.Message, ReportLevel.Error);
                                engine.AddLogsToDatabase(job.JobId, result.CompleteLog);
                                throw;
                            }
                            EntitiesController.Instance.UpdateJobStatus(job);
                            if (job.JobStatus == JobStatus.Successful || job.JobStatus == JobStatus.Cancelled)
                            {
                                // clear everything to be sure imported items take effect
                                DataCache.ClearCache();
                            }
                            break;
                        default:
                            throw new Exception("Unknown job type: " + job.JobType);
                    }

                    ScheduleHistoryItem.Succeeded = true;

                    //restore schedule item running timelapse to default.
                    if (succeeded
                        && ScheduleHistoryItem.TimeLapse == EmergencyScheduleFrequency
                        && ScheduleHistoryItem.TimeLapseMeasurement == EmergencyScheduleFrequencyUnit)
                    {
                        ScheduleHistoryItem.TimeLapse = DefaultScheduleFrequency;
                        ScheduleHistoryItem.TimeLapseMeasurement = DefaultScheduleFrequencyUnit;
                        ScheduleHistoryItem.RetryTimeLapse = DefaultScheduleRetry;
                        ScheduleHistoryItem.RetryTimeLapseMeasurement = DefaultScheduleRetryUnit;
                        ScheduleHistoryItem.RetainHistoryNum = DefaultHistoryNumber;

                        SchedulingController.UpdateSchedule(ScheduleHistoryItem);
                    }

                    var sb = new StringBuilder();
                    var jobType = Localization.GetString("JobType_" + job.JobType, Constants.SharedResources);
                    var jobStatus = Localization.GetString("JobStatus_" + job.JobStatus, Constants.SharedResources);
                    sb.AppendFormat("<br/><b>{0} {1}</b>", jobType, jobStatus);
                    var summary = result.Summary;
                    if (summary.Count > 0)
                    {
                        sb.Append("<br/><b>Summary:</b><ul>");
                        foreach (var entry in summary)
                        {
                            sb.Append($"<li>{entry.Name}: {entry.Value}</li>");
                        }
                        sb.Append("</ul>");
                    }

                    ScheduleHistoryItem.AddLogNote(sb.ToString());
                    engine.AddLogsToDatabase(job.JobId, result.CompleteLog);

                    Logger.Trace("Site Export/Import: Job Finished");
                }
                //SetLastSuccessfulIndexingDateTime(ScheduleHistoryItem.ScheduleID, ScheduleHistoryItem.StartDate);
            }
            catch (Exception ex)
            {
                ScheduleHistoryItem.Succeeded = false;
                ScheduleHistoryItem.AddLogNote("<br/>Export/Import EXCEPTION: " + ex.Message);
                Errored(ref ex);
                // this duplicates the logging
                //if (ScheduleHistoryItem.ScheduleSource != ScheduleSource.STARTED_FROM_BEGIN_REQUEST)
                //{
                //    Exceptions.LogException(ex);
                //}
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="DefaultHistoryNumber">
          <declaration><![CDATA[private const int DefaultHistoryNumber = 60;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DefaultScheduleFrequency">
          <declaration><![CDATA[private const int DefaultScheduleFrequency = 1;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DefaultScheduleFrequencyUnit">
          <declaration><![CDATA[private const string DefaultScheduleFrequencyUnit = "d";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DefaultScheduleRetry">
          <declaration><![CDATA[private const int DefaultScheduleRetry = 1;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DefaultScheduleRetryUnit">
          <declaration><![CDATA[private const string DefaultScheduleRetryUnit = "h";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="EmergencyHistoryNumber">
          <declaration><![CDATA[private const int EmergencyHistoryNumber = 1;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="EmergencyScheduleFrequency">
          <declaration><![CDATA[private const int EmergencyScheduleFrequency = 120;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="EmergencyScheduleFrequencyUnit">
          <declaration><![CDATA[private const string EmergencyScheduleFrequencyUnit = "m";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="EmergencyScheduleRetry">
          <declaration><![CDATA[private const int EmergencyScheduleRetry = 90;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="EmergencyScheduleRetryUnit">
          <declaration><![CDATA[private const string EmergencyScheduleRetryUnit = "s";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Logger">
          <declaration><![CDATA[private static readonly ILog Logger = LoggerSource.Instance.GetLogger(typeof(ExportImportScheduler));]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="Dnn.ExportImport.Components.Services">
    <class name="AssetsExportService">
      <declaration><![CDATA[public class AssetsExportService : BasePortableService]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private readonly string _assetsFolder = string.Format("{0}{1}{{0}}\\{2}", Globals.ApplicationMapPath, "\\App_Data\\ExportImport\\", "export_files.zip");]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="49" sc="9" el="50" ec="102">Components\Services\AssetsExportService.cs</location>
            <body hash="5b73ccfba2d15775f920d4d1ccea8a0c"><![CDATA[private readonly string _assetsFolder =
            $"{Globals.ApplicationMapPath}{Constants.ExportFolder}{{0}}\\{Constants.ExportZipFiles}";]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static AssetsExportService()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="46" sc="9" el="47" ec="62">Components\Services\AssetsExportService.cs</location>
            <body hash="4f20855141d4b5f7e8b59121ecf62551"><![CDATA[private static readonly Regex UserFolderEx = new Regex(@"users/\d+/\d+/(\d+)/",
            RegexOptions.Compiled | RegexOptions.IgnoreCase);]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ExportData">
          <declaration><![CDATA[public override void ExportData(ExportImportJob exportJob, ExportDto exportDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="62" sc="9" el="172" ec="10">Components\Services\AssetsExportService.cs</location>
            <body hash="11d9885a219ca93ebc088dbd52e83cc5"><![CDATA[{
            if (CheckCancelled(exportJob)) return;
            //Skip the export if all the folders have been processed already.
            if (CheckPoint.Stage >= 1)
                return;

            //Create Zip File to hold files
            var skip = GetCurrentSkip();
            var currentIndex = skip;
            var totalFolderExported = 0;
            var totalFolderPermissionsExported = 0;
            var totalFilesExported = 0;
            var portalId = exportJob.PortalId;
            try
            {
                var assetsFile = string.Format(_assetsFolder, exportJob.Directory.TrimEnd('\\').TrimEnd('/'));

                if (CheckPoint.Stage == 0)
                {
                    var fromDate = (exportDto.FromDateUtc ?? Constants.MinDbTime).ToLocalTime();
                    var toDate = exportDto.ToDateUtc.ToLocalTime();
                    var portal = PortalController.Instance.GetPortal(portalId);

                    var folders =
                        CBO.FillCollection<ExportFolder>(DataProvider.Instance()
                            .GetFolders(portalId, toDate, fromDate)).ToList();
                    var totalFolders = folders.Any() ? folders.Count : 0;
                    folders = folders.Skip(skip).ToList();


                    //Update the total items count in the check points. This should be updated only once.
                    CheckPoint.TotalItems = CheckPoint.TotalItems <= 0 ? totalFolders : CheckPoint.TotalItems;
                    CheckPoint.ProcessedItems = skip;
                    CheckPoint.Progress = CheckPoint.TotalItems > 0 ? skip * 100.0 / CheckPoint.TotalItems : 0;
                    if (CheckPointStageCallback(this)) return;
                    using (var zipArchive = CompressionUtil.OpenCreate(assetsFile))
                    {
                        foreach (var folder in folders)
                        {
                            if (CheckCancelled(exportJob)) break;
                            var isUserFolder = false;

                            var files =
                                CBO.FillCollection<ExportFile>(
                                    DataProvider.Instance()
                                        .GetFiles(portalId, folder.FolderId, toDate, fromDate)).Where(x => x.Extension != Constants.TemplatesExtension).ToList();
                            int? userId;
                            if (IsUserFolder(folder.FolderPath, out userId))
                            {
                                isUserFolder = true;
                                folder.UserId = userId;
                                folder.Username =
                                    UserController.GetUserById(portalId, Convert.ToInt32(userId))?.Username;
                            }
                            if (folder.ParentId != null && folder.ParentId > 0)
                            {
                                //If parent id exists then change the parent folder id to parent id.
                                folder.ParentId =
                                    Repository.GetItem<ExportFolder>(
                                        x => x.FolderId == Convert.ToInt32(folder.ParentId))?.Id;
                            }

                            Repository.CreateItem(folder, null);
                            totalFolderExported++;
                            //Include permissions only if IncludePermissions=true
                            if (exportDto.IncludePermissions)
                            {
                                var permissions =
                                    CBO.FillCollection<ExportFolderPermission>(DataProvider.Instance()
                                        .GetFolderPermissionsByPath(portalId, folder.FolderPath, toDate, fromDate));
                                Repository.CreateItems(permissions, folder.Id);
                                totalFolderPermissionsExported += permissions.Count;
                            }
                            Repository.CreateItems(files, folder.Id);
                            totalFilesExported += files.Count;
                            var folderOffset = portal.HomeDirectoryMapPath.Length +
                                               (portal.HomeDirectoryMapPath.EndsWith("\\") ? 0 : 1);

                            if (folder.StorageLocation != (int)FolderController.StorageLocationTypes.DatabaseSecure)
                            {

                                CompressionUtil.AddFilesToArchive(zipArchive, files.Select(file => portal.HomeDirectoryMapPath + folder.FolderPath + GetActualFileName(file)),
                                    folderOffset, isUserFolder ? "TempUsers" : null);

                            }
                            CheckPoint.ProcessedItems++;
                            CheckPoint.Progress = CheckPoint.ProcessedItems * 100.0 / totalFolders;
                            CheckPoint.StageData = null;
                            currentIndex++;
                            //After every 10 items, call the checkpoint stage. This is to avoid too many frequent updates to DB.
                            if (currentIndex % 10 == 0 && CheckPointStageCallback(this)) return;
                            Repository.RebuildIndex<ExportFolder>(x => x.Id, true);
                            Repository.RebuildIndex<ExportFolder>(x => x.UserId);
                            Repository.RebuildIndex<ExportFile>(x => x.ReferenceId);
                        }
                    }
                    CheckPoint.Completed = true;
                    CheckPoint.Stage++;
                    currentIndex = 0;
                    CheckPoint.Progress = 100;
                }
            }
            finally
            {
                CheckPoint.StageData = currentIndex > 0 ? JsonConvert.SerializeObject(new { skip = currentIndex }) : null;
                CheckPointStageCallback(this);
                Result.AddSummary("Exported Folders", totalFolderExported.ToString());
                Result.AddSummary("Exported Folder Permissions", totalFolderPermissionsExported.ToString());
                Result.AddSummary("Exported Files", totalFilesExported.ToString());
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="GetActualFileName">
          <declaration><![CDATA[private string GetActualFileName(ExportFile objFile)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="572" sc="9" el="576" ec="10">Components\Services\AssetsExportService.cs</location>
            <body hash="61ce3391a20d38567a5574f7d5584c57"><![CDATA[{
            return (objFile.StorageLocation == (int)FolderController.StorageLocationTypes.SecureFileSystem)
                ? objFile.FileName + Globals.glbProtectedExtension
                : objFile.FileName;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetCurrentSkip">
          <declaration><![CDATA[private int GetCurrentSkip()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="579" sc="9" el="586" ec="10">Components\Services\AssetsExportService.cs</location>
            <body hash="9c59ad479c1722ee90e27b9af90a612c"><![CDATA[{
            if (!string.IsNullOrEmpty(CheckPoint.StageData))
            {
                dynamic stageData = JsonConvert.DeserializeObject(CheckPoint.StageData);
                return Convert.ToInt32(stageData.skip) ?? 0;
            }
            return 0;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetImportTotal">
          <declaration><![CDATA[public override int GetImportTotal()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="315" sc="9" el="317" ec="10">Components\Services\AssetsExportService.cs</location>
            <body hash="7db3ba5cb985180d23b7957dde878015"><![CDATA[{
            return Repository.GetCount<ExportFolder>();
        }]]></body>
          </codeblock>
        </method>
        <method name="GetLocalWorkFlowId">
          <declaration><![CDATA[private int GetLocalWorkFlowId(int? exportedWorkFlowId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="589" sc="9" el="596" ec="10">Components\Services\AssetsExportService.cs</location>
            <body hash="2b379c75046d234c7370d7b8a6ae8f48"><![CDATA[{
            if (exportedWorkFlowId!=null && exportedWorkFlowId > 1) // 1 is direct publish
            {
                var state = Repository.GetItem<ExportWorkflow>(item => item.WorkflowID == exportedWorkFlowId);
                return state?.LocalId ?? -1;
            }
            return -1;
        }]]></body>
          </codeblock>
        </method>
        <method name="ImportData">
          <declaration><![CDATA[public override void ImportData(ExportImportJob importJob, ImportDto importDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="175" sc="9" el="312" ec="10">Components\Services\AssetsExportService.cs</location>
            <body hash="40ff17033972e2278b08903ffeb8b9e6"><![CDATA[{
            if (CheckCancelled(importJob)) return;
            //Stage 1: Portals files unzipped. 
            //Stage 2: All folders and files imported.
            //Stage 3: Synchronization completed.
            //Skip the export if all the folders have been processed already.
            if (CheckPoint.Stage >= 2 || CheckPoint.Completed)
                return;

            var totalFolderImported = 0;
            var totalFolderPermissionsImported = 0;
            var totalFilesImported = 0;
            var skip = GetCurrentSkip();
            var currentIndex = skip;
            var portalId = importJob.PortalId;
            var portal = PortalController.Instance.GetPortal(portalId);
            var assetsFile = string.Format(_assetsFolder, importJob.Directory.TrimEnd('\\').TrimEnd('/'));
            var userFolderPath = string.Format(UsersAssetsTempFolder, portal.HomeDirectoryMapPath.TrimEnd('\\'));
            if (CheckPoint.Stage == 0)
            {
                if (!File.Exists(assetsFile))
                {
                    Result.AddLogEntry("AssetsFileNotFound", "Assets file not found. Skipping assets import",
                        ReportLevel.Warn);
                    CheckPoint.Completed = true;
                    CheckPointStageCallback(this);
                }
                else
                {
                    CompressionUtil.UnZipArchive(assetsFile, portal.HomeDirectoryMapPath,
                        importDto.CollisionResolution == CollisionResolution.Overwrite);
                    //Stage 1: Once unzipping of portal files is completed.
                    CheckPoint.Stage++;
                    CheckPoint.StageData = null;
                    CheckPoint.Progress = 10;
                    if (CheckPointStageCallback(this)) return;
                }
            }

            if (CheckPoint.Stage == 1)
            {
                try
                {
                    //Stage 2 starts
                    var sourceFolders = Repository.GetAllItems<ExportFolder>(x => x.CreatedOnDate, true, skip).ToList();

                    var totalFolders = sourceFolders.Any() ? sourceFolders.Count : 0;
                    //Update the total items count in the check points. This should be updated only once.
                    CheckPoint.TotalItems = CheckPoint.TotalItems <= 0 ? totalFolders : CheckPoint.TotalItems;
                    if (CheckPointStageCallback(this)) return;

                    foreach (var sourceFolder in sourceFolders)
                    {
                        if (CheckCancelled(importJob)) break;
                        // PROCESS FOLDERS
                        //Create new or update existing folder
                        if (ProcessFolder(importJob, importDto, sourceFolder))
                        {
                            totalFolderImported++;

                            //Include permissions only if permissions were exported in package.
                            if (importDto.ExportDto.IncludePermissions)
                            {
                                // PROCESS FOLDER PERMISSIONS
                                var sourceFolderPermissions =
                                    Repository.GetRelatedItems<ExportFolderPermission>(sourceFolder.Id).ToList();
                                //Replace folderId for each permission with new one.
                                sourceFolderPermissions.ForEach(x =>
                                {
                                    x.FolderId = Convert.ToInt32(sourceFolder.FolderId);
                                    x.FolderPath = sourceFolder.FolderPath;
                                });

                                // PROCESS FOLDER PERMISSIONS
                                //File local files in the system related to the folder path.
                                var localPermissions =
                                    CBO.FillCollection<ExportFolderPermission>(DataProvider.Instance()
                                        .GetFolderPermissionsByPath(portalId, sourceFolder.FolderPath,
                                            DateUtils.GetDatabaseUtcTime().AddYears(1), null));

                                foreach (var folderPermission in sourceFolderPermissions)
                                {
                                    ProcessFolderPermission(importJob, importDto, folderPermission,
                                        localPermissions);
                                }
                                totalFolderPermissionsImported += sourceFolderPermissions.Count;
                            }

                            // PROCESS FILES
                            var sourceFiles =
                                Repository.GetRelatedItems<ExportFile>(sourceFolder.Id).ToList();
                            //Replace folderId for each file with new one.
                            sourceFiles.ForEach(x =>
                            {
                                x.FolderId = Convert.ToInt32(sourceFolder.FolderId);
                                x.Folder = sourceFolder.FolderPath;
                            });

                            //File local files in the system related to the folder
                            var localFiles =
                                CBO.FillCollection<ExportFile>(DataProvider.Instance()
                                    .GetFiles(portalId, sourceFolder.FolderId,
                                        DateUtils.GetDatabaseUtcTime().AddYears(1), null));

                            foreach (var file in sourceFiles)
                            {
                                ProcessFiles(importJob, importDto, file, localFiles);
                            }
                            totalFilesImported += sourceFiles.Count;
                        }

                        currentIndex++;
                        CheckPoint.ProcessedItems++;
                        CheckPoint.Progress = 10 + CheckPoint.ProcessedItems * 90.0 / totalFolders;
                        //After every 10 items, call the checkpoint stage. This is to avoid too many frequent updates to DB.
                        if (currentIndex % 10 == 0 && CheckPointStageCallback(this)) return;
                    }
                    currentIndex = 0;
                    CheckPoint.Completed = true;
                    CheckPoint.Stage++;
                    CheckPoint.Progress = 100;
                }
                finally
                {
                    CheckPoint.StageData = currentIndex > 0
                        ? JsonConvert.SerializeObject(new { skip = currentIndex })
                        : null;
                    CheckPointStageCallback(this);

                    Result.AddSummary("Imported Folders", totalFolderImported.ToString());
                    Result.AddSummary("Imported Folder Permissions", totalFolderPermissionsImported.ToString());
                    Result.AddSummary("Imported Files", totalFilesImported.ToString());

                    if (Directory.Exists(userFolderPath) && currentIndex == 0)
                        Directory.Delete(userFolderPath, true);
                }
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="IsUserFolder">
          <declaration><![CDATA[private static bool IsUserFolder(string folderPath, out int? userId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="563" sc="9" el="569" ec="10">Components\Services\AssetsExportService.cs</location>
            <body hash="03022d756c06019a03a022915f12316d"><![CDATA[{
            userId = null;
            var match = UserFolderEx.Match(folderPath);
            if (match.Success)
                userId = int.Parse(match.Groups[1].Value);
            return match.Success;
        }]]></body>
          </codeblock>
        </method>
        <method name="ProcessFiles">
          <declaration><![CDATA[private void ProcessFiles(ExportImportJob importJob, ImportDto importDto, ExportFile file, IEnumerable<ExportFile> localFiles)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="485" sc="9" el="538" ec="10">Components\Services\AssetsExportService.cs</location>
            <body hash="0257d47e25cb41f88af7e2129c5ffd9d"><![CDATA[{
            if (file == null) return;
            var existingFile = localFiles.FirstOrDefault(x => x.FileName == file.FileName);
            var isUpdate = false;
            if (existingFile != null)
            {
                switch (importDto.CollisionResolution)
                {
                    case CollisionResolution.Overwrite:
                        isUpdate = true;
                        break;
                    case CollisionResolution.Ignore:
                        return;
                    default:
                        throw new ArgumentOutOfRangeException(importDto.CollisionResolution.ToString());
                }
            }
            if (isUpdate)
            {
                var modifiedBy = Util.GetUserIdByName(importJob, file.LastModifiedByUserId, file.LastModifiedByUserName);
                file.FileId = existingFile.FileId;
                DotNetNuke.Data.DataProvider.Instance()
                    .UpdateFile(existingFile.FileId, file.VersionGuid, file.FileName, file.Extension, file.Size,
                        file.Width ?? Null.NullInteger, file.Height ?? Null.NullInteger, file.ContentType, file.FolderId,
                        modifiedBy, file.Sha1Hash, DateUtils.GetDatabaseLocalTime(), file.Title, file.Description,
                        file.StartDate, file.EndDate ?? Null.NullDate, file.EnablePublishPeriod,
                        existingFile.ContentItemId ?? Null.NullInteger);

                if ((file.Content != null && existingFile.Content == null) ||
                    (existingFile.Content != null && file.Content == null) ||
                    (file.Content != null && existingFile.Content != null &&
                     file.Content.SequenceEqual(existingFile.Content)))
                {
                    DotNetNuke.Data.DataProvider.Instance().UpdateFileContent(file.FileId, file.Content);
                }
            }
            else
            {
                var createdBy = Util.GetUserIdByName(importJob, file.CreatedByUserId, file.CreatedByUserName);
                file.FileId = DotNetNuke.Data.DataProvider.Instance()
                    .AddFile(importJob.PortalId, Guid.NewGuid(), file.VersionGuid, file.FileName, file.Extension,
                        file.Size,
                        file.Width ?? Null.NullInteger, file.Height ?? Null.NullInteger, file.ContentType, file.Folder,
                        file.FolderId,
                        createdBy, file.Sha1Hash, DateUtils.GetDatabaseLocalTime(), file.Title, file.Description,
                        file.StartDate, file.EndDate ?? Null.NullDate, file.EnablePublishPeriod,
                        //file.ContentItemId ?? Null.NullInteger);--If we keep it we will see FK_PK relationship errors.
                        Null.NullInteger);


                if (file.Content != null)
                    DotNetNuke.Data.DataProvider.Instance().UpdateFileContent(file.FileId, file.Content);
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="ProcessFolder">
          <declaration><![CDATA[private bool ProcessFolder(ExportImportJob importJob, ImportDto importDto, ExportFolder folder)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="320" sc="9" el="401" ec="10">Components\Services\AssetsExportService.cs</location>
            <body hash="ccab2fc3fe9c6487ca0f83268fa4542b"><![CDATA[{
            var portalId = importJob.PortalId;
            if (folder == null) return false;

            var existingFolder = CBO.FillObject<ExportFolder>(DotNetNuke.Data.DataProvider.Instance().GetFolder(portalId, folder.FolderPath ?? ""));
            var isUpdate = false;
            var modifiedBy = Util.GetUserIdByName(importJob, folder.LastModifiedByUserId, folder.LastModifiedByUserName);
            if (existingFolder != null)
            {
                switch (importDto.CollisionResolution)
                {
                    case CollisionResolution.Overwrite:
                        isUpdate = true;
                        break;
                    case CollisionResolution.Ignore:
                        return false;
                    default:
                        throw new ArgumentOutOfRangeException(importDto.CollisionResolution.ToString());
                }
            }
            folder.FolderPath = string.IsNullOrEmpty(folder.FolderPath) ? "" : folder.FolderPath;
            var folderMapping = FolderMappingController.Instance.GetFolderMapping(portalId, folder.FolderMappingName);
            if (folderMapping == null) return false;
            var workFlowId = GetLocalWorkFlowId(folder.WorkflowId);
            if (isUpdate)
            {
                Util.FixDateTime(existingFolder);
                DotNetNuke.Data.DataProvider.Instance()
                    .UpdateFolder(importJob.PortalId, folder.VersionGuid, existingFolder.FolderId, folder.FolderPath,
                        folder.StorageLocation, folder.MappedPath, folder.IsProtected, folder.IsCached,
                        DateUtils.GetDatabaseLocalTime(), modifiedBy, folderMapping.FolderMappingID, folder.IsVersioned,
                        workFlowId, existingFolder.ParentId ?? Null.NullInteger);

                folder.FolderId = existingFolder.FolderId;

                if (folder.UserId != null && folder.UserId > 0 && !string.IsNullOrEmpty(folder.Username))
                {
                    SyncUserFolder(importJob.PortalId, folder);
                }
            }
            else
            {
                folder.FolderMappingId = folderMapping.FolderMappingID;
                var createdBy = Util.GetUserIdByName(importJob, folder.CreatedByUserId, folder.CreatedByUserName);
                if (folder.ParentId != null && folder.ParentId > 0)
                {
                    //Find the previously created parent folder id.
                    folder.ParentId = CBO.FillObject<ExportFolder>(DotNetNuke.Data.DataProvider.Instance().GetFolder(portalId, folder.ParentFolderPath ?? ""))?.FolderId;
                }
                //ignore folders which start with Users but are not user folders.
                if (!folder.FolderPath.StartsWith(DefaultUsersFoldersPath))
                {
                    folder.FolderId = DotNetNuke.Data.DataProvider.Instance()
                        .AddFolder(importJob.PortalId, Guid.NewGuid(), folder.VersionGuid, folder.FolderPath,
                            folder.MappedPath, folder.StorageLocation, folder.IsProtected, folder.IsCached,
                            DateUtils.GetDatabaseLocalTime(),
                            createdBy, folderMapping.FolderMappingID, folder.IsVersioned, workFlowId,
                            folder.ParentId ?? Null.NullInteger);
                }
                //Case when the folder is a user folder.
                else if (folder.UserId != null && folder.UserId > 0 && !string.IsNullOrEmpty(folder.Username))
                {
                    var userInfo = UserController.GetUserByName(portalId, folder.Username);
                    if (userInfo == null)
                    {
                        folder.FolderId = 0;
                        return false;
                    }
                    var newFolder = FolderManager.Instance.GetUserFolder(userInfo);
                    folder.FolderId = newFolder.FolderID;
                    folder.FolderPath = newFolder.FolderPath;
                    SyncUserFolder(importJob.PortalId, folder);
                    return true;
                }
                else
                {
                    folder.FolderId = 0;
                    return false;
                }
            }
            return true;
        }]]></body>
          </codeblock>
        </method>
        <method name="ProcessFolderPermission">
          <declaration><![CDATA[private void ProcessFolderPermission(ExportImportJob importJob, ImportDto importDto, ExportFolderPermission folderPermission, IEnumerable<ExportFolderPermission> localPermissions)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="405" sc="9" el="482" ec="10">Components\Services\AssetsExportService.cs</location>
            <body hash="f31b8e1a17ca22407039b6e1fb5d9de1"><![CDATA[{
            var portalId = importJob.PortalId;

            if (folderPermission == null) return;

            var existingFolderPermission = localPermissions.FirstOrDefault(
                x =>
                    (x.FolderPath == folderPermission.FolderPath ||
                     (string.IsNullOrEmpty(x.FolderPath) && string.IsNullOrEmpty(folderPermission.FolderPath))) &&
                    x.PermissionCode == folderPermission.PermissionCode &&
                    x.PermissionKey == folderPermission.PermissionKey
                    && x.PermissionName == folderPermission.PermissionName &&
                    (x.RoleName == folderPermission.RoleName ||
                     (string.IsNullOrEmpty(x.RoleName) && string.IsNullOrEmpty(folderPermission.RoleName)))
                    &&
                    (x.Username == folderPermission.Username ||
                     (string.IsNullOrEmpty(x.Username) && string.IsNullOrEmpty(folderPermission.Username))));

            var isUpdate = false;
            if (existingFolderPermission != null)
            {
                switch (importDto.CollisionResolution)
                {
                    case CollisionResolution.Overwrite:
                        isUpdate = true;
                        break;
                    case CollisionResolution.Ignore:
                        return;
                    default:
                        throw new ArgumentOutOfRangeException(importDto.CollisionResolution.ToString());
                }
            }
            if (isUpdate)
            {
                var modifiedBy = Util.GetUserIdByName(importJob, folderPermission.LastModifiedByUserId,
                    folderPermission.LastModifiedByUserName);

                DotNetNuke.Data.DataProvider.Instance()
                    .UpdateFolderPermission(existingFolderPermission.FolderPermissionId, folderPermission.FolderId,
                        existingFolderPermission.PermissionId, existingFolderPermission.RoleId ?? Convert.ToInt32(Globals.glbRoleNothing),
                        folderPermission.AllowAccess, existingFolderPermission.UserId ?? Null.NullInteger, modifiedBy);

                folderPermission.FolderPermissionId = existingFolderPermission.FolderPermissionId;
            }
            else
            {
                var permissionId = DataProvider.Instance()
                    .GetPermissionId(folderPermission.PermissionCode, folderPermission.PermissionKey,
                        folderPermission.PermissionName);

                if (permissionId != null)
                {
                    var noRole = Convert.ToInt32(Globals.glbRoleNothing);

                    folderPermission.PermissionId = Convert.ToInt32(permissionId);
                    if (folderPermission.UserId != null && folderPermission.UserId > 0 && !string.IsNullOrEmpty(folderPermission.Username))
                    {
                        folderPermission.UserId = UserController.GetUserByName(portalId, folderPermission.Username)?.UserID;
                        if (folderPermission.UserId == null)
                            return;
                    }
                    if (folderPermission.RoleId != null && folderPermission.RoleId > noRole && !string.IsNullOrEmpty(folderPermission.RoleName))
                    {
                        folderPermission.RoleId = Util.GetRoleIdByName(portalId, folderPermission.RoleId ?? noRole, folderPermission.RoleName);
                        if (folderPermission.RoleId == null)
                            return;
                    }
                    var createdBy = Util.GetUserIdByName(importJob, folderPermission.CreatedByUserId,
                        folderPermission.CreatedByUserName);

                    folderPermission.FolderPermissionId = DotNetNuke.Data.DataProvider.Instance()
                        .AddFolderPermission(folderPermission.FolderId, folderPermission.PermissionId,
                            folderPermission.RoleId ?? noRole, folderPermission.AllowAccess,
                            folderPermission.UserId ?? Null.NullInteger, createdBy);
                }
            }
            folderPermission.LocalId = folderPermission.FolderPermissionId;
        }]]></body>
          </codeblock>
        </method>
        <method name="SyncUserFolder">
          <declaration><![CDATA[private void SyncUserFolder(int portalId, ExportFolder folder)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="541" sc="9" el="560" ec="10">Components\Services\AssetsExportService.cs</location>
            <body hash="5708ff825e1427103b680388424efbe7"><![CDATA[{
            var portal = PortalController.Instance.GetPortal(portalId);
            var tempUsersFolderPath =
                $"{string.Format(UsersAssetsTempFolder, portal.HomeDirectoryMapPath.TrimEnd('\\'))}{folder.FolderPath}";
            var newUsersFolderPath = $"{portal.HomeDirectoryMapPath}{folder.FolderPath}";
            if (!Directory.Exists(tempUsersFolderPath))
                return;
            if (!Directory.Exists(newUsersFolderPath))
                Directory.CreateDirectory(newUsersFolderPath);
            var files = Directory.GetFiles(tempUsersFolderPath, "*.*", SearchOption.AllDirectories);
            var dirInfo = new DirectoryInfo(newUsersFolderPath);
            foreach (
                var mFile in
                    files.Select(file => new System.IO.FileInfo(file)))
            {
                if (File.Exists(dirInfo + "\\" + mFile.Name))
                    File.Delete(dirInfo + "\\" + mFile.Name);
                mFile.MoveTo(dirInfo + "\\" + mFile.Name);
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_assetsFolder">
          <declaration><![CDATA[private readonly string _assetsFolder = string.Format("{0}{1}{{0}}\\{2}", Globals.ApplicationMapPath, "\\App_Data\\ExportImport\\", "export_files.zip");]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DefaultUsersFoldersPath">
          <declaration><![CDATA[private const string DefaultUsersFoldersPath = "Users";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="UserFolderEx">
          <declaration><![CDATA[private static readonly Regex UserFolderEx = new Regex("users/\\d+/\\d+/(\\d+)/", RegexOptions.IgnoreCase | RegexOptions.Compiled);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="UsersAssetsTempFolder">
          <declaration><![CDATA[private const string UsersAssetsTempFolder = "{0}\\TempUsers\\";]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Category">
          <declaration><![CDATA[public override string Category]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="55" sc="44" el="55" ec="69">Components\Services\AssetsExportService.cs</location>
            <body hash="b74ee71346cafb328f269bf0b7760f92"><![CDATA[Constants.Category_Asset]]></body>
          </codeblock>
        </property>
        <property name="ParentCategory">
          <declaration><![CDATA[public override string ParentCategory]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="57" sc="50" el="57" ec="54">Components\Services\AssetsExportService.cs</location>
            <body hash="40a8712b29ac76182ed0c4f632b7d543"><![CDATA[nul]]></body>
          </codeblock>
        </property>
        <property name="Priority">
          <declaration><![CDATA[public override uint Priority]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="59" sc="42" el="59" ec="44">Components\Services\AssetsExportService.cs</location>
            <body hash="e4da3b7fbbce2345d7772b0674a318d5"><![CDATA[5]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="BasePortableService">
      <declaration><![CDATA[public abstract class BasePortableService]]></declaration>
      <documentation>
        <summary>
 A abstract class specifying the ability to import and export site different areas.
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[protected BasePortableService()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ExportData">
          <declaration><![CDATA[public abstract void ExportData(ExportImportJob exportJob, ExportDto exportDto);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetImportTotal">
          <declaration><![CDATA[public abstract int GetImportTotal();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="ImportData">
          <declaration><![CDATA[public abstract void ImportData(ExportImportJob importJob, ImportDto importDto);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Category">
          <declaration><![CDATA[public abstract string Category]]></declaration>
          <documentation>
            <summary>
 Category name for the exportable module. For example: "ASSETS".
 </summary>
          </documentation>
        </property>
        <property name="CheckCancelled">
          <declaration><![CDATA[public Func<ExportImportJob, bool> CheckCancelled]]></declaration>
          <documentation>
            <summary>
 A callback to the export/import engine to check if the undergoing export/import process was cancelled.
 <para>The interface concrete classes should keep checking continuously for the cancellation flag to be true</para>
 <para>If the callback returns true, the BasePortableService implementations should stop any work they do and
 return control to the caller immediately or as soon as possible.</para>
 </summary>
          </documentation>
          <codeblock>
            <location sl="60" sc="61" el="60" ec="65">Components\Services\BasePortableService.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="60" sc="66" el="60" ec="70">Components\Services\BasePortableService.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="CheckPoint">
          <declaration><![CDATA[public ExportImportChekpoint CheckPoint]]></declaration>
          <documentation>
            <summary>
 A data structure representing a checkpoint for the export/import task. This can be used to tell the
 implementor where to resume it's operation if the job was interrupted previously.
 </summary>
 <remarks>It is up to each BasePortableService implementor to track its own stages and status values to
 properly export/import all of its items in/when and interruption occurs.</remarks></documentation>
          <codeblock>
            <location sl="52" sc="51" el="52" ec="55">Components\Services\BasePortableService.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="52" sc="56" el="52" ec="60">Components\Services\BasePortableService.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="CheckPointStageCallback">
          <declaration><![CDATA[public Func<BasePortableService, bool> CheckPointStageCallback]]></declaration>
          <documentation>
            <summary>
 Callback function to provide a checkpoint mechanism for an <see cref="T:Dnn.ExportImport.Components.Services.BasePortableService" /> implementation.
 The actual method shoul persist the reported checkpoint in the engine so if the process is interrupted,
 it can be resumed. If the reponse to calling this function was false, then the task should stop
 processing and return control immediately to the caller.
 </summary>
 <returns>True if the implementation to abort progress; false to continue.</returns></documentation>
          <codeblock>
            <location sl="69" sc="74" el="69" ec="78">Components\Services\BasePortableService.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="69" sc="79" el="69" ec="83">Components\Services\BasePortableService.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ParentCategory">
          <declaration><![CDATA[public abstract string ParentCategory]]></declaration>
          <documentation>
            <summary>
 Category name for the parent exportable module. For example: "USERS".
 If this is null, then the category is a top parent. If this is not null,
 then this category will be included automatically when the parent is included.
 </summary>
          </documentation>
        </property>
        <property name="Priority">
          <declaration><![CDATA[public abstract uint Priority]]></declaration>
          <documentation>
            <summary>
 A priority for exporting/importing the object. Objects with higher
 priority are exported/imported first. Highest priority is 0.
 </summary>
          </documentation>
        </property>
        <property name="Repository">
          <declaration><![CDATA[public IExportImportRepository Repository]]></declaration>
          <documentation>
            <summary>
 A repository to store exported items in and to retrieve from upon import.
 </summary>
          </documentation>
          <codeblock>
            <location sl="44" sc="53" el="44" ec="57">Components\Services\BasePortableService.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="44" sc="58" el="44" ec="62">Components\Services\BasePortableService.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Result">
          <declaration><![CDATA[public ExportImportResult Result]]></declaration>
          <documentation>
            <summary>
 An object to record the export/import progress information.
 This is set by the export/import engine.
 </summary>
          </documentation>
          <codeblock>
            <location sl="39" sc="44" el="39" ec="48">Components\Services\BasePortableService.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="39" sc="49" el="39" ec="53">Components\Services\BasePortableService.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="PackagesExportService">
      <declaration><![CDATA[public class PackagesExportService : BasePortableService]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public PackagesExportService()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static PackagesExportService()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="20" sc="9" el="22" ec="145">Components\Services\PackagesExportService.cs</location>
            <body hash="252d2d91f2958a888e906edaa7c8dbd4"><![CDATA[private static readonly ILog Logger = LoggerSource.Instance.GetLogger(typeof(PackagesExportService));

        private static readonly Regex ExtensionPackageFilesRegex = new Regex(@"^(.+?)_(.+?)_(\d+\.\d+\.\d+).resources$", RegexOptions.Compiled);]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ExportData">
          <declaration><![CDATA[public override void ExportData(ExportImportJob exportJob, ExportDto exportDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="33" sc="9" el="93" ec="10">Components\Services\PackagesExportService.cs</location>
            <body hash="85f9f213afa72ef9d0d0f8298c3ece50"><![CDATA[{
            if (CheckCancelled(exportJob)) return;
            //Skip the export if all the folders have been processed already.
            if (CheckPoint.Stage >= 1)
                return;

            //Create Zip File to hold files
            var skip = GetCurrentSkip();
            var currentIndex = skip;
            var totalPackagesExported = 0;
            try
            {
                var packagesZipFileFormat = $"{Globals.ApplicationMapPath}{Constants.ExportFolder}{{0}}\\{Constants.ExportZipPackages}";
                var packagesZipFile = string.Format(packagesZipFileFormat, exportJob.Directory.TrimEnd('\\').TrimEnd('/'));

                if (CheckPoint.Stage == 0)
                {
                    var fromDate = exportDto.FromDateUtc ?? Constants.MinDbTime;
                    var toDate = exportDto.ToDateUtc;

                    //export skin packages.
                    var extensionPackagesBackupFolder = Path.Combine(Globals.ApplicationMapPath, DotNetNuke.Services.Installer.Util.BackupInstallPackageFolder);
                    var skinPackageFiles = Directory.GetFiles(extensionPackagesBackupFolder).Where(f => IsValidPackage(f, fromDate, toDate)).ToList();
                    var totalPackages = skinPackageFiles.Count;

                    //Update the total items count in the check points. This should be updated only once.
                    CheckPoint.TotalItems = CheckPoint.TotalItems <= 0 ? totalPackages : CheckPoint.TotalItems;
                    if (CheckPointStageCallback(this)) return;

                    foreach (var file in skinPackageFiles)
                    {
                        var exportPackage = GenerateExportPackage(file);
                        if (exportPackage != null)
                        {
                            Repository.CreateItem(exportPackage, null);
                            totalPackagesExported += 1;
                            var folderOffset = Path.GetDirectoryName(file)?.Length + 1;

                            CompressionUtil.AddFileToArchive(file, packagesZipFile, folderOffset.GetValueOrDefault(0));
                        }

                        CheckPoint.ProcessedItems++;
                        CheckPoint.Progress = CheckPoint.ProcessedItems * 100.0 / totalPackages;
                        currentIndex++;
                        //After every 10 items, call the checkpoint stage. This is to avoid too many frequent updates to DB.
                        if (currentIndex % 10 == 0 && CheckPointStageCallback(this)) return;
                    }

                    CheckPoint.Stage++;
                    currentIndex = 0;
                    CheckPoint.Completed = true;
                    CheckPoint.Progress = 100;
                }
            }
            finally
            {
                CheckPoint.StageData = currentIndex > 0 ? JsonConvert.SerializeObject(new { skip = currentIndex }) : null;
                CheckPointStageCallback(this);
                Result.AddSummary("Exported Packages", totalPackagesExported.ToString());
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="GenerateExportPackage">
          <declaration><![CDATA[private ExportPackage GenerateExportPackage(string filePath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="134" sc="9" el="152" ec="10">Components\Services\PackagesExportService.cs</location>
            <body hash="47b77276c8e82b2903ea51b369a96805"><![CDATA[{
            var fileName = Path.GetFileName(filePath);
            if (string.IsNullOrEmpty(fileName))
            {
                return null;
            }

            var match = ExtensionPackageFilesRegex.Match(fileName);
            if (!match.Success)
            {
                return null;
            }

            var packageType = match.Groups[1].Value;
            var packageName = match.Groups[2].Value;
            var version = new Version(match.Groups[3].Value);

            return new ExportPackage { PackageFileName = fileName, PackageName = packageName, PackageType = packageType, Version = version };
        }]]></body>
          </codeblock>
        </method>
        <method name="GetCurrentSkip">
          <declaration><![CDATA[private int GetCurrentSkip()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="113" sc="9" el="120" ec="10">Components\Services\PackagesExportService.cs</location>
            <body hash="9c59ad479c1722ee90e27b9af90a612c"><![CDATA[{
            if (!string.IsNullOrEmpty(CheckPoint.StageData))
            {
                dynamic stageData = JsonConvert.DeserializeObject(CheckPoint.StageData);
                return Convert.ToInt32(stageData.skip) ?? 0;
            }
            return 0;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetImportTotal">
          <declaration><![CDATA[public override int GetImportTotal()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="108" sc="9" el="110" ec="10">Components\Services\PackagesExportService.cs</location>
            <body hash="835c5c81a1605831c490ea3b39fd696f"><![CDATA[{
            return Repository.GetCount<ExportPackage>();
        }]]></body>
          </codeblock>
        </method>
        <method name="GetInstaller">
          <declaration><![CDATA[private static Installer GetInstaller(Stream stream)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="266" sc="9" el="279" ec="10">Components\Services\PackagesExportService.cs</location>
            <body hash="483971b32cb4fc5f468e102517617718"><![CDATA[{
            var installer = new Installer(stream, Globals.ApplicationMapPath, false, false)
            {
                InstallerInfo = { PortalID = Null.NullInteger }
            };

            //Read the manifest
            if (installer.InstallerInfo.ManifestFile != null)
            {
                installer.ReadManifest(true);
            }

            return installer;
        }]]></body>
          </codeblock>
        </method>
        <method name="ImportData">
          <declaration><![CDATA[public override void ImportData(ExportImportJob importJob, ImportDto importDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="96" sc="9" el="105" ec="10">Components\Services\PackagesExportService.cs</location>
            <body hash="156a298a1898341c3ea1a2de01c54ee0"><![CDATA[{
            if (CheckCancelled(importJob)) return;
            //Skip the export if all the templates have been processed already.
            if (CheckPoint.Stage >= 1 || CheckPoint.Completed)
                return;

            _exportImportJob = importJob;

            ProcessImportModulePackages(importDto);
        }]]></body>
          </codeblock>
        </method>
        <method name="InstallPackage">
          <declaration><![CDATA[public void InstallPackage(string filePath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="235" sc="9" el="263" ec="10">Components\Services\PackagesExportService.cs</location>
            <body hash="a4357a02d57f0cc4c3c5fa4a3893b264"><![CDATA[{
            using (var stream = new FileStream(filePath, FileMode.Open))
            {
                try
                {
                    var installer = GetInstaller(stream);

                    if (installer.IsValid)
                    {
                        //Reset Log
                        installer.InstallerInfo.Log.Logs.Clear();

                        //Set the IgnnoreWhiteList flag
                        installer.InstallerInfo.IgnoreWhiteList = true;

                        //Set the Repair flag
                        installer.InstallerInfo.RepairInstall = true;

                        //Install
                        installer.Install();
                    }
                }
                catch (Exception ex)
                {
                    Result.AddLogEntry("Import Package error", $"{filePath}. ERROR: {ex.Message}");
                    Logger.Error(ex);
                }
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="IsValidPackage">
          <declaration><![CDATA[private bool IsValidPackage(string filePath, DateTime fromDate, DateTime toDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="123" sc="9" el="131" ec="10">Components\Services\PackagesExportService.cs</location>
            <body hash="7a8d93a4e90c494eb85c86186483c31a"><![CDATA[{
            var fileInfo = new FileInfo(filePath);
            if (string.IsNullOrEmpty(fileInfo.Name) || fileInfo.LastWriteTimeUtc < fromDate || fileInfo.LastWriteTimeUtc > toDate)
            {
                return false;
            }

            return fileInfo.Name.StartsWith("Skin_") || fileInfo.Name.StartsWith("Container_");
        }]]></body>
          </codeblock>
        </method>
        <method name="ProcessImportModulePackages">
          <declaration><![CDATA[private void ProcessImportModulePackages(ImportDto importDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="155" sc="9" el="232" ec="10">Components\Services\PackagesExportService.cs</location>
            <body hash="3cc979aa6080372810f85bcba0b9cc9e"><![CDATA[{
            var packageZipFile = $"{Globals.ApplicationMapPath}{Constants.ExportFolder}{_exportImportJob.Directory.TrimEnd('\\', '/')}\\{Constants.ExportZipPackages}";
            var tempFolder = $"{Path.GetDirectoryName(packageZipFile)}\\{DateTime.Now.Ticks}";
            if (File.Exists(packageZipFile))
            {
                CompressionUtil.UnZipArchive(packageZipFile, tempFolder);
                var exportPackages = Repository.GetAllItems<ExportPackage>().ToList();

                CheckPoint.TotalItems = CheckPoint.TotalItems <= 0 ? exportPackages.Count : CheckPoint.TotalItems;
                if (CheckPointStageCallback(this)) return;

                if (CheckPoint.Stage == 0)
                {
                    try
                    {
                        foreach (var exportPackage in exportPackages)
                        {
                            try
                            {
                                var filePath = Path.Combine(tempFolder, exportPackage.PackageFileName);
                                if (!File.Exists(filePath))
                                {
                                    continue;
                                }

                                var packageType = exportPackage.PackageType;
                                var packageName = exportPackage.PackageName;
                                var version = exportPackage.Version;

                                var existPackage = PackageController.Instance.GetExtensionPackage(Null.NullInteger,
                                    p => p.PackageType == packageType && p.Name == packageName);
                                if (existPackage != null &&
                                    (existPackage.Version > version ||
                                     (existPackage.Version == version &&
                                      importDto.CollisionResolution == CollisionResolution.Ignore)))
                                {
                                    Result.AddLogEntry("Import Package ignores",
                                        $"{packageName} has higher version {existPackage.Version} installed, ignore import it");
                                    continue;
                                }

                                InstallPackage(filePath);
                                Result.AddLogEntry("Import Package completed", $"{packageName} version: {version}");
                                CheckPoint.ProcessedItems++;
                                CheckPoint.Progress = CheckPoint.ProcessedItems * 100.0 / exportPackages.Count;
                                CheckPointStageCallback(this); // just to update the counts without exit logic
                            }
                            catch (Exception ex)
                            {
                                Result.AddLogEntry("Import Package error",
                                    $"{exportPackage.PackageName} : {exportPackage.Version} - {ex.Message}");
                                Logger.Error(ex);
                            }
                        }
                        CheckPoint.Stage++;
                        CheckPoint.Completed = true;
                    }
                    finally
                    {
                        CheckPointStageCallback(this);
                        try
                        {
                            FileSystemUtils.DeleteFolderRecursive(tempFolder);
                        }
                        catch (Exception)
                        {
                            //ignore
                        }
                    }
                }
            }
            else
            {
                CheckPoint.Completed = true;
                CheckPointStageCallback(this);
                Result.AddLogEntry("PackagesFileNotFound", "Packages file not found. Skipping packages import", ReportLevel.Warn);
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_exportImportJob">
          <declaration><![CDATA[private ExportImportJob _exportImportJob;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ExtensionPackageFilesRegex">
          <declaration><![CDATA[private static readonly Regex ExtensionPackageFilesRegex = new Regex("^(.+?)_(.+?)_(\\d+\\.\\d+\\.\\d+).resources$", RegexOptions.Compiled);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Logger">
          <declaration><![CDATA[private static readonly ILog Logger = LoggerSource.Instance.GetLogger(typeof(PackagesExportService));]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Category">
          <declaration><![CDATA[public override string Category]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="26" sc="44" el="26" ec="71">Components\Services\PackagesExportService.cs</location>
            <body hash="31ced93e8bcd48cf78118988d97f5139"><![CDATA[Constants.Category_Package]]></body>
          </codeblock>
        </property>
        <property name="ParentCategory">
          <declaration><![CDATA[public override string ParentCategory]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="28" sc="50" el="28" ec="54">Components\Services\PackagesExportService.cs</location>
            <body hash="40a8712b29ac76182ed0c4f632b7d543"><![CDATA[nul]]></body>
          </codeblock>
        </property>
        <property name="Priority">
          <declaration><![CDATA[public override uint Priority]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="30" sc="42" el="30" ec="44">Components\Services\PackagesExportService.cs</location>
            <body hash="c4ca4238a0b923820dcc509a6f75849b"><![CDATA[1]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="PagesExportService">
      <declaration><![CDATA[public class PagesExportService : BasePortableService]]></declaration>
      <documentation>
        <summary>
 Service to export/import pages/tabs.
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private bool <IncludeSystem>k__BackingField = false;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="69" sc="59" el="84" ec="73">Components\Services\PagesExportService.cs</location>
            <body hash="06a4069cb11d0cc64e3e82570b1e435b"><![CDATA[false;

        public virtual bool IgnoreParentMatch { get; set; } = false;

        protected ImportDto ImportDto => _importDto;

        private ProgressTotals _totals;
        private DataProvider _dataProvider;
        private ITabController _tabController;
        private IModuleController _moduleController;
        private IContentController _contentController;
        private ExportImportJob _exportImportJob;
        private ImportDto _importDto;
        private ExportDto _exportDto;

        private IList<int> _exportedModuleDefinitions = new List<int>();]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static PagesExportService()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="86" sc="9" el="86" ec="107">Components\Services\PagesExportService.cs</location>
            <body hash="468e4b0864d3837463ab4bb4e865ec27"><![CDATA[private static readonly ILog Logger = LoggerSource.Instance.GetLogger(typeof(ExportImportEngine))]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AddTabRelatedItems">
          <declaration><![CDATA[private void AddTabRelatedItems(TabInfo localTab, ExportTab otherTab, bool isNew)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="293" sc="9" el="298" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="e017365ebac8f2c49eceb86df1cfb806"><![CDATA[{
            _totals.TotalTabSettings += ImportTabSettings(localTab, otherTab, isNew);
            _totals.TotalTabPermissions += ImportTabPermissions(localTab, otherTab, isNew);
            _totals.TotalTabUrls += ImportTabUrls(localTab, otherTab, isNew);
            _totals.TotalTabModules += ImportTabModulesAndRelatedItems(localTab, otherTab, isNew);
        }]]></body>
          </codeblock>
        </method>
        <method name="DisableVersioning">
          <declaration><![CDATA[private void DisableVersioning(int tabId, out bool tabVersionsEnabled, out bool tabWorkflowEnabled)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1029" sc="9" el="1038" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="1c76af6bfc3c7b4e5bdd33ad0448be7c"><![CDATA[{
            var portalId = _importDto.PortalId;
            tabWorkflowEnabled = TabVersionSettings.Instance.IsVersioningEnabled(portalId, tabId);
            TabVersionSettings.Instance.SetEnabledVersioningForPortal(portalId, false);
            TabVersionSettings.Instance.SetEnabledVersioningForTab(tabId, false);

            var workflowSettings = TabWorkflowSettings.Instance;
            tabVersionsEnabled = workflowSettings.IsWorkflowEnabled(portalId, tabId);
            workflowSettings.SetWorkflowEnabled(portalId, tabId, false);
        }]]></body>
          </codeblock>
        </method>
        <method name="ExportData">
          <declaration><![CDATA[public override void ExportData(ExportImportJob exportJob, ExportDto exportDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="89" sc="9" el="108" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="8831a48bafd2d853d59327d2d84f1555"><![CDATA[{
            if (CheckPoint.Stage > 0) return;
            if (CheckCancelled(exportJob)) return;

            var checkedPages = exportDto.Pages.Where(p => p.CheckedState == TriCheckedState.Checked || p.CheckedState == TriCheckedState.Partial);
            if (checkedPages.Any())
            {
                _exportImportJob = exportJob;
                _exportDto = exportDto;
                _tabController = TabController.Instance;
                _moduleController = ModuleController.Instance;
                ProcessExportPages();
            }

            CheckPoint.Progress = 100;
            CheckPoint.Completed = true;
            CheckPoint.Stage++;
            CheckPoint.StageData = null;
            CheckPointStageCallback(this);
        }]]></body>
          </codeblock>
        </method>
        <method name="ExportModulePackage">
          <declaration><![CDATA[private int ExportModulePackage(ExportModule exportModule)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1363" sc="9" el="1391" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="345c923bc68e1f801456f2838eed39a1"><![CDATA[{
            if (!_exportedModuleDefinitions.Contains(exportModule.ModuleDefID))
            {
                var packageZipFile = $"{Globals.ApplicationMapPath}{Constants.ExportFolder}{_exportImportJob.Directory.TrimEnd('\\', '/')}\\{Constants.ExportZipPackages}";
                var moduleDefinition = ModuleDefinitionController.GetModuleDefinitionByID(exportModule.ModuleDefID);
                var desktopModuleId = moduleDefinition.DesktopModuleID;
                var desktopModule = DesktopModuleController.GetDesktopModule(desktopModuleId, Null.NullInteger);
                var package = PackageController.Instance.GetExtensionPackage(Null.NullInteger, p => p.PackageID == desktopModule.PackageID);

                var filePath = InstallerUtil.GetPackageBackupPath(package);
                if (File.Exists(filePath))
                {
                    var offset = Path.GetDirectoryName(filePath)?.Length + 1;
                    CompressionUtil.AddFileToArchive(filePath, packageZipFile, offset.GetValueOrDefault(0));

                    Repository.CreateItem(new ExportPackage
                    {
                        PackageName = package.Name,
                        Version = package.Version,
                        PackageType = package.PackageType,
                        PackageFileName = InstallerUtil.GetPackageBackupName(package)
                    }, null);

                    _exportedModuleDefinitions.Add(exportModule.ModuleDefID);
                    return 1;
                }
            }
            return 0;
        }]]></body>
          </codeblock>
        </method>
        <method name="ExportModulePermissions">
          <declaration><![CDATA[private int ExportModulePermissions(ExportModule exportModule, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1402" sc="9" el="1407" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="1827a7dfeb8c5b4b35f7426a1f97f954"><![CDATA[{
            var modulePermission = EntitiesController.Instance.GetModulePermissions(exportModule.ModuleID, toDate, fromDate);
            if (modulePermission.Count > 0)
                Repository.CreateItems(modulePermission, exportModule.Id);
            return modulePermission.Count;
        }]]></body>
          </codeblock>
        </method>
        <method name="ExportModuleSettings">
          <declaration><![CDATA[private int ExportModuleSettings(ExportModule exportModule, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1394" sc="9" el="1399" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="26c9c1da0584b093666cf0385dc127bc"><![CDATA[{
            var moduleSettings = EntitiesController.Instance.GetModuleSettings(exportModule.ModuleID, toDate, fromDate);
            if (moduleSettings.Count > 0)
                Repository.CreateItems(moduleSettings, exportModule.Id);
            return moduleSettings.Count;
        }]]></body>
          </codeblock>
        </method>
        <method name="ExportPortableContent">
          <declaration><![CDATA[private int ExportPortableContent(ExportTab exportPage, ExportModule exportModule, DateTime toDate, DateTime? fromDat)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1413" sc="9" el="1460" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="e01c385246644df2ceefe66098776d87"><![CDATA[{
            // check if module's contnt was exported before
            var existingItems = Repository.FindItems<ExportModuleContent>(m => m.ModuleID == exportModule.ModuleID);
            if (!existingItems.Any())
            {
                var moduleDef = ModuleDefinitionController.GetModuleDefinitionByID(exportModule.ModuleDefID);
                var desktopModuleInfo = DesktopModuleController.GetDesktopModule(moduleDef.DesktopModuleID, _exportDto.PortalId);
                if (!string.IsNullOrEmpty(desktopModuleInfo?.BusinessControllerClass))
                {
                    try
                    {
                        var module = _moduleController.GetModule(exportModule.ModuleID, exportPage.TabId, true);
                        if (!string.IsNullOrEmpty(module.DesktopModule.BusinessControllerClass) && module.DesktopModule.IsPortable)
                        {
                            try
                            {
                                var businessController = Reflection.CreateObject(module.DesktopModule.BusinessControllerClass,
                                    module.DesktopModule.BusinessControllerClass);
                                var controller = businessController as IPortable;
                                var content = controller?.ExportModule(module.ModuleID);
                                if (!string.IsNullOrEmpty(content))
                                {
                                    var record = new ExportModuleContent
                                    {
                                        ModuleID = exportModule.ModuleID,
                                        ModuleDefID = exportModule.ModuleDefID,
                                        XmlContent = content,
                                    };

                                    Repository.CreateItem(record, exportModule.Id);
                                    return 1;
                                }
                            }
                            catch (Exception e)
                            {
                                Result.AddLogEntry("Error exporting module data, Module ID=" + exportModule.ModuleID, e.Message, ReportLevel.Error);
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Result.AddLogEntry("Error cerating business class type", desktopModuleInfo.BusinessControllerClass, ReportLevel.Error);
                        Logger.Error("Error cerating business class type. " + ex);
                    }
                }
            }
            return 0;
        }]]></body>
          </codeblock>
        </method>
        <method name="ExportTabModules">
          <declaration><![CDATA[private int ExportTabModules(ExportTab exportPage, bool includeDeleted, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1319" sc="9" el="1324" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="04ec4100e39cf5a2af3e55deaacd18b6"><![CDATA[{
            var tabModules = EntitiesController.Instance.GetTabModules(exportPage.TabId, includeDeleted, toDate, fromDate);
            if (tabModules.Count > 0)
                Repository.CreateItems(tabModules, exportPage.Id);
            return tabModules.Count;
        }]]></body>
          </codeblock>
        </method>
        <method name="ExportTabModulesAndRelatedItems">
          <declaration><![CDATA[private int ExportTabModulesAndRelatedItems(ExportTab exportPage, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1335" sc="9" el="1360" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="c57696a657993c7c6837471b7bdf0b51"><![CDATA[{
            var modules = EntitiesController.Instance.GetModules(exportPage.TabId, _exportDto.IncludeDeletions, toDate, fromDate);
            if (modules.Count > 0)
            {
                Repository.CreateItems(modules, exportPage.Id);
                foreach (var exportModule in modules)
                {
                    _totals.TotalModuleSettings +=
                        ExportModuleSettings(exportModule, toDate, fromDate);

                    _totals.TotalModulePermissions +=
                        ExportModulePermissions(exportModule, toDate, fromDate);

                    if (_exportDto.IncludeContent)
                    {
                        _totals.TotalContents +=
                            ExportPortableContent(exportPage, exportModule, toDate, fromDate);
                    }

                    _totals.TotalPackages +=
                        ExportModulePackage(exportModule);
                }
            }

            return modules.Count;
        }]]></body>
          </codeblock>
        </method>
        <method name="ExportTabModuleSettings">
          <declaration><![CDATA[private int ExportTabModuleSettings(ExportTab exportPage, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1327" sc="9" el="1332" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="f9ea6bc216a0774145be3dd3f1d22d9d"><![CDATA[{
            var tabModuleSettings = EntitiesController.Instance.GetTabModuleSettings(exportPage.TabId, toDate, fromDate);
            if (tabModuleSettings.Count > 0)
                Repository.CreateItems(tabModuleSettings, exportPage.Id);
            return tabModuleSettings.Count;
        }]]></body>
          </codeblock>
        </method>
        <method name="ExportTabPermissions">
          <declaration><![CDATA[private int ExportTabPermissions(ExportTab exportPage, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1301" sc="9" el="1308" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="f4c4d50b8e8b5fd657de49c312317424"><![CDATA[{
            if (!_exportDto.IncludePermissions) return 0;

            var tabPermissions = EntitiesController.Instance.GetTabPermissions(exportPage.TabId, toDate, fromDate);
            if (tabPermissions.Count > 0)
                Repository.CreateItems(tabPermissions, exportPage.Id);
            return tabPermissions.Count;
        }]]></body>
          </codeblock>
        </method>
        <method name="ExportTabSettings">
          <declaration><![CDATA[private int ExportTabSettings(ExportTab exportPage, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1293" sc="9" el="1298" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="25f198de867968e6ce00faca701bd03a"><![CDATA[{
            var tabSettings = EntitiesController.Instance.GetTabSettings(exportPage.TabId, toDate, fromDate);
            if (tabSettings.Count > 0)
                Repository.CreateItems(tabSettings, exportPage.Id);
            return tabSettings.Count;
        }]]></body>
          </codeblock>
        </method>
        <method name="ExportTabUrls">
          <declaration><![CDATA[private int ExportTabUrls(ExportTab exportPage, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1311" sc="9" el="1316" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="b19de07106525dd00d6e51e3aeea21d5"><![CDATA[{
            var tabUrls = EntitiesController.Instance.GetTabUrls(exportPage.TabId, toDate, fromDate);
            if (tabUrls.Count > 0)
                Repository.CreateItems(tabUrls, exportPage.Id);
            return tabUrls.Count;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetImportTotal">
          <declaration><![CDATA[public override int GetImportTotal()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="132" sc="9" el="134" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="37a69e5795a3c46683b756c93730d442"><![CDATA[{
            return Repository.GetCount<ExportTab>(x => x.IsSystem == IncludeSystem);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetLocalStateId">
          <declaration><![CDATA[private int GetLocalStateId(int exportedStateId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1601" sc="9" el="1610" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="054ed9303e232a3f014a326445f7de79"><![CDATA[{
            var exportWorkflowState = Repository.GetItem<ExportWorkflowState>(item => item.StateID == exportedStateId);
            var stateId = exportWorkflowState?.LocalId ?? Null.NullInteger;
            if (stateId <= 0) return stateId;
            var state = WorkflowStateManager.Instance.GetWorkflowState(stateId);
            if (state == null) return -1;
            var workflow = WorkflowManager.Instance.GetWorkflow(state.WorkflowID);
            if (workflow == null) return -1;
            return workflow.FirstState.StateID;
        }]]></body>
          </codeblock>
        </method>
        <method name="ImportData">
          <declaration><![CDATA[public override void ImportData(ExportImportJob importJob, ImportDto importDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="111" sc="9" el="129" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="bbfdd23cc566c1cdbd1220065a21019c"><![CDATA[{
            if (CheckPoint.Stage > 0) return;
            if (CheckCancelled(importJob)) return;

            _exportImportJob = importJob;
            _importDto = importDto;
            _exportDto = importDto.ExportDto;
            _tabController = TabController.Instance;
            _moduleController = ModuleController.Instance;
            _contentController = ContentController.Instance;

            ProcessImportPages();

            CheckPoint.Progress = 100;
            CheckPoint.Completed = true;
            CheckPoint.Stage++;
            CheckPoint.StageData = null;
            CheckPointStageCallback(this);
        }]]></body>
          </codeblock>
        </method>
        <method name="ImportModulePermissions">
          <declaration><![CDATA[private int ImportModulePermissions(ModuleInfo localModule, ExportModule otherModule, bool isNew)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="862" sc="9" el="945" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="66f9718846b0b79adcc3d89c971296be"><![CDATA[{
            var count = 0;
            var modulePermissions = Repository.GetRelatedItems<ExportModulePermission>(otherModule.Id).ToList();
            var localModulePermissions = isNew
                ? new List<ModulePermissionInfo>()
                : localModule.ModulePermissions.OfType<ModulePermissionInfo>().ToList();
            foreach (var other in modulePermissions)
            {
                var local = localModulePermissions.FirstOrDefault(
                    x => x.PermissionCode == other.PermissionCode &&
                         x.PermissionKey == other.PermissionKey
                         && x.PermissionName == other.PermissionName &&
                         (x.RoleName == other.RoleName || string.IsNullOrEmpty(x.RoleName) && string.IsNullOrEmpty(other.RoleName))
                         &&
                         (x.Username == other.Username || string.IsNullOrEmpty(x.Username) && string.IsNullOrEmpty(other.Username)));

                var isUpdate = false;
                if (local != null)
                {
                    switch (_importDto.CollisionResolution)
                    {
                        case CollisionResolution.Overwrite:
                            isUpdate = true;
                            break;
                        case CollisionResolution.Ignore:
                            Result.AddLogEntry("Ignored tab permission", other.PermissionKey);
                            break;
                        default:
                            throw new ArgumentOutOfRangeException(_importDto.CollisionResolution.ToString());
                    }
                }

                if (isUpdate)
                {
                    //UNDONE: Do we really need to update an existing permission? It won't do anything; permissions are immutable
                    //Result.AddLogEntry("Updated tab permission", other.PermissionKey);
                }
                else
                {
                    var permissionId = DataProvider.Instance().GetPermissionId(other.PermissionCode, other.PermissionKey, other.PermissionName);

                    if (permissionId != null)
                    {
                        var noRole = Convert.ToInt32(Globals.glbRoleNothing);

                        local = new ModulePermissionInfo
                        {
                            ModuleID = localModule.ModuleID,
                            UserID = Null.NullInteger,
                            RoleID = noRole,
                            RoleName = other.RoleName,
                            Username = other.Username,
                            PermissionKey = other.PermissionKey,
                            AllowAccess = other.AllowAccess,
                            PermissionID = permissionId.Value
                        };
                        if (other.UserID != null && other.UserID > 0 && !string.IsNullOrEmpty(other.Username))
                        {
                            var userId = UserController.GetUserByName(_importDto.PortalId, other.Username)?.UserID;
                            if (userId == null)
                                continue;
                            local.UserID = userId.Value;
                        }
                        if (other.RoleID != null && other.RoleID > noRole && !string.IsNullOrEmpty(other.RoleName))
                        {
                            var roleId = Util.GetRoleIdByName(_importDto.PortalId, other.RoleID ?? noRole, other.RoleName);
                            if (roleId == null)
                                continue;
                            local.RoleID = roleId.Value;
                        }

                        other.LocalId = localModule.ModulePermissions.Add(local);
                        var createdBy = Util.GetUserIdByName(_exportImportJob, other.CreatedByUserID, other.CreatedByUserName);
                        var modifiedBy = Util.GetUserIdByName(_exportImportJob, other.LastModifiedByUserID, other.LastModifiedByUserName);
                        UpdateModulePermissionChangers(local.ModulePermissionID, createdBy, modifiedBy);

                        Result.AddLogEntry("Added module permission", $"{other.PermissionKey} - {other.PermissionID}");
                        count++;
                    }
                }
            }

            return count;
        }]]></body>
          </codeblock>
        </method>
        <method name="ImportModuleSettings">
          <declaration><![CDATA[private int ImportModuleSettings(ModuleInfo localModule, ExportModule otherModule, bool isNew)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="812" sc="9" el="859" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="df22ba47c1b2f7befbc9dcd06382dbcc"><![CDATA[{
            var count = 0;
            var moduleSettings = Repository.GetRelatedItems<ExportModuleSetting>(otherModule.Id).ToList();
            foreach (var other in moduleSettings)
            {
                var localValue = isNew ? string.Empty : Convert.ToString(localModule.ModuleSettings[other.SettingName]);
                if (string.IsNullOrEmpty(localValue))
                {
                    _moduleController.UpdateModuleSetting(localModule.ModuleID, other.SettingName, other.SettingValue);
                    var createdBy = Util.GetUserIdByName(_exportImportJob, other.CreatedByUserID, other.CreatedByUserName);
                    var modifiedBy = Util.GetUserIdByName(_exportImportJob, other.LastModifiedByUserID, other.LastModifiedByUserName);
                    _dataProvider.UpdateSettingRecordChangers("ModuleSettings", "ModuleID",
                        localModule.ModuleID, other.SettingName, createdBy, modifiedBy);
                    Result.AddLogEntry("Added module setting", $"{other.SettingName} - {other.ModuleID}");
                    count++;
                }
                else
                {
                    switch (_importDto.CollisionResolution)
                    {
                        case CollisionResolution.Overwrite:
                            if (localValue != other.SettingValue)
                            {
                                // the next will clear the cache
                                _moduleController.UpdateModuleSetting(localModule.ModuleID, other.SettingName, other.SettingValue);
                                var createdBy = Util.GetUserIdByName(_exportImportJob, other.CreatedByUserID, other.CreatedByUserName);
                                var modifiedBy = Util.GetUserIdByName(_exportImportJob, other.LastModifiedByUserID, other.LastModifiedByUserName);
                                _dataProvider.UpdateSettingRecordChangers("ModuleSettings", "ModuleID",
                                    localModule.ModuleID, other.SettingName, createdBy, modifiedBy);
                                Result.AddLogEntry("Updated module setting", $"{other.SettingName} - {other.ModuleID}");
                                count++;
                            }
                            else
                            {
                                goto case CollisionResolution.Ignore;
                            }
                            break;
                        case CollisionResolution.Ignore:
                            Result.AddLogEntry("Ignored module setting", other.SettingName);
                            break;
                        default:
                            throw new ArgumentOutOfRangeException(_importDto.CollisionResolution.ToString());
                    }
                }
            }

            return count;
        }]]></body>
          </codeblock>
        </method>
        <method name="ImportPortableContent">
          <declaration><![CDATA[private int ImportPortableContent(int tabId, ModuleInfo localModule, ExportModule otherModule, bool isNew)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="948" sc="9" el="1026" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="2d7e8c8fcbcf4da6edb7e1af056ad131"><![CDATA[{
            var exportedContent = Repository.FindItems<ExportModuleContent>(m => m.ModuleID == otherModule.ModuleID).ToList();
            if (exportedContent.Count > 0)
            {
                var moduleDef = ModuleDefinitionController.GetModuleDefinitionByID(localModule.ModuleDefID);
                var desktopModuleInfo = DesktopModuleController.GetDesktopModule(moduleDef.DesktopModuleID, _exportDto.PortalId);
                if (!string.IsNullOrEmpty(desktopModuleInfo?.BusinessControllerClass))
                {
                    try
                    {
                        var module = _moduleController.GetModule(localModule.ModuleID, tabId, true);
                        if (!string.IsNullOrEmpty(module.DesktopModule.BusinessControllerClass) && module.DesktopModule.IsPortable)
                        {
                            var businessController = Reflection.CreateObject(module.DesktopModule.BusinessControllerClass, module.DesktopModule.BusinessControllerClass);
                            var controller = businessController as IPortable;
                            if (controller != null)
                            {
                                //Note: there is no chek whether the content exists or not to manage conflict resolution
                                if (isNew || _importDto.CollisionResolution == CollisionResolution.Overwrite)
                                {
                                    var restoreCount = 0;
                                    var version = DotNetNukeContext.Current.Application.Version.ToString(3);

                                    bool tabVersionsEnabled;
                                    bool tabWorkflowEnabled;
                                    DisableVersioning(tabId, out tabVersionsEnabled, out tabWorkflowEnabled);

                                    try
                                    {
                                        foreach (var moduleContent in exportedContent)
                                        {
                                            if (!moduleContent.IsRestored)
                                            {
                                                try
                                                {
                                                    var content = moduleContent.XmlContent;
                                                    if (content.IndexOf('\x03') >= 0)
                                                    {
                                                        // exported data contains this character sometimes
                                                        content = content.Replace('\x03', ' ');
                                                    }

                                                    controller.ImportModule(localModule.ModuleID, content, version, _exportImportJob.CreatedByUserId);
                                                    moduleContent.IsRestored = true;
                                                    Repository.UpdateItem(moduleContent);
                                                    restoreCount++;
                                                }
                                                catch (Exception ex)
                                                {
                                                    Result.AddLogEntry("Error importing module data, Module ID=" + localModule.ModuleID, ex.Message, ReportLevel.Error);
                                                    Logger.ErrorFormat("ModuleContent: (Module ID={0}). Error: {1}{2}{3}",
                                                        localModule.ModuleID, ex, Environment.NewLine, moduleContent.XmlContent);
                                                }
                                            }
                                        }
                                    }
                                    finally
                                    {
                                        RestoreVersioning(tabId, tabVersionsEnabled, tabWorkflowEnabled);
                                    }

                                    if (restoreCount > 0)
                                    {
                                        Result.AddLogEntry("Added/Updated module content inside Tab ID=" + tabId, "Module ID=" + localModule.ModuleID);
                                        return restoreCount;
                                    }
                                }
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Result.AddLogEntry("Error cerating business class type", desktopModuleInfo.BusinessControllerClass, ReportLevel.Error);
                        Logger.Error("Error cerating business class type. " + ex);
                    }
                }
            }
            return 0;
        }]]></body>
          </codeblock>
        </method>
        <method name="ImportTabModulesAndRelatedItems">
          <declaration><![CDATA[private int ImportTabModulesAndRelatedItems(TabInfo localTab, ExportTab otherTab, bool isNew)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="517" sc="9" el="809" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="5276d15ccef159cf3214efd8341185b1"><![CDATA[{
            var count = 0;
            var exportedModules = Repository.GetRelatedItems<ExportModule>(otherTab.Id).ToList();
            var exportedTabModules = Repository.GetRelatedItems<ExportTabModule>(otherTab.Id).ToList();
            var localExportModules = isNew ? new List<ExportModule>()
                : EntitiesController.Instance.GetModules(localTab.TabID, true, Constants.MaxDbTime, null).ToList();
            var localTabModules = isNew ? new List<ModuleInfo>() : _moduleController.GetTabModules(localTab.TabID).Values.ToList();

            var allExistingIds = localTabModules.Select(l => l.ModuleID).ToList();
            var allImportedIds = new List<int>();

            foreach (var other in exportedTabModules)
            {
                var locals = localTabModules.Where(
                    m => m.UniqueId == other.UniqueId ||
                        (m.ModuleDefinition.FriendlyName == other.FriendlyName &&
                        m.PaneName == other.PaneName && m.ModuleOrder == other.ModuleOrder)).ToList();

                var otherModule = exportedModules.FirstOrDefault(m => m.ModuleID == other.ModuleID);
                if (otherModule == null) continue; // must not happen

                var moduleDefinition = ModuleDefinitionController.GetModuleDefinitionByFriendlyName(other.FriendlyName);
                if (moduleDefinition == null)
                {
                    Result.AddLogEntry("Error adding tab module, ModuleDef=" + other.FriendlyName,
                        "The modue definition is not present in the system", ReportLevel.Error);
                    continue; // the module is not installed, therefore ignore it
                }

                var sharedModules = Repository.FindItems<ExportModule>(m => m.ModuleID == other.ModuleID);
                var sharedModule = sharedModules.FirstOrDefault(m => m.LocalId.HasValue);

                if (locals.Count == 0)
                {
                    var local = new ModuleInfo
                    {
                        TabID = localTab.TabID,
                        ModuleID = sharedModule?.LocalId ?? -1,
                        ModuleDefID = moduleDefinition.ModuleDefID,
                        PaneName = other.PaneName,
                        ModuleOrder = other.ModuleOrder,
                        CacheTime = other.CacheTime,
                        Alignment = other.Alignment,
                        Color = other.Color,
                        Border = other.Border,
                        IconFile = other.IconFile,
                        Visibility = (VisibilityState)other.Visibility,
                        ContainerSrc = other.ContainerSrc,
                        DisplayTitle = other.DisplayTitle,
                        DisplayPrint = other.DisplayPrint,
                        DisplaySyndicate = other.DisplaySyndicate,
                        IsWebSlice = other.IsWebSlice,
                        WebSliceTitle = other.WebSliceTitle,
                        WebSliceExpiryDate = other.WebSliceExpiryDate ?? DateTime.MinValue,
                        WebSliceTTL = other.WebSliceTTL ?? -1,
                        IsDeleted = other.IsDeleted,
                        CacheMethod = other.CacheMethod,
                        ModuleTitle = other.ModuleTitle,
                        Header = other.Header,
                        Footer = other.Footer,
                        CultureCode = other.CultureCode,
                        //UniqueId = other.UniqueId,
                        UniqueId = Guid.NewGuid(),
                        VersionGuid = other.VersionGuid,
                        DefaultLanguageGuid = other.DefaultLanguageGuid ?? Guid.Empty,
                        LocalizedVersionGuid = other.LocalizedVersionGuid,
                        InheritViewPermissions = other.InheritViewPermissions,
                        IsShareable = other.IsShareable,
                        IsShareableViewOnly = other.IsShareableViewOnly,
                        PortalID = _exportImportJob.PortalId
                    };

                    //Logger.Error($"Local Tab ID={local.TabID}, ModuleID={local.ModuleID}, ModuleDefID={local.ModuleDefID}");
                    try
                    {
                        //this will create up to 2 records:  Module (if it is not already there) and TabModule
                        otherModule.LocalId = _moduleController.AddModule(local);
                        other.LocalId = local.TabModuleID;
                        Repository.UpdateItem(otherModule);
                        allImportedIds.Add(local.ModuleID);

                        // this is not saved upon adding the module
                        if (other.IsDeleted)
                        {
                            local.IsDeleted = other.IsDeleted;
                            EntitiesController.Instance.SetTabModuleDeleted(local.TabModuleID, true);
                            //_moduleController.UpdateModule(local); // to clear cache
                        }

                        var createdBy = Util.GetUserIdByName(_exportImportJob, other.CreatedByUserID, other.CreatedByUserName);
                        var modifiedBy = Util.GetUserIdByName(_exportImportJob, other.LastModifiedByUserID, other.LastModifiedByUserName);
                        UpdateTabModuleChangers(local.TabModuleID, createdBy, modifiedBy);

                        if (sharedModule == null)
                        {
                            createdBy = Util.GetUserIdByName(_exportImportJob, otherModule.CreatedByUserID, otherModule.CreatedByUserName);
                            modifiedBy = Util.GetUserIdByName(_exportImportJob, otherModule.LastModifiedByUserID, otherModule.LastModifiedByUserName);
                            UpdateModuleChangers(local.ModuleID, createdBy, modifiedBy);

                            _totals.TotalModuleSettings += ImportModuleSettings(local, otherModule, isNew);
                            _totals.TotalModulePermissions += ImportModulePermissions(local, otherModule, isNew);
                            _totals.TotalTabModuleSettings += ImportTabModuleSettings(local, other, isNew);

                            if (_exportDto.IncludeContent)
                            {
                                _totals.TotalContents += ImportPortableContent(localTab.TabID, local, otherModule, isNew);
                            }

                            Result.AddLogEntry("Added module", local.ModuleID.ToString());
                        }

                        Result.AddLogEntry("Added tab module", local.TabModuleID.ToString());
                        count++;
                    }
                    catch (Exception ex)
                    {
                        Result.AddLogEntry("EXCEPTION importing tab module, Module ID=" + local.ModuleID, ex.Message, ReportLevel.Error);
                        Logger.Error(ex);
                    }
                }
                else
                {
                    for (var i = 0; i < locals.Count; i++)
                    {
                        var local = locals.ElementAt(i);

                        try
                        {
                            var localExpModule = localExportModules.FirstOrDefault(
                                m => m.ModuleID == local.ModuleID && m.FriendlyName == local.ModuleDefinition.FriendlyName);
                            if (localExpModule == null)
                            {
                                local = new ModuleInfo
                                {
                                    TabID = localTab.TabID,
                                    ModuleID = sharedModule?.LocalId ?? -1,
                                    ModuleDefID = moduleDefinition.ModuleDefID,
                                    PaneName = other.PaneName,
                                    ModuleOrder = other.ModuleOrder,
                                    CacheTime = other.CacheTime,
                                    Alignment = other.Alignment,
                                    Color = other.Color,
                                    Border = other.Border,
                                    IconFile = other.IconFile,
                                    Visibility = (VisibilityState)other.Visibility,
                                    ContainerSrc = other.ContainerSrc,
                                    DisplayTitle = other.DisplayTitle,
                                    DisplayPrint = other.DisplayPrint,
                                    DisplaySyndicate = other.DisplaySyndicate,
                                    IsWebSlice = other.IsWebSlice,
                                    WebSliceTitle = other.WebSliceTitle,
                                    WebSliceExpiryDate = other.WebSliceExpiryDate ?? DateTime.MinValue,
                                    WebSliceTTL = other.WebSliceTTL ?? -1,
                                    IsDeleted = other.IsDeleted,
                                    CacheMethod = other.CacheMethod,
                                    ModuleTitle = other.ModuleTitle,
                                    Header = other.Header,
                                    Footer = other.Footer,
                                    CultureCode = other.CultureCode,
                                    //UniqueId = other.UniqueId,
                                    UniqueId = Guid.NewGuid(),
                                    VersionGuid = other.VersionGuid,
                                    DefaultLanguageGuid = other.DefaultLanguageGuid ?? Guid.Empty,
                                    LocalizedVersionGuid = other.LocalizedVersionGuid,
                                    InheritViewPermissions = other.InheritViewPermissions,
                                    IsShareable = other.IsShareable,
                                    IsShareableViewOnly = other.IsShareableViewOnly,
                                    PortalID = _exportImportJob.PortalId
                                };

                                //this will create up to 2 records:  Module (if it is not already there) and TabModule
                                otherModule.LocalId = _moduleController.AddModule(local);
                                other.LocalId = local.TabModuleID;
                                Repository.UpdateItem(otherModule);
                                allImportedIds.Add(local.ModuleID);

                                // this is not saved upon adding the module
                                if (other.IsDeleted)
                                {
                                    local.IsDeleted = other.IsDeleted;
                                    EntitiesController.Instance.SetTabModuleDeleted(local.TabModuleID, true);
                                    //_moduleController.UpdateModule(local); // to clear cache
                                }
                            }
                            else
                            {
                                // setting module properties
                                localExpModule.AllTabs = otherModule.AllTabs;
                                localExpModule.StartDate = otherModule.StartDate;
                                localExpModule.EndDate = otherModule.EndDate;
                                localExpModule.InheritViewPermissions = otherModule.InheritViewPermissions;
                                localExpModule.IsDeleted = otherModule.IsDeleted;
                                localExpModule.IsShareable = otherModule.IsShareable;
                                localExpModule.IsShareableViewOnly = otherModule.IsShareableViewOnly;

                                local.AllTabs = otherModule.AllTabs;
                                local.StartDate = otherModule.StartDate ?? DateTime.MinValue;
                                local.EndDate = otherModule.EndDate ?? DateTime.MaxValue;
                                local.InheritViewPermissions = otherModule.InheritViewPermissions ?? true;
                                local.IsDeleted = otherModule.IsDeleted;
                                local.IsShareable = otherModule.IsShareable;
                                local.IsShareableViewOnly = otherModule.IsShareableViewOnly;

                                // setting tab module properties
                                local.AllTabs = otherModule.AllTabs;
                                local.ModuleTitle = other.ModuleTitle;
                                local.Header = other.Header;
                                local.Footer = other.Footer;
                                local.ModuleOrder = other.ModuleOrder;
                                local.PaneName = other.PaneName;
                                local.CacheMethod = other.CacheMethod;
                                local.CacheTime = other.CacheTime;
                                local.Alignment = other.Alignment;
                                local.Color = other.Color;
                                local.Border = other.Border;
                                local.IconFile = other.IconFile;
                                local.Visibility = (VisibilityState)other.Visibility;
                                local.ContainerSrc = other.ContainerSrc;
                                local.DisplayTitle = other.DisplayTitle;
                                local.DisplayPrint = other.DisplayPrint;
                                local.DisplaySyndicate = other.DisplaySyndicate;
                                local.IsDeleted = other.IsDeleted;
                                local.IsShareable = otherModule.IsShareable;
                                local.IsShareableViewOnly = otherModule.IsShareableViewOnly;
                                local.IsWebSlice = other.IsWebSlice;
                                local.WebSliceTitle = other.WebSliceTitle;
                                local.WebSliceExpiryDate = other.WebSliceExpiryDate ?? DateTime.MaxValue;
                                local.WebSliceTTL = other.WebSliceTTL ?? -1;
                                local.VersionGuid = other.VersionGuid;
                                local.DefaultLanguageGuid = other.DefaultLanguageGuid ?? Guid.Empty;
                                local.LocalizedVersionGuid = other.LocalizedVersionGuid;
                                local.CultureCode = other.CultureCode;

                                // this coould cause problem in some cases
                                //if (local.UniqueId != other.UniqueId) local.UniqueId = other.UniqueId;

                                // this is not saved upon updating the module
                                EntitiesController.Instance.SetTabModuleDeleted(local.TabModuleID, other.IsDeleted);

                                // updates both module and tab module db records
                                _moduleController.UpdateModule(local);
                                other.LocalId = local.TabModuleID;
                                otherModule.LocalId = localExpModule.ModuleID;
                                Repository.UpdateItem(otherModule);
                                allImportedIds.Add(local.ModuleID);
                            }

                            var createdBy = Util.GetUserIdByName(_exportImportJob, other.CreatedByUserID, other.CreatedByUserName);
                            var modifiedBy = Util.GetUserIdByName(_exportImportJob, other.LastModifiedByUserID, other.LastModifiedByUserName);
                            UpdateTabModuleChangers(local.TabModuleID, createdBy, modifiedBy);

                            createdBy = Util.GetUserIdByName(_exportImportJob, otherModule.CreatedByUserID, otherModule.CreatedByUserName);
                            modifiedBy = Util.GetUserIdByName(_exportImportJob, otherModule.LastModifiedByUserID, otherModule.LastModifiedByUserName);
                            UpdateModuleChangers(local.ModuleID, createdBy, modifiedBy);

                            _totals.TotalTabModuleSettings += ImportTabModuleSettings(local, other, isNew);

                            _totals.TotalModuleSettings += ImportModuleSettings(local, otherModule, isNew);
                            _totals.TotalModulePermissions += ImportModulePermissions(local, otherModule, isNew);

                            if (_exportDto.IncludeContent)
                            {
                                _totals.TotalContents += ImportPortableContent(localTab.TabID, local, otherModule, isNew);
                            }

                            Result.AddLogEntry("Updated tab module", local.TabModuleID.ToString());
                            Result.AddLogEntry("Updated module", local.ModuleID.ToString());

                            count++;
                        }
                        catch (Exception ex)
                        {
                            Result.AddLogEntry("EXCEPTION importing tab module, Module ID=" + local.ModuleID, ex.Message, ReportLevel.Error);
                            Logger.Error(ex);
                        }
                    }
                }
            }

            if (!isNew && _exportDto.ExportMode == ExportMode.Full &&
                _importDto.CollisionResolution == CollisionResolution.Overwrite)
            {
                // delete left over tab modules for full import in an existing page
                var unimported = allExistingIds.Distinct().Except(allImportedIds);
                foreach (var moduleId in unimported)
                {
                    _moduleController.DeleteTabModule(localTab.TabID, moduleId, false);
                    Result.AddLogEntry("Removed existing tab module", "Module ID=" + moduleId);
                }
            }

            return count;
        }]]></body>
          </codeblock>
        </method>
        <method name="ImportTabModuleSettings">
          <declaration><![CDATA[private int ImportTabModuleSettings(ModuleInfo localTabModule, ExportTabModule otherTabModule, bool isNew)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1049" sc="9" el="1097" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="e61bb9d4558ade244f667c254eecf482"><![CDATA[{
            var count = 0;
            var tabModuleSettings = Repository.GetRelatedItems<ExportTabModuleSetting>(otherTabModule.Id).ToList();
            foreach (var other in tabModuleSettings)
            {
                var localValue = isNew ? "" : Convert.ToString(localTabModule.TabModuleSettings[other.SettingName]);
                if (string.IsNullOrEmpty(localValue))
                {
                    // the next will clear the cache
                    _moduleController.UpdateTabModuleSetting(localTabModule.TabModuleID, other.SettingName, other.SettingValue);
                    var createdBy = Util.GetUserIdByName(_exportImportJob, other.CreatedByUserID, other.CreatedByUserName);
                    var modifiedBy = Util.GetUserIdByName(_exportImportJob, other.LastModifiedByUserID, other.LastModifiedByUserName);
                    _dataProvider.UpdateSettingRecordChangers("TabModuleSettings", "TabModuleID",
                        localTabModule.TabModuleID, other.SettingName, createdBy, modifiedBy);
                    Result.AddLogEntry("Added tab module setting", $"{other.SettingName} - {other.TabModuleID}");
                    count++;
                }
                else
                {
                    switch (_importDto.CollisionResolution)
                    {
                        case CollisionResolution.Overwrite:
                            if (localValue != other.SettingValue)
                            {
                                // the next will clear the cache
                                _moduleController.UpdateTabModuleSetting(localTabModule.TabModuleID, other.SettingName, other.SettingValue);
                                var createdBy = Util.GetUserIdByName(_exportImportJob, other.CreatedByUserID, other.CreatedByUserName);
                                var modifiedBy = Util.GetUserIdByName(_exportImportJob, other.LastModifiedByUserID, other.LastModifiedByUserName);
                                _dataProvider.UpdateSettingRecordChangers("TabModuleSettings", "TabModuleID",
                                    localTabModule.TabModuleID, other.SettingName, createdBy, modifiedBy);
                                Result.AddLogEntry("Updated tab module setting", $"{other.SettingName} - {other.TabModuleID}");
                                count++;
                            }
                            else
                            {
                                goto case CollisionResolution.Ignore;
                            }
                            break;
                        case CollisionResolution.Ignore:
                            Result.AddLogEntry("Ignored module setting", other.SettingName);
                            break;
                        default:
                            throw new ArgumentOutOfRangeException(_importDto.CollisionResolution.ToString());
                    }
                }
            }

            return count;
        }]]></body>
          </codeblock>
        </method>
        <method name="ImportTabPermissions">
          <declaration><![CDATA[private int ImportTabPermissions(TabInfo localTab, ExportTab otherTab, bool isNew)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="348" sc="9" el="445" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="e0a7f07dddf860a9b8342c0f8019547e"><![CDATA[{
            if (!_exportDto.IncludePermissions) return 0;

            var count = 0;
            var tabPermissions = Repository.GetRelatedItems<ExportTabPermission>(otherTab.Id).ToList();
            var localTabPermissions = localTab.TabPermissions.OfType<TabPermissionInfo>().ToList();
            foreach (var other in tabPermissions)
            {
                var local = isNew ? null : localTabPermissions.FirstOrDefault(
                    x => x.PermissionCode == other.PermissionCode &&
                         x.PermissionKey == other.PermissionKey &&
                         x.PermissionName == other.PermissionName &&
                        (x.RoleName == other.RoleName || (string.IsNullOrEmpty(x.RoleName) && string.IsNullOrEmpty(other.RoleName))) &&
                    (x.Username == other.Username || (string.IsNullOrEmpty(x.Username) && string.IsNullOrEmpty(other.Username))));
                var isUpdate = false;
                if (local != null)
                {
                    switch (_importDto.CollisionResolution)
                    {
                        case CollisionResolution.Overwrite:
                            isUpdate = true;
                            break;
                        case CollisionResolution.Ignore:
                            Result.AddLogEntry("Ignored tab permission", other.PermissionKey);
                            break;
                        default:
                            throw new ArgumentOutOfRangeException(_importDto.CollisionResolution.ToString());
                    }
                }

                if (isUpdate)
                {
                    //UNDONE: Do we really need to update an existing permission? It won't do anything; permissions are immutable
                    //Result.AddLogEntry("Updated tab permission", other.PermissionKey);
                }
                else
                {
                    var permissionId = DataProvider.Instance().GetPermissionId(other.PermissionCode, other.PermissionKey, other.PermissionName);
                    if (permissionId != null)
                    {
                        var noRole = Convert.ToInt32(Globals.glbRoleNothing);
                        local = new TabPermissionInfo
                        {
                            TabID = localTab.TabID,
                            UserID = Null.NullInteger,
                            RoleID = noRole,
                            Username = other.Username,
                            RoleName = other.RoleName,
                            ModuleDefID = Util.GeModuleDefIdByFriendltName(other.FriendlyName) ?? -1,
                            PermissionKey = other.PermissionKey,
                            AllowAccess = other.AllowAccess,
                            PermissionID = permissionId.Value
                        };
                        if (other.UserID != null && other.UserID > 0 && !string.IsNullOrEmpty(other.Username))
                        {
                            var userId = UserController.GetUserByName(_importDto.PortalId, other.Username)?.UserID;
                            if (userId == null)
                            {
                                Result.AddLogEntry("Couldn't add tab permission; User is undefined!",
                                    $"{other.PermissionKey} - {other.PermissionID}", ReportLevel.Warn);
                                continue;
                            }
                            local.UserID = userId.Value;
                        }
                        if (other.RoleID != null && other.RoleID > noRole && !string.IsNullOrEmpty(other.RoleName))
                        {
                            var roleId = Util.GetRoleIdByName(_importDto.PortalId, other.RoleID ?? noRole, other.RoleName);
                            if (roleId == null)
                            {
                                Result.AddLogEntry("Couldn't add tab permission; Role is undefined!",
                                    $"{other.PermissionKey} - {other.PermissionID}", ReportLevel.Warn);
                                continue;
                            }
                            local.RoleID = roleId.Value;
                        }
                        localTab.TabPermissions.Add(local, true);
                        //UNDONE: none set; not possible until after saving all tab permissions as donbefore exiting this method
                        //var createdBy = Util.GetUserIdByName(_exportImportJob, other.CreatedByUserID, other.CreatedByUserName);
                        //var modifiedBy = Util.GetUserIdByName(_exportImportJob, other.LastModifiedByUserID, other.LastModifiedByUserName);
                        //UpdateTabPermissionChangers(local.TabPermissionID, createdBy, modifiedBy);
                        Result.AddLogEntry("Added tab permission", $"{other.PermissionKey} - {other.PermissionID}");
                        count++;
                    }
                    else
                    {
                        Result.AddLogEntry("Couldn't add tab permission; Permission is undefined!",
                            $"{other.PermissionKey} - {other.PermissionID}", ReportLevel.Warn);
                    }
                }
            }

            if (count > 0)
            {
                TabPermissionController.SaveTabPermissions(localTab);
            }

            return count;
        }]]></body>
          </codeblock>
        </method>
        <method name="ImportTabSettings">
          <declaration><![CDATA[private int ImportTabSettings(TabInfo localTab, ExportTab otherTab, bool isNew)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="301" sc="9" el="345" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="f63bab0ea12d458b5b427662c31b76fa"><![CDATA[{
            var tabSettings = Repository.GetRelatedItems<ExportTabSetting>(otherTab.Id).ToList();
            foreach (var other in tabSettings)
            {
                var localValue = isNew ? string.Empty : Convert.ToString(localTab.TabSettings[other.SettingName]);
                if (string.IsNullOrEmpty(localValue))
                {
                    _tabController.UpdateTabSetting(localTab.TabID, other.SettingName, other.SettingValue);
                    var createdBy = Util.GetUserIdByName(_exportImportJob, other.CreatedByUserID, other.CreatedByUserName);
                    var modifiedBy = Util.GetUserIdByName(_exportImportJob, other.LastModifiedByUserID, other.LastModifiedByUserName);
                    _dataProvider.UpdateSettingRecordChangers("TabSettings", "TabID",
                        localTab.TabID, other.SettingName, createdBy, modifiedBy);
                    Result.AddLogEntry("Added tab setting", $"{other.SettingName} - {other.TabID}");
                }
                else
                {
                    switch (_importDto.CollisionResolution)
                    {
                        case CollisionResolution.Overwrite:
                            if (localValue != other.SettingValue)
                            {
                                // the next will clear the cache
                                _tabController.UpdateTabSetting(localTab.TabID, other.SettingName, other.SettingValue);
                                var createdBy = Util.GetUserIdByName(_exportImportJob, other.CreatedByUserID, other.CreatedByUserName);
                                var modifiedBy = Util.GetUserIdByName(_exportImportJob, other.LastModifiedByUserID, other.LastModifiedByUserName);
                                _dataProvider.UpdateSettingRecordChangers("TabSettings", "TabID",
                                    localTab.TabID, other.SettingName, createdBy, modifiedBy);
                                Result.AddLogEntry("Updated tab setting", $"{other.SettingName} - {other.TabID}");
                            }
                            else
                            {
                                goto case CollisionResolution.Ignore;
                            }
                            break;
                        case CollisionResolution.Ignore:
                            Result.AddLogEntry("Ignored tab setting", other.SettingName);
                            break;
                        default:
                            throw new ArgumentOutOfRangeException(_importDto.CollisionResolution.ToString());
                    }
                }
            }

            return tabSettings.Count;
        }]]></body>
          </codeblock>
        </method>
        <method name="ImportTabUrls">
          <declaration><![CDATA[private int ImportTabUrls(TabInfo localTab, ExportTab otherTab, bool isNew)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="448" sc="9" el="514" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="7348ee1c490211afb1b423c158f661b6"><![CDATA[{
            var count = 0;
            var tabUrls = Repository.GetRelatedItems<ExportTabUrl>(otherTab.Id).ToList();
            var localUrls = localTab.TabUrls;
            foreach (var other in tabUrls)
            {
                var local = isNew ? null : localUrls.FirstOrDefault(url => url.SeqNum == other.SeqNum);
                if (local != null)
                {
                    switch (_importDto.CollisionResolution)
                    {
                        case CollisionResolution.Overwrite:
                            try
                            {
                                local.Url = other.Url;
                                TabController.Instance.SaveTabUrl(local, _importDto.PortalId, true);
                                Result.AddLogEntry("Update Tab Url", other.Url);
                                count++;
                            }
                            catch (Exception ex)
                            {
                                Result.AddLogEntry("EXCEPTION updating tab, Tab ID=" + local.TabId, ex.Message, ReportLevel.Error);
                            }
                            break;
                        case CollisionResolution.Ignore:
                            Result.AddLogEntry("Ignored tab url", other.Url);
                            break;
                        default:
                            throw new ArgumentOutOfRangeException(_importDto.CollisionResolution.ToString());
                    }
                }
                else
                {
                    var alias = PortalAliasController.Instance.GetPortalAliasesByPortalId(_importDto.PortalId).FirstOrDefault(a => a.IsPrimary);
                    local = new TabUrlInfo
                    {
                        TabId = localTab.TabID,
                        CultureCode = other.CultureCode,
                        HttpStatus = other.HttpStatus,
                        IsSystem = other.IsSystem,
                        PortalAliasId = alias?.PortalAliasID ?? -1,
                        PortalAliasUsage = (PortalAliasUsageType)(other.PortalAliasUsage ?? 0), // reset to default
                        QueryString = other.QueryString,
                        SeqNum = other.SeqNum,
                        Url = other.Url,
                    };

                    try
                    {
                        TabController.Instance.SaveTabUrl(local, _importDto.PortalId, true);

                        var createdBy = Util.GetUserIdByName(_exportImportJob, other.CreatedByUserID, other.CreatedByUserName);
                        var modifiedBy = Util.GetUserIdByName(_exportImportJob, other.LastModifiedByUserID, other.LastModifiedByUserName);
                        _dataProvider.UpdateTabUrlChangers(local.TabId, local.SeqNum, createdBy, modifiedBy);

                        Result.AddLogEntry("Added Tab Url", other.Url);
                        count++;
                    }
                    catch (Exception ex)
                    {
                        Result.AddLogEntry("EXCEPTION adding tab, Tab ID=" + local.TabId, ex.Message, ReportLevel.Error);
                    }
                }
            }

            return count;
        }]]></body>
          </codeblock>
        </method>
        <method name="IsTabIncluded">
          <declaration><![CDATA[private static bool IsTabIncluded(ExportTabInfo tab, IList<ExportTabInfo> allTabs, PageToExport[] selectedPages)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1514" sc="9" el="1540" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="6a9ebc5aa57f88be35e77fcaca9899c3"><![CDATA[{
            var first = true;
            do
            {
                var pg = selectedPages.FirstOrDefault(p => p.TabId == tab.TabID);
                if (pg != null)
                {
                    // this is the current page or a parent page for the one we are checking for.
                    if (pg.CheckedState == TriCheckedState.UnChecked)
                        return false;

                    // this is the current page or a parent page for the one we are checking for.
                    // it must be fully checked
                    if (pg.CheckedState == TriCheckedState.Checked)
                        return true;

                    // this is the current page we are checking for and it is partially checked.
                    if (first)
                        return true;
                }

                first = false;
                tab = allTabs.FirstOrDefault(t => t.TabID == tab.ParentID);
            } while (tab != null);

            return false;
        }]]></body>
          </codeblock>
        </method>
        <method name="IsTabPublished">
          <declaration><![CDATA[private bool IsTabPublished(TabInfo tab)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1613" sc="9" el="1621" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="e26eb7134ec902de6e61e06804bd3a63"><![CDATA[{
            var stateId = tab.StateID;
            if (stateId <= 0) return true;
            var state = WorkflowStateManager.Instance.GetWorkflowState(stateId);
            if (state == null) return true;
            var workflow = WorkflowManager.Instance.GetWorkflow(state.WorkflowID);
            if (workflow == null) return true;
            return workflow.LastState.StateID == stateId;
        }]]></body>
          </codeblock>
        </method>
        <method name="ProcessExportPages">
          <declaration><![CDATA[private void ProcessExportPages()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1221" sc="9" el="1290" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="b048901d99da43b635b3dc02774b1e17"><![CDATA[{
            var selectedPages = _exportDto.Pages;
            _totals = string.IsNullOrEmpty(CheckPoint.StageData)
                ? new ProgressTotals()
                : JsonConvert.DeserializeObject<ProgressTotals>(CheckPoint.StageData);

            var portalId = _exportImportJob.PortalId;

            var toDate = _exportImportJob.CreatedOnDate.ToLocalTime();
            var fromDate = (_exportDto.FromDateUtc ?? Constants.MinDbTime).ToLocalTime();
            var isAllIncluded =
                selectedPages.Any(p => p.TabId == -1 && p.CheckedState == TriCheckedState.Checked);

            var allTabs = EntitiesController.Instance.GetPortalTabs(portalId,
                    _exportDto.IncludeDeletions, IncludeSystem, toDate, fromDate) // ordered by TabID
                .OrderBy(tab => tab.TabPath).ToArray();

            //Update the total items count in the check points. This should be updated only once.
            CheckPoint.TotalItems = CheckPoint.TotalItems <= 0 ? allTabs.Length : CheckPoint.TotalItems;
            if (CheckPointStageCallback(this)) return;
            var progressStep = 100.0 / allTabs.Length;

            CheckPoint.TotalItems = IncludeSystem || isAllIncluded
                ? allTabs.Length
                : allTabs.Count(otherPg => IsTabIncluded(otherPg, allTabs, selectedPages));

            //Note: We assume no new tabs were added while running; otherwise, some tabs might get skipped.
            for (var index = 0; index < allTabs.Length; index++)
            {
                if (CheckCancelled(_exportImportJob)) break;

                var otherPg = allTabs.ElementAt(index);
                if (_totals.LastProcessedId > index) continue;

                if (IncludeSystem || isAllIncluded || IsTabIncluded(otherPg, allTabs, selectedPages))
                {
                    var tab = _tabController.GetTab(otherPg.TabID, portalId);
                    var exportPage = SaveExportPage(tab);

                    _totals.TotalTabSettings +=
                        ExportTabSettings(exportPage, toDate, fromDate);

                    _totals.TotalTabPermissions +=
                        ExportTabPermissions(exportPage, toDate, fromDate);

                    _totals.TotalTabUrls +=
                        ExportTabUrls(exportPage, toDate, fromDate);

                    _totals.TotalModules +=
                        ExportTabModulesAndRelatedItems(exportPage, toDate, fromDate);

                    _totals.TotalTabModules +=
                        ExportTabModules(exportPage, _exportDto.IncludeDeletions, toDate, fromDate);

                    _totals.TotalTabModuleSettings +=
                        ExportTabModuleSettings(exportPage, toDate, fromDate);

                    _totals.TotalTabs++;
                    _totals.LastProcessedId = index;
                }

                CheckPoint.Progress += progressStep;
                CheckPoint.ProcessedItems++;
                CheckPoint.StageData = JsonConvert.SerializeObject(_totals);
                if (CheckPointStageCallback(this)) break;
            }

            ReportExportTotals();
            UpdateTotalProcessedPackages();
        }]]></body>
          </codeblock>
        </method>
        <method name="ProcessImportPage">
          <declaration><![CDATA[protected virtual void ProcessImportPage(ExportTab otherTab, IList<ExportTab> exportedTabs, IList<TabInfo> localTabs)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="174" sc="9" el="268" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="4213f79f40e489099ef70d6acfa88110"><![CDATA[{
            var portalId = _exportImportJob.PortalId;
            var createdBy = Util.GetUserIdByName(_exportImportJob, otherTab.CreatedByUserID, otherTab.CreatedByUserName);
            var modifiedBy = Util.GetUserIdByName(_exportImportJob, otherTab.LastModifiedByUserID, otherTab.LastModifiedByUserName);
            var localTab = localTabs.FirstOrDefault(t =>
                otherTab.TabPath.Equals(t.TabPath, StringComparison.InvariantCultureIgnoreCase)
                && (t.CultureCode ?? "") == (otherTab.CultureCode ?? ""));

            if (localTab != null)
            {
                localTab.TabSettings.Remove("TabImported");
                otherTab.LocalId = localTab.TabID;
                switch (_importDto.CollisionResolution)
                {
                    case CollisionResolution.Ignore:
                        Result.AddLogEntry("Ignored Tab", $"{otherTab.TabName} ({otherTab.TabPath})");
                        break;
                    case CollisionResolution.Overwrite:
                        if (!IsTabPublished(localTab)) return;
                        SetTabData(localTab, otherTab);
                        localTab.StateID = GetLocalStateId(otherTab.StateID);
                        var parentId = IgnoreParentMatch ? otherTab.ParentId.GetValueOrDefault(Null.NullInteger) : TryFindLocalParentTabId(otherTab, exportedTabs, localTabs);
                        if (parentId == -1 && otherTab.ParentId > 0)
                        {
                            Result.AddLogEntry("Importing existing tab skipped as its parent was not found", $"{otherTab.TabName} ({otherTab.TabPath})", ReportLevel.Warn);
                            return;
                        }

                        // this is not saved when adding the tab; so set it explicitly
                        localTab.IsDeleted = otherTab.IsDeleted;
                        localTab.IsVisible = otherTab.IsVisible;
                        EntitiesController.Instance.SetTabSpecificData(localTab.TabID, localTab.IsDeleted, localTab.IsVisible);

                        try
                        {
                            localTab.TabPermissions.Clear(); // without this the UpdateTab() could fail
                            localTab.ParentId = parentId;
                            _tabController.UpdateTab(localTab);
                        }
                        catch (Exception ex)
                        {
                            Result.AddLogEntry($"Importing tab '{otherTab.TabName}' exception", ex.Message, ReportLevel.Error);
                            return;
                        }

                        UpdateTabChangers(localTab.TabID, createdBy, modifiedBy);
                        AddTabRelatedItems(localTab, otherTab, false);
                        TriggerImportEvent(localTab);
                        Result.AddLogEntry("Updated Tab", $"{otherTab.TabName} ({otherTab.TabPath})");
                        _totals.TotalTabs++;
                        break;
                    default:
                        throw new ArgumentOutOfRangeException(_importDto.CollisionResolution.ToString());
                }
            }
            else
            {
                localTab = new TabInfo { PortalID = portalId };
                SetTabData(localTab, otherTab);
                localTab.StateID = GetLocalStateId(otherTab.StateID);
                var parentId = IgnoreParentMatch ? otherTab.ParentId.GetValueOrDefault(Null.NullInteger) : TryFindLocalParentTabId(otherTab, exportedTabs, localTabs);
                if (parentId == -1 && otherTab.ParentId > 0)
                {
                    Result.AddLogEntry("Importing new tab skipped as its parent was not found", $"{otherTab.TabName} ({otherTab.TabPath})", ReportLevel.Warn);
                    return;
                }

                try
                {
                    localTab.ParentId = parentId;
                    localTab.UniqueId = Guid.NewGuid();
                    otherTab.LocalId = _tabController.AddTab(localTab);
                    localTabs.Add(localTab);
                }
                catch (Exception ex)
                {
                    Result.AddLogEntry($"Importing tab '{otherTab.TabName}' exception", ex.Message, ReportLevel.Error);
                    return;
                }

                UpdateTabChangers(localTab.TabID, createdBy, modifiedBy);

                // this is not saved upon updating the tab
                localTab.IsDeleted = otherTab.IsDeleted;
                localTab.IsVisible = otherTab.IsVisible;
                EntitiesController.Instance.SetTabSpecificData(localTab.TabID, localTab.IsDeleted, localTab.IsVisible);
                //_tabController.UpdateTab(localTab); // to clear cache

                Result.AddLogEntry("Added Tab", $"{otherTab.TabName} ({otherTab.TabPath})");
                _totals.TotalTabs++;
                AddTabRelatedItems(localTab, otherTab, true);

                TriggerImportEvent(localTab);
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="ProcessImportPages">
          <declaration><![CDATA[private void ProcessImportPages()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="139" sc="9" el="171" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="a892458fe4d103f03a89aee408a5b4cb"><![CDATA[{
            _dataProvider = DataProvider.Instance();
            _totals = string.IsNullOrEmpty(CheckPoint.StageData)
                ? new ProgressTotals()
                : JsonConvert.DeserializeObject<ProgressTotals>(CheckPoint.StageData);

            var portalId = _exportImportJob.PortalId;

            var localTabs = _tabController.GetTabsByPortal(portalId).Values.ToList();

            var exportedTabs = Repository.GetItems<ExportTab>(x => x.IsSystem == (Category == Constants.Category_Templates)).ToList(); // ordered by TabID
            //Update the total items count in the check points. This should be updated only once.
            CheckPoint.TotalItems = CheckPoint.TotalItems <= 0 ? exportedTabs.Count : CheckPoint.TotalItems;
            if (CheckPointStageCallback(this)) return;
            var progressStep = 100.0 / exportedTabs.OrderByDescending(x => x.Id).Count(x => x.Id < _totals.LastProcessedId);

            foreach (var otherTab in exportedTabs)
            {
                if (CheckCancelled(_exportImportJob)) break;
                if (_totals.LastProcessedId > otherTab.Id) continue; // this is the exported DB row ID; not the TabID

                ProcessImportPage(otherTab, exportedTabs, localTabs);

                CheckPoint.ProcessedItems++;
                CheckPoint.Progress += progressStep;
                if (CheckPointStageCallback(this)) break;

                _totals.LastProcessedId = otherTab.Id;
                CheckPoint.StageData = JsonConvert.SerializeObject(_totals);
            }

            ReportImportTotals();
        }]]></body>
          </codeblock>
        </method>
        <method name="ReportExportTotals">
          <declaration><![CDATA[private void ReportExportTotals()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1563" sc="9" el="1565" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="1f29bdb65e396e0debe8c6353dc7b2eb"><![CDATA[{
            ReportTotals("Exported");
        }]]></body>
          </codeblock>
        </method>
        <method name="ReportImportTotals">
          <declaration><![CDATA[private void ReportImportTotals()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1568" sc="9" el="1570" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="26e74a1efb445c03354d35b5844f8ba3"><![CDATA[{
            ReportTotals("Imported");
        }]]></body>
          </codeblock>
        </method>
        <method name="ReportTotals">
          <declaration><![CDATA[private void ReportTotals(string prefix)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1573" sc="9" el="1584" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="830e7cda331bad92b19084df1cb172ad"><![CDATA[{
            Result.AddSummary(prefix + " Tabs", _totals.TotalTabs.ToString());
            Result.AddLogEntry(prefix + " Tab Settings", _totals.TotalTabSettings.ToString());
            Result.AddLogEntry(prefix + " Tab Permissions", _totals.TotalTabPermissions.ToString());
            Result.AddLogEntry(prefix + " Tab Urls", _totals.TotalTabUrls.ToString());
            Result.AddLogEntry(prefix + " Modules", _totals.TotalModules.ToString());
            Result.AddLogEntry(prefix + " Module Settings", _totals.TotalModuleSettings.ToString());
            Result.AddLogEntry(prefix + " Module Permissions", _totals.TotalModulePermissions.ToString());
            Result.AddLogEntry(prefix + " Tab Modules", _totals.TotalTabModules.ToString());
            Result.AddLogEntry(prefix + " Tab Module Settings", _totals.TotalTabModuleSettings.ToString());
            Result.AddLogEntry(prefix + " Module Packages", _totals.TotalPackages.ToString());
        }]]></body>
          </codeblock>
        </method>
        <method name="ResetContentsFlag">
          <declaration><![CDATA[public static void ResetContentsFlag(ExportImportRepository repository)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1543" sc="9" el="1560" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="30ef991468b5f6e55bbcd12c170f3b0f"><![CDATA[{
            // reset restored flag; if it same extracted db is reused, then content will be restored
            var toSkip = 0;
            const int batchSize = 100;
            var totalCount = repository.GetCount<ExportModuleContent>();
            while (totalCount > 0)
            {
                var items = repository.GetAllItems<ExportModuleContent>(skip: toSkip, max: batchSize)
                    .Where(item => item.IsRestored).ToList();
                if (items.Count > 0)
                {
                    items.ForEach(item => item.IsRestored = false);
                    repository.UpdateItems(items);
                }
                toSkip += batchSize;
                totalCount -= batchSize;
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="RestoreVersioning">
          <declaration><![CDATA[private void RestoreVersioning(int tabId, bool tabVersionsEnabled, bool tabWorkflowEnabled)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1041" sc="9" el="1046" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="bc45b9c06b88d483c80dc662b5b5d26b"><![CDATA[{
            var portalId = _importDto.PortalId;
            TabVersionSettings.Instance.SetEnabledVersioningForPortal(portalId, tabVersionsEnabled);
            TabVersionSettings.Instance.SetEnabledVersioningForTab(tabId, tabVersionsEnabled);
            TabWorkflowSettings.Instance.SetWorkflowEnabled(portalId, tabId, tabWorkflowEnabled);
        }]]></body>
          </codeblock>
        </method>
        <method name="SaveExportPage">
          <declaration><![CDATA[private ExportTab SaveExportPage(TabInfo tab)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1463" sc="9" el="1507" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="3e30f0b736973bcf293377eb84576b01"><![CDATA[{
            var exportPage = new ExportTab
            {
                TabId = tab.TabID,
                TabOrder = tab.TabOrder,
                TabName = tab.TabName,
                IsVisible = tab.IsVisible,
                ParentId = tab.ParentId <= 0 ? null : (int?)tab.ParentId,
                IconFile = tab.IconFile,
                DisableLink = tab.DisableLink,
                Title = tab.Title,
                Description = tab.Description,
                KeyWords = tab.KeyWords,
                IsDeleted = tab.IsDeleted,
                Url = tab.Url,
                SkinSrc = tab.SkinSrc,
                ContainerSrc = tab.ContainerSrc,
                StartDate = tab.StartDate == DateTime.MinValue ? null : (DateTime?)tab.StartDate,
                EndDate = tab.EndDate == DateTime.MinValue ? null : (DateTime?)tab.EndDate,
                RefreshInterval = tab.RefreshInterval <= 0 ? null : (int?)tab.RefreshInterval,
                PageHeadText = tab.PageHeadText,
                IsSecure = tab.IsSecure,
                PermanentRedirect = tab.PermanentRedirect,
                SiteMapPriority = tab.SiteMapPriority,
                CreatedByUserID = tab.CreatedByUserID <= 0 ? null : (int?)tab.CreatedByUserID,
                CreatedOnDate = tab.CreatedOnDate == DateTime.MinValue ? null : (DateTime?)tab.CreatedOnDate,
                LastModifiedByUserID = tab.LastModifiedByUserID <= 0 ? null : (int?)tab.LastModifiedByUserID,
                LastModifiedOnDate = tab.LastModifiedOnDate == DateTime.MinValue ? null : (DateTime?)tab.LastModifiedOnDate,
                IconFileLarge = tab.IconFileLarge,
                CultureCode = tab.CultureCode,
                ContentItemID = tab.ContentItemId < 0 ? null : (int?)tab.ContentItemId,
                UniqueId = Guid.NewGuid(), //tab.UniqueId,
                VersionGuid = tab.VersionGuid,
                DefaultLanguageGuid = tab.DefaultLanguageGuid == Guid.Empty ? null : (Guid?)tab.DefaultLanguageGuid,
                LocalizedVersionGuid = tab.LocalizedVersionGuid,
                Level = tab.Level,
                TabPath = tab.TabPath,
                HasBeenPublished = tab.HasBeenPublished,
                IsSystem = tab.IsSystem,
                StateID = tab.StateID,
            };
            Repository.CreateItem(exportPage, null);
            Result.AddLogEntry("Exported page", tab.TabName + " (" + tab.TabPath + ")");
            return exportPage;
        }]]></body>
          </codeblock>
        </method>
        <method name="SetTabData">
          <declaration><![CDATA[private static void SetTabData(TabInfo localTab, ExportTab otherTab)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1133" sc="9" el="1164" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="0615019979e68488666ddbbfe29464ee"><![CDATA[{
            localTab.TabOrder = otherTab.TabOrder;
            localTab.TabName = otherTab.TabName;
            localTab.IsVisible = otherTab.IsVisible;
            localTab.IconFile = otherTab.IconFile;
            localTab.DisableLink = otherTab.DisableLink;
            localTab.Title = otherTab.Title;
            localTab.Description = otherTab.Description;
            localTab.KeyWords = otherTab.KeyWords;
            //localTab.IsDeleted = otherTab.IsDeleted; // DO NOT enable this; leave this to other logic
            localTab.Url = otherTab.Url;
            localTab.SkinSrc = otherTab.SkinSrc;
            localTab.ContainerSrc = otherTab.ContainerSrc;
            localTab.StartDate = otherTab.StartDate ?? DateTime.MinValue;
            localTab.EndDate = otherTab.EndDate ?? DateTime.MinValue;
            localTab.RefreshInterval = otherTab.RefreshInterval ?? -1;
            localTab.PageHeadText = otherTab.PageHeadText;
            localTab.IsSecure = otherTab.IsSecure;
            localTab.PermanentRedirect = otherTab.PermanentRedirect;
            localTab.SiteMapPriority = otherTab.SiteMapPriority;
            localTab.IconFileLarge = otherTab.IconFileLarge;
            localTab.CultureCode = otherTab.CultureCode;
            //TODO: check if these GUIDs need changing
            //localTab.UniqueId = otherTab.UniqueId;
            localTab.VersionGuid = otherTab.VersionGuid;
            localTab.DefaultLanguageGuid = otherTab.DefaultLanguageGuid ?? Guid.Empty;
            localTab.LocalizedVersionGuid = otherTab.LocalizedVersionGuid;
            localTab.Level = otherTab.Level;
            localTab.TabPath = otherTab.TabPath;
            localTab.HasBeenPublished = otherTab.HasBeenPublished;
            localTab.IsSystem = otherTab.IsSystem;
        }]]></body>
          </codeblock>
        </method>
        <method name="TriggerImportEvent">
          <declaration><![CDATA[private void TriggerImportEvent(TabInfo localTab)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="271" sc="9" el="290" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="aa013e41974dbacc437184896471a55c"><![CDATA[{
            try
            {
                //update tab with import flag, to trigger update event handler.
                if (localTab.TabSettings.ContainsKey("TabImported"))
                {
                    localTab.TabSettings["TabImported"] = "Y";
                }
                else
                {
                    localTab.TabSettings.Add("TabImported", "Y");
                }
                _tabController.UpdateTab(localTab);
                TabController.Instance.DeleteTabSetting(localTab.TabID, "TabImported");
            }
            catch (Exception ex)
            {
                TabController.Instance.DeleteTabSetting(localTab.TabID, "TabImported");
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="TryFindLocalParentTabId">
          <declaration><![CDATA[private static int TryFindLocalParentTabId(ExportTab exportedTab, IEnumerable<ExportTab> exportedTabs, IEnumerable<TabInfo> localTabs)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1100" sc="9" el="1130" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="2c0e23d128b6e461fb5fe21ebd8e79b5"><![CDATA[{
            var otherParentId = exportedTab.ParentId;
            if (otherParentId.HasValue && otherParentId.Value > 0)
            {
                var otherParent = exportedTabs.FirstOrDefault(t => t.TabId == otherParentId);
                if (otherParent != null)
                {
                    if (otherParent.LocalId.HasValue)
                    {
                        var localTab = localTabs.FirstOrDefault(t => t.TabID == otherParent.LocalId);
                        if (localTab != null)
                            return localTab.TabID;
                    }
                }
                else if (exportedTab.TabPath.HasValue())
                {
                    var index = exportedTab.TabPath.LastIndexOf(@"//", StringComparison.Ordinal);
                    if (index > 0)
                    {
                        var path = exportedTab.TabPath.Substring(0, index);
                        var localTab = localTabs.FirstOrDefault(t =>
                            path.Equals(t.TabPath, StringComparison.InvariantCultureIgnoreCase)
                            && (t.CultureCode ?? "") == (exportedTab.CultureCode ?? ""));
                        if (localTab != null)
                            return localTab.TabID;
                    }
                }
            }

            return -1;
        }]]></body>
          </codeblock>
        </method>
        <method name="UpdateModuleChangers">
          <declaration><![CDATA[private void UpdateModuleChangers(int moduleId, int createdBy, int modifiedBy)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1200" sc="9" el="1202" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="7b82cf8a1b2e9ebd6a3957331d1f2077"><![CDATA[{
            _dataProvider.UpdateRecordChangers("Modules", "ModuleID", moduleId, createdBy, modifiedBy);
        }]]></body>
          </codeblock>
        </method>
        <method name="UpdateModulePermissionChangers">
          <declaration><![CDATA[private void UpdateModulePermissionChangers(int modulePermissionId, int createdBy, int modifiedBy)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1205" sc="9" el="1207" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="185df9182d8653e0647295f043ecbee5"><![CDATA[{
            _dataProvider.UpdateRecordChangers("ModulePermission", "ModulePermissionID", modulePermissionId, createdBy, modifiedBy);
        }]]></body>
          </codeblock>
        </method>
        <method name="UpdateModuleSettingsChangers">
          <declaration><![CDATA[private void UpdateModuleSettingsChangers(int moduleId, string settingName, int createdBy, int modifiedBy)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1210" sc="9" el="1212" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="0d6e549dfd38673ac49b59c63ca24a2a"><![CDATA[{
            _dataProvider.UpdateSettingRecordChangers("ModuleSettings", "ModuleID", moduleId, settingName, createdBy, modifiedBy);
        }]]></body>
          </codeblock>
        </method>
        <method name="UpdateTabChangers">
          <declaration><![CDATA[private void UpdateTabChangers(int tabId, int createdBy, int modifiedBy)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1169" sc="9" el="1171" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="5519fcfa3841e4f4d79b5be0998635e0"><![CDATA[{
            _dataProvider.UpdateRecordChangers("Tabs", "TabID", tabId, createdBy, modifiedBy);
        }]]></body>
          </codeblock>
        </method>
        <method name="UpdateTabModuleChangers">
          <declaration><![CDATA[private void UpdateTabModuleChangers(int tabModuleId, int createdBy, int modifiedBy)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1190" sc="9" el="1192" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="f28a49ed420011139fed577e797d7ab4"><![CDATA[{
            _dataProvider.UpdateRecordChangers("TabModules", "TabModuleID", tabModuleId, createdBy, modifiedBy);
        }]]></body>
          </codeblock>
        </method>
        <method name="UpdateTabModuleSettingsChangers">
          <declaration><![CDATA[private void UpdateTabModuleSettingsChangers(int tabModuleId, string settingName, int createdBy, int modifiedBy)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1195" sc="9" el="1197" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="5193a39ad1a260ad9acd6ca58659e3a5"><![CDATA[{
            _dataProvider.UpdateSettingRecordChangers("TabModuleSettings", "TabModuleID", tabModuleId, settingName, createdBy, modifiedBy);
        }]]></body>
          </codeblock>
        </method>
        <method name="UpdateTabPermissionChangers">
          <declaration><![CDATA[private void UpdateTabPermissionChangers(int tabPermissionId, int createdBy, int modifiedBy)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1175" sc="9" el="1177" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="f6db78152dac670b5687ab61748b5d0f"><![CDATA[{
            _dataProvider.UpdateRecordChangers("TabPermission", "TabPermissionID", tabPermissionId, createdBy, modifiedBy);
        }]]></body>
          </codeblock>
        </method>
        <method name="UpdateTabSettingChangers">
          <declaration><![CDATA[private void UpdateTabSettingChangers(int tabId, string settingName, int createdBy, int modifiedBy)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1180" sc="9" el="1182" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="817ccfef96aaca00ebb4dbcce0c89bb8"><![CDATA[{
            _dataProvider.UpdateSettingRecordChangers("TabSettings", "TabID", tabId, settingName, createdBy, modifiedBy);
        }]]></body>
          </codeblock>
        </method>
        <method name="UpdateTabUrlChangers">
          <declaration><![CDATA[private void UpdateTabUrlChangers(int tabUrlId, int createdBy, int modifiedBy)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1185" sc="9" el="1187" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="860c46fd91e94961ab1bd4541d959b53"><![CDATA[{
            _dataProvider.UpdateRecordChangers("TabUrls", "TabUrlID", tabUrlId, createdBy, modifiedBy);
        }]]></body>
          </codeblock>
        </method>
        <method name="UpdateTotalProcessedPackages">
          <declaration><![CDATA[private void UpdateTotalProcessedPackages()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="1587" sc="9" el="1598" ec="10">Components\Services\PagesExportService.cs</location>
            <body hash="50e8ef313b0c7d0d96f3fb8ad9417a24"><![CDATA[{
            //HACK: get skin packages checkpoint and add "_totals.TotalPackages" to it
            var packagesCheckpoint = EntitiesController.Instance.GetJobChekpoints(_exportImportJob.JobId).FirstOrDefault(
                cp => cp.Category == Constants.Category_Packages);
            if (packagesCheckpoint != null)
            {
                //Note: if restart of job occurs, these will report wrong values
                packagesCheckpoint.TotalItems += _totals.TotalPackages;
                packagesCheckpoint.ProcessedItems += _totals.TotalPackages;
                EntitiesController.Instance.UpdateJobChekpoint(packagesCheckpoint);
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_contentController">
          <declaration><![CDATA[private IContentController _contentController;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_dataProvider">
          <declaration><![CDATA[private DataProvider _dataProvider;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_exportDto">
          <declaration><![CDATA[private ExportDto _exportDto;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_exportedModuleDefinitions">
          <declaration><![CDATA[private IList<int> _exportedModuleDefinitions = new List<int>();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_exportImportJob">
          <declaration><![CDATA[private ExportImportJob _exportImportJob;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_importDto">
          <declaration><![CDATA[private ImportDto _importDto;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_moduleController">
          <declaration><![CDATA[private IModuleController _moduleController;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_tabController">
          <declaration><![CDATA[private ITabController _tabController;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_totals">
          <declaration><![CDATA[private PagesExportService.ProgressTotals _totals;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Logger">
          <declaration><![CDATA[private static readonly ILog Logger = LoggerSource.Instance.GetLogger(typeof(ExportImportEngine));]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Category">
          <declaration><![CDATA[public override string Category]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="63" sc="44" el="63" ec="68">Components\Services\PagesExportService.cs</location>
            <body hash="ce5eac5d28859b73d840b11a6aee7350"><![CDATA[Constants.Category_Page]]></body>
          </codeblock>
        </property>
        <property name="IgnoreParentMatch">
          <declaration><![CDATA[public virtual bool IgnoreParentMatch]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="71" sc="49" el="71" ec="53">Components\Services\PagesExportService.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="71" sc="54" el="71" ec="58">Components\Services\PagesExportService.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ImportDto">
          <declaration><![CDATA[protected ImportDto ImportDto]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="73" sc="42" el="73" ec="52">Components\Services\PagesExportService.cs</location>
            <body hash="dd8d2ae94983e8bceb9c4ede9a50c3fb"><![CDATA[_importDt]]></body>
          </codeblock>
        </property>
        <property name="IncludeSystem">
          <declaration><![CDATA[public virtual bool IncludeSystem]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="69" sc="45" el="69" ec="49">Components\Services\PagesExportService.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="69" sc="50" el="69" ec="54">Components\Services\PagesExportService.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ParentCategory">
          <declaration><![CDATA[public override string ParentCategory]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="65" sc="50" el="65" ec="54">Components\Services\PagesExportService.cs</location>
            <body hash="40a8712b29ac76182ed0c4f632b7d543"><![CDATA[nul]]></body>
          </codeblock>
        </property>
        <property name="Priority">
          <declaration><![CDATA[public override uint Priority]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="67" sc="42" el="67" ec="44">Components\Services\PagesExportService.cs</location>
            <body hash="c81e728d9d4c2f636f067f89cc14862c"><![CDATA[2]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="PageTemplatesExportService">
      <declaration><![CDATA[public class PageTemplatesExportService : AssetsExportService]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private readonly string _templatesFolder = string.Format("{0}{1}{{0}}\\{2}", Globals.ApplicationMapPath, "\\App_Data\\ExportImport\\", "export_templates.zip");]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="20" sc="9" el="21" ec="106">Components\Services\PageTemplatesExportService.cs</location>
            <body hash="8147b34f81baff44f4e0e606d28130c2"><![CDATA[private readonly string _templatesFolder =
            $"{Globals.ApplicationMapPath}{Constants.ExportFolder}{{0}}\\{Constants.ExportZipTemplates}";]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ExportData">
          <declaration><![CDATA[public override void ExportData(ExportImportJob exportJob, ExportDto exportDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="30" sc="9" el="93" ec="10">Components\Services\PageTemplatesExportService.cs</location>
            <body hash="d7edf28210c7e0fa8dacbebbcddc4c33"><![CDATA[{
            if (CheckCancelled(exportJob)) return;
            //Skip the export if all the folders have been processed already.
            if (CheckPoint.Stage >= 1)
                return;

            //Create Zip File to hold files
            var skip = GetCurrentSkip();
            var currentIndex = skip;
            var totalTemplatesExported = 0;
            var portalId = exportJob.PortalId;
            try
            {
                var templatesFile = string.Format(_templatesFolder, exportJob.Directory.TrimEnd('\\').TrimEnd('/'));

                if (CheckPoint.Stage == 0)
                {
                    var fromDate = (exportDto.FromDateUtc ?? Constants.MinDbTime).ToLocalTime();
                    var toDate = exportDto.ToDateUtc.ToLocalTime();
                    var portal = PortalController.Instance.GetPortal(portalId);

                    var templates =
                        CBO.FillCollection<ExportPageTemplate>(
                            DataProvider.Instance()
                                .GetFiles(portalId, null, toDate, fromDate))
                            .Where(x => x.Extension == Constants.TemplatesExtension)
                            .ToList();
                    var totalTemplates = templates.Count;

                    //Update the total items count in the check points. This should be updated only once.
                    CheckPoint.TotalItems = CheckPoint.TotalItems <= 0 ? totalTemplates : CheckPoint.TotalItems;
                    if (CheckPointStageCallback(this)) return;

                    foreach (var template in templates)
                    {
                        Repository.CreateItem(template, null);
                        totalTemplatesExported += 1;
                        var folderOffset = portal.HomeDirectoryMapPath.Length +
                                           (portal.HomeDirectoryMapPath.EndsWith("\\") ? 0 : 1);

                        var folder = FolderManager.Instance.GetFolder(template.FolderId);
                        CompressionUtil.AddFileToArchive(
                            portal.HomeDirectoryMapPath + folder.FolderPath + GetActualFileName(template), templatesFile,
                            folderOffset);

                        CheckPoint.ProcessedItems++;
                        CheckPoint.Progress = CheckPoint.ProcessedItems * 100.0 / totalTemplates;
                        currentIndex++;
                        //After every 10 items, call the checkpoint stage. This is to avoid too many frequent updates to DB.
                        if (currentIndex % 10 == 0 && CheckPointStageCallback(this)) return;
                    }
                    CheckPoint.Stage++;
                    currentIndex = 0;
                    CheckPoint.Completed = true;
                    CheckPoint.Progress = 100;
                }
            }
            finally
            {
                CheckPoint.StageData = currentIndex > 0 ? JsonConvert.SerializeObject(new { skip = currentIndex }) : null;
                CheckPointStageCallback(this);
                Result.AddSummary("Exported Templates", totalTemplatesExported.ToString());
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="GetActualFileName">
          <declaration><![CDATA[private string GetActualFileName(ExportPageTemplate objFile)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="152" sc="9" el="156" ec="10">Components\Services\PageTemplatesExportService.cs</location>
            <body hash="61ce3391a20d38567a5574f7d5584c57"><![CDATA[{
            return (objFile.StorageLocation == (int)FolderController.StorageLocationTypes.SecureFileSystem)
                ? objFile.FileName + Globals.glbProtectedExtension
                : objFile.FileName;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetCurrentSkip">
          <declaration><![CDATA[private int GetCurrentSkip()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="159" sc="9" el="166" ec="10">Components\Services\PageTemplatesExportService.cs</location>
            <body hash="9c59ad479c1722ee90e27b9af90a612c"><![CDATA[{
            if (!string.IsNullOrEmpty(CheckPoint.StageData))
            {
                dynamic stageData = JsonConvert.DeserializeObject(CheckPoint.StageData);
                return Convert.ToInt32(stageData.skip) ?? 0;
            }
            return 0;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetImportTotal">
          <declaration><![CDATA[public override int GetImportTotal()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="147" sc="9" el="149" ec="10">Components\Services\PageTemplatesExportService.cs</location>
            <body hash="caf0364c7783b0c1af9efb0e5a5f33d8"><![CDATA[{
            return Repository.GetCount<ExportPageTemplate>();
        }]]></body>
          </codeblock>
        </method>
        <method name="ImportData">
          <declaration><![CDATA[public override void ImportData(ExportImportJob importJob, ImportDto importDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="96" sc="9" el="144" ec="10">Components\Services\PageTemplatesExportService.cs</location>
            <body hash="0628710107209269d2bdbfda468560fa"><![CDATA[{
            if (CheckCancelled(importJob)) return;
            //Skip the export if all the templates have been processed already.
            if (CheckPoint.Stage >= 2 || CheckPoint.Completed)
                return;

            var portalId = importJob.PortalId;
            var templatesFile = string.Format(_templatesFolder, importJob.Directory.TrimEnd('\\').TrimEnd('/'));
            var totalTemplates = GetImportTotal();

            CheckPoint.TotalItems = CheckPoint.TotalItems <= 0 ? totalTemplates : CheckPoint.TotalItems;
            if (CheckPointStageCallback(this)) return;

            if (CheckPoint.Stage == 0)
            {
                if (!File.Exists(templatesFile))
                {
                    Result.AddLogEntry("TemplatesFileNotFound", "Templates file not found. Skipping templates import",
                        ReportLevel.Warn);
                    CheckPoint.Completed = true;
                    CheckPointStageCallback(this);
                }
                else
                {
                    var portal = PortalController.Instance.GetPortal(portalId);

                    CompressionUtil.UnZipArchive(templatesFile, portal.HomeDirectoryMapPath,
                        importDto.CollisionResolution == CollisionResolution.Overwrite);

                    Result.AddSummary("Imported templates", totalTemplates.ToString());
                    CheckPoint.Stage++;
                    CheckPoint.StageData = null;
                    CheckPoint.Progress = 90;
                    CheckPoint.TotalItems = totalTemplates;
                    CheckPoint.ProcessedItems = totalTemplates;
                    if (CheckPointStageCallback(this)) return;
                }
            }
            if (CheckPoint.Stage == 1)
            {
                Func<ExportPageTemplate, object> predicate = x => x.Folder;
                var templates = Repository.GetAllItems(predicate).Select(x => x.Folder).Distinct();
                templates.ForEach(x => FolderManager.Instance.Synchronize(importJob.PortalId, x));
                CheckPoint.Stage++;
                CheckPoint.Completed = true;
                CheckPoint.Progress = 100;
                CheckPointStageCallback(this);
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_templatesFolder">
          <declaration><![CDATA[private readonly string _templatesFolder = string.Format("{0}{1}{{0}}\\{2}", Globals.ApplicationMapPath, "\\App_Data\\ExportImport\\", "export_templates.zip");]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Category">
          <declaration><![CDATA[public override string Category]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="23" sc="44" el="23" ec="72">Components\Services\PageTemplatesExportService.cs</location>
            <body hash="9cc2bbb4a33ad0967e7e83f95ae941b2"><![CDATA[Constants.Category_Template]]></body>
          </codeblock>
        </property>
        <property name="ParentCategory">
          <declaration><![CDATA[public override string ParentCategory]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="25" sc="50" el="25" ec="54">Components\Services\PageTemplatesExportService.cs</location>
            <body hash="40a8712b29ac76182ed0c4f632b7d543"><![CDATA[nul]]></body>
          </codeblock>
        </property>
        <property name="Priority">
          <declaration><![CDATA[public override uint Priority]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="27" sc="42" el="27" ec="44">Components\Services\PageTemplatesExportService.cs</location>
            <body hash="c4ca4238a0b923820dcc509a6f75849b"><![CDATA[1]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="PortalExportService">
      <declaration><![CDATA[public class PortalExportService : BasePortableService]]></declaration>
      <documentation>
        <summary>
 Service to export/import portal data.
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public PortalExportService()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ExportData">
          <declaration><![CDATA[public override void ExportData(ExportImportJob exportJob, ExportDto exportDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="48" sc="9" el="104" ec="10">Components\Services\PortalExportService.cs</location>
            <body hash="c45940cac89a88ce7259e03e1af26655"><![CDATA[{
            var fromDate = (exportDto.FromDateUtc ?? Constants.MinDbTime).ToLocalTime();
            var toDate = exportDto.ToDateUtc.ToLocalTime();
            if (CheckPoint.Stage > 1) return;
            if (CheckCancelled(exportJob)) return;
            List<ExportPortalLanguage> portalLanguages = null;
            if (CheckPoint.Stage == 0)
            {
                var portalSettings = new List<ExportPortalSetting>();
                var settingToMigrate =
                    SettingsController.Instance.GetSetting(Constants.PortalSettingExportKey)?.SettingValue?.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);

                if (settingToMigrate != null)
                {
                    portalSettings = CBO.FillCollection<ExportPortalSetting>(DataProvider.Instance().GetPortalSettings(exportJob.PortalId, toDate, fromDate));

                    //Migrate only allowed portal settings.
                    portalSettings =
                        portalSettings.Where(x => settingToMigrate.Any(setting => setting.Trim().Equals(x.SettingName, StringComparison.InvariantCultureIgnoreCase))).ToList();

                    //Update the total items count in the check points. This should be updated only once.
                    CheckPoint.TotalItems = CheckPoint.TotalItems <= 0 ? portalSettings.Count : CheckPoint.TotalItems;
                    if (CheckPoint.TotalItems == portalSettings.Count)
                    {
                        portalLanguages =
                            CBO.FillCollection<ExportPortalLanguage>(
                                DataProvider.Instance().GetPortalLanguages(exportJob.PortalId, toDate, fromDate));
                        CheckPoint.TotalItems += portalLanguages.Count;
                    }
                    CheckPointStageCallback(this);

                    Repository.CreateItems(portalSettings);
                }
                Result.AddSummary("Exported Portal Settings", portalSettings.Count.ToString());

                CheckPoint.Progress = 50;
                CheckPoint.ProcessedItems = portalSettings.Count;
                CheckPoint.Stage++;
                if (CheckPointStageCallback(this)) return;
            }

            if (CheckPoint.Stage == 1)
            {
                if (CheckCancelled(exportJob)) return;
                if (portalLanguages == null)
                    portalLanguages = CBO.FillCollection<ExportPortalLanguage>(DataProvider.Instance()
                        .GetPortalLanguages(exportJob.PortalId, toDate, fromDate));

                Repository.CreateItems(portalLanguages);
                Result.AddSummary("Exported Portal Languages", portalLanguages.Count.ToString());
                CheckPoint.Progress = 100;
                CheckPoint.Completed = true;
                CheckPoint.Stage++;
                CheckPoint.ProcessedItems += portalLanguages.Count;
                CheckPointStageCallback(this);
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="GetImportTotal">
          <declaration><![CDATA[public override int GetImportTotal()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="144" sc="9" el="146" ec="10">Components\Services\PortalExportService.cs</location>
            <body hash="10d43114b6bc135e3c3f1a3c57e174da"><![CDATA[{
            return Repository.GetCount<ExportPortalSetting>() + Repository.GetCount<ExportPortalLanguage>();
        }]]></body>
          </codeblock>
        </method>
        <method name="ImportData">
          <declaration><![CDATA[public override void ImportData(ExportImportJob importJob, ImportDto importDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="107" sc="9" el="141" ec="10">Components\Services\PortalExportService.cs</location>
            <body hash="13394c9a6577d1721177aadcc6d78dce"><![CDATA[{
            //Update the total items count in the check points. This should be updated only once.
            CheckPoint.TotalItems = CheckPoint.TotalItems = CheckPoint.TotalItems <= 0 ? GetImportTotal() : CheckPoint.TotalItems;
            if (CheckPointStageCallback(this)) return;
            if (CheckPoint.Stage > 1) return;
            if (CheckPoint.Stage == 0)
            {
                var portalSettings = Repository.GetAllItems<ExportPortalSetting>().ToList();
                ProcessPortalSettings(importJob, importDto, portalSettings);
                CheckPoint.TotalItems = GetImportTotal();
                Result.AddSummary("Imported Portal Settings", portalSettings.Count.ToString());
                CheckPoint.Progress += 50;
                CheckPoint.Stage++;
                CheckPoint.ProcessedItems = portalSettings.Count;
                if (CheckPointStageCallback(this)) return;
            }
            if (CheckPoint.Stage == 1)
            {
                var portalLanguages = Repository.GetAllItems<ExportPortalLanguage>().ToList();
                ProcessPortalLanguages(importJob, importDto, portalLanguages);
                Result.AddSummary("Imported Portal Languages", portalLanguages.Count.ToString());
                CheckPoint.Progress += 50;
                CheckPoint.Completed = true;
                CheckPoint.Stage++;
                CheckPoint.ProcessedItems += portalLanguages.Count;
                CheckPointStageCallback(this);
            }
            /*
            ProgressPercentage = 0;
            var portalLocalizations = Repository.GetAllItems<ExportPortalLocalization>().ToList();
            ProcessPortalLocalizations(importJob, importDto, portalLocalizations);
            Result.AddSummary("Imported Portal Localizations", portalLocalizations.Count.ToString());
            ProgressPercentage += 40;
            */
        }]]></body>
          </codeblock>
        </method>
        <method name="ProcessPortalLanguages">
          <declaration><![CDATA[private void ProcessPortalLanguages(ExportImportJob importJob, ImportDto importDto, IEnumerable<ExportPortalLanguage> portalLanguages)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="206" sc="9" el="255" ec="10">Components\Services\PortalExportService.cs</location>
            <body hash="b3f920193bed0e07b0fc511e4e7dbe42"><![CDATA[{
            var portalId = importJob.PortalId;
            var localPortalLanguages =
                CBO.FillCollection<ExportPortalLanguage>(DataProvider.Instance().GetPortalLanguages(portalId, DateUtils.GetDatabaseUtcTime().AddYears(1), null));
            var localLanguages = CBO.FillCollection<Locale>(DotNetNuke.Data.DataProvider.Instance().GetLanguages());
            foreach (var exportPortalLanguage in portalLanguages)
            {
                if (CheckCancelled(importJob)) return;
                var localLanguageId =
                    localLanguages.FirstOrDefault(x => x.Code == exportPortalLanguage.CultureCode)?.LanguageId;
                var existingPortalLanguage =
                    localPortalLanguages.FirstOrDefault(
                        t =>
                            t.LanguageId == localLanguageId);
                var isUpdate = false;
                if (existingPortalLanguage != null)
                {
                    switch (importDto.CollisionResolution)
                    {
                        case CollisionResolution.Overwrite:
                            isUpdate = true;
                            break;
                        case CollisionResolution.Ignore:
                            Result.AddLogEntry("Ignored portal language", exportPortalLanguage.CultureCode);
                            continue;
                        default:
                            throw new ArgumentOutOfRangeException(importDto.CollisionResolution.ToString());
                    }
                }
                if (isUpdate)
                {
                    var modifiedBy = Util.GetUserIdByName(importJob, exportPortalLanguage.LastModifiedByUserId, exportPortalLanguage.LastModifiedByUserName);

                    DotNetNuke.Data.DataProvider.Instance()
                        .UpdatePortalLanguage(importJob.PortalId, exportPortalLanguage.LanguageId,
                            exportPortalLanguage.IsPublished, modifiedBy);

                    Result.AddLogEntry("Updated portal language", exportPortalLanguage.CultureCode);
                }
                else
                {
                    var createdBy = Util.GetUserIdByName(importJob, exportPortalLanguage.CreatedByUserId, exportPortalLanguage.CreatedByUserName);

                    exportPortalLanguage.PortalLanguageId = DotNetNuke.Data.DataProvider.Instance()
                        .AddPortalLanguage(importJob.PortalId, exportPortalLanguage.LanguageId,
                            exportPortalLanguage.IsPublished, createdBy);
                    Result.AddLogEntry("Added portal language", exportPortalLanguage.CultureCode);
                }
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="ProcessPortalSettings">
          <declaration><![CDATA[private void ProcessPortalSettings(ExportImportJob importJob, ImportDto importDto, IEnumerable<ExportPortalSetting> portalSettings)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="150" sc="9" el="202" ec="10">Components\Services\PortalExportService.cs</location>
            <body hash="530c1a2164dd1367a67140f087f60e34"><![CDATA[{
            var portalId = importJob.PortalId;
            var localPortalSettings =
                CBO.FillCollection<ExportPortalSetting>(DataProvider.Instance().GetPortalSettings(portalId, DateUtils.GetDatabaseUtcTime().AddYears(1), null));
            foreach (var exportPortalSetting in portalSettings)
            {
                if (CheckCancelled(importJob)) return;

                var existingPortalSetting =
                    localPortalSettings.FirstOrDefault(
                        t =>
                            t.SettingName == exportPortalSetting.SettingName &&
                            (t.CultureCode == exportPortalSetting.CultureCode ||
                             (string.IsNullOrEmpty(t.CultureCode) &&
                              string.IsNullOrEmpty(exportPortalSetting.CultureCode))));
                var isUpdate = false;
                if (existingPortalSetting != null)
                {
                    switch (importDto.CollisionResolution)
                    {
                        case CollisionResolution.Overwrite:
                            isUpdate = true;
                            break;
                        case CollisionResolution.Ignore:
                            Result.AddLogEntry("Ignored portal settings", exportPortalSetting.SettingName);
                            continue;
                        default:
                            throw new ArgumentOutOfRangeException(importDto.CollisionResolution.ToString());
                    }
                }
                if (isUpdate)
                {
                    var modifiedBy = Util.GetUserIdByName(importJob, exportPortalSetting.LastModifiedByUserId,
                     exportPortalSetting.LastModifiedByUserName);

                    exportPortalSetting.PortalSettingId = existingPortalSetting.PortalSettingId;
                    DotNetNuke.Data.DataProvider.Instance()
                        .UpdatePortalSetting(importJob.PortalId, exportPortalSetting.SettingName,
                            exportPortalSetting.SettingValue, modifiedBy, exportPortalSetting.CultureCode);
                    Result.AddLogEntry("Updated portal settings", exportPortalSetting.SettingName);
                }
                else
                {
                    var createdBy = Util.GetUserIdByName(importJob, exportPortalSetting.CreatedByUserId, exportPortalSetting.CreatedByUserName);

                    DotNetNuke.Data.DataProvider.Instance()
                        .UpdatePortalSetting(importJob.PortalId, exportPortalSetting.SettingName,
                            exportPortalSetting.SettingValue, createdBy, exportPortalSetting.CultureCode);

                    Result.AddLogEntry("Added portal settings", exportPortalSetting.SettingName);
                }
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Category">
          <declaration><![CDATA[public override string Category]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="41" sc="44" el="41" ec="69">Components\Services\PortalExportService.cs</location>
            <body hash="54ea713762ec5a90f5b25db3019cca9a"><![CDATA[Constants.Category_Porta]]></body>
          </codeblock>
        </property>
        <property name="ParentCategory">
          <declaration><![CDATA[public override string ParentCategory]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="43" sc="50" el="43" ec="54">Components\Services\PortalExportService.cs</location>
            <body hash="40a8712b29ac76182ed0c4f632b7d543"><![CDATA[nul]]></body>
          </codeblock>
        </property>
        <property name="Priority">
          <declaration><![CDATA[public override uint Priority]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ProfilePropertiesService">
      <declaration><![CDATA[public class ProfilePropertiesService : BasePortableService]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ProfilePropertiesService()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ExportData">
          <declaration><![CDATA[public override void ExportData(ExportImportJob exportJob, ExportDto exportDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="42" sc="9" el="67" ec="10">Components\Services\ProfilePropertiesService.cs</location>
            <body hash="61f3e84ca947704ced3e9db225cec481"><![CDATA[{
            var fromDate = (exportDto.FromDateUtc ?? Constants.MinDbTime).ToLocalTime();
            var toDate = exportDto.ToDateUtc.ToLocalTime();
            if (CheckCancelled(exportJob)) return;
            if (CheckPoint.Stage > 0) return;
            if (CheckCancelled(exportJob)) return;

            var profileProperties =
                CBO.FillCollection<ExportProfileProperty>(
                    DataProvider.Instance()
                        .GetPropertyDefinitionsByPortal(exportJob.PortalId, exportDto.IncludeDeletions, toDate,
                            fromDate)).ToList();
            CheckPoint.Progress = 50;
            //Update the total items count in the check points. This should be updated only once.
            CheckPoint.TotalItems = CheckPoint.TotalItems <= 0 ? profileProperties.Count : CheckPoint.TotalItems;
            CheckPointStageCallback(this);

            if (CheckCancelled(exportJob)) return;
            Repository.CreateItems(profileProperties);
            Result.AddSummary("Exported Profile Properties", profileProperties.Count.ToString());
            CheckPoint.Progress = 100;
            CheckPoint.ProcessedItems = profileProperties.Count;
            CheckPoint.Completed = true;
            CheckPoint.Stage++;
            CheckPointStageCallback(this);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetImportTotal">
          <declaration><![CDATA[public override int GetImportTotal()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="116" sc="9" el="118" ec="10">Components\Services\ProfilePropertiesService.cs</location>
            <body hash="0902fce5fe31d3920bfa48605b8b349e"><![CDATA[{
            return Repository.GetCount<ExportProfileProperty>();
        }]]></body>
          </codeblock>
        </method>
        <method name="ImportData">
          <declaration><![CDATA[public override void ImportData(ExportImportJob importJob, ImportDto importDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="70" sc="9" el="113" ec="10">Components\Services\ProfilePropertiesService.cs</location>
            <body hash="fb196159a041fb95825b5f87e1522507"><![CDATA[{
            if (CheckPoint.Stage > 0) return;
            var profileProperties = Repository.GetAllItems<ExportProfileProperty>().ToList();
            //Update the total items count in the check points. This should be updated only once.
            CheckPoint.TotalItems = CheckPoint.TotalItems <= 0 ? profileProperties.Count : CheckPoint.TotalItems;
            CheckPointStageCallback(this);

            foreach (var profileProperty in profileProperties)
            {
                if (CheckCancelled(importJob)) return;

                var existingProfileProperty = CBO.FillObject<ExportProfileProperty>(DotNetNuke.Data.DataProvider.Instance()
                    .GetPropertyDefinitionByName(importJob.PortalId, profileProperty.PropertyName));

                if (existingProfileProperty != null)
                {
                    switch (importDto.CollisionResolution)
                    {
                        case CollisionResolution.Overwrite:
                            var modifiedById = Util.GetUserIdByName(importJob, profileProperty.LastModifiedByUserId, profileProperty.LastModifiedByUserName);
                            ProcessUpdateProfileProperty(profileProperty, existingProfileProperty, modifiedById);
                            break;
                        case CollisionResolution.Ignore:
                            break;
                        default:
                            throw new ArgumentOutOfRangeException(importDto.CollisionResolution.ToString());
                    }
                }
                else
                {
                    var createdById = Util.GetUserIdByName(importJob, profileProperty.CreatedByUserId,
                        profileProperty.CreatedByUserName);

                    ProcessCreateProfileProperty(importJob, profileProperty, createdById);
                }
            }

            Result.AddSummary("Imported Profile Properties", profileProperties.Count.ToString());
            CheckPoint.ProcessedItems = profileProperties.Count;
            CheckPoint.Completed = true;
            CheckPoint.Progress = 100;
            CheckPoint.Stage++;
            CheckPointStageCallback(this);
        }]]></body>
          </codeblock>
        </method>
        <method name="ProcessCreateProfileProperty">
          <declaration><![CDATA[private static void ProcessCreateProfileProperty(ExportImportJob importJob, ExportProfileProperty profileProperty, int createdById)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="122" sc="9" el="130" ec="10">Components\Services\ProfilePropertiesService.cs</location>
            <body hash="a91bb87ecd8fb0cf0aa045342a53b80d"><![CDATA[{
            DotNetNuke.Data.DataProvider.Instance()
                .AddPropertyDefinition(importJob.PortalId, profileProperty.ModuleDefId ?? Null.NullInteger,
                    profileProperty.DataType ?? Null.NullInteger,
                    profileProperty.DefaultValue, profileProperty.PropertyCategory, profileProperty.PropertyName,
                    profileProperty.ReadOnly, profileProperty.Required,
                    profileProperty.ValidationExpression, profileProperty.ViewOrder, profileProperty.Visible,
                    profileProperty.Length, profileProperty.DefaultVisibility, createdById);
        }]]></body>
          </codeblock>
        </method>
        <method name="ProcessUpdateProfileProperty">
          <declaration><![CDATA[private static void ProcessUpdateProfileProperty(ExportProfileProperty profileProperty, ExportProfileProperty existingProfileProperty, int modifiedById)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="134" sc="9" el="142" ec="10">Components\Services\ProfilePropertiesService.cs</location>
            <body hash="98e2e4f8fc643374eedd527736873421"><![CDATA[{
            DotNetNuke.Data.DataProvider.Instance()
                .UpdatePropertyDefinition(existingProfileProperty.PropertyDefinitionId,
                    profileProperty.DataType ?? Null.NullInteger,
                    profileProperty.DefaultValue, profileProperty.PropertyCategory, profileProperty.PropertyName,
                    profileProperty.ReadOnly, profileProperty.Required,
                    profileProperty.ValidationExpression, profileProperty.ViewOrder, profileProperty.Visible,
                    profileProperty.Length, profileProperty.DefaultVisibility, modifiedById);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Category">
          <declaration><![CDATA[public override string Category]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="35" sc="44" el="35" ec="75">Components\Services\ProfilePropertiesService.cs</location>
            <body hash="7ab02df18f393bc8a26cb2fdebcd8549"><![CDATA[Constants.Category_ProfileProp]]></body>
          </codeblock>
        </property>
        <property name="ParentCategory">
          <declaration><![CDATA[public override string ParentCategory]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="37" sc="50" el="37" ec="54">Components\Services\ProfilePropertiesService.cs</location>
            <body hash="40a8712b29ac76182ed0c4f632b7d543"><![CDATA[nul]]></body>
          </codeblock>
        </property>
        <property name="Priority">
          <declaration><![CDATA[public override uint Priority]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="RolesExportService">
      <declaration><![CDATA[public class RolesExportService : BasePortableService]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public RolesExportService()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ExportData">
          <declaration><![CDATA[public override void ExportData(ExportImportJob exportJob, ExportDto exportDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="44" sc="9" el="105" ec="10">Components\Services\RolesExportService.cs</location>
            <body hash="abcb8db2c050290609b012fa7c4b98b7"><![CDATA[{
            var fromDate = (exportDto.FromDateUtc ?? Constants.MinDbTime).ToLocalTime();
            var toDate = exportDto.ToDateUtc.ToLocalTime();
            if (CheckPoint.Stage > 2) return;
            List<ExportRole> roles = null;
            List<ExportRoleSetting> roleSettings = null;
            if (CheckPoint.Stage == 0)
            {
                if (CheckCancelled(exportJob)) return;

                var roleGroups = CBO.FillCollection<ExportRoleGroup>(
                    DataProvider.Instance().GetAllRoleGroups(exportJob.PortalId, toDate, fromDate));

                //Update the total items count in the check points. This should be updated only once.
                CheckPoint.TotalItems = CheckPoint.TotalItems <= 0 ? roleGroups.Count : CheckPoint.TotalItems;
                if (CheckPoint.TotalItems == roleGroups.Count)
                {
                    roles = CBO.FillCollection<ExportRole>(
                        DataProvider.Instance().GetAllRoles(exportJob.PortalId, toDate, fromDate));
                    roleSettings = CBO.FillCollection<ExportRoleSetting>(
                        DataProvider.Instance().GetAllRoleSettings(exportJob.PortalId, toDate, fromDate));
                    CheckPoint.TotalItems += roles.Count + roleSettings.Count;
                }
                CheckPointStageCallback(this);

                Repository.CreateItems(roleGroups);
                Result.AddSummary("Exported Role Groups", roleGroups.Count.ToString());
                CheckPoint.ProcessedItems = roleGroups.Count;
                CheckPoint.Progress = 30;
                CheckPoint.Stage++;
                if (CheckPointStageCallback(this)) return;
            }

            if (CheckPoint.Stage == 1)
            {
                if (CheckCancelled(exportJob)) return;
                if (roles == null)
                    roles = CBO.FillCollection<ExportRole>(
                    DataProvider.Instance().GetAllRoles(exportJob.PortalId, toDate, fromDate));
                Repository.CreateItems(roles);
                Result.AddSummary("Exported Roles", roles.Count.ToString());
                CheckPoint.Progress = 80;
                CheckPoint.ProcessedItems += roles.Count;
                CheckPoint.Stage++;
                if (CheckPointStageCallback(this)) return;
            }

            if (CheckPoint.Stage == 2)
            {
                if (CheckCancelled(exportJob)) return;
                if (roleSettings == null)
                    roleSettings = CBO.FillCollection<ExportRoleSetting>(
                       DataProvider.Instance().GetAllRoleSettings(exportJob.PortalId, toDate, fromDate));
                Repository.CreateItems(roleSettings);
                Result.AddSummary("Exported Role Settings", roleSettings.Count.ToString());
                CheckPoint.Progress = 100;
                CheckPoint.ProcessedItems += roleSettings.Count;
                CheckPoint.Completed = true;
                CheckPoint.Stage++;
                CheckPointStageCallback(this);
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="GetImportTotal">
          <declaration><![CDATA[public override int GetImportTotal()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="157" sc="9" el="160" ec="10">Components\Services\RolesExportService.cs</location>
            <body hash="05b0bc1125e998824f7feb60ff86702e"><![CDATA[{
            return Repository.GetCount<ExportRoleGroup>() + Repository.GetCount<ExportRole>() +
                   Repository.GetCount<ExportRoleSetting>();
        }]]></body>
          </codeblock>
        </method>
        <method name="ImportData">
          <declaration><![CDATA[public override void ImportData(ExportImportJob importJob, ImportDto importDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="108" sc="9" el="154" ec="10">Components\Services\RolesExportService.cs</location>
            <body hash="ce0bb4cc431155cb277d0d6747b2c97e"><![CDATA[{
            if (CheckPoint.Stage > 2) return;

            if (CheckCancelled(importJob)) return;
            //Update the total items count in the check points. This should be updated only once.
            CheckPoint.TotalItems = CheckPoint.TotalItems <= 0 ? GetImportTotal() : CheckPoint.TotalItems;
            CheckPointStageCallback(this);

            var otherRoleGroups = Repository.GetAllItems<ExportRoleGroup>().ToList();
            if (CheckPoint.Stage == 0)
            {
                ProcessRoleGroups(importJob, importDto, otherRoleGroups);
                Repository.UpdateItems(otherRoleGroups);
                Result.AddSummary("Imported Role Groups", otherRoleGroups.Count.ToString());
                CheckPoint.Progress = 40;
                CheckPoint.ProcessedItems = otherRoleGroups.Count;
                CheckPoint.Stage++;
                if (CheckPointStageCallback(this)) return;
            }

            if (CheckCancelled(importJob)) return;
            var otherRoles = Repository.GetAllItems<ExportRole>().ToList();
            if (CheckPoint.Stage == 1)
            {
                Result.AddSummary("Imported Roles", otherRoles.Count.ToString());
                ProcessRoles(importJob, importDto, otherRoleGroups, otherRoles);
                Repository.UpdateItems(otherRoles);
                CheckPoint.Progress = 50;
                CheckPoint.ProcessedItems += otherRoles.Count;
                CheckPoint.Stage++;
                if (CheckPointStageCallback(this)) return;
            }

            if (CheckPoint.Stage == 2)
            {
                if (CheckCancelled(importJob)) return;
                var otherRoleSettings = Repository.GetAllItems<ExportRoleSetting>().ToList();
                ProcessRoleSettings(importJob, importDto, otherRoles, otherRoleSettings);
                Repository.UpdateItems(otherRoleSettings);
                Result.AddSummary("Imported Role Settings", otherRoleSettings.Count.ToString());
                CheckPoint.Progress = 100;
                CheckPoint.ProcessedItems += otherRoleSettings.Count;
                CheckPoint.Completed = true;
                CheckPoint.Stage++;
                CheckPointStageCallback(this);
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="ProcessRoleGroups">
          <declaration><![CDATA[private void ProcessRoleGroups(ExportImportJob importJob, ImportDto importDto, IEnumerable<ExportRoleGroup> otherRoleGroups)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="164" sc="9" el="213" ec="10">Components\Services\RolesExportService.cs</location>
            <body hash="b638d7d0c83a0c37837b5b3d44c16994"><![CDATA[{
            var changedGroups = new List<RoleGroupItem>();
            var portalId = importJob.PortalId;
            var localRoleGroups = CBO.FillCollection<ExportRoleGroup>(DataProvider.Instance().GetAllRoleGroups(portalId, DateUtils.GetDatabaseUtcTime().AddYears(1), null));
            foreach (var other in otherRoleGroups)
            {
                if (CheckCancelled(importJob)) return;
                var createdBy = Util.GetUserIdByName(importJob, other.CreatedByUserID, other.CreatedByUserName);
                var modifiedBy = Util.GetUserIdByName(importJob, other.LastModifiedByUserID, other.LastModifiedByUserName);
                var local = localRoleGroups.FirstOrDefault(t => t.RoleGroupName == other.RoleGroupName);

                if (local != null)
                {
                    other.LocalId = local.RoleGroupID;
                    switch (importDto.CollisionResolution)
                    {
                        case CollisionResolution.Ignore:
                            Result.AddLogEntry("Ignored role group", other.RoleGroupName);
                            break;
                        case CollisionResolution.Overwrite:
                            var roleGroup = new RoleGroupInfo(local.RoleGroupID, portalId, false)
                            {
                                RoleGroupName = other.RoleGroupName,
                                Description = other.Description,
                            };
                            RoleController.UpdateRoleGroup(roleGroup, false);
                            changedGroups.Add(new RoleGroupItem(roleGroup.RoleGroupID, createdBy, modifiedBy));
                            DataCache.ClearCache(string.Format(DataCache.RoleGroupsCacheKey, local.RoleGroupID));
                            Result.AddLogEntry("Updated role group", other.RoleGroupName);
                            break;
                        default:
                            throw new ArgumentOutOfRangeException(importDto.CollisionResolution.ToString());
                    }
                }
                else
                {
                    var roleGroup = new RoleGroupInfo()
                    {
                        PortalID = portalId,
                        RoleGroupName = other.RoleGroupName,
                        Description = other.Description,
                    };
                    other.LocalId = RoleController.AddRoleGroup(roleGroup);
                    changedGroups.Add(new RoleGroupItem(roleGroup.RoleGroupID, createdBy, modifiedBy));
                    Result.AddLogEntry("Added role group", other.RoleGroupName);
                }
            }
            if (changedGroups.Count > 0)
                RefreshRecordsUserIds(changedGroups);
        }]]></body>
          </codeblock>
        </method>
        <method name="ProcessRoles">
          <declaration><![CDATA[private void ProcessRoles(ExportImportJob importJob, ImportDto importDto, List<ExportRoleGroup> otherRoleGroups, IEnumerable<ExportRole> otherRoles)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="217" sc="9" el="308" ec="10">Components\Services\RolesExportService.cs</location>
            <body hash="26151f7cc88ab7e40857a768331692db"><![CDATA[{
            var roleItems = new List<RoleItem>();
            var portalId = importJob.PortalId;
            foreach (var other in otherRoles)
            {
                if (CheckCancelled(importJob)) return;
                var createdBy = Util.GetUserIdByName(importJob, other.CreatedByUserID, other.CreatedByUserName);
                var modifiedBy = Util.GetUserIdByName(importJob, other.LastModifiedByUserID, other.LastModifiedByUserName);
                var localRoleInfo = RoleController.Instance.GetRoleByName(portalId, other.RoleName);
                if (localRoleInfo != null)
                {
                    other.LocalId = localRoleInfo.RoleID;
                    switch (importDto.CollisionResolution)
                    {
                        case CollisionResolution.Ignore:
                            Result.AddLogEntry("Ignored role", other.RoleName);
                            break;
                        case CollisionResolution.Overwrite:
                            var group = other.RoleGroupID.HasValue
                                ? otherRoleGroups.FirstOrDefault(g => g.RoleGroupID == other.RoleGroupID.Value)
                                : null;

                            localRoleInfo.RoleName = other.RoleName;
                            localRoleInfo.AutoAssignment = false; //other.AutoAssignment; CP: said do not do this
                            localRoleInfo.BillingFrequency = other.BillingFrequency;
                            localRoleInfo.BillingPeriod = other.BillingPeriod ?? 0;
                            localRoleInfo.Description = other.Description;
                            localRoleInfo.IconFile = other.IconFile;      //TODO: map to local file
                            localRoleInfo.IsPublic = other.IsPublic;
                            localRoleInfo.IsSystemRole = other.IsSystemRole;
                            localRoleInfo.RoleGroupID = group?.LocalId ?? Null.NullInteger;
                            localRoleInfo.RSVPCode = other.RSVPCode;
                            localRoleInfo.SecurityMode = (SecurityMode)other.SecurityMode;
                            localRoleInfo.ServiceFee = Convert.ToSingle(other.ServiceFee ?? 0m);
                            localRoleInfo.Status = (RoleStatus)other.Status;
                            localRoleInfo.TrialFee = Convert.ToSingle(other.TrialFee ?? 0m);
                            localRoleInfo.TrialFrequency = other.TrialFrequency;
                            localRoleInfo.TrialPeriod = other.TrialPeriod ?? 0;

                            RoleController.Instance.UpdateRole(localRoleInfo, false);
                            roleItems.Add(new RoleItem(localRoleInfo.RoleID, createdBy, modifiedBy));

                            // do not assign existing users to the roles automatically
                            if (other.AutoAssignment)
                                DataProvider.Instance().SetRoleAutoAssign(localRoleInfo.RoleID);

                            RoleController.Instance.ClearRoleCache(localRoleInfo.RoleID);
                            Result.AddLogEntry("Updated role", other.RoleName);
                            break;
                        default:
                            throw new ArgumentOutOfRangeException(importDto.CollisionResolution.ToString());
                    }
                }

                if (localRoleInfo == null)
                {
                    var group = other.RoleGroupID.HasValue
                        ? otherRoleGroups.FirstOrDefault(g => g.RoleGroupID == other.RoleGroupID.Value)
                        : null;

                    var roleInfo = new RoleInfo
                    {
                        PortalID = portalId,
                        RoleName = other.RoleName,
                        AutoAssignment = other.AutoAssignment,
                        BillingFrequency = other.BillingFrequency,
                        BillingPeriod = other.BillingPeriod ?? 0,
                        Description = other.Description,
                        IconFile = other.IconFile,      //TODO: map to local file
                        IsPublic = other.IsPublic,
                        IsSystemRole = other.IsSystemRole,
                        RoleGroupID = group?.LocalId ?? Null.NullInteger,
                        RSVPCode = other.RSVPCode,
                        SecurityMode = (SecurityMode)other.SecurityMode,
                        ServiceFee = Convert.ToSingle(other.ServiceFee ?? 0m),
                        Status = (RoleStatus)other.Status,
                        TrialFee = Convert.ToSingle(other.TrialFee ?? 0m),
                        TrialFrequency = other.TrialFrequency,
                        TrialPeriod = other.TrialPeriod ?? 0,
                    };

                    other.LocalId = RoleController.Instance.AddRole(roleInfo, false);
                    roleItems.Add(new RoleItem(roleInfo.RoleID, createdBy, modifiedBy));
                    RoleController.Instance.ClearRoleCache(roleInfo.RoleID);
                    Result.AddLogEntry("Added role", other.RoleName);
                }
            }

            //set created/updated for any added/modified item
            if (roleItems.Count > 0)
                RefreshRecordsUserIds(roleItems);
        }]]></body>
          </codeblock>
        </method>
        <method name="ProcessRoleSettings">
          <declaration><![CDATA[private void ProcessRoleSettings(ExportImportJob importJob, ImportDto importDto, IList<ExportRole> otherRoles, IEnumerable<ExportRoleSetting> otherRoleSettings)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="312" sc="9" el="356" ec="10">Components\Services\RolesExportService.cs</location>
            <body hash="1c82081a8fb9247151f66798482e367e"><![CDATA[{
            var changedSettings = new List<SettingItem>();
            var portalId = importJob.PortalId;
            foreach (var other in otherRoleSettings)
            {
                if (CheckCancelled(importJob)) return;
                var createdBy = Util.GetUserIdByName(importJob, other.CreatedByUserID, other.CreatedByUserName);
                var modifiedBy = Util.GetUserIdByName(importJob, other.LastModifiedByUserID, other.LastModifiedByUserName);
                var otherRole = otherRoles.FirstOrDefault(r => r.RoleID == other.RoleID);
                if (otherRole == null || !otherRole.LocalId.HasValue) continue;
                var localRoleInfo = RoleController.Instance.GetRoleById(portalId, otherRole.LocalId.Value);
                if (localRoleInfo == null) continue;

                switch (importDto.CollisionResolution)
                {
                    case CollisionResolution.Ignore:
                        Result.AddLogEntry("Ignored role setting", other.SettingName);
                        break;
                    case CollisionResolution.Overwrite:
                        string settingValue;
                        if (!localRoleInfo.Settings.TryGetValue(other.SettingName, out settingValue) ||
                            settingValue != other.SettingValue)
                        {
                            changedSettings.Add(new SettingItem(localRoleInfo.RoleID, other.SettingName, createdBy, modifiedBy));
                            localRoleInfo.Settings[other.SettingName] = other.SettingValue;
                            RoleController.Instance.UpdateRoleSettings(localRoleInfo, false);
                            Result.AddLogEntry("Updated role setting", other.SettingName);
                            //No need to clear cache as the caller will do it one time at end
                        }
                        else
                        {
                            Result.AddLogEntry("Ignored role setting", other.SettingName);
                        }
                        break;
                    default:
                        throw new ArgumentOutOfRangeException(importDto.CollisionResolution.ToString());
                }

            }

            if (changedSettings.Count > 0)
                RefreshRecordsUserIds(changedSettings);

            RoleController.Instance.ClearRoleCache(importJob.PortalId);
        }]]></body>
          </codeblock>
        </method>
        <method name="RefreshRecordsUserIds">
          <declaration><![CDATA[private static void RefreshRecordsUserIds(IEnumerable<RolesExportService.RoleGroupItem> roleGroupItems)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="359" sc="9" el="366" ec="10">Components\Services\RolesExportService.cs</location>
            <body hash="6cf31f850ed30f4c937941e54d0406dd"><![CDATA[{
            var provider = DataProvider.Instance();
            foreach (var roleGroupItem in roleGroupItems)
            {
                provider.UpdateRecordChangers("RoleGroups", "RoleGroupID",
                    roleGroupItem.RoleGroupId, roleGroupItem.CreatedBy, roleGroupItem.ModifiedBy);
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="RefreshRecordsUserIds">
          <declaration><![CDATA[private static void RefreshRecordsUserIds(IEnumerable<RolesExportService.RoleItem> roleItems)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="369" sc="9" el="376" ec="10">Components\Services\RolesExportService.cs</location>
            <body hash="170c0cb8d4c8c1d88af88a434d3bf1cf"><![CDATA[{
            var provider = DataProvider.Instance();
            foreach (var roleItem in roleItems)
            {
                provider.UpdateRecordChangers("Roles", "RoleID",
                    roleItem.RoleId, roleItem.CreatedBy, roleItem.ModifiedBy);
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="RefreshRecordsUserIds">
          <declaration><![CDATA[private static void RefreshRecordsUserIds(IEnumerable<RolesExportService.SettingItem> settingItems)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="379" sc="9" el="386" ec="10">Components\Services\RolesExportService.cs</location>
            <body hash="b789f4c2e2ce3767641ad354ff2d47c1"><![CDATA[{
            var provider = DataProvider.Instance();
            foreach (var item in settingItems)
            {
                provider.UpdateSettingRecordChangers("RoleSettings", "RoleID",
                    item.RoleId, item.Name, item.CreatedBy, item.ModifiedBy);
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Category">
          <declaration><![CDATA[public override string Category]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="37" sc="44" el="37" ec="68">Components\Services\RolesExportService.cs</location>
            <body hash="30b93e5f58d30550341c771af12f94f8"><![CDATA[Constants.Category_Role]]></body>
          </codeblock>
        </property>
        <property name="ParentCategory">
          <declaration><![CDATA[public override string ParentCategory]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="39" sc="50" el="39" ec="54">Components\Services\RolesExportService.cs</location>
            <body hash="40a8712b29ac76182ed0c4f632b7d543"><![CDATA[nul]]></body>
          </codeblock>
        </property>
        <property name="Priority">
          <declaration><![CDATA[public override uint Priority]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ThemesExportService">
      <declaration><![CDATA[public class ThemesExportService : BasePortableService]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ThemesExportService()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static ThemesExportService()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="18" sc="9" el="18" ec="108">Components\Services\ThemesExportService.cs</location>
            <body hash="da414576b97996b080c41dea95f66dd2"><![CDATA[private static readonly ILog Logger = LoggerSource.Instance.GetLogger(typeof(ThemesExportService))]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ExportData">
          <declaration><![CDATA[public override void ExportData(ExportImportJob exportJob, ExportDto exportDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="31" sc="9" el="88" ec="10">Components\Services\ThemesExportService.cs</location>
            <body hash="b804f70a8dfe02196f1b6d8058802c9d"><![CDATA[{
            if (CheckCancelled(exportJob)) return;
            //Skip the export if all the folders have been processed already.
            if (CheckPoint.Stage >= 1)
                return;

            _exportImportJob = exportJob;
            _portalSettings = new PortalSettings(exportJob.PortalId);

            //Create Zip File to hold files
            var currentIndex = 0;
            var totalThemesExported = 0;
            try
            {
                var packagesZipFileFormat = $"{Globals.ApplicationMapPath}{Constants.ExportFolder}{{0}}\\{Constants.ExportZipThemes}";
                var packagesZipFile = string.Format(packagesZipFileFormat, exportJob.Directory.TrimEnd('\\').TrimEnd('/'));

                if (CheckPoint.Stage == 0)
                {
                    //export skin packages.
                    var exportThemes = GetExportThemes();
                    var totalThemes = exportThemes.Count;

                    //Update the total items count in the check points. This should be updated only once.
                    CheckPoint.TotalItems = CheckPoint.TotalItems <= 0 ? totalThemes : CheckPoint.TotalItems;
                    if (CheckPointStageCallback(this)) return;

                    foreach (var theme in exportThemes)
                    {
                        var filePath = SkinController.FormatSkinSrc(theme, _portalSettings);
                        var physicalPath = Path.Combine(Globals.ApplicationMapPath, filePath.TrimStart('/'));
                        if (Directory.Exists(physicalPath))
                        {
                            foreach (var file in Directory.GetFiles(physicalPath, "*.*", SearchOption.AllDirectories))
                            {
                                var folderOffset = Path.Combine(Globals.ApplicationMapPath, "Portals").Length + 1;
                                CompressionUtil.AddFileToArchive(file, packagesZipFile, folderOffset);
                            }
                            totalThemesExported += 1;
                        }

                        CheckPoint.ProcessedItems++;
                        CheckPoint.Progress = CheckPoint.ProcessedItems * 100.0 / totalThemes;
                        currentIndex++;
                        //After every 10 items, call the checkpoint stage. This is to avoid too many frequent updates to DB.
                        if (currentIndex % 10 == 0 && CheckPointStageCallback(this)) return;
                    }
                    CheckPoint.Stage++;
                    CheckPoint.Completed = true;
                    CheckPoint.Progress = 100;
                }
            }
            finally
            {
                CheckPointStageCallback(this);
                Result.AddSummary("Exported Themes", totalThemesExported.ToString());
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="GetExportThemes">
          <declaration><![CDATA[private IList<string> GetExportThemes()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="184" sc="9" el="216" ec="10">Components\Services\ThemesExportService.cs</location>
            <body hash="e7130ed85f3fda8e18789e2c630097ac"><![CDATA[{
            var exportThemes = new List<string>();

            //get site level themes
            exportThemes.Add(_portalSettings.DefaultPortalSkin);
            exportThemes.Add(_portalSettings.DefaultPortalContainer);

            if (!exportThemes.Contains(_portalSettings.DefaultAdminSkin))
            {
                exportThemes.Add(_portalSettings.DefaultAdminSkin);
            }

            if (!exportThemes.Contains(_portalSettings.DefaultAdminContainer))
            {
                exportThemes.Add(_portalSettings.DefaultAdminContainer);
            }

            exportThemes.AddRange(LoadExportThemesForPages());
            exportThemes.AddRange(LoadExportContainersForModules());

            //get the theme packages
            var themePackages = new List<string>();
            foreach (var theme in exportThemes)
            {
                var packageName = theme.Substring(0, theme.LastIndexOf("/", StringComparison.InvariantCultureIgnoreCase));
                if (!themePackages.Contains(packageName))
                {
                    themePackages.Add(packageName);
                }
            }

            return themePackages;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetImportTotal">
          <declaration><![CDATA[public override int GetImportTotal()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="179" sc="9" el="181" ec="10">Components\Services\ThemesExportService.cs</location>
            <body hash="dcdb7e522e8e8e6d8d260148382bb42d"><![CDATA[{
            return _importCount;
        }]]></body>
          </codeblock>
        </method>
        <method name="ImportData">
          <declaration><![CDATA[public override void ImportData(ExportImportJob importJob, ImportDto importDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="91" sc="9" el="176" ec="10">Components\Services\ThemesExportService.cs</location>
            <body hash="eed37f0227abce965e4f5789f98dab69"><![CDATA[{
            if (CheckCancelled(importJob)) return;
            //Skip the export if all the templates have been processed already.
            if (CheckPoint.Stage >= 1 || CheckPoint.Completed)
                return;

            _exportImportJob = importJob;

            var packageZipFile = $"{Globals.ApplicationMapPath}{Constants.ExportFolder}{_exportImportJob.Directory.TrimEnd('\\', '/')}\\{Constants.ExportZipThemes}";
            var tempFolder = $"{Path.GetDirectoryName(packageZipFile)}\\{DateTime.Now.Ticks}";
            if (File.Exists(packageZipFile))
            {
                CompressionUtil.UnZipArchive(packageZipFile, tempFolder);
                var exporeFiles = Directory.Exists(tempFolder) ? Directory.GetFiles(tempFolder, "*.*", SearchOption.AllDirectories) : new string[0];
                var portalSettings = new PortalSettings(importDto.PortalId);
                _importCount = exporeFiles.Length;

                CheckPoint.TotalItems = CheckPoint.TotalItems <= 0 ? exporeFiles.Length : CheckPoint.TotalItems;
                if (CheckPointStageCallback(this)) return;

                if (CheckPoint.Stage == 0)
                {
                    try
                    {
                        foreach (var file in exporeFiles)
                        {
                            try
                            {
                                var checkFolder = file.Replace(tempFolder + "\\", string.Empty).Split('\\')[0];
                                var relativePath = file.Substring((tempFolder + "\\" + checkFolder + "\\").Length);
                                string targetPath;


                                if (checkFolder == "_default")
                                {
                                    targetPath = Path.Combine(Globals.HostMapPath, relativePath);
                                }
                                else if (checkFolder.EndsWith("-System"))
                                {
                                    targetPath = Path.Combine(portalSettings.HomeSystemDirectoryMapPath, relativePath);
                                }
                                else
                                {
                                    targetPath = Path.Combine(portalSettings.HomeDirectoryMapPath, relativePath);
                                }

                                if (!File.Exists(targetPath) ||
                                    importDto.CollisionResolution == CollisionResolution.Overwrite)
                                {
                                    var directory = Path.GetDirectoryName(targetPath);
                                    if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
                                    {
                                        Directory.CreateDirectory(directory);
                                    }

                                    File.Copy(file, targetPath, true);
                                }

                                Result.AddLogEntry("Import Theme File completed", targetPath);
                                CheckPoint.ProcessedItems++;
                                CheckPoint.Progress = CheckPoint.ProcessedItems * 100.0 / exporeFiles.Length;
                                CheckPointStageCallback(this); // just to update the counts without exit logic
                            }
                            catch (Exception ex)
                            {
                                Result.AddLogEntry("Import Theme error", file);
                                Logger.Error(ex);
                            }
                        }
                        CheckPoint.Stage++;
                        CheckPoint.Completed = true;
                    }
                    finally
                    {
                        CheckPointStageCallback(this);
                        FileSystemUtils.DeleteFolderRecursive(tempFolder);
                    }
                }
            }
            else
            {
                CheckPoint.Completed = true;
                CheckPointStageCallback(this);
                Result.AddLogEntry("ThemesFileNotFound", "Themes file not found. Skipping themes import", ReportLevel.Warn);
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="LoadExportContainersForModules">
          <declaration><![CDATA[private IList<string> LoadExportContainersForModules()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="239" sc="9" el="251" ec="10">Components\Services\ThemesExportService.cs</location>
            <body hash="7141080d19ee28a05750ec46b25a6ad7"><![CDATA[{
            var exportThemes = new List<string>();

            foreach (var module in Repository.GetAllItems<ExportTabModule>())
            {
                if (!string.IsNullOrEmpty(module.ContainerSrc) && !exportThemes.Contains(module.ContainerSrc))
                {
                    exportThemes.Add(module.ContainerSrc);
                }
            }

            return exportThemes;
        }]]></body>
          </codeblock>
        </method>
        <method name="LoadExportThemesForPages">
          <declaration><![CDATA[private IList<string> LoadExportThemesForPages()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="219" sc="9" el="236" ec="10">Components\Services\ThemesExportService.cs</location>
            <body hash="9f15c6a8db180f8ba0f844ca8221a7b2"><![CDATA[{
            var exportThemes = new List<string>();

            foreach (var exportTab in Repository.GetAllItems<ExportTab>())
            {
                if (!string.IsNullOrEmpty(exportTab.SkinSrc) && !exportThemes.Contains(exportTab.SkinSrc))
                {
                    exportThemes.Add(exportTab.SkinSrc);
                }

                if (!string.IsNullOrEmpty(exportTab.ContainerSrc) && !exportThemes.Contains(exportTab.ContainerSrc))
                {
                    exportThemes.Add(exportTab.ContainerSrc);
                }
            }

            return exportThemes;
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_exportImportJob">
          <declaration><![CDATA[private ExportImportJob _exportImportJob;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_importCount">
          <declaration><![CDATA[private int _importCount;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_portalSettings">
          <declaration><![CDATA[private PortalSettings _portalSettings;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Logger">
          <declaration><![CDATA[private static readonly ILog Logger = LoggerSource.Instance.GetLogger(typeof(ThemesExportService));]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Category">
          <declaration><![CDATA[public override string Category]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="24" sc="44" el="24" ec="69">Components\Services\ThemesExportService.cs</location>
            <body hash="4003a3022e7466f478121a8406ac64f1"><![CDATA[Constants.Category_Theme]]></body>
          </codeblock>
        </property>
        <property name="ParentCategory">
          <declaration><![CDATA[public override string ParentCategory]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="26" sc="50" el="26" ec="74">Components\Services\ThemesExportService.cs</location>
            <body hash="ce5eac5d28859b73d840b11a6aee7350"><![CDATA[Constants.Category_Page]]></body>
          </codeblock>
        </property>
        <property name="Priority">
          <declaration><![CDATA[public override uint Priority]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="28" sc="42" el="28" ec="44">Components\Services\ThemesExportService.cs</location>
            <body hash="c4ca4238a0b923820dcc509a6f75849b"><![CDATA[1]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="UsersDataExportService">
      <declaration><![CDATA[public class UsersDataExportService : BasePortableService]]></declaration>
      <documentation>
        <summary>
 Supplementary service to import users additional data.
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public UsersDataExportService()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static UsersDataExportService()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="248" sc="9" el="273" ec="11">Components\Services\UsersDataExportService.cs</location>
            <body hash="6db62cfac5d11462e6c2a0d4a23abd2b"><![CDATA[private static readonly Tuple<string, Type>[] UserRolesDatasetColumns =
        {
            new Tuple<string, Type>("PortalId", typeof (int)),
            new Tuple<string, Type>("UserId", typeof (int)),
            new Tuple<string, Type>("RoleId", typeof (int)),
            new Tuple<string, Type>("ExpiryDate", typeof (DateTime)),
            new Tuple<string, Type>("IsTrialUsed", typeof (bool)),
            new Tuple<string, Type>("EffectiveDate", typeof (DateTime)),
            new Tuple<string, Type>("CreatedByUserId", typeof (int)),
            new Tuple<string, Type>("LastModifiedByUserId", typeof (int)),
            new Tuple<string, Type>("Status", typeof (int)),
            new Tuple<string, Type>("IsOwner", typeof (bool)),
            new Tuple<string, Type>("IsSuperUser", typeof (bool)),
        };

        private static readonly Tuple<string, Type>[] UserProfileDatasetColumns =
        {
            new Tuple<string, Type>("PortalId", typeof (int)),
            new Tuple<string, Type>("UserId", typeof (int)),
            new Tuple<string, Type>("PropertyDefinitionId", typeof (int)),
            new Tuple<string, Type>("PropertyValue", typeof (string)),
            new Tuple<string, Type>("PropertyText", typeof (string)),
            new Tuple<string, Type>("Visibility", typeof (int)),
            new Tuple<string, Type>("ExtendedVisibility", typeof (string)),
            new Tuple<string, Type>("IsSuperUser", typeof (bool))
        };]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ExportData">
          <declaration><![CDATA[public override void ExportData(ExportImportJob exportJob, ExportDto exportDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="50" sc="9" el="57" ec="10">Components\Services\UsersDataExportService.cs</location>
            <body hash="49e95c1dfc570fba22ca9fe3d24d0cb7"><![CDATA[{
            CheckPoint.Progress += 100;
            CheckPoint.Completed = true;
            CheckPoint.TotalItems = 0;
            CheckPoint.ProcessedItems = 0;
            CheckPointStageCallback(this);
            //No implementation required in export users child as everything is exported in parent service.
        }]]></body>
          </codeblock>
        </method>
        <method name="GetImportTotal">
          <declaration><![CDATA[public override int GetImportTotal()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="244" sc="9" el="246" ec="10">Components\Services\UsersDataExportService.cs</location>
            <body hash="44196987a7a117baece9cb3e52a49f26"><![CDATA[{
            return Repository.GetCount<ExportUser>();
        }]]></body>
          </codeblock>
        </method>
        <method name="GetUserPhotoId">
          <declaration><![CDATA[private string GetUserPhotoId(int portalId, string importFileId, ExportUser user)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="214" sc="9" el="241" ec="10">Components\Services\UsersDataExportService.cs</location>
            <body hash="841afee8a75e80d669dbd33ee6ef0edc"><![CDATA[{
            int profilePictureId;
            if (string.IsNullOrEmpty(importFileId) ||
                !int.TryParse(importFileId, out profilePictureId)) return null;
            var files =
                FolderManager.Instance.GetFiles(
                    FolderManager.Instance.GetUserFolder(
                        UserController.GetUserByName(portalId, user.Username)))
                    .ToList();
            if (!files.Any()) return null;
            var importUserFolder =
                Repository.GetItem<ExportFolder>(x => x.UserId == user.UserId);
            if (importUserFolder == null) return null;
            {
                var profilePicture =
                    Repository.GetRelatedItems<ExportFile>(importUserFolder.Id)
                        .FirstOrDefault(x => x.FileId == profilePictureId);
                if (profilePicture != null &&
                    files.Any(x => x.FileName == profilePicture.FileName))
                {
                    return Convert.ToString(
                        files.First(
                            x => x.FileName == profilePicture.FileName)
                            .FileId);
                }
            }
            return null;
        }]]></body>
          </codeblock>
        </method>
        <method name="ImportData">
          <declaration><![CDATA[public override void ImportData(ExportImportJob importJob, ImportDto importDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="60" sc="9" el="211" ec="10">Components\Services\UsersDataExportService.cs</location>
            <body hash="06e9e5142920998101f870b554846339"><![CDATA[{
            if (CheckCancelled(importJob)) return;

            var pageIndex = 0;
            const int pageSize = Constants.DefaultPageSize;
            var totalUserRolesImported = 0;
            var totalProfilesImported = 0;
            var totalProcessed = 0;
            var totalUsers = Repository.GetCount<ExportUser>();
            if (totalUsers == 0)
            {
                CheckPoint.Completed = true;
                CheckPointStageCallback(this);
                return;
            }
            var totalPages = Util.CalculateTotalPages(totalUsers, pageSize);
            //Skip the import if all the users has been processed already.
            if (CheckPoint.Stage >= totalPages)
                return;

            pageIndex = CheckPoint.Stage;

            var totalUsersToBeProcessed = totalUsers - pageIndex * pageSize;

            //Update the total items count in the check points. This should be updated only once.
            CheckPoint.TotalItems = CheckPoint.TotalItems <= 0 ? totalUsers : CheckPoint.TotalItems;
            if (CheckPointStageCallback(this)) return;
            var includeProfile = importDto.ExportDto.IncludeProperfileProperties;
            try
            {
                Repository.RebuildIndex<ExportUserRole>(x => x.ReferenceId);
                if (includeProfile)
                    Repository.RebuildIndex<ExportUserProfile>(x => x.ReferenceId);
                var portalId = importJob.PortalId;
                using (var tableUserProfile = new DataTable("UserProfile"))
                using (var tableUserRoles = new DataTable("UserRoles"))
                {
                    // must create the columns from scratch with each iteration
                    tableUserProfile.Columns.AddRange(UserProfileDatasetColumns.Select(column => new DataColumn(column.Item1, column.Item2)).ToArray());
                    tableUserRoles.Columns.AddRange(UserRolesDatasetColumns.Select(column => new DataColumn(column.Item1, column.Item2)).ToArray());
                    var dataProvider = DotNetNuke.Data.DataProvider.Instance();
                    while (totalProcessed < totalUsersToBeProcessed)
                    {
                        if (CheckCancelled(importJob)) return;
                        var users = Repository.GetAllItems<ExportUser>(null, true, pageIndex * pageSize, pageSize).ToList();
                        var tempUserRolesCount = 0;
                        var tempUserProfileCount = 0;
                        try
                        {
                            foreach (var user in users)
                            {
                                if (CheckCancelled(importJob)) return;
                                //Find the correct userId from the system which was added/updated by UserExportService.
                                var userId = UserController.GetUserByName(user.Username)?.UserID;
                                if (userId != null)
                                {
                                    var userRoles = Repository.GetRelatedItems<ExportUserRole>(user.Id).ToList();
                                    foreach (var userRole in userRoles)
                                    {
                                        var roleId = Util.GetRoleIdByName(importJob.PortalId, userRole.RoleId, userRole.RoleName);
                                        if (roleId == null) continue;
                                        if (!(roleId > Convert.ToInt32(Globals.glbRoleNothing))) continue;
                                        var userRoleRow = tableUserRoles.NewRow();
                                        userRoleRow["PortalId"] = portalId;
                                        userRoleRow["UserId"] = userId;
                                        userRoleRow["RoleId"] = roleId;
                                        userRoleRow["ExpiryDate"] = dataProvider.GetNull(userRole.ExpiryDate);
                                        userRoleRow["IsTrialUsed"] = userRole.IsTrialUsed;
                                        userRoleRow["EffectiveDate"] = dataProvider.GetNull(userRole.EffectiveDate);
                                        userRoleRow["CreatedByUserId"] = Util.GetUserIdByName(importJob, user.CreatedByUserId, user.CreatedByUserName);
                                        userRoleRow["LastModifiedByUserId"] = Util.GetUserIdByName(importJob, user.LastModifiedByUserId, user.LastModifiedByUserName);
                                        userRoleRow["Status"] = userRole.Status;
                                        userRoleRow["IsOwner"] = userRole.IsOwner;
                                        userRoleRow["IsSuperUser"] = user.IsSuperUser;
                                        tableUserRoles.Rows.Add(userRoleRow);
                                        tempUserRolesCount++;
                                    }
                                    if (includeProfile)
                                    {
                                        var userProfiles =
                                            Repository.GetRelatedItems<ExportUserProfile>(user.Id).ToList();
                                        foreach (var userProfile in userProfiles)
                                        {
                                            var profileDefinitionId = Util.GetProfilePropertyId(importJob.PortalId,
                                                userProfile.PropertyDefinitionId, userProfile.PropertyName);
                                            if (profileDefinitionId == null || profileDefinitionId == -1) continue;
                                            var value = userProfile.PropertyValue;
                                            if (userProfile.PropertyName.Equals("photo", StringComparison.InvariantCultureIgnoreCase) && (value = GetUserPhotoId(portalId, value, user)) == null)
                                            {
                                                continue;
                                            }

                                            var userProfileRow = tableUserProfile.NewRow();
                                            userProfileRow["PortalId"] = importJob.PortalId;
                                            userProfileRow["UserId"] = userId;
                                            userProfileRow["PropertyDefinitionId"] = profileDefinitionId.Value;
                                            userProfileRow["PropertyValue"] = value;
                                            userProfileRow["PropertyText"] = userProfile.PropertyText;
                                            userProfileRow["Visibility"] = userProfile.Visibility;
                                            userProfileRow["ExtendedVisibility"] = userProfile.ExtendedVisibility;
                                            userProfileRow["IsSuperUser"] = user.IsSuperUser;
                                            tableUserProfile.Rows.Add(userProfileRow);
                                            tempUserProfileCount++;
                                        }
                                    }
                                }
                            }
                            var overwrite = importDto.CollisionResolution == CollisionResolution.Overwrite;
                            //Bulk insert the data in DB
                            DotNetNuke.Data.DataProvider.Instance()
                                .BulkInsert("ExportImport_AddUpdateUserRolesBulk", "@DataTable", tableUserRoles, new Dictionary<string, object> { { "Overwrite", overwrite } });
                            totalUserRolesImported += tempUserRolesCount;

                            if (includeProfile)
                            {
                                DotNetNuke.Data.DataProvider.Instance()
                                    .BulkInsert("ExportImport_AddUpdateUsersProfilesBulk", "@DataTable",
                                        tableUserProfile, new Dictionary<string, object> { { "Overwrite", overwrite } });
                                totalProfilesImported += tempUserProfileCount;
                            }

                            CheckPoint.ProcessedItems += users.Count;
                            totalProcessed += users.Count;
                            CheckPoint.Progress = CheckPoint.ProcessedItems * 100.0 / totalUsers;
                            CheckPoint.StageData = null;
                        }
                        catch (Exception ex)
                        {
                            Result.AddLogEntry($"Importing Users Data from {pageIndex * pageSize} to {pageIndex * pageSize + pageSize} exception", ex.Message, ReportLevel.Error);
                        }
                        tableUserRoles.Rows.Clear();
                        tableUserProfile.Rows.Clear();
                        pageIndex++;
                        CheckPoint.Progress = CheckPoint.ProcessedItems * 100.0 / totalUsers;
                        CheckPoint.Stage++;
                        CheckPoint.StageData = null;
                        if (CheckPointStageCallback(this)) return;
                    }
                }
                CheckPoint.Completed = true;
                CheckPoint.Progress = 100;
            }
            finally
            {
                CheckPointStageCallback(this);
                Result.AddSummary("Imported User Roles", totalUserRolesImported.ToString());
                if (includeProfile)
                {
                    Result.AddSummary("Imported User Profiles", totalProfilesImported.ToString());
                }
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="UserProfileDatasetColumns">
          <declaration><![CDATA[private static readonly Tuple<string, Type>[] UserProfileDatasetColumns = new Tuple<string, Type>[]]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="UserRolesDatasetColumns">
          <declaration><![CDATA[private static readonly Tuple<string, Type>[] UserRolesDatasetColumns = new Tuple<string, Type>[]]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Category">
          <declaration><![CDATA[public override string Category]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="43" sc="44" el="43" ec="72">Components\Services\UsersDataExportService.cs</location>
            <body hash="95efebe9f4d4bd048aeb922ce0388cc7"><![CDATA[Constants.Category_UsersDat]]></body>
          </codeblock>
        </property>
        <property name="ParentCategory">
          <declaration><![CDATA[public override string ParentCategory]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="45" sc="50" el="45" ec="74">Components\Services\UsersDataExportService.cs</location>
            <body hash="25e14d7f5eb71cbd04dba76786094402"><![CDATA[Constants.Category_User]]></body>
          </codeblock>
        </property>
        <property name="Priority">
          <declaration><![CDATA[public override uint Priority]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="47" sc="42" el="47" ec="44">Components\Services\UsersDataExportService.cs</location>
            <body hash="c4ca4238a0b923820dcc509a6f75849b"><![CDATA[1]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="UsersExportService">
      <declaration><![CDATA[public class UsersExportService : BasePortableService]]></declaration>
      <documentation>
        <summary>
 Service to export/import users.
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public UsersExportService()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static UsersExportService()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="423" sc="9" el="460" ec="11">Components\Services\UsersExportService.cs</location>
            <body hash="8e69bc9b9c25dfa28bc757c3ceb989f0"><![CDATA[private static readonly Tuple<string, Type>[] UsersDatasetColumns =
        {
            new Tuple<string, Type>("PortalId", typeof (int)),
            new Tuple<string, Type>("Username", typeof (string)),
            new Tuple<string, Type>("FirstName", typeof (string)),
            new Tuple<string, Type>("LastName", typeof (string)),
            new Tuple<string, Type>("AffiliateId", typeof (int)),
            new Tuple<string, Type>("IsSuperUser", typeof (bool)),
            new Tuple<string, Type>("Email", typeof (string)),
            new Tuple<string, Type>("DisplayName", typeof (string)),
            new Tuple<string, Type>("UpdatePassword", typeof (bool)),
            new Tuple<string, Type>("Authorised", typeof (bool)),
            new Tuple<string, Type>("CreatedByUserID", typeof (int)),
            new Tuple<string, Type>("VanityUrl", typeof (string)),
            new Tuple<string, Type>("RefreshRoles", typeof (bool)),
            new Tuple<string, Type>("LastIPAddress", typeof (string)),
            new Tuple<string, Type>("PasswordResetToken", typeof (Guid)),
            new Tuple<string, Type>("PasswordResetExpiration", typeof (DateTime)),
            new Tuple<string, Type>("IsDeleted", typeof (bool)),
            new Tuple<string, Type>("LastModifiedByUserID", typeof (int)),
            new Tuple<string, Type>("ApplicationId", typeof (Guid)),
            new Tuple<string, Type>("AspUserId", typeof (Guid)),
            new Tuple<string, Type>("MobileAlias", typeof (string)),
            new Tuple<string, Type>("IsAnonymous", typeof (bool)),
            new Tuple<string, Type>("Password", typeof (string)),
            new Tuple<string, Type>("PasswordFormat", typeof (int)),
            new Tuple<string, Type>("PasswordSalt", typeof (string)),
            new Tuple<string, Type>("MobilePIN", typeof (string)),
            new Tuple<string, Type>("PasswordQuestion", typeof (string)),
            new Tuple<string, Type>("PasswordAnswer", typeof (string)),
            new Tuple<string, Type>("IsApproved", typeof (bool)),
            new Tuple<string, Type>("IsLockedOut", typeof (bool)),
            new Tuple<string, Type>("FailedPasswordAttemptCount", typeof (int)),
            new Tuple<string, Type>("FailedPasswordAnswerAttemptCount", typeof (int)),
            new Tuple<string, Type>("Comment", typeof (string)),
            new Tuple<string, Type>("AuthenticationType", typeof (string)),
            new Tuple<string, Type>("AuthenticationToken", typeof (string))
        };]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ExportData">
          <declaration><![CDATA[public override void ExportData(ExportImportJob exportJob, ExportDto exportDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="48" sc="9" el="216" ec="10">Components\Services\UsersExportService.cs</location>
            <body hash="acdbb286c5ae35569f28acd2d4512d29"><![CDATA[{
            if (CheckCancelled(exportJob)) return;
            var fromDateUtc = exportDto.FromDateUtc;
            var toDateUtc = exportDto.ToDateUtc;

            var portalId = exportJob.PortalId;
            var pageIndex = 0;
            const int pageSize = Constants.DefaultPageSize;
            var totalUsersExported = 0;
            var totalUserRolesExported = 0;
            var totalPortalsExported = 0;
            var totalProfilesExported = 0;
            var totalAuthenticationExported = 0;
            var totalAspnetUserExported = 0;
            var totalAspnetMembershipExported = 0;
            var totalUsers = DataProvider.Instance().GetUsersCount(portalId, exportDto.IncludeDeletions, toDateUtc, fromDateUtc);
            if (totalUsers == 0)
            {
                CheckPoint.Completed = true;
                CheckPointStageCallback(this);
                return;
            }
            var totalPages = Util.CalculateTotalPages(totalUsers, pageSize);

            //Skip the export if all the users has been processed already.
            if (CheckPoint.Stage >= totalPages)
                return;

            //Check if there is any pending stage or partially processed data.
            if (CheckPoint.Stage > 0)
            {
                pageIndex = CheckPoint.Stage;
            }
            //Update the total items count in the check points. This should be updated only once.
            CheckPoint.TotalItems = CheckPoint.TotalItems <= 0 ? totalUsers : CheckPoint.TotalItems;
            CheckPoint.ProcessedItems = CheckPoint.Stage * pageSize;
            if (CheckPointStageCallback(this)) return;
            var includeProfile = exportDto.IncludeProperfileProperties;
            try
            {
                while (pageIndex < totalPages)
                {
                    if (CheckCancelled(exportJob)) return;
                    var exportUsersList = new List<ExportUser>();
                    var exportAspnetUserList = new List<ExportAspnetUser>();
                    var exportAspnetMembershipList = new List<ExportAspnetMembership>();
                    var exportUserRoleList = new List<ExportUserRole>();
                    var exportUserPortalList = new List<ExportUserPortal>();
                    var exportUserAuthenticationList = new List<ExportUserAuthentication>();
                    var exportUserProfileList = new List<ExportUserProfile>();
                    try
                    {
                        using (var reader = DataProvider.Instance()
                            .GetAllUsers(portalId, pageIndex, pageSize, exportDto.IncludeDeletions, toDateUtc, fromDateUtc))
                        {
                            CBO.FillCollection(reader, exportUsersList, false);
                            reader.NextResult();

                            CBO.FillCollection(reader, exportUserAuthenticationList, false);
                            reader.NextResult();

                            CBO.FillCollection(reader, exportUserRoleList, false);
                            reader.NextResult();

                            if (includeProfile)
                            {
                                CBO.FillCollection(reader, exportUserProfileList, false);
                            }
                            reader.NextResult();

                            CBO.FillCollection(reader, exportUserPortalList, false);
                            reader.NextResult();

                            CBO.FillCollection(reader, exportAspnetUserList, false);
                            reader.NextResult();

                            CBO.FillCollection(reader, exportAspnetMembershipList, true);
                        }

                        Repository.CreateItems(exportUsersList, null);
                        totalUsersExported += exportUsersList.Count;

                        exportUserAuthenticationList.ForEach(
                            x =>
                            {
                                x.ReferenceId = exportUsersList.FirstOrDefault(user => user.UserId == x.UserId)?.Id;
                            });
                        Repository.CreateItems(exportUserAuthenticationList, null);
                        totalAuthenticationExported += exportUserAuthenticationList.Count;

                        exportUserRoleList.ForEach(
                            x =>
                            {
                                x.ReferenceId = exportUsersList.FirstOrDefault(user => user.UserId == x.UserId)?.Id;
                            });
                        Repository.CreateItems(exportUserRoleList, null);
                        totalUserRolesExported += exportUserRoleList.Count;
                        if (includeProfile)
                        {
                            exportUserProfileList.ForEach(
                                x =>
                                {
                                    x.ReferenceId = exportUsersList.FirstOrDefault(user => user.UserId == x.UserId)?.Id;
                                });
                            Repository.CreateItems(exportUserProfileList, null);
                            totalProfilesExported += exportUserProfileList.Count;
                        }
                        exportUserPortalList.ForEach(
                            x =>
                            {
                                x.ReferenceId = exportUsersList.FirstOrDefault(user => user.UserId == x.UserId)?.Id;
                            });
                        Repository.CreateItems(exportUserPortalList, null);
                        totalPortalsExported += exportUserPortalList.Count;

                        exportAspnetUserList.ForEach(
                            x =>
                            {
                                x.ReferenceId = exportUsersList.FirstOrDefault(user => user.Username == x.UserName)?.Id;
                            });
                        Repository.CreateItems(exportAspnetUserList, null);
                        totalAspnetUserExported += exportAspnetUserList.Count;

                        exportAspnetMembershipList.ForEach(
                            x =>
                            {
                                x.ReferenceId = exportAspnetUserList.FirstOrDefault(user => user.UserId == x.UserId)?.Id;
                            });
                        Repository.CreateItems(exportAspnetMembershipList, null);
                        totalAspnetMembershipExported += exportAspnetMembershipList.Count;

                        CheckPoint.ProcessedItems += exportUsersList.Count;
                    }
                    catch (Exception ex)
                    {
                        Result.AddLogEntry($"Exporting Users from {pageIndex * pageSize} to {pageIndex * pageSize + pageSize} exception", ex.Message, ReportLevel.Error);
                    }
                    CheckPoint.Progress = CheckPoint.ProcessedItems * 100.0 / totalUsers;
                    CheckPoint.Stage++;
                    if (CheckPointStageCallback(this)) return;
                    //Rebuild the indexes in the exported database.
                    Repository.RebuildIndex<ExportUser>(x => x.Id, true);
                    Repository.RebuildIndex<ExportUserPortal>(x => x.ReferenceId);
                    Repository.RebuildIndex<ExportAspnetUser>(x => x.ReferenceId);
                    Repository.RebuildIndex<ExportAspnetMembership>(x => x.ReferenceId);
                    Repository.RebuildIndex<ExportUserAuthentication>(x => x.ReferenceId);
                    Repository.RebuildIndex<ExportUserRole>(x => x.ReferenceId);
                    if (includeProfile)
                        Repository.RebuildIndex<ExportUserProfile>(x => x.ReferenceId);
                    pageIndex++;
                }
                CheckPoint.Completed = true;
                CheckPoint.Progress = 100;
            }
            finally
            {
                CheckPointStageCallback(this);
                Result.AddSummary("Exported Users", totalUsersExported.ToString());
                Result.AddSummary("Exported User Portals", totalPortalsExported.ToString());
                Result.AddSummary("Exported User Roles", totalUserRolesExported.ToString());
                if (includeProfile)
                {
                    Result.AddSummary("Exported User Profiles", totalProfilesExported.ToString());
                }
                Result.AddSummary("Exported User Authentication", totalAuthenticationExported.ToString());
                Result.AddSummary("Exported Aspnet User", totalAspnetUserExported.ToString());
                Result.AddSummary("Exported Aspnet Membership", totalAspnetMembershipExported.ToString());
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="GetApplicationId">
          <declaration><![CDATA[private Guid GetApplicationId()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="413" sc="9" el="421" ec="10">Components\Services\UsersExportService.cs</location>
            <body hash="183a269d6537b78cb33fce6b21061397"><![CDATA[{
            using (var db =
                new PetaPocoDataContext(DotNetNuke.Data.DataProvider.Instance().Settings["connectionStringName"],
                    "aspnet_"))
            {
                return db.ExecuteScalar<Guid>(CommandType.Text,
                    "SELECT TOP 1 ApplicationId FROM aspnet_Applications");
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="GetImportTotal">
          <declaration><![CDATA[public override int GetImportTotal()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="408" sc="9" el="410" ec="10">Components\Services\UsersExportService.cs</location>
            <body hash="44196987a7a117baece9cb3e52a49f26"><![CDATA[{
            return Repository.GetCount<ExportUser>();
        }]]></body>
          </codeblock>
        </method>
        <method name="ImportData">
          <declaration><![CDATA[public override void ImportData(ExportImportJob importJob, ImportDto importDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="219" sc="9" el="405" ec="10">Components\Services\UsersExportService.cs</location>
            <body hash="8414c70722d4d1acd58d3606c1877a05"><![CDATA[{
            if (CheckCancelled(importJob)) return;

            const int pageSize = Constants.DefaultPageSize;
            var totalUsersImported = 0;
            var totalPortalsImported = 0;
            var totalAspnetUserImported = 0;
            var totalAspnetMembershipImported = 0;
            var totalUserAuthenticationCount = 0;
            var totalUsers = Repository.GetCount<ExportUser>();
            if (totalUsers == 0)
            {
                CheckPoint.Completed = true;
                CheckPointStageCallback(this);
                return;
            }
            var totalPages = Util.CalculateTotalPages(totalUsers, pageSize);
            //Skip the import if all the users has been processed already.
            if (CheckPoint.Stage >= totalPages)
                return;

            var pageIndex = CheckPoint.Stage;

            var totalUsersToBeProcessed = totalUsers - pageIndex * pageSize;
            //Update the total items count in the check points. This should be updated only once.
            CheckPoint.TotalItems = CheckPoint.TotalItems <= 0 ? totalUsers : CheckPoint.TotalItems;
            if (CheckPointStageCallback(this)) return;
            try
            {
                Repository.RebuildIndex<ExportUser>(x => x.Id, true);
                Repository.RebuildIndex<ExportUserPortal>(x => x.ReferenceId);
                Repository.RebuildIndex<ExportAspnetUser>(x => x.ReferenceId);
                Repository.RebuildIndex<ExportAspnetMembership>(x => x.ReferenceId);
                Repository.RebuildIndex<ExportUserAuthentication>(x => x.ReferenceId);
                var portalId = importJob.PortalId;
                var dataProvider = DotNetNuke.Data.DataProvider.Instance();
                using (var table = new DataTable("Users"))
                {
                    // must create the columns from scratch with each iteration
                    table.Columns.AddRange(
                        UsersDatasetColumns.Select(column => new DataColumn(column.Item1, column.Item2)).ToArray());
                    while (totalUsersImported < totalUsersToBeProcessed)
                    {
                        if (CheckCancelled(importJob)) return;
                        var users =
                            Repository.GetAllItems<ExportUser>(null, true, pageIndex * pageSize, pageSize).ToList();
                        var tempAspUserCount = 0;
                        var tempAspMembershipCount = 0;
                        var tempUserPortalCount = 0;
                        var tempUserAuthenticationCount = 0;
                        try
                        {
                            foreach (var user in users)
                            {
                                if (CheckCancelled(importJob)) return;
                                var row = table.NewRow();

                                var userPortal = Repository.GetRelatedItems<ExportUserPortal>(user.Id).FirstOrDefault();
                                var userAuthentication = Repository.GetRelatedItems<ExportUserAuthentication>(user.Id).FirstOrDefault();
                                //Aspnet Users and Membership
                                var aspNetUser = Repository.GetRelatedItems<ExportAspnetUser>(user.Id).FirstOrDefault();
                                var aspnetMembership = aspNetUser != null
                                    ? Repository.GetRelatedItems<ExportAspnetMembership>(aspNetUser.Id).FirstOrDefault()
                                    : null;

                                row["PortalId"] = portalId;
                                row["Username"] = user.Username;
                                row["FirstName"] = string.IsNullOrEmpty(user.FirstName) ? string.Empty : user.FirstName;
                                row["LastName"] = string.IsNullOrEmpty(user.LastName) ? string.Empty : user.LastName;
                                row["AffiliateId"] = dataProvider.GetNull(user.AffiliateId);
                                row["IsSuperUser"] = user.IsSuperUser;
                                row["Email"] = user.Email;
                                row["DisplayName"] = string.IsNullOrEmpty(user.DisplayName) ? string.Empty : user.DisplayName;
                                row["UpdatePassword"] = user.UpdatePassword;
                                row["CreatedByUserID"] = Util.GetUserIdByName(importJob, user.CreatedByUserId, user.CreatedByUserName);
                                row["LastIPAddress"] = dataProvider.GetNull(user.LastIpAddress);
                                row["PasswordResetToken"] = dataProvider.GetNull(user.PasswordResetToken);
                                row["PasswordResetExpiration"] = dataProvider.GetNull(user.PasswordResetExpiration);
                                row["LastModifiedByUserID"] = Util.GetUserIdByName(importJob, user.LastModifiedByUserId, user.LastModifiedByUserName);

                                if (userPortal != null)
                                {
                                    tempUserPortalCount += 1;
                                    row["Authorised"] = userPortal.Authorised;
                                    row["VanityUrl"] = userPortal.VanityUrl;
                                    row["RefreshRoles"] = userPortal.RefreshRoles;
                                    row["IsDeleted"] = userPortal.IsDeleted;
                                }
                                else
                                {
                                    row["Authorised"] = DBNull.Value;
                                    row["VanityUrl"] = DBNull.Value;
                                    row["RefreshRoles"] = DBNull.Value;
                                    row["IsDeleted"] = DBNull.Value;
                                }
                                if (userAuthentication != null)
                                {
                                    tempUserAuthenticationCount += 1;
                                    row["AuthenticationType"] = userAuthentication?.AuthenticationType;
                                    row["AuthenticationToken"] = userAuthentication?.AuthenticationToken;
                                }
                                else
                                {
                                    row["AuthenticationType"] = DBNull.Value;
                                    row["AuthenticationToken"] = DBNull.Value;
                                }

                                if (aspNetUser != null)
                                {
                                    tempAspUserCount += 1;
                                    row["ApplicationId"] = GetApplicationId();
                                    row["AspUserId"] = aspNetUser.UserId;
                                    row["MobileAlias"] = aspNetUser.MobileAlias;
                                    row["IsAnonymous"] = aspNetUser.IsAnonymous;
                                    if (aspnetMembership != null)
                                    {
                                        tempAspMembershipCount += 1;
                                        row["Password"] = string.IsNullOrEmpty(aspnetMembership.Password) ? string.Empty : aspnetMembership.Password;
                                        row["PasswordFormat"] = aspnetMembership.PasswordFormat;
                                        row["PasswordSalt"] = aspnetMembership.PasswordSalt;
                                        row["MobilePIN"] = aspnetMembership.MobilePin;
                                        row["PasswordQuestion"] = aspnetMembership.PasswordQuestion;
                                        row["PasswordAnswer"] = aspnetMembership.PasswordAnswer;
                                        row["IsApproved"] = aspnetMembership.IsApproved;
                                        row["IsLockedOut"] = aspnetMembership.IsLockedOut;
                                        row["FailedPasswordAttemptCount"] = aspnetMembership.FailedPasswordAttemptCount;
                                        row["FailedPasswordAnswerAttemptCount"] = aspnetMembership.FailedPasswordAnswerAttemptCount;
                                        row["Comment"] = aspnetMembership.Comment;
                                    }
                                }
                                else
                                {
                                    row["ApplicationId"] = DBNull.Value;
                                    row["AspUserId"] = DBNull.Value;
                                    row["MobileAlias"] = DBNull.Value;
                                    row["IsAnonymous"] = DBNull.Value;
                                    row["Password"] = DBNull.Value;
                                    row["PasswordFormat"] = DBNull.Value;
                                    row["PasswordSalt"] = DBNull.Value;
                                    row["MobilePIN"] = DBNull.Value;
                                    row["PasswordQuestion"] = DBNull.Value;
                                    row["PasswordAnswer"] = DBNull.Value;
                                    row["IsApproved"] = DBNull.Value;
                                    row["IsLockedOut"] = DBNull.Value;
                                    row["FailedPasswordAttemptCount"] = DBNull.Value;
                                    row["FailedPasswordAnswerAttemptCount"] = DBNull.Value;
                                    row["Comment"] = DBNull.Value;
                                }

                                table.Rows.Add(row);
                            }
                            var overwrite = importDto.CollisionResolution == CollisionResolution.Overwrite;
                            //Bulk insert the data in DB
                            DotNetNuke.Data.DataProvider.Instance()
                                .BulkInsert("ExportImport_AddUpdateUsersBulk", "@DataTable", table, new Dictionary<string, object> { { "Overwrite", overwrite } });
                            totalUsersImported += users.Count;
                            totalAspnetUserImported += tempAspUserCount;
                            totalAspnetMembershipImported += tempAspMembershipCount;
                            totalPortalsImported += tempUserPortalCount;
                            totalUserAuthenticationCount += tempUserAuthenticationCount;
                            CheckPoint.ProcessedItems += users.Count;
                        }
                        catch (Exception ex)
                        {
                            Result.AddLogEntry($"Importing Users from {pageIndex * pageSize} to {pageIndex * pageSize + pageSize} exception", ex.Message, ReportLevel.Error);
                        }
                        table.Rows.Clear();
                        pageIndex++;
                        CheckPoint.Progress = CheckPoint.ProcessedItems * 100.0 / totalUsers;
                        CheckPoint.Stage++;
                        CheckPoint.StageData = null;
                        if (CheckPointStageCallback(this)) return;
                    }
                }
                CheckPoint.Completed = true;
                CheckPoint.Progress = 100;
            }
            finally
            {
                CheckPointStageCallback(this);
                Result.AddSummary("Imported Users", totalUsersImported.ToString());
                Result.AddSummary("Imported User Portals", totalPortalsImported.ToString());
                Result.AddSummary("Import User Authentications", totalUserAuthenticationCount.ToString());
                Result.AddSummary("Imported Aspnet Users", totalAspnetUserImported.ToString());
                Result.AddSummary("Imported Aspnet Memberships", totalAspnetMembershipImported.ToString());
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="UsersDatasetColumns">
          <declaration><![CDATA[private static readonly Tuple<string, Type>[] UsersDatasetColumns = new Tuple<string, Type>[]]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Category">
          <declaration><![CDATA[public override string Category]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="41" sc="44" el="41" ec="68">Components\Services\UsersExportService.cs</location>
            <body hash="25e14d7f5eb71cbd04dba76786094402"><![CDATA[Constants.Category_User]]></body>
          </codeblock>
        </property>
        <property name="ParentCategory">
          <declaration><![CDATA[public override string ParentCategory]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="43" sc="50" el="43" ec="54">Components\Services\UsersExportService.cs</location>
            <body hash="40a8712b29ac76182ed0c4f632b7d543"><![CDATA[nul]]></body>
          </codeblock>
        </property>
        <property name="Priority">
          <declaration><![CDATA[public override uint Priority]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="VocabularyService">
      <declaration><![CDATA[public class VocabularyService : BasePortableService]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public VocabularyService()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ExportData">
          <declaration><![CDATA[public override void ExportData(ExportImportJob exportJob, ExportDto exportDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="45" sc="9" el="103" ec="10">Components\Services\VocabularyService.cs</location>
            <body hash="0a2ee592a1ec1669a02d30e43a4eb5a9"><![CDATA[{
            if (CheckPoint.Stage > 0) return;
            if (CheckCancelled(exportJob)) return;

            var fromDate = (exportDto.FromDateUtc ?? Constants.MinDbTime).ToLocalTime();
            var toDate = exportDto.ToDateUtc.ToLocalTime();
            List<TaxonomyVocabularyType> vocabularyTypes = null;

            if (CheckPoint.Stage == 0)
            {
                var taxonomyTerms = GetTaxonomyTerms(exportDto.PortalId, toDate, fromDate);
                var taxonomyVocabularies = GetTaxonomyVocabularies(exportDto.PortalId, toDate, fromDate);
                if (taxonomyTerms.Count > 0 || taxonomyVocabularies.Count > 0)
                {
                    var scopeTypes = CBO.FillCollection<TaxonomyScopeType>(DataProvider.Instance().GetAllScopeTypes());
                    //Update the total items count in the check points. This should be updated only once.
                    CheckPoint.TotalItems = CheckPoint.TotalItems <= 0 ? scopeTypes.Count : CheckPoint.TotalItems;
                    if (CheckPoint.TotalItems == scopeTypes.Count)
                    {
                        vocabularyTypes = CBO.FillCollection<TaxonomyVocabularyType>(DataProvider.Instance().GetAllVocabularyTypes());
                        taxonomyTerms = GetTaxonomyTerms(exportDto.PortalId, toDate, fromDate);
                        taxonomyVocabularies = GetTaxonomyVocabularies(exportDto.PortalId, toDate, fromDate);
                        CheckPoint.TotalItems += taxonomyTerms.Count + taxonomyVocabularies.Count;
                    }
                    CheckPointStageCallback(this);

                    Repository.CreateItems(scopeTypes);
                    //Result.AddSummary("Exported Taxonomy Scopes", scopeTypes.Count.ToString()); -- not imported so don't show
                    //CheckPoint.ProcessedItems += scopeTypes.Count;
                }
                CheckPoint.Progress = 25;

                if (taxonomyVocabularies == null) taxonomyVocabularies = GetTaxonomyVocabularies(exportDto.PortalId, toDate, fromDate);
                if (taxonomyTerms.Count > 0 || taxonomyVocabularies.Count > 0)
                {
                    if (vocabularyTypes == null)
                        vocabularyTypes = CBO.FillCollection<TaxonomyVocabularyType>(DataProvider.Instance().GetAllVocabularyTypes());
                    Repository.CreateItems(vocabularyTypes);
                    //Result.AddSummary("Exported Vocabulary Types", vocabularyTypes.Count.ToString()); -- not imported so don't show
                    //CheckPoint.ProcessedItems += vocabularyTypes.Count;
                }

                Repository.CreateItems(taxonomyTerms);
                Result.AddSummary("Exported Vocabularies", taxonomyTerms.Count.ToString());
                CheckPoint.Progress = 75;
                CheckPoint.ProcessedItems += taxonomyTerms.Count;
                CheckPoint.Stage++;
                if (CheckPointStageCallback(this)) return;

                if (taxonomyVocabularies == null) taxonomyVocabularies = GetTaxonomyVocabularies(exportDto.PortalId, toDate, fromDate);
                Repository.CreateItems(taxonomyVocabularies);
                Result.AddSummary("Exported Terms", taxonomyVocabularies.Count.ToString());
                CheckPoint.Progress = 100;
                CheckPoint.ProcessedItems += taxonomyVocabularies.Count;
                CheckPoint.Stage++;
                CheckPoint.Completed = true;
                CheckPointStageCallback(this);
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="GetImportTotal">
          <declaration><![CDATA[public override int GetImportTotal()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="152" sc="9" el="154" ec="10">Components\Services\VocabularyService.cs</location>
            <body hash="01dd384ba882b4ae2801dc56cc114a84"><![CDATA[{
            return Repository.GetCount<TaxonomyVocabulary>() + Repository.GetCount<TaxonomyTerm>();
        }]]></body>
          </codeblock>
        </method>
        <method name="GetTaxonomyTerms">
          <declaration><![CDATA[private static List<TaxonomyTerm> GetTaxonomyTerms(int portalId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="106" sc="9" el="108" ec="10">Components\Services\VocabularyService.cs</location>
            <body hash="d3087ebc46dc4e65b60131938ae1b47e"><![CDATA[{
            return CBO.FillCollection<TaxonomyTerm>(DataProvider.Instance().GetAllTerms(portalId, toDate, fromDate));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetTaxonomyVocabularies">
          <declaration><![CDATA[private static List<TaxonomyVocabulary> GetTaxonomyVocabularies(int portalId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="111" sc="9" el="113" ec="10">Components\Services\VocabularyService.cs</location>
            <body hash="2a88e1246391f66bc459946a8b0d2648"><![CDATA[{
            return CBO.FillCollection<TaxonomyVocabulary>(DataProvider.Instance().GetAllVocabularies(portalId, toDate, fromDate));
        }]]></body>
          </codeblock>
        </method>
        <method name="ImportData">
          <declaration><![CDATA[public override void ImportData(ExportImportJob importJob, ImportDto importDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="116" sc="9" el="149" ec="10">Components\Services\VocabularyService.cs</location>
            <body hash="e379c05372d09e5c447ec88c51b34640"><![CDATA[{
            if (CheckPoint.Stage > 0) return;
            if (CheckCancelled(importJob)) return;

            //Update the total items count in the check points. This should be updated only once.
            CheckPoint.TotalItems = CheckPoint.TotalItems = CheckPoint.TotalItems <= 0 ? GetImportTotal() : CheckPoint.TotalItems;
            if (CheckPoint.Stage == 0)
            {
                var otherScopeTypes = Repository.GetAllItems<TaxonomyScopeType>().ToList();
                //the table Taxonomy_ScopeTypes is used for lookup only and never changed/updated in the database
                //CheckPoint.Progress = 10;

                //var otherVocabularyTypes = Repository.GetAllItems<TaxonomyVocabularyType>().ToList();
                //the table Taxonomy_VocabularyTypes is used for lookup only and never changed/updated in the database
                CheckPoint.Progress = 20;

                var otherVocabularies = Repository.GetAllItems<TaxonomyVocabulary>().ToList();
                ProcessVocabularies(importJob, importDto, otherScopeTypes, otherVocabularies);
                Repository.UpdateItems(otherVocabularies);
                Result.AddSummary("Imported Vocabularies", otherVocabularies.Count.ToString());
                CheckPoint.Progress = 60;
                CheckPoint.ProcessedItems += otherVocabularies.Count;

                var otherTaxonomyTerms = Repository.GetAllItems<TaxonomyTerm>().ToList();
                ProcessTaxonomyTerms(importJob, importDto, otherVocabularies, otherTaxonomyTerms);
                Repository.UpdateItems(otherTaxonomyTerms);
                Result.AddSummary("Imported Terms", otherTaxonomyTerms.Count.ToString());
                CheckPoint.Progress = 100;
                CheckPoint.ProcessedItems += otherTaxonomyTerms.Count;
                CheckPoint.Stage++;
                CheckPoint.Completed = true;
                CheckPointStageCallback(this);
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="ProcessTaxonomyTerms">
          <declaration><![CDATA[private void ProcessTaxonomyTerms(ExportImportJob importJob, ImportDto importDto, IList<TaxonomyVocabulary> otherVocabularies, IList<TaxonomyTerm> otherTaxonomyTerms)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="223" sc="9" el="288" ec="10">Components\Services\VocabularyService.cs</location>
            <body hash="68b704f16455ca23f5d60a667a8e73d1"><![CDATA[{
            var dataService = Util.GetDataService();
            //var vocabularyController = new VocabularyController();
            var localTaxonomyTerms = GetTaxonomyTerms(importDto.PortalId, DateUtils.GetDatabaseUtcTime().AddYears(1), null);
            foreach (var other in otherTaxonomyTerms)
            {
                var createdBy = Common.Util.GetUserIdByName(importJob, other.CreatedByUserID, other.CreatedByUserName);
                var modifiedBy = Common.Util.GetUserIdByName(importJob, other.LastModifiedByUserID, other.LastModifiedByUserName);

                var vocabulary = otherVocabularies.FirstOrDefault(v => v.VocabularyID == other.VocabularyID);
                var vocabularyId = vocabulary?.LocalId ?? 0;
                var local = localTaxonomyTerms.FirstOrDefault(t => t.Name == other.Name && t.VocabularyID == vocabularyId);

                if (local != null)
                {
                    other.LocalId = local.TermID;
                    switch (importDto.CollisionResolution)
                    {
                        case CollisionResolution.Ignore:
                            Result.AddLogEntry("Ignored taxonomy", other.Name);
                            break;
                        case CollisionResolution.Overwrite:
                            var parent = other.ParentTermID.HasValue
                                ? otherTaxonomyTerms.FirstOrDefault(v => v.TermID == other.ParentTermID.Value)
                                : null;
                            var term = new Term(other.Name, other.Description, vocabularyId)
                            {
                                TermId = local.TermID,
                                ParentTermId = parent?.LocalId,
                                Weight = other.Weight,
                            };

                            if (term.ParentTermId.HasValue)
                            {
                                dataService.UpdateHeirarchicalTerm(term, modifiedBy);
                            }
                            else
                            {
                                dataService.UpdateSimpleTerm(term, modifiedBy);
                            }
                            DataCache.ClearCache(string.Format(DataCache.TermCacheKey, term.TermId));
                            Result.AddLogEntry("Updated taxonomy", other.Name);
                            break;
                        default:
                            throw new ArgumentOutOfRangeException(importDto.CollisionResolution.ToString());
                    }
                }
                else
                {
                    var parent = other.ParentTermID.HasValue
                        ? otherTaxonomyTerms.FirstOrDefault(v => v.TermID == other.ParentTermID.Value)
                        : null;
                    var term = new Term(other.Name, other.Description, vocabularyId)
                    {
                        ParentTermId = parent?.LocalId,
                        Weight = other.Weight,
                    };


                    other.LocalId = term.ParentTermId.HasValue
                        ? dataService.AddHeirarchicalTerm(term, createdBy)
                        : dataService.AddSimpleTerm(term, createdBy);
                    Result.AddLogEntry("Added taxonomy", other.Name);
                }
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="ProcessVocabularies">
          <declaration><![CDATA[private void ProcessVocabularies(ExportImportJob importJob, ImportDto importDto, IList<TaxonomyScopeType> otherScopeTypes, IEnumerable<TaxonomyVocabulary> otherVocabularies)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="158" sc="9" el="219" ec="10">Components\Services\VocabularyService.cs</location>
            <body hash="b32516f60233d248204054747f1a2cae"><![CDATA[{
            var changed = false;
            var dataService = Util.GetDataService();
            var localVocabularies = GetTaxonomyVocabularies(importDto.PortalId, DateUtils.GetDatabaseUtcTime().AddYears(1), null);
            foreach (var other in otherVocabularies)
            {
                var createdBy = Common.Util.GetUserIdByName(importJob, other.CreatedByUserID, other.CreatedByUserName);
                var modifiedBy = Common.Util.GetUserIdByName(importJob, other.LastModifiedByUserID, other.LastModifiedByUserName);
                var local = localVocabularies.FirstOrDefault(t => t.Name == other.Name);
                var scope = otherScopeTypes.FirstOrDefault(s => s.ScopeTypeID == other.ScopeTypeID);

                var scopeId = other.ScopeID ?? Null.NullInteger;
                if (scope != null && scope.ScopeType.Equals("Application", StringComparison.InvariantCultureIgnoreCase))
                {
                    scopeId = Null.NullInteger;
                }
                else if (scope != null && scope.ScopeType.Equals("Portal", StringComparison.InvariantCultureIgnoreCase))
                {
                    scopeId = importDto.PortalId;
                }

                if (local != null)
                {
                    other.LocalId = local.VocabularyID;
                    switch (importDto.CollisionResolution)
                    {
                        case CollisionResolution.Ignore:
                            Result.AddLogEntry("Ignored vocabulary", other.Name);
                            break;
                        case CollisionResolution.Overwrite:
                            var vocabulary = new Vocabulary(other.Name, other.Description)
                            {
                                IsSystem = other.IsSystem,
                                Weight = other.Weight,
                                ScopeId = scopeId,
                                ScopeTypeId = scope?.LocalId ?? other.ScopeTypeID,
                            };
                            dataService.UpdateVocabulary(vocabulary, modifiedBy);
                            Result.AddLogEntry("Updated vocabulary", other.Name);
                            changed = true;
                            break;
                        default:
                            throw new ArgumentOutOfRangeException(importDto.CollisionResolution.ToString());
                    }
                }
                else
                {
                    var vocabulary = new Vocabulary(other.Name, other.Description, (VocabularyType)other.VocabularyTypeID)
                    {
                        IsSystem = other.IsSystem,
                        Weight = other.Weight,
                        ScopeId = scopeId,
                        ScopeTypeId = scope?.LocalId ?? other.ScopeTypeID,
                    };
                    other.LocalId = dataService.AddVocabulary(vocabulary, createdBy);
                    Result.AddLogEntry("Added vocabulary", other.Name);
                    changed = true;
                }
            }
            if (changed)
                DataCache.ClearCache(DataCache.VocabularyCacheKey);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Category">
          <declaration><![CDATA[public override string Category]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="38" sc="44" el="38" ec="75">Components\Services\VocabularyService.cs</location>
            <body hash="43ca8789a58e6238ee1eda127b21bd68"><![CDATA[Constants.Category_Vocabularie]]></body>
          </codeblock>
        </property>
        <property name="ParentCategory">
          <declaration><![CDATA[public override string ParentCategory]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="40" sc="50" el="40" ec="54">Components\Services\VocabularyService.cs</location>
            <body hash="40a8712b29ac76182ed0c4f632b7d543"><![CDATA[nul]]></body>
          </codeblock>
        </property>
        <property name="Priority">
          <declaration><![CDATA[public override uint Priority]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="WorkflowsExportService">
      <declaration><![CDATA[public class WorkflowsExportService : BasePortableService]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public WorkflowsExportService()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ExportData">
          <declaration><![CDATA[public override void ExportData(ExportImportJob exportJob, ExportDto exportDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="56" sc="9" el="95" ec="10">Components\Services\WorkflowsExportService.cs</location>
            <body hash="afca9f96e2a2b69b6008182ead655017"><![CDATA[{
            if (CheckPoint.Stage > 0) return;
            if (CheckCancelled(exportJob)) return;

            var fromDate = (exportDto.FromDateUtc ?? Constants.MinDbTime).ToLocalTime();
            var toDate = exportDto.ToDateUtc.ToLocalTime();

            var contentWorkflows = GetWorkflows(exportDto.PortalId, exportDto.IncludeDeletions);
            if (contentWorkflows.Count > 0)
            {
                var defaultWorkflowId = TabWorkflowSettings.Instance.GetDefaultTabWorkflowId(exportDto.PortalId);
                var defaultWorkflow = contentWorkflows.FirstOrDefault(w => w.WorkflowID == defaultWorkflowId);
                if (defaultWorkflow != null)
                {
                    defaultWorkflow.IsDefault = true;
                }

                CheckPoint.TotalItems = contentWorkflows.Count;
                Repository.CreateItems(contentWorkflows);
                Result.AddLogEntry("Exported ContentWorkflows", contentWorkflows.Count.ToString());

                foreach (var workflow in contentWorkflows)
                {
                    var contentWorkflowStates = GetWorkflowStates(workflow.WorkflowID);
                    Repository.CreateItems(contentWorkflowStates, workflow.Id);

                    foreach (var workflowState in contentWorkflowStates)
                    {
                        var contentWorkflowStatePermissions = GetWorkflowStatePermissions(workflowState.StateID, toDate, fromDate);
                        Repository.CreateItems(contentWorkflowStatePermissions, workflowState.Id);
                    }
                }
            }

            CheckPoint.Progress = 100;
            CheckPoint.Completed = true;
            CheckPoint.Stage++;
            CheckPoint.StageData = null;
            CheckPointStageCallback(this);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetImportTotal">
          <declaration><![CDATA[public override int GetImportTotal()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="49" sc="9" el="51" ec="10">Components\Services\WorkflowsExportService.cs</location>
            <body hash="01dd384ba882b4ae2801dc56cc114a84"><![CDATA[{
            return Repository.GetCount<TaxonomyVocabulary>() + Repository.GetCount<TaxonomyTerm>();
        }]]></body>
          </codeblock>
        </method>
        <method name="GetWorkflows">
          <declaration><![CDATA[private static List<ExportWorkflow> GetWorkflows(int portalId, bool includeDeletions)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="98" sc="9" el="101" ec="10">Components\Services\WorkflowsExportService.cs</location>
            <body hash="5c85477d0b5bb8148ccf9dff94e2af6d"><![CDATA[{
            return CBO.FillCollection<ExportWorkflow>(
                DataProvider.Instance().GetAllWorkflows(portalId, includeDeletions));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetWorkflowStatePermissions">
          <declaration><![CDATA[private static List<ExportWorkflowStatePermission> GetWorkflowStatePermissions(int stateId, DateTime toDate, DateTime? fromDate)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="111" sc="9" el="114" ec="10">Components\Services\WorkflowsExportService.cs</location>
            <body hash="caa214d5321911a1dc4d4806f35efd67"><![CDATA[{
            return CBO.FillCollection<ExportWorkflowStatePermission>(
                DataProvider.Instance().GetAllWorkflowStatePermissions(stateId, toDate, fromDate));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetWorkflowStates">
          <declaration><![CDATA[private static List<ExportWorkflowState> GetWorkflowStates(int workflowId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="104" sc="9" el="107" ec="10">Components\Services\WorkflowsExportService.cs</location>
            <body hash="ba84eb945ad84f5f6b1e54cad5e93b08"><![CDATA[{
            return CBO.FillCollection<ExportWorkflowState>(
                DataProvider.Instance().GetAllWorkflowStates(workflowId));
        }]]></body>
          </codeblock>
        </method>
        <method name="ImportData">
          <declaration><![CDATA[public override void ImportData(ExportImportJob importJob, ImportDto importDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="121" sc="9" el="304" ec="10">Components\Services\WorkflowsExportService.cs</location>
            <body hash="1f4e7d1f5d0ce78b343c1a2603b3e24a"><![CDATA[{
            if (CheckCancelled(importJob) || CheckPoint.Stage >= 1 || CheckPoint.Completed || CheckPointStageCallback(this))
            {
                return;
            }

            var workflowManager = WorkflowManager.Instance;
            var workflowStateManager = WorkflowStateManager.Instance;
            var portalId = importJob.PortalId;
            var importWorkflows = Repository.GetAllItems<ExportWorkflow>().ToList();
            var existWorkflows = workflowManager.GetWorkflows(portalId).ToList();
            var defaultTabWorkflowId = importWorkflows.FirstOrDefault(w => w.IsDefault)?.WorkflowID ?? 1;
            CheckPoint.TotalItems = CheckPoint.TotalItems <= 0 ? importWorkflows.Count : CheckPoint.TotalItems;

            #region importing workflows

            foreach (var importWorkflow in importWorkflows)
            {
                var workflow = existWorkflows.FirstOrDefault(w => w.WorkflowName == importWorkflow.WorkflowName);
                if (workflow != null)
                {
                    if (!importWorkflow.IsSystem && importDto.CollisionResolution == CollisionResolution.Overwrite)
                    {
                        if (workflow.Description != importWorkflow.Description ||
                            workflow.WorkflowKey != importWorkflow.WorkflowKey)
                        {
                            workflow.Description = importWorkflow.Description;
                            workflow.WorkflowKey = importWorkflow.WorkflowKey;
                            workflowManager.UpdateWorkflow(workflow);
                            Result.AddLogEntry("Updated workflow", workflow.WorkflowName);
                        }
                    }
                }
                else
                {
                    workflow = new Workflow
                    {
                        PortalID = portalId,
                        WorkflowName = importWorkflow.WorkflowName,
                        Description = importWorkflow.Description,
                        WorkflowKey = importWorkflow.WorkflowKey,
                    };

                    workflowManager.AddWorkflow(workflow);
                    Result.AddLogEntry("Added workflow", workflow.WorkflowName);

                    if (importWorkflow.WorkflowID == defaultTabWorkflowId)
                    {
                        TabWorkflowSettings.Instance.SetDefaultTabWorkflowId(portalId, workflow.WorkflowID);
                    }
                }

                importWorkflow.LocalId = workflow.WorkflowID;

                #region importing workflow states

                var importStates = Repository.GetRelatedItems<ExportWorkflowState>(importWorkflow.Id).ToList();
                foreach (var importState in importStates)
                {
                    var workflowState = workflow.States.FirstOrDefault(s => s.StateName == importState.StateName);
                    if (workflowState != null)
                    {
                        if (!workflowState.IsSystem)
                        {
                            workflowState.Order = importState.Order;
                            workflowState.IsSystem = false;
                            workflowState.SendNotification = importState.SendNotification;
                            workflowState.SendNotificationToAdministrators = importState.SendNotificationToAdministrators;
                            workflowStateManager.UpdateWorkflowState(workflowState);
                            Result.AddLogEntry("Updated workflow state", workflowState.StateID.ToString());
                        }
                    }
                    else
                    {
                        workflowState = new WorkflowState
                        {
                            StateName = importState.StateName,
                            WorkflowID = workflow.WorkflowID,
                            Order = importState.Order,
                            IsSystem = importState.IsSystem,
                            SendNotification = importState.SendNotification,
                            SendNotificationToAdministrators = importState.SendNotificationToAdministrators
                        };
                        WorkflowStateManager.Instance.AddWorkflowState(workflowState);
                        Result.AddLogEntry("Added workflow state", workflowState.StateID.ToString());
                    }
                    importState.LocalId = workflowState.StateID;

                    #region importin permissions

                    if (!workflowState.IsSystem)
                    {
                        var importPermissions = Repository.GetRelatedItems<ExportWorkflowStatePermission>(importState.Id).ToList();
                        foreach (var importPermission in importPermissions)
                        {
                            var permissionId = DataProvider.Instance().GetPermissionId(
                                importPermission.PermissionCode, importPermission.PermissionKey, importPermission.PermissionName);

                            if (permissionId != null)
                            {
                                var noRole = Convert.ToInt32(Globals.glbRoleNothing);
                                var permission = new WorkflowStatePermission
                                {
                                    PermissionID = permissionId ?? -1,
                                    StateID = workflowState.StateID,
                                    RoleID = noRole,
                                    UserID = -1,
                                    AllowAccess = importPermission.AllowAccess,
                                    //TODO: ModuleDefID = ??? what value to set here ?
                                };

                                if (importPermission.UserID != null && importPermission.UserID > 0 && !string.IsNullOrEmpty(importPermission.Username))
                                {
                                    var userId = UserController.GetUserByName(importDto.PortalId, importPermission.Username)?.UserID;
                                    if (userId == null)
                                    {
                                        Result.AddLogEntry("Couldn't add tab permission; User is undefined!",
                                            $"{importPermission.PermissionKey} - {importPermission.PermissionID}", ReportLevel.Warn);
                                        continue;
                                    }
                                    permission.UserID = userId.Value;
                                }

                                if (importPermission.RoleID != null && importPermission.RoleID > noRole && !string.IsNullOrEmpty(importPermission.RoleName))
                                {
                                    var roleId = Util.GetRoleIdByName(importDto.PortalId, importPermission.RoleID ?? noRole, importPermission.RoleName);
                                    if (roleId == null)
                                    {
                                        Result.AddLogEntry("Couldn't add tab permission; Role is undefined!",
                                            $"{importPermission.PermissionKey} - {importPermission.PermissionID}", ReportLevel.Warn);
                                        continue;
                                    }
                                    permission.RoleID = roleId.Value;
                                }

                                try
                                {
                                    var existingPermissions = workflowStateManager.GetWorkflowStatePermissionByState(workflowState.StateID);
                                    var local = existingPermissions.FirstOrDefault(
                                        x => x.PermissionCode == importPermission.PermissionCode &&
                                             x.PermissionKey == importPermission.PermissionKey
                                             && x.PermissionName == importPermission.PermissionName &&
                                             (x.RoleName == importPermission.RoleName || string.IsNullOrEmpty(x.RoleName) && string.IsNullOrEmpty(importPermission.RoleName))
                                             &&
                                             (x.Username == importPermission.Username || string.IsNullOrEmpty(x.Username) && string.IsNullOrEmpty(importPermission.Username)));


                                    if (local != null)
                                    {
                                        workflowStateManager.AddWorkflowStatePermission(permission, -1);
                                        importPermission.LocalId = permission.WorkflowStatePermissionID;
                                        Result.AddLogEntry("Added workflow state permission", permission.WorkflowStatePermissionID.ToString());
                                    }
                                }
                                catch (Exception ex)
                                {
                                    Result.AddLogEntry("Exception adding workflow state permission", ex.Message, ReportLevel.Error);
                                }
                            }
                        }
                    }

                    #endregion
                }

                #endregion

                Repository.UpdateItems(importStates);
                Result.AddSummary("Imported Workflow", importWorkflows.Count.ToString());
                CheckPoint.ProcessedItems++;
                CheckPointStageCallback(this); // no need to return; very small amount of data processed
            }

            #endregion

            Repository.UpdateItems(importWorkflows);

            CheckPoint.Stage++;
            CheckPoint.StageData = null;
            CheckPoint.Progress = 100;
            CheckPoint.TotalItems = importWorkflows.Count;
            CheckPoint.ProcessedItems = importWorkflows.Count;
            CheckPointStageCallback(this);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Category">
          <declaration><![CDATA[public override string Category]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="42" sc="44" el="42" ec="72">Components\Services\WorkflowsExportService.cs</location>
            <body hash="41aeb534ce705afb235beb46a083612b"><![CDATA[Constants.Category_Workflow]]></body>
          </codeblock>
        </property>
        <property name="ParentCategory">
          <declaration><![CDATA[public override string ParentCategory]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="44" sc="50" el="44" ec="54">Components\Services\WorkflowsExportService.cs</location>
            <body hash="40a8712b29ac76182ed0c4f632b7d543"><![CDATA[nul]]></body>
          </codeblock>
        </property>
        <property name="Priority">
          <declaration><![CDATA[public override uint Priority]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="Dnn.ExportImport.Services">
    <class name="ExportImportController">
      <declaration><![CDATA[public class ExportImportController : DnnApiController]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ExportImportController()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AllJobs">
          <declaration><![CDATA[public HttpResponseMessage AllJobs(int portal, int? pageSize = 10, int? pageIndex = 0, int? jobType = null, string keywords = null)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="137" sc="9" el="147" ec="10">Services\ExportImportController.cs</location>
            <body hash="4b03e1c0c269ac0c45548d5292369a3d"><![CDATA[{
            if (!UserInfo.IsSuperUser && portal != PortalSettings.PortalId)
            {
                var error = Localization.GetString("NotPortalAdmin", Constants.SharedResources);
                return Request.CreateErrorResponse(HttpStatusCode.BadRequest, error);
            }
            var controller = new BaseController();
            var jobs = controller.GetAllJobs(portal, PortalSettings.PortalId, pageSize, pageIndex, jobType, keywords);
            jobs?.ConvertToLocal(UserInfo);
            return Request.CreateResponse(HttpStatusCode.OK, jobs);
        }]]></body>
          </codeblock>
        </method>
        <method name="CancelProcess">
          <declaration><![CDATA[public HttpResponseMessage CancelProcess([FromUri] int jobId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="97" sc="9" el="102" ec="10">Services\ExportImportController.cs</location>
            <body hash="c614e1836526722c51ae5e1d2c18c6db"><![CDATA[{
            var controller = new BaseController();
            var cancelStatus = controller.CancelJob(UserInfo.IsSuperUser ? -1 : PortalSettings.PortalId, jobId);
            return Request.CreateResponse(
                cancelStatus ? HttpStatusCode.OK : HttpStatusCode.BadRequest, new { success = cancelStatus });
        }]]></body>
          </codeblock>
        </method>
        <method name="Export">
          <declaration><![CDATA[public HttpResponseMessage Export(ExportDto exportDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="40" sc="9" el="45" ec="10">Services\ExportImportController.cs</location>
            <body hash="7342674ed59481ee28db780fefa81a33"><![CDATA[{
            var controller = new ExportController();
            var jobId = controller.QueueOperation(PortalSettings.UserId, exportDto);

            return Request.CreateResponse(HttpStatusCode.OK, new { jobId });
        }]]></body>
          </codeblock>
        </method>
        <method name="GetImportPackages">
          <declaration><![CDATA[public HttpResponseMessage GetImportPackages(string keyword = "", string order = "newest", int pageIndex = 0, int pageSize = 10)]]></declaration>
          <documentation>
            <summary>
 Get list of packages to import
 </summary>
 <param name="keyword">Keyword to search the import package. This will look into the package name and description</param>
 <param name="order">Order by which the packages list should be sorted. Allowed values: newest, oldest, name</param>
 <param name="pageIndex">Page index to get</param>
 <param name="pageSize">Page size. Should not be more than 100.</param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="85" sc="9" el="91" ec="10">Services\ExportImportController.cs</location>
            <body hash="315529820e080d88ec4c87a59e0b79ab"><![CDATA[{
            var controller = new ImportController();
            int total;
            var packages = controller.GetImportPackages(out total, keyword, order, pageIndex, pageSize).ToList();
            packages.ForEach(package => package.ConvertToLocal(UserInfo));
            return Request.CreateResponse(HttpStatusCode.OK, new { packages, total });
        }]]></body>
          </codeblock>
        </method>
        <method name="Import">
          <declaration><![CDATA[public HttpResponseMessage Import(ImportDto importDto)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="50" sc="9" el="59" ec="10">Services\ExportImportController.cs</location>
            <body hash="92072d0149bd554923b31c3da0053360"><![CDATA[{
            var controller = new ImportController();
            string message;
            if (controller.VerifyImportPackage(importDto.PackageId, null, out message))
            {
                var jobId = controller.QueueOperation(PortalSettings.UserId, importDto);
                return Request.CreateResponse(HttpStatusCode.OK, new { jobId });
            }
            return Request.CreateErrorResponse(HttpStatusCode.BadRequest, message);
        }]]></body>
          </codeblock>
        </method>
        <method name="JobDetails">
          <declaration><![CDATA[public HttpResponseMessage JobDetails(int jobId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="151" sc="9" el="159" ec="10">Services\ExportImportController.cs</location>
            <body hash="29dc2b20ae61cc6485a7ef6cec724080"><![CDATA[{
            var controller = new BaseController();
            var job = controller.GetJobDetails(UserInfo.IsSuperUser ? -1 : PortalSettings.PortalId, jobId);
            job?.ConvertToLocal(UserInfo);
            return job != null
                ? Request.CreateResponse(HttpStatusCode.OK, job)
                : Request.CreateResponse(HttpStatusCode.BadRequest,
                    new { message = Localization.GetString("JobNotExist", Constants.SharedResources) });
        }]]></body>
          </codeblock>
        </method>
        <method name="LastJobTime">
          <declaration><![CDATA[public HttpResponseMessage LastJobTime(int portal, JobType jobType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="117" sc="9" el="132" ec="10">Services\ExportImportController.cs</location>
            <body hash="f0010e5f14e70ac99b141e2156f9f697"><![CDATA[{
            if (!UserInfo.IsSuperUser && portal != PortalSettings.PortalId)
            {
                var error = Localization.GetString("NotPortalAdmin", Constants.SharedResources);
                return Request.CreateErrorResponse(HttpStatusCode.BadRequest, error);
            }

            if (portal < 0)
                return Request.CreateErrorResponse(HttpStatusCode.BadRequest,
                    Localization.GetString("InvalidPortal", Constants.SharedResources));

            var controller = new BaseController();
            var lastTime = controller.GetLastJobTime(portal, jobType);
            return Request.CreateResponse(HttpStatusCode.OK,
                new { lastTime = Util.GetDateTimeString(lastTime) });
        }]]></body>
          </codeblock>
        </method>
        <method name="RemoveJob">
          <declaration><![CDATA[public HttpResponseMessage RemoveJob([FromUri] int jobId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="108" sc="9" el="113" ec="10">Services\ExportImportController.cs</location>
            <body hash="7d70589daf356a5ad0e7fbc6a6bc2ce8"><![CDATA[{
            var controller = new BaseController();
            var cancelStatus = controller.RemoveJob(UserInfo.IsSuperUser ? -1 : PortalSettings.PortalId, jobId);
            return Request.CreateResponse(
                cancelStatus ? HttpStatusCode.OK : HttpStatusCode.BadRequest, new { success = cancelStatus });
        }]]></body>
          </codeblock>
        </method>
        <method name="VerifyImportPackage">
          <declaration><![CDATA[public HttpResponseMessage VerifyImportPackage(string packageId)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="63" sc="9" el="72" ec="10">Services\ExportImportController.cs</location>
            <body hash="27e7898315a0d66353feae0030044210"><![CDATA[{
            var controller = new ImportController();
            string message;
            var summary = new ImportExportSummary();
            var isValid = controller.VerifyImportPackage(packageId, summary, out message);
            summary.ConvertToLocal(UserInfo);
            return isValid
                ? Request.CreateResponse(HttpStatusCode.OK, summary)
                : Request.CreateErrorResponse(HttpStatusCode.BadRequest, message);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="ServiceRouteMapper">
      <declaration><![CDATA[public class ServiceRouteMapper : IServiceRouteMapper]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ServiceRouteMapper()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="RegisterRoutes">
          <declaration><![CDATA[public void RegisterRoutes(IMapRoute routeManager)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="29" sc="9" el="34" ec="10">Services\ServiceRouteMapper.cs</location>
            <body hash="71cc18fdaaadb3fce1b39a5333b06777"><![CDATA[{
            routeManager.MapHttpRoute("SiteExportImport",
                                      "default",
                                      "{controller}/{action}",
                                      new[] { typeof(ServiceRouteMapper).Namespace });
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
</root>