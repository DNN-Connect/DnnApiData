<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<root file="ClientDependency.Core.dll" version="00.00.00" generated="2017-08-10 13:30:38Z" generationTime="17.1268098">
  <namespace name="ClientDependency.Core">
    <class name="BaseLoader">
      <declaration><![CDATA[public class BaseLoader]]></declaration>
      <documentation>
        <summary>
 The base class that exposees all of the basic operations used for rendering dependencies in a request
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[internal List<ProviderDependencyList> Dependencies = new List<ProviderDependencyList>();]]></declaration>
          <documentation>
            <summary>
 Tracks all dependencies and maintains a deduplicated list
 </summary>
          </documentation>
          <codeblock>
            <location sl="21" sc="9" el="312" ec="99">BaseLoader.cs</location>
            <body hash="67dfa225fcedec269dfe78ac610057ee"><![CDATA[public BaseLoader(HttpContextBase http)
        {
            CurrentContext = http;

            //add the pre-defined paths to the instance collection
            foreach (var p in PathsCollection.GetPaths())
            {
                AddPath(p);
            }
        }

        protected HttpContextBase CurrentContext { get; private set; }

        public BaseFileRegistrationProvider Provider { get; set; }

        /// <summary>
        /// Tracks all dependencies and maintains a deduplicated list
        /// </summary>
        internal List<ProviderDependencyList> Dependencies = new List<ProviderDependencyList>();
        /// <summary>
        /// Tracks all paths and maintains a deduplicated list
        /// </summary>
        internal HashSet<IClientDependencyPath> Paths = new HashSet<IClientDependencyPath>();

        /// <summary>
        /// Adds a path to the current loader
        /// </summary>
        /// <param name="pathNameAlias"></param>
        /// <param name="path"></param>
        /// <returns>Returns the current loader instance so you can chain calls together</returns>
        public BaseLoader AddPath(string pathNameAlias, string path)
        {
            AddPath(new BasicPath() { Name = pathNameAlias, Path = path });
            return this;
        }

        /// <summary>
        /// Adds a path to the current loader
        /// </summary>
        /// <param name="path"></param>
        /// <returns>Returns the current loader instance so you can chain calls together</returns>
        public BaseLoader AddPath(IClientDependencyPath path)
        {
            Paths.Add(path);
            return this;
        }		

        /// <summary>
        /// Registers dependencies with the specified provider.
        /// </summary>
        /// <param name="provider"></param>
        /// <param name="dependencies"></param>
        /// <param name="paths"></param>
        /// <param name="currProviders"></param>
        /// <remarks>
        /// This is the top most overloaded method
        /// </remarks>
        public void RegisterClientDependencies(BaseFileRegistrationProvider provider, IEnumerable<IClientDependencyFile> dependencies, IEnumerable<IClientDependencyPath> paths, ProviderCollection currProviders)
        {
            var asList = dependencies.ToList();

            //find or create the ProviderDependencyList for the provider
            ProviderDependencyList currList = Dependencies
                .Where(x => x.ProviderIs(provider))
                .DefaultIfEmpty(new ProviderDependencyList(provider))
                .SingleOrDefault();

            if (currList == null) return;
            
            //add the dependencies that don't have a provider specified
            currList.AddDependencies(asList
                .Where(x => string.IsNullOrEmpty(x.ForceProvider)));
            
            //add the list if it is new
            if (!Dependencies.Contains(currList) && currList.Dependencies.Count > 0)
                Dependencies.Add(currList); 

            //we need to look up all of the dependencies that have forced providers, 
            //check if we've got a provider list for it, create one if not and add the dependencies
            //to it.
            var allProviderNamesInList = asList
                .Select(x => x.ForceProvider)
                .Where(x => !string.IsNullOrEmpty(x))
                .Distinct();
            var forceProviders = (from provName in allProviderNamesInList
                                  where currProviders[provName] != null
                                  select (BaseFileRegistrationProvider) currProviders[provName]).ToList();
            foreach (var prov in forceProviders)
            {
                //find or create the ProviderDependencyList for the prov
                var p = prov;
                var forceList = Dependencies
                    .Where(x => x.ProviderIs(prov))
                    .DefaultIfEmpty(new ProviderDependencyList(prov))
                    .SingleOrDefault();

                if (forceList == null) continue;

                //add the dependencies that don't have a force provider specified
                forceList.AddDependencies(asList
                    .Where(x => x.ForceProvider == p.Name));
                //add the list if it is new
                if (!Dependencies.Contains(forceList))
                    Dependencies.Add(forceList);
            }

            //add the paths, ensure no dups
            Paths.UnionWith(paths);
        }

        public void RegisterClientDependencies(List<IClientDependencyFile> dependencies, params IClientDependencyPath[] paths)
        {
            //We will combine both the MVC and web forms providers here to pass in to the method since this method could be executing
            //under the webforms context or the mvc context. This list as a parameter is used only for forced providers and wont
            //matter if it includes the webforms and mvc ones together since they will only ever render when they are in their own
            //context. This is better than checking if it is a System.Web.UI.Page handler currently IMO, plus the provider names
            //between mvc and webforms are generally different.
            var combinedCollection = new ProviderCollection();
            foreach (ProviderBase p in ClientDependencySettings.Instance.MvcRendererCollection)
                combinedCollection.Add(p);
            foreach (ProviderBase p in ClientDependencySettings.Instance.FileRegistrationProviderCollection)
                combinedCollection.Add(p);

            RegisterClientDependencies(Provider, dependencies, paths, combinedCollection);
        }

        public void RegisterClientDependencies(List<IClientDependencyFile> dependencies, IEnumerable<IClientDependencyPath> paths)
        {
            //We will combine both the MVC and web forms providers here to pass in to the method since this method could be executing
            //under the webforms context or the mvc context. This list as a parameter is used only for forced providers and wont
            //matter if it includes the webforms and mvc ones together since they will only ever render when they are in their own
            //context. This is better than checking if it is a System.Web.UI.Page handler currently IMO, plus the provider names
            //between mvc and webforms are generally different.
            var combinedCollection = new ProviderCollection();
            foreach (ProviderBase p in ClientDependencySettings.Instance.MvcRendererCollection)
                combinedCollection.Add(p);
            foreach (ProviderBase p in ClientDependencySettings.Instance.FileRegistrationProviderCollection)
                combinedCollection.Add(p);

            RegisterClientDependencies(Provider, dependencies, paths, combinedCollection);
        }
        
        #region RegisterDependency overloads

        public void RegisterDependency(IClientDependencyFile file)
        {
            RegisterDependency(file, null);
        }

        public void RegisterDependency(IClientDependencyFile file, object htmlAttributes)
        {
            RegisterDependency(
                file.Group,
                file.Priority,
                file.FilePath,
                file.PathNameAlias,
                file.DependencyType,
                htmlAttributes,
                file.ForceProvider,
                file.ForceBundle);
        }

        public void RegisterDependency(string filePath, ClientDependencyType type)
        {
            RegisterDependency(filePath, "", type);
        }

        public void RegisterDependency(string filePath, ClientDependencyType type, object htmlAttributes)
        {
            RegisterDependency(filePath, "", type, htmlAttributes);
        }

        public void RegisterDependency(int priority, string filePath, ClientDependencyType type)
        {
            RegisterDependency(priority, filePath, "", type);
        }

		public void RegisterDependency(int group, int priority, string filePath, ClientDependencyType type)
		{
			RegisterDependency(group, priority, filePath, "", type);
		}
		
		public void RegisterDependency(int priority, string filePath, ClientDependencyType type, object htmlAttributes)
        {
            RegisterDependency(priority, filePath, "", type, htmlAttributes);
        }

		public void RegisterDependency(int group, int priority, string filePath, ClientDependencyType type, object htmlAttributes)
		{
			RegisterDependency(group, priority, filePath, "", type, htmlAttributes);
		}
		
		public void RegisterDependency(string filePath, string pathNameAlias, ClientDependencyType type)
        {
            RegisterDependency(Constants.DefaultPriority, filePath, pathNameAlias, type);
        }

        public void RegisterDependency(string filePath, string pathNameAlias, ClientDependencyType type, object htmlAttributes)
        {
            RegisterDependency(Constants.DefaultPriority, filePath, pathNameAlias, type, htmlAttributes);
        }

        public void RegisterDependency(int priority, string filePath, string pathNameAlias, ClientDependencyType type)
        {
            RegisterDependency(Constants.DefaultGroup, priority, filePath, pathNameAlias, type);
        }

        public void RegisterDependency(int priority, string filePath, string pathNameAlias, ClientDependencyType type, object htmlAttributes)
        {
            RegisterDependency(Constants.DefaultGroup, priority, filePath, pathNameAlias, type, htmlAttributes);
        }

		// those two methods below actually do the work
		// everything else above is just overloads

		/// <summary>
		/// Dynamically registers a dependency into the loader at runtime.
		/// This is similar to ScriptManager.RegisterClientScriptInclude.
		/// Registers a file dependency with the default provider.
		/// </summary>
		/// <param name="group">The dependencies group identifier.</param>
		/// <param name="priority">The dependency priority.</param>
		/// <param name="filePath">The dependency file.</param>
		/// <param name="pathNameAlias">The dependency files path alias.</param>
		/// <param name="type">The type of the dependency.</param>
		public void RegisterDependency(int group, int priority, string filePath, string pathNameAlias, ClientDependencyType type)
        {
            var file = new BasicFile(type) { Group = group, Priority = priority, FilePath = filePath, PathNameAlias = pathNameAlias };
            RegisterClientDependencies(new List<IClientDependencyFile> { file }, new List<IClientDependencyPath>()); //send an empty paths collection
        }

        [Obsolete("Use the overloaded RegisterDependency method instead")]
		public void RegisterDependencyWithProvider(int group, int priority, string filePath, string pathNameAlias, ClientDependencyType type, string provider)
        {
            RegisterDependency(group, priority, filePath, pathNameAlias, type, provider);
        }

        public void RegisterDependency(int group, int priority, string filePath, string pathNameAlias, ClientDependencyType type, string provider)
        {
            RegisterDependency(group, priority, filePath, pathNameAlias, type, provider, false);
        }

        public void RegisterDependency(int group, int priority, string filePath, string pathNameAlias, ClientDependencyType type, string provider, bool forceBundle)
        {
            RegisterDependency(group, priority, filePath, pathNameAlias, type, null, provider, forceBundle);
        }

		/// <summary>
		/// Dynamically registers a dependency into the loader at runtime.
		/// This is similar to ScriptManager.RegisterClientScriptInclude.
		/// Registers a file dependency with the default provider.
		/// </summary>
		/// <param name="group">The dependencies group identifier.</param>
		/// <param name="priority">The dependency priority.</param>
		/// <param name="filePath">The dependency file.</param>
		/// <param name="pathNameAlias">The dependency files path alias.</param>
		/// <param name="type">The type of the dependency.</param>
		/// <param name="htmlAttributes"></param>
		public void RegisterDependency(int group, int priority, string filePath, string pathNameAlias, ClientDependencyType type, object htmlAttributes)
		{
		    RegisterDependency(group, priority, filePath, pathNameAlias, type, htmlAttributes, null);
		}

        public void RegisterDependency(int group, int priority, string filePath, string pathNameAlias, ClientDependencyType type, object htmlAttributes, string provider)
        {
            RegisterDependency(group, priority, filePath, pathNameAlias, type, htmlAttributes, null, false);
        }

        public void RegisterDependency(int group, int priority, string filePath, string pathNameAlias, ClientDependencyType type, object htmlAttributes, string provider, bool forceBundle)
        {
            var file = new BasicFile(type)
            {
                Group = group,
                Priority = priority,
                FilePath = filePath,
                PathNameAlias = pathNameAlias,
                ForceProvider = provider,
                ForceBundle = forceBundle
            };

            //now add the attributes to the list
            foreach (var d in htmlAttributes.ToDictionary())
            {
                file.HtmlAttributes.Add(d.Key, d.Value.ToString());
            }

            RegisterClientDependencies(new List<IClientDependencyFile> { file }, new List<IClientDependencyPath>()); //send an empty paths collection
        }

        #endregion

        private readonly List<BundleDefinition> _registeredBundles = new List<BundleDefinition>();]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AddPath">
          <declaration><![CDATA[public BaseLoader AddPath(string pathNameAlias, string path)]]></declaration>
          <documentation>
            <summary>
 Adds a path to the current loader
 </summary>
 <param name="pathNameAlias"></param>
 <param name="path"></param>
 <returns>Returns the current loader instance so you can chain calls together</returns></documentation>
          <codeblock>
            <location sl="52" sc="9" el="55" ec="10">BaseLoader.cs</location>
            <body hash="34b13b7b41eab1e4beae69a7ad268ce7"><![CDATA[{
            AddPath(new BasicPath() { Name = pathNameAlias, Path = path });
            return this;
        }]]></body>
          </codeblock>
        </method>
        <method name="AddPath">
          <declaration><![CDATA[public BaseLoader AddPath(IClientDependencyPath path)]]></declaration>
          <documentation>
            <summary>
 Adds a path to the current loader
 </summary>
 <param name="path"></param>
 <returns>Returns the current loader instance so you can chain calls together</returns></documentation>
          <codeblock>
            <location sl="63" sc="9" el="66" ec="10">BaseLoader.cs</location>
            <body hash="6e14be51da86b94855020b0a103ff087"><![CDATA[{
            Paths.Add(path);
            return this;
        }]]></body>
          </codeblock>
        </method>
        <method name="EnsureBundleRegistered">
          <declaration><![CDATA[private void EnsureBundleRegistered(BundleResult result)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="334" sc="9" el="348" ec="10">BaseLoader.cs</location>
            <body hash="fd17f169153dbb1d086a31130b6c12ca"><![CDATA[{
            var found = result;
            if (found == null) return;

            //only register once
            if (_registeredBundles.Contains(found.Definition)) return;

            //set the flag so it doesn't get registered for output again
            _registeredBundles.Add(found.Definition);

            foreach (var file in found.Files)
            {
                RegisterDependency(file);
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="EnsureCssBundleRegistered">
          <declaration><![CDATA[internal void EnsureCssBundleRegistered(string bundleName)]]></declaration>
          <documentation>
            <summary>
 Ensures that the bundle with the specified name is registered for output
 </summary>
          </documentation>
          <codeblock>
            <location sl="328" sc="9" el="331" ec="10">BaseLoader.cs</location>
            <body hash="8ab0bddb76a9cc264cb94630d8f124f4"><![CDATA[{
            var found = BundleManager.GetCssBundle(bundleName);
            EnsureBundleRegistered(found);
        }]]></body>
          </codeblock>
        </method>
        <method name="EnsureJsBundleRegistered">
          <declaration><![CDATA[internal void EnsureJsBundleRegistered(string bundleName)]]></declaration>
          <documentation>
            <summary>
 Ensures that the bundle with the specified name is registered for output
 </summary>
 <param name="bundleName"></param></documentation>
          <codeblock>
            <location sl="319" sc="9" el="322" ec="10">BaseLoader.cs</location>
            <body hash="e73a4f2c48e97781119e9ab9a95e1b9d"><![CDATA[{
            var found = BundleManager.GetJsBundle(bundleName);
            EnsureBundleRegistered(found);
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterClientDependencies">
          <declaration><![CDATA[public void RegisterClientDependencies(BaseFileRegistrationProvider provider, IEnumerable<IClientDependencyFile> dependencies, IEnumerable<IClientDependencyPath> paths, ProviderCollection currProviders)]]></declaration>
          <documentation>
            <summary>
 Registers dependencies with the specified provider.
 </summary>
 <param name="provider"></param>
 <param name="dependencies"></param>
 <param name="paths"></param>
 <param name="currProviders"></param>
 <remarks>
 This is the top most overloaded method
 </remarks></documentation>
          <codeblock>
            <location sl="79" sc="9" el="129" ec="10">BaseLoader.cs</location>
            <body hash="42ff9d58dbbcc17d377c09640ff4541b"><![CDATA[{
            var asList = dependencies.ToList();

            //find or create the ProviderDependencyList for the provider
            ProviderDependencyList currList = Dependencies
                .Where(x => x.ProviderIs(provider))
                .DefaultIfEmpty(new ProviderDependencyList(provider))
                .SingleOrDefault();

            if (currList == null) return;
            
            //add the dependencies that don't have a provider specified
            currList.AddDependencies(asList
                .Where(x => string.IsNullOrEmpty(x.ForceProvider)));
            
            //add the list if it is new
            if (!Dependencies.Contains(currList) && currList.Dependencies.Count > 0)
                Dependencies.Add(currList); 

            //we need to look up all of the dependencies that have forced providers, 
            //check if we've got a provider list for it, create one if not and add the dependencies
            //to it.
            var allProviderNamesInList = asList
                .Select(x => x.ForceProvider)
                .Where(x => !string.IsNullOrEmpty(x))
                .Distinct();
            var forceProviders = (from provName in allProviderNamesInList
                                  where currProviders[provName] != null
                                  select (BaseFileRegistrationProvider) currProviders[provName]).ToList();
            foreach (var prov in forceProviders)
            {
                //find or create the ProviderDependencyList for the prov
                var p = prov;
                var forceList = Dependencies
                    .Where(x => x.ProviderIs(prov))
                    .DefaultIfEmpty(new ProviderDependencyList(prov))
                    .SingleOrDefault();

                if (forceList == null) continue;

                //add the dependencies that don't have a force provider specified
                forceList.AddDependencies(asList
                    .Where(x => x.ForceProvider == p.Name));
                //add the list if it is new
                if (!Dependencies.Contains(forceList))
                    Dependencies.Add(forceList);
            }

            //add the paths, ensure no dups
            Paths.UnionWith(paths);
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterClientDependencies">
          <declaration><![CDATA[public void RegisterClientDependencies(List<IClientDependencyFile> dependencies, params IClientDependencyPath[] paths)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="132" sc="9" el="145" ec="10">BaseLoader.cs</location>
            <body hash="09026545356a807e923b24fd888249ff"><![CDATA[{
            //We will combine both the MVC and web forms providers here to pass in to the method since this method could be executing
            //under the webforms context or the mvc context. This list as a parameter is used only for forced providers and wont
            //matter if it includes the webforms and mvc ones together since they will only ever render when they are in their own
            //context. This is better than checking if it is a System.Web.UI.Page handler currently IMO, plus the provider names
            //between mvc and webforms are generally different.
            var combinedCollection = new ProviderCollection();
            foreach (ProviderBase p in ClientDependencySettings.Instance.MvcRendererCollection)
                combinedCollection.Add(p);
            foreach (ProviderBase p in ClientDependencySettings.Instance.FileRegistrationProviderCollection)
                combinedCollection.Add(p);

            RegisterClientDependencies(Provider, dependencies, paths, combinedCollection);
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterClientDependencies">
          <declaration><![CDATA[public void RegisterClientDependencies(List<IClientDependencyFile> dependencies, IEnumerable<IClientDependencyPath> paths)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="148" sc="9" el="161" ec="10">BaseLoader.cs</location>
            <body hash="09026545356a807e923b24fd888249ff"><![CDATA[{
            //We will combine both the MVC and web forms providers here to pass in to the method since this method could be executing
            //under the webforms context or the mvc context. This list as a parameter is used only for forced providers and wont
            //matter if it includes the webforms and mvc ones together since they will only ever render when they are in their own
            //context. This is better than checking if it is a System.Web.UI.Page handler currently IMO, plus the provider names
            //between mvc and webforms are generally different.
            var combinedCollection = new ProviderCollection();
            foreach (ProviderBase p in ClientDependencySettings.Instance.MvcRendererCollection)
                combinedCollection.Add(p);
            foreach (ProviderBase p in ClientDependencySettings.Instance.FileRegistrationProviderCollection)
                combinedCollection.Add(p);

            RegisterClientDependencies(Provider, dependencies, paths, combinedCollection);
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependency">
          <declaration><![CDATA[public void RegisterDependency(IClientDependencyFile file)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="166" sc="9" el="168" ec="10">BaseLoader.cs</location>
            <body hash="8e387b834acea4217d634847c25dbca1"><![CDATA[{
            RegisterDependency(file, null);
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependency">
          <declaration><![CDATA[public void RegisterDependency(IClientDependencyFile file, object htmlAttributes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="171" sc="9" el="181" ec="10">BaseLoader.cs</location>
            <body hash="ea30b776a52b218dbc0ea5c358700558"><![CDATA[{
            RegisterDependency(
                file.Group,
                file.Priority,
                file.FilePath,
                file.PathNameAlias,
                file.DependencyType,
                htmlAttributes,
                file.ForceProvider,
                file.ForceBundle);
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependency">
          <declaration><![CDATA[public void RegisterDependency(string filePath, ClientDependencyType type)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="184" sc="9" el="186" ec="10">BaseLoader.cs</location>
            <body hash="4bf09939df933be37753132f7c68b0b6"><![CDATA[{
            RegisterDependency(filePath, "", type);
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependency">
          <declaration><![CDATA[public void RegisterDependency(string filePath, ClientDependencyType type, object htmlAttributes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="189" sc="9" el="191" ec="10">BaseLoader.cs</location>
            <body hash="9e26489464032a9f8a132f0a1495b012"><![CDATA[{
            RegisterDependency(filePath, "", type, htmlAttributes);
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependency">
          <declaration><![CDATA[public void RegisterDependency(int priority, string filePath, ClientDependencyType type)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="194" sc="9" el="196" ec="10">BaseLoader.cs</location>
            <body hash="45496d22b42c1d290a8f952ff987797b"><![CDATA[{
            RegisterDependency(priority, filePath, "", type);
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependency">
          <declaration><![CDATA[public void RegisterDependency(int group, int priority, string filePath, ClientDependencyType type)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="199" sc="3" el="201" ec="4">BaseLoader.cs</location>
            <body hash="291a4ceaa0b6df18e5c97a7771789f54"><![CDATA[{
			RegisterDependency(group, priority, filePath, "", type);
		}]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependency">
          <declaration><![CDATA[public void RegisterDependency(int priority, string filePath, ClientDependencyType type, object htmlAttributes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="204" sc="9" el="206" ec="10">BaseLoader.cs</location>
            <body hash="6e1ed8a81d88f7a7085188a94c58f60c"><![CDATA[{
            RegisterDependency(priority, filePath, "", type, htmlAttributes);
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependency">
          <declaration><![CDATA[public void RegisterDependency(int group, int priority, string filePath, ClientDependencyType type, object htmlAttributes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="209" sc="3" el="211" ec="4">BaseLoader.cs</location>
            <body hash="a1cec61c16c1f937cb0acbbf41949d4f"><![CDATA[{
			RegisterDependency(group, priority, filePath, "", type, htmlAttributes);
		}]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependency">
          <declaration><![CDATA[public void RegisterDependency(string filePath, string pathNameAlias, ClientDependencyType type)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="214" sc="9" el="216" ec="10">BaseLoader.cs</location>
            <body hash="2e5a1545f300f9fa94d320de8dd0f86d"><![CDATA[{
            RegisterDependency(Constants.DefaultPriority, filePath, pathNameAlias, type);
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependency">
          <declaration><![CDATA[public void RegisterDependency(string filePath, string pathNameAlias, ClientDependencyType type, object htmlAttributes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="219" sc="9" el="221" ec="10">BaseLoader.cs</location>
            <body hash="e1cc3cdfb92f1f4806020c3fc60a060e"><![CDATA[{
            RegisterDependency(Constants.DefaultPriority, filePath, pathNameAlias, type, htmlAttributes);
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependency">
          <declaration><![CDATA[public void RegisterDependency(int priority, string filePath, string pathNameAlias, ClientDependencyType type)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="224" sc="9" el="226" ec="10">BaseLoader.cs</location>
            <body hash="1aa0d62f1679de00364005d659b229e0"><![CDATA[{
            RegisterDependency(Constants.DefaultGroup, priority, filePath, pathNameAlias, type);
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependency">
          <declaration><![CDATA[public void RegisterDependency(int priority, string filePath, string pathNameAlias, ClientDependencyType type, object htmlAttributes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="229" sc="9" el="231" ec="10">BaseLoader.cs</location>
            <body hash="ff999bcf986a59e223d7b328000a5151"><![CDATA[{
            RegisterDependency(Constants.DefaultGroup, priority, filePath, pathNameAlias, type, htmlAttributes);
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependency">
          <declaration><![CDATA[public void RegisterDependency(int group, int priority, string filePath, string pathNameAlias, ClientDependencyType type)]]></declaration>
          <documentation>
            <summary>
 Dynamically registers a dependency into the loader at runtime.
 This is similar to ScriptManager.RegisterClientScriptInclude.
 Registers a file dependency with the default provider.
 </summary>
 <param name="group">The dependencies group identifier.</param>
 <param name="priority">The dependency priority.</param>
 <param name="filePath">The dependency file.</param>
 <param name="pathNameAlias">The dependency files path alias.</param>
 <param name="type">The type of the dependency.</param></documentation>
          <codeblock>
            <location sl="247" sc="9" el="250" ec="10">BaseLoader.cs</location>
            <body hash="afd3d924bcf90b7d1b986b57ae6acb15"><![CDATA[{
            var file = new BasicFile(type) { Group = group, Priority = priority, FilePath = filePath, PathNameAlias = pathNameAlias };
            RegisterClientDependencies(new List<IClientDependencyFile> { file }, new List<IClientDependencyPath>()); //send an empty paths collection
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependency">
          <declaration><![CDATA[public void RegisterDependency(int group, int priority, string filePath, string pathNameAlias, ClientDependencyType type, string provider)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="259" sc="9" el="261" ec="10">BaseLoader.cs</location>
            <body hash="09659262d09e1a914bed064900b4d18b"><![CDATA[{
            RegisterDependency(group, priority, filePath, pathNameAlias, type, provider, false);
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependency">
          <declaration><![CDATA[public void RegisterDependency(int group, int priority, string filePath, string pathNameAlias, ClientDependencyType type, string provider, bool forceBundle)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="264" sc="9" el="266" ec="10">BaseLoader.cs</location>
            <body hash="dd302c30a0d49ae066b3be78d416ad46"><![CDATA[{
            RegisterDependency(group, priority, filePath, pathNameAlias, type, null, provider, forceBundle);
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependency">
          <declaration><![CDATA[public void RegisterDependency(int group, int priority, string filePath, string pathNameAlias, ClientDependencyType type, object htmlAttributes)]]></declaration>
          <documentation>
            <summary>
 Dynamically registers a dependency into the loader at runtime.
 This is similar to ScriptManager.RegisterClientScriptInclude.
 Registers a file dependency with the default provider.
 </summary>
 <param name="group">The dependencies group identifier.</param>
 <param name="priority">The dependency priority.</param>
 <param name="filePath">The dependency file.</param>
 <param name="pathNameAlias">The dependency files path alias.</param>
 <param name="type">The type of the dependency.</param>
 <param name="htmlAttributes"></param></documentation>
          <codeblock>
            <location sl="280" sc="3" el="282" ec="4">BaseLoader.cs</location>
            <body hash="2ba15a110c4b75cd0c3b1cf0a244944a"><![CDATA[{
		    RegisterDependency(group, priority, filePath, pathNameAlias, type, htmlAttributes, null);
		}]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependency">
          <declaration><![CDATA[public void RegisterDependency(int group, int priority, string filePath, string pathNameAlias, ClientDependencyType type, object htmlAttributes, string provider)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="285" sc="9" el="287" ec="10">BaseLoader.cs</location>
            <body hash="235065317d23fd6d3bf0b327efa9ea98"><![CDATA[{
            RegisterDependency(group, priority, filePath, pathNameAlias, type, htmlAttributes, null, false);
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependency">
          <declaration><![CDATA[public void RegisterDependency(int group, int priority, string filePath, string pathNameAlias, ClientDependencyType type, object htmlAttributes, string provider, bool forceBundle)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="290" sc="9" el="308" ec="10">BaseLoader.cs</location>
            <body hash="edccbc22c50e3c5e9229730bd4c66f2f"><![CDATA[{
            var file = new BasicFile(type)
            {
                Group = group,
                Priority = priority,
                FilePath = filePath,
                PathNameAlias = pathNameAlias,
                ForceProvider = provider,
                ForceBundle = forceBundle
            };

            //now add the attributes to the list
            foreach (var d in htmlAttributes.ToDictionary())
            {
                file.HtmlAttributes.Add(d.Key, d.Value.ToString());
            }

            RegisterClientDependencies(new List<IClientDependencyFile> { file }, new List<IClientDependencyPath>()); //send an empty paths collection
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependencyWithProvider">
          <deprecation>Use the overloaded RegisterDependency method instead</deprecation>
          <declaration><![CDATA[public void RegisterDependencyWithProvider(int group, int priority, string filePath, string pathNameAlias, ClientDependencyType type, string provider)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="254" sc="9" el="256" ec="10">BaseLoader.cs</location>
            <body hash="2f4a19393899077f3cc4bc657eb67c51"><![CDATA[{
            RegisterDependency(group, priority, filePath, pathNameAlias, type, provider);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_registeredBundles">
          <declaration><![CDATA[private readonly List<BundleDefinition> _registeredBundles = new List<BundleDefinition>();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Dependencies">
          <declaration><![CDATA[internal List<ProviderDependencyList> Dependencies = new List<ProviderDependencyList>();]]></declaration>
          <documentation>
            <summary>
 Tracks all dependencies and maintains a deduplicated list
 </summary>
          </documentation>
        </field>
        <field name="Paths">
          <declaration><![CDATA[internal HashSet<IClientDependencyPath> Paths = new HashSet<IClientDependencyPath>();]]></declaration>
          <documentation>
            <summary>
 Tracks all paths and maintains a deduplicated list
 </summary>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="CurrentContext">
          <declaration><![CDATA[protected HttpContextBase CurrentContext]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="32" sc="52" el="32" ec="56">BaseLoader.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="32" sc="57" el="32" ec="69">BaseLoader.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
        <property name="Provider">
          <declaration><![CDATA[public BaseFileRegistrationProvider Provider]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="34" sc="56" el="34" ec="60">BaseLoader.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="34" sc="61" el="34" ec="65">BaseLoader.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="BasicFile">
      <declaration><![CDATA[public class BasicFile : IClientDependencyFile, IHaveHtmlAttributes]]></declaration>
      <documentation>
        <summary>
 Represents a dependency file
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public BasicFile(ClientDependencyType type)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="15" sc="3" el="24" ec="10">BasicFile.cs</location>
            <body hash="04dcb2f67e5b9fb24192767ded4e02e2"><![CDATA[public BasicFile(ClientDependencyType type)
		{
			DependencyType = type;
		    HtmlAttributes = new Dictionary<string, string>();
		    Priority = Constants.DefaultPriority;
		    Group = Constants.DefaultGroup;
            Name = "";
            Version = "";
            ForceVersion = false;
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Equals">
          <declaration><![CDATA[protected bool Equals(BasicFile other)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="67" sc="9" el="69" ec="10">BasicFile.cs</location>
            <body hash="a6023baaf1caa9a2a898282ab4c29378"><![CDATA[{
            return string.Equals(FilePath, other.FilePath, StringComparison.InvariantCultureIgnoreCase) && DependencyType == other.DependencyType && Priority == other.Priority && Group == other.Group && string.Equals(PathNameAlias, other.PathNameAlias, StringComparison.InvariantCultureIgnoreCase) && string.Equals(ForceProvider, other.ForceProvider) && Equals(HtmlAttributes, other.HtmlAttributes);
        }]]></body>
          </codeblock>
        </method>
        <method name="Equals">
          <declaration><![CDATA[public override bool Equals(object obj)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="72" sc="9" el="77" ec="10">BasicFile.cs</location>
            <body hash="4b4ca0b8919f6aff4bef21efcc70de95"><![CDATA[{
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            if (obj.GetType() != this.GetType()) return false;
            return Equals((BasicFile) obj);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetHashCode">
          <declaration><![CDATA[public override int GetHashCode()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="80" sc="9" el="92" ec="10">BasicFile.cs</location>
            <body hash="267a052211d4ea7a3cfa131b0d1a8351"><![CDATA[{
            unchecked
            {
                int hashCode = (FilePath != null ? FilePath.GetHashCode() : 0);
                hashCode = (hashCode*397) ^ (int) DependencyType;
                hashCode = (hashCode*397) ^ Priority;
                hashCode = (hashCode*397) ^ Group;
                hashCode = (hashCode*397) ^ (PathNameAlias != null ? PathNameAlias.GetHashCode() : 0);
                hashCode = (hashCode*397) ^ (ForceProvider != null ? ForceProvider.GetHashCode() : 0);
                hashCode = (hashCode*397) ^ (HtmlAttributes != null ? HtmlAttributes.GetHashCode() : 0);
                return hashCode;
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="DependencyType">
          <declaration><![CDATA[public ClientDependencyType DependencyType]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="29" sc="48" el="29" ec="52">BasicFile.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="29" sc="53" el="29" ec="65">BasicFile.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
        <property name="FilePath">
          <declaration><![CDATA[public string FilePath]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="28" sc="34" el="28" ec="38">BasicFile.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="28" sc="39" el="28" ec="43">BasicFile.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ForceBundle">
          <declaration><![CDATA[public bool ForceBundle]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="37" sc="29" el="37" ec="33">BasicFile.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="37" sc="34" el="37" ec="38">BasicFile.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ForceProvider">
          <declaration><![CDATA[public string ForceProvider]]></declaration>
          <documentation>
            <summary>
 This can be empty and will use default provider
 </summary>
          </documentation>
          <codeblock>
            <location sl="36" sc="33" el="36" ec="37">BasicFile.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="36" sc="38" el="36" ec="42">BasicFile.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ForceVersion">
          <declaration><![CDATA[public bool ForceVersion]]></declaration>
          <documentation>
            <summary>
 Force this version to be used. Meant for skin designers that wish to override
 choices made by module developers or the framework.
 </summary>
          </documentation>
          <codeblock>
            <location sl="62" sc="36" el="62" ec="40">BasicFile.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="62" sc="41" el="62" ec="45">BasicFile.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Group">
          <declaration><![CDATA[public int Group]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="31" sc="22" el="31" ec="26">BasicFile.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="31" sc="27" el="31" ec="31">BasicFile.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="HtmlAttributes">
          <declaration><![CDATA[public IDictionary<string, string> HtmlAttributes]]></declaration>
          <documentation>
            <summary>
 Used to store additional attributes in the HTML markup for the item
 </summary>
 <remarks>
 Mostly used for CSS Media, but could be for anything
 </remarks></documentation>
          <codeblock>
            <location sl="45" sc="61" el="45" ec="65">BasicFile.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="45" sc="66" el="45" ec="78">BasicFile.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
        <property name="Name">
          <declaration><![CDATA[public string Name]]></declaration>
          <documentation>
            <summary>
 Name of a framework such as jQuery, Bootstrap, Angular, etc.
 </summary>
          </documentation>
          <codeblock>
            <location sl="50" sc="30" el="50" ec="34">BasicFile.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="50" sc="35" el="50" ec="39">BasicFile.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="PathNameAlias">
          <declaration><![CDATA[public string PathNameAlias]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="32" sc="33" el="32" ec="37">BasicFile.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="32" sc="38" el="32" ec="42">BasicFile.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Priority">
          <declaration><![CDATA[public int Priority]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="30" sc="25" el="30" ec="29">BasicFile.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="30" sc="30" el="30" ec="34">BasicFile.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Version">
          <declaration><![CDATA[public string Version]]></declaration>
          <documentation>
            <summary>
 Version of this resource if it is a framework
 Note this field is only used when Framework is specified
 </summary>
          </documentation>
          <codeblock>
            <location sl="56" sc="33" el="56" ec="37">BasicFile.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="56" sc="38" el="56" ec="42">BasicFile.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="BasicPath">
      <declaration><![CDATA[public class BasicPath : IClientDependencyPath]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public BasicPath()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="12" sc="9" el="12" ec="27">BasicPath.cs</location>
            <body hash="5f7038a0b3a3536ce1132707050328af"><![CDATA[public BasicPath(]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public BasicPath(string name, string path)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="13" sc="9" el="19" ec="10">BasicPath.cs</location>
            <body hash="472c57f3976df417dbc3d0e99916e073"><![CDATA[public BasicPath(string name, string path)
        {
            if (string.IsNullOrEmpty(name)) throw new ArgumentNullException("name");
            if (string.IsNullOrEmpty(path)) throw new ArgumentNullException("path");
            Name = name;
            Path = path;
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Equals">
          <declaration><![CDATA[protected bool Equals(BasicPath other)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="26" sc="6" el="29" ec="7">BasicPath.cs</location>
            <body hash="ddc193f39b8407a18d5345a6ae73cc99"><![CDATA[{
	        return string.Equals(Name, other.Name, StringComparison.InvariantCultureIgnoreCase)
	               && string.Equals(Path, other.Path, StringComparison.InvariantCultureIgnoreCase);
	    }]]></body>
          </codeblock>
        </method>
        <method name="Equals">
          <declaration><![CDATA[public override bool Equals(object obj)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="32" sc="6" el="37" ec="7">BasicPath.cs</location>
            <body hash="b84651479d869d5d00f8b580e70f5692"><![CDATA[{
	        if (ReferenceEquals(null, obj)) return false;
	        if (ReferenceEquals(this, obj)) return true;
	        if (obj.GetType() != this.GetType()) return false;
	        return Equals((BasicPath) obj);
	    }]]></body>
          </codeblock>
        </method>
        <method name="GetHashCode">
          <declaration><![CDATA[public override int GetHashCode()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="40" sc="6" el="45" ec="7">BasicPath.cs</location>
            <body hash="bea990891335b81bbd6dd47a38e5c441"><![CDATA[{
	        unchecked
	        {
	            return (Name.GetHashCode()*397) ^ Path.GetHashCode();
	        }
	    }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="ForceBundle">
          <declaration><![CDATA[public bool ForceBundle]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="23" sc="29" el="23" ec="33">BasicPath.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="23" sc="34" el="23" ec="38">BasicPath.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Name">
          <declaration><![CDATA[public string Name]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="21" sc="24" el="21" ec="28">BasicPath.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="21" sc="29" el="21" ec="33">BasicPath.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Path">
          <declaration><![CDATA[public string Path]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="22" sc="24" el="22" ec="28">BasicPath.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="22" sc="29" el="22" ec="33">BasicPath.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="BundleDefinition">
      <declaration><![CDATA[internal class BundleDefinition]]></declaration>
      <documentation>
        <summary>
 Defines all information relating to a pre-defined bundle
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public BundleDefinition(ClientDependencyType type, string name, int priority = 100, int group = 100)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="11" sc="9" el="21" ec="10">BundleDefinition.cs</location>
            <body hash="495ebab22709bdc88a31fefd6b3f00d0"><![CDATA[public BundleDefinition(
            ClientDependencyType type,
            string name, 
            int priority = Constants.DefaultPriority, int group = Constants.DefaultGroup)
        {
            if (name == null) throw new ArgumentNullException("name");
            Type = type;
            Name = name;
            Group = group;
            Priority = priority;
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Equals">
          <declaration><![CDATA[protected bool Equals(BundleDefinition other)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="29" sc="9" el="31" ec="10">BundleDefinition.cs</location>
            <body hash="9d4629b59514de2be0d49da40a3fa73a"><![CDATA[{
            return Type == other.Type && string.Equals(Name, other.Name);
        }]]></body>
          </codeblock>
        </method>
        <method name="Equals">
          <declaration><![CDATA[public override bool Equals(object obj)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="34" sc="9" el="39" ec="10">BundleDefinition.cs</location>
            <body hash="1b7c03cc9ef964d69bc96dc8b164d2bc"><![CDATA[{
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            if (obj.GetType() != this.GetType()) return false;
            return Equals((BundleDefinition) obj);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetHashCode">
          <declaration><![CDATA[public override int GetHashCode()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="42" sc="9" el="47" ec="10">BundleDefinition.cs</location>
            <body hash="d29a5911ce0c757beafbdb0998236514"><![CDATA[{
            unchecked
            {
                return ((int) Type*397) ^ Name.GetHashCode();
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Group">
          <declaration><![CDATA[public int Group]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="25" sc="28" el="25" ec="32">BundleDefinition.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="25" sc="33" el="25" ec="37">BundleDefinition.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Name">
          <declaration><![CDATA[public string Name]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="24" sc="30" el="24" ec="34">BundleDefinition.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="24" sc="35" el="24" ec="47">BundleDefinition.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
        <property name="Priority">
          <declaration><![CDATA[public int Priority]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="26" sc="31" el="26" ec="35">BundleDefinition.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="26" sc="36" el="26" ec="40">BundleDefinition.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Type">
          <declaration><![CDATA[public ClientDependencyType Type]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="23" sc="44" el="23" ec="48">BundleDefinition.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="23" sc="49" el="23" ec="61">BundleDefinition.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="BundleManager">
      <declaration><![CDATA[public static class BundleManager]]></declaration>
      <documentation>
        <summary>
 Allows creating pre-defined bundles for scrips and styles
 </summary>
      </documentation>
      <constructors>
        <constructor name=".cctor">
          <declaration><![CDATA[static BundleManager()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="17" sc="9" el="23" ec="199">BundleManager.cs</location>
            <body hash="3fa237df671a3ea72afdfc4dc29f94ed"><![CDATA[{
            GetHttpContextDelegate = () => new HttpContextWrapper(HttpContext.Current);
        }

        internal static Func<HttpContextBase> GetHttpContextDelegate { get; set; }

        private static readonly ConcurrentDictionary<BundleDefinition, IEnumerable<IClientDependencyFile>> Bundles = new ConcurrentDictionary<BundleDefinition, IEnumerable<IClientDependencyFile>>();]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ClearBundles">
          <declaration><![CDATA[internal static void ClearBundles()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="26" sc="9" el="28" ec="10">BundleManager.cs</location>
            <body hash="9adb8ef15e749dc4f6de59930baeb8e5"><![CDATA[{
            Bundles.Clear();
        }]]></body>
          </codeblock>
        </method>
        <method name="CreateCssBundle">
          <declaration><![CDATA[public static void CreateCssBundle(string name, params CssFile[] files)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="85" sc="9" el="87" ec="10">BundleManager.cs</location>
            <body hash="5974c7e24ecf62ef12157f12b229ffa4"><![CDATA[{
            Bundles.AddOrUpdate(new BundleDefinition(ClientDependencyType.Css, name), s => OrderFiles(files), (s, enumerable) => OrderFiles(files));
        }]]></body>
          </codeblock>
        </method>
        <method name="CreateCssBundle">
          <declaration><![CDATA[public static void CreateCssBundle(string name, int priority, params CssFile[] files)]]></declaration>
          <documentation>
            <summary>
 Creates a pre-defined bundle and sets the priority for each file supplied, unless any of the files already have a priority set
 </summary>
 <param name="name"></param>
 <param name="priority"></param>
 <param name="files"></param></documentation>
          <codeblock>
            <location sl="96" sc="9" el="105" ec="10">BundleManager.cs</location>
            <body hash="bc19b0d859342655ac480a687a637d25"><![CDATA[{
            //set priorities on files that don't have one set already
            var filesToChange = files.Where(x => x.Priority == Constants.DefaultPriority);
            foreach (var f in filesToChange)
            {
                f.Priority = priority;
            }

            Bundles.AddOrUpdate(new BundleDefinition(ClientDependencyType.Css, name), s => OrderFiles(files), (s, enumerable) => OrderFiles(files));
        }]]></body>
          </codeblock>
        </method>
        <method name="CreateCssBundle">
          <declaration><![CDATA[public static void CreateCssBundle(string name, int priority, int group, params CssFile[] files)]]></declaration>
          <documentation>
            <summary>
 Creates a pre-defined bundle and sets the priority and group for each file supplied, unless any of the files already have a priority/group set
 </summary>
 <param name="name"></param>
 <param name="priority"></param>
 <param name="group"></param>
 <param name="files"></param></documentation>
          <codeblock>
            <location sl="115" sc="9" el="130" ec="10">BundleManager.cs</location>
            <body hash="1f69a011ee559cf3153a85044060cacc"><![CDATA[{
            //set priorities on files that don't have one set already
            var filesToChange = files.Where(x => x.Priority == Constants.DefaultPriority);
            foreach (var f in filesToChange)
            {
                f.Priority = priority;
            }
            //set groups on files that don't have one set already
            filesToChange = files.Where(x => x.Group == Constants.DefaultGroup);
            foreach (var f in filesToChange)
            {
                f.Group = group;
            }

            Bundles.AddOrUpdate(new BundleDefinition(ClientDependencyType.Css, name), s => OrderFiles(files), (s, enumerable) => OrderFiles(files));
        }]]></body>
          </codeblock>
        </method>
        <method name="CreateJsBundle">
          <declaration><![CDATA[public static void CreateJsBundle(string name, params JavascriptFile[] files)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="135" sc="9" el="137" ec="10">BundleManager.cs</location>
            <body hash="dd4a57c5cd95c41489ff5933d73e8f7b"><![CDATA[{
            Bundles.AddOrUpdate(new BundleDefinition(ClientDependencyType.Javascript, name), s => OrderFiles(files), (s, enumerable) => OrderFiles(files));
        }]]></body>
          </codeblock>
        </method>
        <method name="CreateJsBundle">
          <declaration><![CDATA[public static void CreateJsBundle(string name, int priority, params JavascriptFile[] files)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="140" sc="9" el="142" ec="10">BundleManager.cs</location>
            <body hash="dd4a57c5cd95c41489ff5933d73e8f7b"><![CDATA[{
            Bundles.AddOrUpdate(new BundleDefinition(ClientDependencyType.Javascript, name), s => OrderFiles(files), (s, enumerable) => OrderFiles(files));
        }]]></body>
          </codeblock>
        </method>
        <method name="CreateJsBundle">
          <declaration><![CDATA[public static void CreateJsBundle(string name, int priority, int group, params JavascriptFile[] files)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="145" sc="9" el="147" ec="10">BundleManager.cs</location>
            <body hash="dd4a57c5cd95c41489ff5933d73e8f7b"><![CDATA[{
            Bundles.AddOrUpdate(new BundleDefinition(ClientDependencyType.Javascript, name), s => OrderFiles(files), (s, enumerable) => OrderFiles(files));
        }]]></body>
          </codeblock>
        </method>
        <method name="GetBundles">
          <declaration><![CDATA[internal static IDictionary<BundleDefinition, IEnumerable<IClientDependencyFile>> GetBundles()]]></declaration>
          <documentation>
            <summary>
 Returns all bundles registered
 </summary>
 <returns></returns></documentation>
          <codeblock>
            <location sl="35" sc="9" el="37" ec="10">BundleManager.cs</location>
            <body hash="0021f6d6bde1302d47b7846e2b819fdb"><![CDATA[{
            return Bundles;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetCssBundle">
          <declaration><![CDATA[internal static BundleResult GetCssBundle(string bundleName)]]></declaration>
          <documentation>
            <summary>
 Returns a css bundle by name
 </summary>
 <param name="bundleName"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="54" sc="9" el="59" ec="10">BundleManager.cs</location>
            <body hash="142089c78378766684a18bf3d81bb13f"><![CDATA[{
            var found = Bundles.Where(x => x.Key.Type == ClientDependencyType.Css && x.Key.Name.Equals(bundleName, StringComparison.InvariantCultureIgnoreCase));
            if (!found.Any()) return null;
            var b = found.First();
            return new BundleResult {Definition = b.Key, Files = b.Value};
        }]]></body>
          </codeblock>
        </method>
        <method name="GetCssBundles">
          <declaration><![CDATA[internal static IDictionary<BundleDefinition, IEnumerable<IClientDependencyFile>> GetCssBundles()]]></declaration>
          <documentation>
            <summary>
 Returns all Css bundles registered
 </summary>
 <returns></returns></documentation>
          <codeblock>
            <location sl="44" sc="9" el="46" ec="10">BundleManager.cs</location>
            <body hash="9d272d3373375f831f80e5861caed217"><![CDATA[{
            return Bundles.Where(x => x.Key.Type == ClientDependencyType.Css).ToDictionary(x => x.Key, x => x.Value);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetJsBundle">
          <declaration><![CDATA[internal static BundleResult GetJsBundle(string bundleName)]]></declaration>
          <documentation>
            <summary>
 Returns a js bundle by name
 </summary>
 <param name="bundleName"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="76" sc="9" el="81" ec="10">BundleManager.cs</location>
            <body hash="c36bbc396bf2b2e3d1b31e543116efda"><![CDATA[{
            var found = Bundles.Where(x => x.Key.Type == ClientDependencyType.Javascript && x.Key.Name.Equals(bundleName, StringComparison.InvariantCultureIgnoreCase));
            if (!found.Any()) return null;
            var b = found.First();
            return new BundleResult { Definition = b.Key, Files = b.Value };
        }]]></body>
          </codeblock>
        </method>
        <method name="GetJsBundles">
          <declaration><![CDATA[internal static IDictionary<BundleDefinition, IEnumerable<IClientDependencyFile>> GetJsBundles()]]></declaration>
          <documentation>
            <summary>
 Returns all js bundles registered
 </summary>
 <returns></returns></documentation>
          <codeblock>
            <location sl="66" sc="9" el="68" ec="10">BundleManager.cs</location>
            <body hash="f1201002d7394cbda8084cf5521f2311"><![CDATA[{
            return Bundles.Where(x => x.Key.Type == ClientDependencyType.Javascript).ToDictionary(x => x.Key, x => x.Value);
        }]]></body>
          </codeblock>
        </method>
        <method name="OrderFiles">
          <declaration><![CDATA[private static IEnumerable<IClientDependencyFile> OrderFiles(IList<IClientDependencyFile> files)]]></declaration>
          <documentation>
            <summary>
 This will order the files
 </summary>
 <param name="files"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="156" sc="9" el="158" ec="10">BundleManager.cs</location>
            <body hash="663e23caf481668f44b1e33092246082"><![CDATA[{
            return !files.Any() ? files : DependencySorter.SortItems(files);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="Bundles">
          <declaration><![CDATA[private static readonly ConcurrentDictionary<BundleDefinition, IEnumerable<IClientDependencyFile>> Bundles;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="GetHttpContextDelegate">
          <declaration><![CDATA[internal static Func<HttpContextBase> GetHttpContextDelegate]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="21" sc="72" el="21" ec="76">BundleManager.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="21" sc="77" el="21" ec="81">BundleManager.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="BundleResult">
      <declaration><![CDATA[internal class BundleResult]]></declaration>
      <documentation>
        <summary>
 Is returned when resolving a bundle
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public BundleResult()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Definition">
          <declaration><![CDATA[public BundleDefinition Definition]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="10" sc="46" el="10" ec="50">BundleResult.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="10" sc="51" el="10" ec="55">BundleResult.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Files">
          <declaration><![CDATA[public IEnumerable<IClientDependencyFile> Files]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="11" sc="59" el="11" ec="63">BundleResult.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="11" sc="64" el="11" ec="68">BundleResult.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ClientDependencyAttribute">
      <declaration><![CDATA[public class ClientDependencyAttribute : Attribute, IClientDependencyFile, IRequiresHtmlAttributesParsing, IHaveHtmlAttributes]]></declaration>
      <documentation>
        <summary>
 This attribute is used for data types that uses client assets like Javascript and CSS for liveediting.
 The Live Editing feature in umbraco will look for this attribute and preload all dependencies to the page
 to ensure that all client events and assets gets loaded
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ClientDependencyAttribute()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="15" sc="9" el="22" ec="10">ClientDependencyAttribute.cs</location>
            <body hash="2a94e3aa6b369fa754304a8089326783"><![CDATA[public ClientDependencyAttribute()
        {
            Priority = Constants.DefaultPriority;
            Group = Constants.DefaultGroup;
			PathNameAlias = "";
            HtmlAttributes = new Dictionary<string, string>();
            ForceVersion = false;
        }]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public ClientDependencyAttribute(ClientDependencyType dependencyType, string fullFilePath) : this(100, dependencyType, fullFilePath, string.Empty)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="25" sc="15" el="26" ec="4">ClientDependencyAttribute.cs</location>
            <body hash="b5640223bcb6b91c1be08dbdc4afe78e"><![CDATA[this(Constants.DefaultPriority, dependencyType, fullFilePath, string.Empty)
		{]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public ClientDependencyAttribute(ClientDependencyType dependencyType, string fileName, string pathNameAlias) : this(100, dependencyType, fileName, pathNameAlias)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="29" sc="15" el="30" ec="4">ClientDependencyAttribute.cs</location>
            <body hash="0d81b68f88738a389af5abc456207b21"><![CDATA[this(Constants.DefaultPriority, dependencyType, fileName, pathNameAlias)
		{]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public ClientDependencyAttribute(int priority, ClientDependencyType dependencyType, string fullFilePath) : this(priority, dependencyType, fullFilePath, string.Empty)]]></declaration>
          <documentation>
            <summary>
 Initializes a new instance of the <see cref="T:ClientDependency.Core.ClientDependencyAttribute" /> class.
 </summary>
 <param name="priority">The priority.</param>
 <param name="dependencyType">Type of the dependency.</param>
 <param name="fullFilePath">The file path to the dependency.</param></documentation>
          <codeblock>
            <location sl="39" sc="6" el="40" ec="4">ClientDependencyAttribute.cs</location>
            <body hash="28339834a53bac0620adebe0652b1960"><![CDATA[this(priority, dependencyType, fullFilePath, string.Empty)
		{]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public ClientDependencyAttribute(int priority, ClientDependencyType dependencyType, string fileName, string pathNameAlias) : this(100, priority, dependencyType, fileName, pathNameAlias, false)]]></declaration>
          <documentation>
            <summary>
 Initializes a new instance of the <see cref="T:ClientDependency.Core.ClientDependencyAttribute" /> class.
 </summary>
 <param name="priority">The priority.</param>
 <param name="dependencyType">Type of the dependency.</param>
 <param name="fileName"></param>
 <param name="pathNameAlias"></param></documentation>
          <codeblock>
            <location sl="51" sc="9" el="53" ec="4">ClientDependencyAttribute.cs</location>
            <body hash="1ffa843b1342b4fe7ef9aa496df4c29c"><![CDATA[this(Constants.DefaultGroup, priority, dependencyType, fileName, pathNameAlias, false)
        {
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public ClientDependencyAttribute(int group, int priority, ClientDependencyType dependencyType, string fileName, string pathNameAlias, bool forceBundle)]]></declaration>
          <documentation>
            <summary>
 Initializes a new instance of the <see cref="T:ClientDependency.Core.ClientDependencyAttribute" /> class.
 </summary>
 <param name="group"></param>
 <param name="priority">The priority.</param>
 <param name="dependencyType">Type of the dependency.</param>
 <param name="fileName"></param>
 <param name="pathNameAlias"></param></documentation>
          <codeblock>
            <location sl="63" sc="9" el="83" ec="10">ClientDependencyAttribute.cs</location>
            <body hash="6cd1193f012b8487aa752004a8d60f4f"><![CDATA[public ClientDependencyAttribute(int group, int priority, ClientDependencyType dependencyType, string fileName, string pathNameAlias, bool forceBundle)
        {
            if (String.IsNullOrEmpty(fileName))
                throw new ArgumentNullException("fileName");

            Priority = priority;

            Group = group;

            FilePath = fileName;
            PathNameAlias = pathNameAlias;

            DependencyType = dependencyType;
			ForceBundle = forceBundle;

            HtmlAttributes = new Dictionary<string, string>();

            Name = "";
            Version = "";
            ForceVersion = false;
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Equals">
          <declaration><![CDATA[protected bool Equals(ClientDependencyAttribute other)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="159" sc="9" el="161" ec="10">ClientDependencyAttribute.cs</location>
            <body hash="a6023baaf1caa9a2a898282ab4c29378"><![CDATA[{
            return string.Equals(FilePath, other.FilePath, StringComparison.InvariantCultureIgnoreCase) && DependencyType == other.DependencyType && Priority == other.Priority && Group == other.Group && string.Equals(PathNameAlias, other.PathNameAlias, StringComparison.InvariantCultureIgnoreCase) && string.Equals(ForceProvider, other.ForceProvider) && Equals(HtmlAttributes, other.HtmlAttributes);
        }]]></body>
          </codeblock>
        </method>
        <method name="Equals">
          <declaration><![CDATA[public override bool Equals(object obj)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="164" sc="9" el="169" ec="10">ClientDependencyAttribute.cs</location>
            <body hash="70b43de2e617f6d238251558af41ffb4"><![CDATA[{
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            if (obj.GetType() != this.GetType()) return false;
            return Equals((ClientDependencyAttribute)obj);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetHashCode">
          <declaration><![CDATA[public override int GetHashCode()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="172" sc="9" el="184" ec="10">ClientDependencyAttribute.cs</location>
            <body hash="4ffa17b75293b3c09efe53bb1ce94895"><![CDATA[{
            unchecked
            {
                int hashCode = (FilePath != null ? FilePath.GetHashCode() : 0);
                hashCode = (hashCode * 397) ^ (int)DependencyType;
                hashCode = (hashCode * 397) ^ Priority;
                hashCode = (hashCode * 397) ^ Group;
                hashCode = (hashCode * 397) ^ (PathNameAlias != null ? PathNameAlias.GetHashCode() : 0);
                hashCode = (hashCode * 397) ^ (ForceProvider != null ? ForceProvider.GetHashCode() : 0);
                hashCode = (hashCode * 397) ^ (HtmlAttributes != null ? HtmlAttributes.GetHashCode() : 0);
                return hashCode;
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="DependencyType">
          <declaration><![CDATA[public ClientDependencyType DependencyType]]></declaration>
          <documentation>
            <summary>
 Gets or sets the type of the dependency.
 </summary>
 <value>The type of the dependency.</value></documentation>
          <codeblock>
            <location sl="139" sc="54" el="139" ec="58">ClientDependencyAttribute.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="139" sc="59" el="139" ec="63">ClientDependencyAttribute.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="FilePath">
          <declaration><![CDATA[public string FilePath]]></declaration>
          <documentation>
            <summary>
 Gets or sets the file path.
 </summary>
 <value>The file path.</value></documentation>
          <codeblock>
            <location sl="109" sc="34" el="109" ec="38">ClientDependencyAttribute.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="109" sc="39" el="109" ec="43">ClientDependencyAttribute.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ForceBundle">
          <declaration><![CDATA[public bool ForceBundle]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="103" sc="35" el="103" ec="39">ClientDependencyAttribute.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="103" sc="40" el="103" ec="44">ClientDependencyAttribute.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ForceProvider">
          <declaration><![CDATA[public string ForceProvider]]></declaration>
          <documentation>
            <summary>
 This can be empty and will use default provider
 </summary>
          </documentation>
          <codeblock>
            <location sl="101" sc="39" el="101" ec="43">ClientDependencyAttribute.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="101" sc="44" el="101" ec="48">ClientDependencyAttribute.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ForceVersion">
          <declaration><![CDATA[public bool ForceVersion]]></declaration>
          <documentation>
            <summary>
 Force this version to be used. Meant for skin designers that wish to override
 choices made by module developers or the framework.
 </summary>
          </documentation>
          <codeblock>
            <location sl="156" sc="36" el="156" ec="40">ClientDependencyAttribute.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="156" sc="41" el="156" ec="45">ClientDependencyAttribute.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Group">
          <declaration><![CDATA[public int Group]]></declaration>
          <documentation>
            <summary>
 Gets or sets the group.
 </summary>
 <value>The group.</value></documentation>
          <codeblock>
            <location sl="96" sc="28" el="96" ec="32">ClientDependencyAttribute.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="96" sc="33" el="96" ec="37">ClientDependencyAttribute.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="HtmlAttributes">
          <declaration><![CDATA[public IDictionary<string, string> HtmlAttributes]]></declaration>
          <documentation>
            <summary>
 Used to store additional attributes in the HTML markup for the item
 </summary>
 <remarks>
 Mostly used for CSS Media, but could be for anything
 </remarks></documentation>
          <codeblock>
            <location sl="133" sc="61" el="133" ec="65">ClientDependencyAttribute.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="133" sc="66" el="133" ec="78">ClientDependencyAttribute.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
        <property name="HtmlAttributesAsString">
          <declaration><![CDATA[public string HtmlAttributesAsString]]></declaration>
          <documentation>
            <summary>
 Used to set the HtmlAttributes on this class via a string which is parsed
 </summary>
 <remarks>
 The syntax for the string must be: key1:value1,key2:value2   etc...
 </remarks></documentation>
          <codeblock>
            <location sl="125" sc="48" el="125" ec="52">ClientDependencyAttribute.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="125" sc="53" el="125" ec="57">ClientDependencyAttribute.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Name">
          <declaration><![CDATA[public string Name]]></declaration>
          <documentation>
            <summary>
 Name of a framework such as jQuery, Bootstrap, Angular, etc.
 </summary>
          </documentation>
          <codeblock>
            <location sl="144" sc="30" el="144" ec="34">ClientDependencyAttribute.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="144" sc="35" el="144" ec="39">ClientDependencyAttribute.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="PathNameAlias">
          <declaration><![CDATA[public string PathNameAlias]]></declaration>
          <documentation>
            <summary>
 The path alias to be pre-pended to the file path if specified.
 The alias is specified in in the ClientDependencyHelper constructor.
 If the alias specified does not exist in the ClientDependencyHelper
 path collection, an exception is thrown.
 </summary>
          </documentation>
          <codeblock>
            <location sl="117" sc="39" el="117" ec="43">ClientDependencyAttribute.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="117" sc="44" el="117" ec="48">ClientDependencyAttribute.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Priority">
          <declaration><![CDATA[public int Priority]]></declaration>
          <documentation>
            <summary>
 Gets or sets the priority.
 </summary>
 <value>The priority.</value></documentation>
          <codeblock>
            <location sl="90" sc="31" el="90" ec="35">ClientDependencyAttribute.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="90" sc="36" el="90" ec="40">ClientDependencyAttribute.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Version">
          <declaration><![CDATA[public string Version]]></declaration>
          <documentation>
            <summary>
 Version of this resource if it is a framework
 Note this field is only used when Framework is specified
 </summary>
          </documentation>
          <codeblock>
            <location sl="150" sc="33" el="150" ec="37">ClientDependencyAttribute.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="150" sc="38" el="150" ec="42">ClientDependencyAttribute.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ClientDependencyFileExtensions">
      <declaration><![CDATA[public static class ClientDependencyFileExtensions]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="ResolveFilePath">
          <declaration><![CDATA[public static string ResolveFilePath(this IClientDependencyFile file, HttpContextBase http)]]></declaration>
          <documentation>
            <summary>
 Resolves an absolute web path for the file path
 </summary>
 <param name="file"></param>
 <param name="http"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="18" sc="9" el="40" ec="10">IClientDependencyFileExtensions.cs</location>
            <body hash="00ae92b28c6876493a38a13390ce72b7"><![CDATA[{
            var trimmedPath = file.FilePath.Trim();
            if (string.IsNullOrEmpty(trimmedPath))
            {
                throw new ArgumentException("The Path specified is null", "Path");
            }
            if (trimmedPath.StartsWith("~/"))
            {
                return http.ResolveUrl(file.FilePath);
            }
            if (trimmedPath.StartsWith("http://", StringComparison.InvariantCultureIgnoreCase) 
                || trimmedPath.StartsWith("https://", StringComparison.InvariantCultureIgnoreCase))
            {
                return file.FilePath; 
            }
            if (!http.IsAbsolute(file.FilePath))
            {
                //get the relative path
                var path = http.Request.AppRelativeCurrentExecutionFilePath.Substring(0, http.Request.AppRelativeCurrentExecutionFilePath.LastIndexOf('/') + 1);
                return http.ResolveUrl(path + file.FilePath);
            }
            return file.FilePath;
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="ClientDependencyPathExtensions">
      <declaration><![CDATA[public static class ClientDependencyPathExtensions]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="ResolvePath">
          <declaration><![CDATA[public static string ResolvePath(this IClientDependencyPath path, HttpContextBase http)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="13" sc="9" el="23" ec="10">IClientDependencyPathExtensions.cs</location>
            <body hash="c0f6c8205d9f08f4f61f123647c9d7f9"><![CDATA[{
            if (string.IsNullOrEmpty(path.Path))
            {
                throw new ArgumentException("The Path specified is null", "Path");
            }
            if (path.Path.StartsWith("~/"))
            {
                return http.ResolveUrl(path.Path);
            }
            return path.Path;            
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="ClientDependencyType">
      <declaration><![CDATA[public enum ClientDependencyType]]></declaration>
      <documentation>
        <summary>
 The type of client file
 </summary>
      </documentation>
      <constructors>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="Css">
          <declaration><![CDATA[public const ClientDependencyType Css = 1;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Javascript">
          <declaration><![CDATA[public const ClientDependencyType Javascript = 0;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="CompressionType">
      <declaration><![CDATA[public enum CompressionType]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="deflate">
          <declaration><![CDATA[public const CompressionType deflate = 0;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="gzip">
          <declaration><![CDATA[public const CompressionType gzip = 1;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="none">
          <declaration><![CDATA[public const CompressionType none = 2;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="Constants">
      <declaration><![CDATA[public static class Constants]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="DefaultGroup">
          <declaration><![CDATA[public const int DefaultGroup = 100;]]></declaration>
          <documentation>
            <summary>
 If a group is not set, the default will be 100.
 </summary>
 <remarks>
 Unless a group is specified, all dependencies will go into the same, default, group.
 </remarks></documentation>
        </field>
        <field name="DefaultPriority">
          <declaration><![CDATA[public const int DefaultPriority = 100;]]></declaration>
          <documentation>
            <summary>
 If a priority is not set, the default will be 100.
 </summary>
 <remarks>
 This will generally mean that if a developer doesn't specify a priority it will come after all other dependencies that
 have unless the priority is explicitly set above 100.
 </remarks></documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="ControlExtensions">
      <declaration><![CDATA[public static class ControlExtensions]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="FlattenChildren">
          <declaration><![CDATA[public static IEnumerable<Control> FlattenChildren(this Control control)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="15" sc="9" el="18" ec="10">ControlExtensions.cs</location>
            <body hash="3c8c38cd734a684e5c0f60cc13ed06c5"><![CDATA[{
            var children = control.Controls.Cast<Control>().ToArray();
            return children.SelectMany(FlattenChildren).Concat(children);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="CssFile">
      <declaration><![CDATA[public class CssFile : BasicFile]]></declaration>
      <documentation>
        <summary>
 Represents a CSS file
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public CssFile(string filePath) : base(ClientDependencyType.Css)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="9" sc="15" el="12" ec="10">CssFile.cs</location>
            <body hash="27627f3514dfd9356aa69252156f8dc6"><![CDATA[base(ClientDependencyType.Css)
        {
            FilePath = filePath;
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="CssFileUrlFormatter">
      <deprecation>Use CssHelper instead</deprecation>
      <declaration><![CDATA[public class CssFileUrlFormatter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public CssFileUrlFormatter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="TransformCssFile">
          <declaration><![CDATA[public static string TransformCssFile(string fileContent, Uri cssLocation)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="13" sc="3" el="15" ec="4">CssFileUrlFormatter.cs</location>
            <body hash="3b86f6c9b091658991bfd020d82bf2d5"><![CDATA[{
		    return CssHelper.ReplaceUrlsWithAbsolutePaths(fileContent, cssLocation);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="CssHelper">
      <declaration><![CDATA[public static class CssHelper]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".cctor">
          <declaration><![CDATA[static CssHelper()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="12" sc="9" el="13" ec="126">CssHelper.cs</location>
            <body hash="40bc2dbea52e958fc79dfc05a4288b8d"><![CDATA[private static readonly Regex ImportCssRegex = new Regex(@"@import url\((.+?)\);?", RegexOptions.Compiled);
        private static readonly Regex CssUrlRegex = new Regex(@"url\(((?![""']?data:|[""']?#).+?)\)", RegexOptions.Compiled);]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="IsAbsoluteUrl">
          <declaration><![CDATA[private static bool IsAbsoluteUrl(string url, out Uri uri)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="121" sc="9" el="123" ec="10">CssHelper.cs</location>
            <body hash="9697bcd47f167b78a50e2cb1abd451bb"><![CDATA[{
            return Uri.TryCreate(url, UriKind.Absolute, out uri);
        }]]></body>
          </codeblock>
        </method>
        <method name="MinifyCss">
          <declaration><![CDATA[public static string MinifyCss(string body)]]></declaration>
          <documentation>
            <summary>
 Minifies Css
 </summary>
 <param name="body"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="110" sc="9" el="118" ec="10">CssHelper.cs</location>
            <body hash="dc77667a021b240d7d0c263ad8dda268"><![CDATA[{
            body = Regex.Replace(body, @"[\n\r]+\s*", string.Empty);
            body = Regex.Replace(body, @"\s+", " ");
            body = Regex.Replace(body, @"\s?([:,;{}])\s?", "$1");
            body = Regex.Replace(body, @"([\s:]0)(px|pt|%|em)", "$1");
            body = Regex.Replace(body, @"/\*[\d\D]*?\*/", string.Empty);
            return body;

        }]]></body>
          </codeblock>
        </method>
        <method name="ParseImportStatements">
          <declaration><![CDATA[public static string ParseImportStatements(string content, out IEnumerable<string> importedPaths)]]></declaration>
          <documentation>
            <summary>
 Returns the paths for the import statements and the resultant original css without the import statements
 </summary>
 <param name="content">The original css contents</param>
 <param name="importedPaths"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="22" sc="9" el="61" ec="10">CssHelper.cs</location>
            <body hash="0c1cbc58995ac07e357041e2eb798098"><![CDATA[{
            var pathsFound = new List<string>();
            var matches = ImportCssRegex.Matches(content);
            foreach (Match match in matches)
            {
                //Ignore external imports
                var urlMatch = CssUrlRegex.Match(match.Value);
                if (urlMatch.Success && urlMatch.Groups.Count >= 2)
                {
                    var path = urlMatch.Groups[1].Value.Trim('\'', '"');
                    if ((path.StartsWith("http://", StringComparison.InvariantCultureIgnoreCase)
                         || path.StartsWith("https://", StringComparison.InvariantCultureIgnoreCase)
                         || path.StartsWith("//", StringComparison.InvariantCultureIgnoreCase)))
                    {
                        Uri uri;
                        if (!IsAbsoluteUrl(path, out uri))
                        {
                            continue;
                        }
                        var domain = $".{uri.Host}:{uri.Port}";
                        var approvedDomains =
                            ClientDependencySettings.Instance.DefaultCompositeFileProcessingProvider.BundleDomains;
                        if (!approvedDomains.Any(bundleDomain => domain.EndsWith(bundleDomain)))
                        {
                            continue;
                        }
                    }
                }

                //Strip the import statement                
                content = content.ReplaceFirst(match.Value, "");

                //write import css content
                var filePath = match.Groups[1].Value.Trim('\'', '"');
                pathsFound.Add(filePath);
            }

            importedPaths = pathsFound;
            return content.Trim();
        }]]></body>
          </codeblock>
        </method>
        <method name="ReplaceUrlsWithAbsolutePaths">
          <declaration><![CDATA[public static string ReplaceUrlsWithAbsolutePaths(string fileContents, string url, HttpContextBase http)]]></declaration>
          <documentation>
            <summary>
 Returns the CSS file with all of the url's formatted to be absolute locations
 </summary>
 <param name="fileContents"></param>
 <param name="url"></param>
 <param name="http"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="71" sc="9" el="75" ec="10">CssHelper.cs</location>
            <body hash="35ad292f3f385b13481199924ef2b6bf"><![CDATA[{
            var uri = new Uri(url, UriKind.RelativeOrAbsolute);
            fileContents = CssHelper.ReplaceUrlsWithAbsolutePaths(fileContents, uri.MakeAbsoluteUri(http));
            return fileContents;
        }]]></body>
          </codeblock>
        </method>
        <method name="ReplaceUrlsWithAbsolutePaths">
          <declaration><![CDATA[public static string ReplaceUrlsWithAbsolutePaths(string fileContent, Uri cssLocation)]]></declaration>
          <documentation>
            <summary>
 Returns the CSS file with all of the url's formatted to be absolute locations
 </summary>
 <param name="fileContent">content of the css file</param>
 <param name="cssLocation">the uri location of the css file</param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="84" sc="9" el="102" ec="10">CssHelper.cs</location>
            <body hash="f9f408c65fef190f442dd712fd8580b0"><![CDATA[{
            var str = CssUrlRegex.Replace(fileContent, m =>
                {
                    if (m.Groups.Count == 2)
                    {
                        var match = m.Groups[1].Value.Trim('\'', '"');
                        var hashSplit = match.Split(new[] {'#'}, StringSplitOptions.RemoveEmptyEntries);

                        return string.Format(@"url(""{0}{1}"")",
                                             (match.StartsWith("http://", StringComparison.InvariantCultureIgnoreCase)
                                             || match.StartsWith("https://", StringComparison.InvariantCultureIgnoreCase)
                                             || match.StartsWith("//", StringComparison.InvariantCultureIgnoreCase)) ? match : new Uri(cssLocation, match).PathAndQuery,
                                             hashSplit.Length > 1 ? ("#" + hashSplit[1]) : "");
                    }
                    return m.Value;
                });            

            return str;
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="CssUrlRegex">
          <declaration><![CDATA[private static readonly Regex CssUrlRegex = new Regex("url\\(((?![\"']?data:|[\"']?#).+?)\\)", RegexOptions.Compiled);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ImportCssRegex">
          <declaration><![CDATA[private static readonly Regex ImportCssRegex = new Regex("@import url\\((.+?)\\);?", RegexOptions.Compiled);]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="CssMediaType">
      <declaration><![CDATA[public enum CssMediaType]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="All">
          <declaration><![CDATA[public const CssMediaType All = 0;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Print">
          <declaration><![CDATA[public const CssMediaType Print = 2;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Screen">
          <declaration><![CDATA[public const CssMediaType Screen = 1;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="DependencyHtmlElement">
      <declaration><![CDATA[public class DependencyHtmlElement]]></declaration>
      <documentation>
        <summary>
  A simple model defining the source of the dependency and the Html Elements that need to be rendered as part of the html tag
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public DependencyHtmlElement()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="HtmlAttributes">
          <declaration><![CDATA[public IDictionary<string, string> HtmlAttributes]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="11" sc="61" el="11" ec="65">DependencyHtmlElement.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="11" sc="66" el="11" ec="70">DependencyHtmlElement.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Source">
          <declaration><![CDATA[public string Source]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="10" sc="32" el="10" ec="36">DependencyHtmlElement.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="10" sc="37" el="10" ec="41">DependencyHtmlElement.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="DependencySorter">
      <declaration><![CDATA[internal static class DependencySorter]]></declaration>
      <documentation>
        <summary>
 Utility for sorting dependencies based on their priority and the index in which they exist in the list (# they were added)
 </summary>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="FilterDependencies">
          <declaration><![CDATA[public static IList<IClientDependencyFile> FilterDependencies(IList<IClientDependencyFile> dependencies)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="15" sc="9" el="35" ec="10">DependencySorter.cs</location>
            <body hash="370665089ecf921867664ce55f16df67"><![CDATA[{
            if (dependencies.Any(f => f.Name != ""))
            {
                var newList = dependencies.Where(f => f.Name == "").ToList();
                var frameworks = dependencies.Where(f => f.Name != "").GroupBy(f => f.Name.ToLower());
                foreach (var framework in frameworks)
                {
                    var topPriority = framework.FirstOrDefault(d => d.ForceVersion);
                    if (topPriority == null)
                    {
                        newList.Add(framework.OrderByDescending(f => f.Version).First());
                    }
                    else
                    {
                        newList.Add(topPriority);
                    }
                }
                dependencies = newList;
            }
            return dependencies;
        }]]></body>
          </codeblock>
        </method>
        <method name="SortItems">
          <declaration><![CDATA[public static IList<IClientDependencyFile> SortItems(IList<IClientDependencyFile> files)]]></declaration>
          <documentation>
            <summary>
 Sort the items by their priority and their index they currently exist in the collection
 </summary>
 <param name="files"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="43" sc="9" el="66" ec="10">DependencySorter.cs</location>
            <body hash="1592816375407a927a5c1e339333e820"><![CDATA[{
            //first check if each item's order is the same, if this is the case we'll make sure that we order them 
            //by the way they were defined
            if (!files.Any()) return files;

            var firstPriority = files.First().Priority;

            if (files.Any(x => x.Priority != firstPriority))
            {
                var sortedOutput = new List<IClientDependencyFile>();
                //ok they are not the same so we'll need to sort them by priority and by how they've been entered
                var groups = files.GroupBy(x => x.Priority).OrderBy(x => x.Key);
                foreach (var currentPriority in groups)
                {
                    //for this priority group, we'll need to prioritize them by how they are found in the files array
                    sortedOutput.AddRange(currentPriority.OrderBy(files.IndexOf));
                }
                return sortedOutput;
            }

            //they are all the same so we can really just return the original list since it will already be in the 
            //order that they were added.
            return files;
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="DictionaryExtensions">
      <declaration><![CDATA[public static class DictionaryExtensions]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="IsEqualTo">
          <declaration><![CDATA[public static bool IsEqualTo(this IDictionary<string, string> d, IDictionary<string, string> compareTo)]]></declaration>
          <documentation>
            <summary>
 Determines if 2 dictionaries contain the exact same keys/values
 </summary>
 <param name="d"></param>
 <param name="compareTo"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="27" sc="9" el="40" ec="10">DictionaryExtensions.cs</location>
            <body hash="3cf728d41d4a1e8f7d813529542ab72f"><![CDATA[{
            if (d.Count != compareTo.Count)
                return false;

            foreach(var i in d)
            {
                if (!compareTo.ContainsKey(i.Key))
                    return false;
                if (!compareTo[i.Key].Equals(i.Value, StringComparison.InvariantCultureIgnoreCase))
                    return false;
            }

            return true;
        }]]></body>
          </codeblock>
        </method>
        <method name="ToHtmlAttributes">
          <declaration><![CDATA[public static string ToHtmlAttributes(this IDictionary<string, string> d)]]></declaration>
          <documentation>
            <summary>
 Returns the dictionary as formatted html attributes for use in an html tag
 </summary>
 <param name="d"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="16" sc="9" el="18" ec="10">DictionaryExtensions.cs</location>
            <body hash="12899de15f96dba1ba6a85fb6c4f9ab5"><![CDATA[{
            return string.Join(" ", d.Select(x => x.Key + "=\"" + x.Value + "\"").ToArray());
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="FileWriters">
      <declaration><![CDATA[public class FileWriters]]></declaration>
      <documentation>
        <summary>
 Defines the file writers for file extensions or for explicit file paths
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public FileWriters()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static FileWriters()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="16" sc="9" el="20" ec="89">FileWriters.cs</location>
            <body hash="210bbd658522c2f8f32486028448854b"><![CDATA[private static readonly ConcurrentDictionary<string, IFileWriter> ExtensionWriters = new ConcurrentDictionary<string, IFileWriter>();
        private static readonly ConcurrentDictionary<string, IFileWriter> PathWriters = new ConcurrentDictionary<string, IFileWriter>();
        private static readonly ConcurrentDictionary<string, IVirtualFileWriter> VirtualExtensionWriters = new ConcurrentDictionary<string, IVirtualFileWriter>();
        private static readonly ConcurrentDictionary<string, IVirtualFileWriter> VirtualPathWriters = new ConcurrentDictionary<string, IVirtualFileWriter>();
        private static readonly IFileWriter DefaultFileWriter = new DefaultFileWriter();]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AddWriterForExtension">
          <declaration><![CDATA[public static void AddWriterForExtension(string fileExtension, IVirtualFileWriter writer)]]></declaration>
          <documentation>
            <summary>
 This will add or update a writer for a specific file extension
 </summary>
 <param name="fileExtension"></param>
 <param name="writer"></param></documentation>
          <codeblock>
            <location sl="47" sc="9" el="56" ec="10">FileWriters.cs</location>
            <body hash="1a2782c9925a364737644f6f10f4d3e6"><![CDATA[{
            if (fileExtension == null) throw new ArgumentNullException("fileExtension");
            if (writer == null) throw new ArgumentNullException("writer");

            if (!fileExtension.StartsWith("."))
            {
                throw new FormatException("A file extension must begin with a '.'");
            }
            VirtualExtensionWriters.AddOrUpdate(fileExtension.ToUpper(), s => writer, (s, fileWriter) => writer);
        }]]></body>
          </codeblock>
        </method>
        <method name="AddWriterForExtension">
          <declaration><![CDATA[public static void AddWriterForExtension(string fileExtension, IFileWriter writer)]]></declaration>
          <documentation>
            <summary>
 This will add or update a writer for a specific file extension
 </summary>
 <param name="fileExtension"></param>
 <param name="writer"></param></documentation>
          <codeblock>
            <location sl="111" sc="9" el="120" ec="10">FileWriters.cs</location>
            <body hash="f99a3fab835b8ee24b716a7bac3721e0"><![CDATA[{
            if (fileExtension == null) throw new ArgumentNullException("fileExtension");
            if (writer == null) throw new ArgumentNullException("writer");

            if (!fileExtension.StartsWith("."))
            {
                throw new FormatException("A file extension must begin with a '.'");
            }
            ExtensionWriters.AddOrUpdate(fileExtension.ToUpper(), s => writer, (s, fileWriter) => writer);
        }]]></body>
          </codeblock>
        </method>
        <method name="AddWriterForFile">
          <declaration><![CDATA[public static void AddWriterForFile(string filePath, IVirtualFileWriter writer)]]></declaration>
          <documentation>
            <summary>
 This will add or update a writer for a specific file
 </summary>
 <param name="filePath"></param>
 <param name="writer"></param></documentation>
          <codeblock>
            <location sl="79" sc="9" el="88" ec="10">FileWriters.cs</location>
            <body hash="85865e298e275eefd9cc304245a034b7"><![CDATA[{
            if (filePath == null) throw new ArgumentNullException("filePath");
            if (writer == null) throw new ArgumentNullException("writer");

            if (!filePath.StartsWith("/"))
            {
                throw new FormatException("A file path must begin with a '/'");
            }
            VirtualPathWriters.AddOrUpdate(filePath.ToUpper(), s => writer, (s, fileWriter) => writer);
        }]]></body>
          </codeblock>
        </method>
        <method name="AddWriterForFile">
          <declaration><![CDATA[public static void AddWriterForFile(string filePath, IFileWriter writer)]]></declaration>
          <documentation>
            <summary>
 This will add or update a writer for a specific file
 </summary>
 <param name="filePath"></param>
 <param name="writer"></param></documentation>
          <codeblock>
            <location sl="143" sc="9" el="152" ec="10">FileWriters.cs</location>
            <body hash="81843431950841b79c67d1bdab3d5d7b"><![CDATA[{
            if (filePath == null) throw new ArgumentNullException("filePath");
            if (writer == null) throw new ArgumentNullException("writer");

            if (!filePath.StartsWith("/"))
            {
                throw new FormatException("A file path must begin with a '/'");
            }
            PathWriters.AddOrUpdate(filePath.ToUpper(), s => writer, (s, fileWriter) => writer);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetDefault">
          <declaration><![CDATA[public static IFileWriter GetDefault()]]></declaration>
          <documentation>
            <summary>
 Returns the default writer
 </summary>
 <returns></returns></documentation>
          <codeblock>
            <location sl="27" sc="9" el="29" ec="10">FileWriters.cs</location>
            <body hash="81b58eb37ce38d78be53dcb0371ccb5b"><![CDATA[{
            return DefaultFileWriter;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetRegisteredExtensions">
          <declaration><![CDATA[internal static IEnumerable<string> GetRegisteredExtensions()]]></declaration>
          <documentation>
            <summary>
 returns all extensions that have been registered
 </summary>
 <returns></returns></documentation>
          <codeblock>
            <location sl="36" sc="9" el="39" ec="10">FileWriters.cs</location>
            <body hash="f2751e6d3dc05a535c4436a690a03418"><![CDATA[{
            return ExtensionWriters.Select(x => x.Key.ToUpper()).Distinct()
                .Union(VirtualExtensionWriters.Select(x => x.Key.ToUpper()).Distinct());
        }]]></body>
          </codeblock>
        </method>
        <method name="GetVirtualWriterForExtension">
          <declaration><![CDATA[public static IVirtualFileWriter GetVirtualWriterForExtension(string fileExtension)]]></declaration>
          <documentation>
            <summary>
 Returns the writer for the file extension, if none is found then the null will be returned
 </summary>
 <param name="fileExtension"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="64" sc="9" el="71" ec="10">FileWriters.cs</location>
            <body hash="0110695e41bdd0262edd9197b38a5efa"><![CDATA[{
            if (fileExtension == null) throw new ArgumentNullException("fileExtension");

            IVirtualFileWriter writer;
            return VirtualExtensionWriters.TryGetValue(fileExtension.ToUpper(), out writer) 
                ? writer 
                : null;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetVirtualWriterForFile">
          <declaration><![CDATA[public static IVirtualFileWriter GetVirtualWriterForFile(string filePath)]]></declaration>
          <documentation>
            <summary>
 Returns the writer for the file path, if none is found then the null will be returned
 </summary>
 <param name="filePath"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="96" sc="9" el="103" ec="10">FileWriters.cs</location>
            <body hash="2d3025ec5a363109fba833a59dcd3413"><![CDATA[{
            if (filePath == null) throw new ArgumentNullException("filePath");

            IVirtualFileWriter writer;
            return VirtualPathWriters.TryGetValue(filePath.ToUpper(), out writer)
                ? writer
                : null;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetWriterForExtension">
          <declaration><![CDATA[public static IFileWriter GetWriterForExtension(string fileExtension)]]></declaration>
          <documentation>
            <summary>
 Returns the writer for the file extension, if none is found then the default writer will be returned
 </summary>
 <param name="fileExtension"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="128" sc="9" el="135" ec="10">FileWriters.cs</location>
            <body hash="c42b55cd5324a19b8fdcccfeae006ba3"><![CDATA[{
            if (fileExtension == null) throw new ArgumentNullException("fileExtension");

            IFileWriter writer;
            return ExtensionWriters.TryGetValue(fileExtension.ToUpper(), out writer)
                ? writer
                : DefaultFileWriter;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetWriterForFile">
          <declaration><![CDATA[public static IFileWriter GetWriterForFile(string filePath)]]></declaration>
          <documentation>
            <summary>
 Returns the writer for the file path, if none is found then the default writer will be returned
 </summary>
 <param name="filePath"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="160" sc="9" el="167" ec="10">FileWriters.cs</location>
            <body hash="48db47c99e1f29cac257326862fd1249"><![CDATA[{
            if (filePath == null) throw new ArgumentNullException("filePath");

            IFileWriter writer;
            return PathWriters.TryGetValue(filePath.ToUpper(), out writer)
                ? writer
                : DefaultFileWriter;
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="DefaultFileWriter">
          <declaration><![CDATA[private static readonly IFileWriter DefaultFileWriter = new DefaultFileWriter();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ExtensionWriters">
          <declaration><![CDATA[private static readonly ConcurrentDictionary<string, IFileWriter> ExtensionWriters = new ConcurrentDictionary<string, IFileWriter>();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="PathWriters">
          <declaration><![CDATA[private static readonly ConcurrentDictionary<string, IFileWriter> PathWriters = new ConcurrentDictionary<string, IFileWriter>();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="VirtualExtensionWriters">
          <declaration><![CDATA[private static readonly ConcurrentDictionary<string, IVirtualFileWriter> VirtualExtensionWriters = new ConcurrentDictionary<string, IVirtualFileWriter>();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="VirtualPathWriters">
          <declaration><![CDATA[private static readonly ConcurrentDictionary<string, IVirtualFileWriter> VirtualPathWriters = new ConcurrentDictionary<string, IVirtualFileWriter>();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="HashCodeCombiner">
      <declaration><![CDATA[internal class HashCodeCombiner]]></declaration>
      <documentation>
        <summary>
 Used to create a hash code from multiple objects.
 </summary>
 <remarks>
 .Net has a class the same as this: System.Web.Util.HashCodeCombiner and of course it works for all sorts of things
 which we've not included here as we just need a quick easy class for this in order to create a unique
 hash of directories/files to see if they have changed.
 </remarks></documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private long _combinedHash = 5381L;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="17" sc="9" el="17" ec="44">HashCodeCombiner.cs</location>
            <body hash="b47cdd0a07d9386cb4f36d0768ae1be7"><![CDATA[private long _combinedHash = 5381L]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AddCaseInsensitiveString">
          <declaration><![CDATA[internal void AddCaseInsensitiveString(string s)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="35" sc="9" el="38" ec="10">HashCodeCombiner.cs</location>
            <body hash="cf1f29b7e972d04b180ebceba80a06a7"><![CDATA[{
            if (s != null)
                AddInt((StringComparer.InvariantCultureIgnoreCase).GetHashCode(s));
        }]]></body>
          </codeblock>
        </method>
        <method name="AddDateTime">
          <declaration><![CDATA[internal void AddDateTime(DateTime d)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="30" sc="9" el="32" ec="10">HashCodeCombiner.cs</location>
            <body hash="c459145e22c3447fcbcd4034164392ef"><![CDATA[{
            AddInt(d.GetHashCode());
        }]]></body>
          </codeblock>
        </method>
        <method name="AddFile">
          <declaration><![CDATA[internal void AddFile(FileInfo f)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="72" sc="9" el="74" ec="10">HashCodeCombiner.cs</location>
            <body hash="2189fd31823ae63b35e0fc303ff5d4c0"><![CDATA[{
            AddFileSystemItem(f);
        }]]></body>
          </codeblock>
        </method>
        <method name="AddFileSystemItem">
          <declaration><![CDATA[internal void AddFileSystemItem(FileSystemInfo f)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="41" sc="9" el="69" ec="10">HashCodeCombiner.cs</location>
            <body hash="f07ae56514afdc2169262035189f9285"><![CDATA[{
            //if it doesn't exist, don't proceed.
            if (!f.Exists)
                return;

            AddCaseInsensitiveString(f.FullName);
            AddDateTime(f.CreationTimeUtc);
            AddDateTime(f.LastWriteTimeUtc);

            //check if it is a file or folder 
            var fileInfo = f as FileInfo;
            if (fileInfo != null)
            {
                AddInt(fileInfo.Length.GetHashCode());
            }

            var dirInfo = f as DirectoryInfo;
            if (dirInfo != null)
            {
                foreach (var d in dirInfo.GetFiles())
                {
                    AddFile(d);
                }
                foreach (var s in dirInfo.GetDirectories())
                {
                    AddFolder(s);
                }
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="AddFolder">
          <declaration><![CDATA[internal void AddFolder(DirectoryInfo d)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="77" sc="9" el="79" ec="10">HashCodeCombiner.cs</location>
            <body hash="f26130a492812bc96085899e6696c593"><![CDATA[{
            AddFileSystemItem(d);
        }]]></body>
          </codeblock>
        </method>
        <method name="AddInt">
          <declaration><![CDATA[internal void AddInt(int i)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="20" sc="9" el="22" ec="10">HashCodeCombiner.cs</location>
            <body hash="ef1fef6bba62358fc921dead9bd4825d"><![CDATA[{
            _combinedHash = ((_combinedHash << 5) + _combinedHash) ^ i;
        }]]></body>
          </codeblock>
        </method>
        <method name="AddObject">
          <declaration><![CDATA[internal void AddObject(object o)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="25" sc="9" el="27" ec="10">HashCodeCombiner.cs</location>
            <body hash="8eefb8f56cdac07509c65b1ce8cbe78c"><![CDATA[{
            AddInt(o.GetHashCode());
        }]]></body>
          </codeblock>
        </method>
        <method name="GetCombinedHashCode">
          <declaration><![CDATA[internal string GetCombinedHashCode()]]></declaration>
          <documentation>
            <summary>
 Returns the hex code of the combined hash code
 </summary>
 <returns></returns></documentation>
          <codeblock>
            <location sl="86" sc="9" el="88" ec="10">HashCodeCombiner.cs</location>
            <body hash="83a393e1fd738bd0f58a5728f8478812"><![CDATA[{
            return _combinedHash.ToString("x", CultureInfo.InvariantCulture);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_combinedHash">
          <declaration><![CDATA[private long _combinedHash = 5381L;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="HtmlAttributesStringParser">
      <declaration><![CDATA[internal static class HtmlAttributesStringParser]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="ParseIntoDictionary">
          <declaration><![CDATA[internal static void ParseIntoDictionary(string attributes, IDictionary<string, string> destination)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="11" sc="9" el="77" ec="10">HtmlAttributesStringParser.cs</location>
            <body hash="fe6f646cbd101f43c43e31400ebb8261"><![CDATA[{
            if (string.IsNullOrEmpty(attributes))
                return;

            var key = "";
            var val = "";
            var isKey = true;
            var isVal = false;
            var isValDelimited = false;
            for (var i = 0; i < attributes.Length; i++)
            {
                var c = attributes.ToCharArray()[i];
                if (isKey && c == ':')
                {
                    isKey = false;
                    isVal = true;
                    continue;
                }

                if (isKey)
                {
                    key += c;
                }

                if (isVal)
                {
                    if (c == '\'')
                    {
                        if (!isValDelimited)
                        {
                            isValDelimited = true;
                            continue;
                        }
                        else
                        {
                            isValDelimited = false;
                            if ((i == attributes.Length - 1))
                            {
                                //if it the end, add/replace the value
                                destination[key] = val;                                
                            }
                            continue;
                        }
                    }
                    
                    if (c == ',' && !isValDelimited)
                    {
                        //we've reached a comma and the value is not longer delimited, this means we create a new key
                        isKey = true;
                        isVal = false;

                        //now we can add/replace the current value to the dictionary
                        destination[key] = val;
                        continue;
                    }
                    
                    val += c;

                    if ((i == attributes.Length - 1))
                    {
                        //if it the end, add/replace the value
                        destination[key] = val;
                    }
                }
            }

        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="HttpContextBaseExtensions">
      <declaration><![CDATA[public static class HttpContextBaseExtensions]]></declaration>
      <documentation>
        <summary>
 Extension methods for the HttpContext object
 </summary>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="AddCompressionResponseHeader">
          <declaration><![CDATA[public static void AddCompressionResponseHeader(this HttpContextBase context, CompressionType cType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="36" sc="9" el="45" ec="10">HttpContextBaseExtensions.cs</location>
            <body hash="dff71ba1907ce407f89f709511de0c5e"><![CDATA[{
            if (cType == CompressionType.deflate)
            {
                context.Response.AddHeader("Content-encoding", "deflate");
            }
            else if (cType == CompressionType.gzip)
            {
                context.Response.AddHeader("Content-encoding", "gzip");
            }            
        }]]></body>
          </codeblock>
        </method>
        <method name="GetClientCompression">
          <declaration><![CDATA[public static CompressionType GetClientCompression(this HttpContextBase context)]]></declaration>
          <documentation>
            <summary>
 Check what kind of compression to use. Need to select the first available compression
 from the header value as this is how .Net performs caching by compression so we need to follow
 this process.
 If IE 6 is detected, we will ignore compression as it's known that some versions of IE 6
 have issues with it.
 </summary>
          </documentation>
          <codeblock>
            <location sl="105" sc="9" el="135" ec="10">HttpContextBaseExtensions.cs</location>
            <body hash="e0c861d5b892347fd11ca160d4ec1da2"><![CDATA[{
            CompressionType type = CompressionType.none;

            if (context.Request.UserAgent.Contains("MSIE 6"))
            {
                return type;
            }

            string acceptEncoding = context.Request.Headers["Accept-Encoding"];

            if (!string.IsNullOrEmpty(acceptEncoding))
            {
                string[] supported = acceptEncoding.Split(',');
                //get the first type that we support
                for (var i = 0; i < supported.Length; i++)
                {
                    if (supported[i].Contains("deflate"))
                    {
                        type = CompressionType.deflate;
                        break;
                    }
                    else if (supported[i].Contains("gzip")) //sometimes it could be x-gzip!
                    {
                        type = CompressionType.gzip;
                        break;
                    }
                }
            }

            return type;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetRawUrlSafe">
          <declaration><![CDATA[internal static string GetRawUrlSafe(this HttpContextBase context)]]></declaration>
          <documentation>
            <summary>
 We are not running .Net 4.5 which has a Request.Unvalidated property so that we don't have to deal with
 HttpRequestValidationException but in our case we need to deal with it. Luckily we don't want to deal with
 invalidated RawUrl's so we'll just catch the exception and return null
 </summary>
 <param name="context"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="24" sc="9" el="33" ec="10">HttpContextBaseExtensions.cs</location>
            <body hash="752dc7efe0307c5753472230d81db655"><![CDATA[{
            try
            {
                return context.Request.RawUrl;
            }
            catch (HttpRequestValidationException)
            {
                return string.Empty;
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="IsAbsolute">
          <declaration><![CDATA[public static bool IsAbsolute(this HttpContextBase context, string virtualPath)]]></declaration>
          <documentation>
            <summary>
 Checks for absolute path to root of the website.
 </summary>
 <remarks>
 This was taken from the mono source so should be accurate.
 The reason we're not using the VirtualPathUtility one is because it has bugs in 3.5 whereas
 if the path has query strings, it throws exceptions.
 </remarks>
 <param name="context"></param>
 <param name="virtualPath"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="149" sc="9" el="159" ec="10">HttpContextBaseExtensions.cs</location>
            <body hash="05722618ee93ab8d4374015525ea7cfd"><![CDATA[{
            if (IsAbsolutePath(context, virtualPath))
            {
                throw new InvalidOperationException("IsAbsolute method will check if a Virtual path is absolute, it is not supported for full URLs");
            }

            if (string.IsNullOrEmpty(virtualPath))
                throw new ArgumentNullException("virtualPath");

            return (virtualPath[0] == '/' || virtualPath[0] == '\\');
        }]]></body>
          </codeblock>
        </method>
        <method name="IsAbsolutePath">
          <declaration><![CDATA[public static bool IsAbsolutePath(this HttpContextBase context, string originalUrl)]]></declaration>
          <documentation>
            <summary>
 Checks for an absolute http path
 </summary>
 <remarks>
 Takes into account this type of url:
 ~/pathtoresolve/page.aspx?returnurl=http://servertoredirect/resource.aspx
 which is not an absolute path but contains the characters to describe it as one.
 </remarks>
 <param name="context"></param>
 <param name="originalUrl"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="217" sc="9" el="230" ec="10">HttpContextBaseExtensions.cs</location>
            <body hash="4fdf6dbe6feb0c870da82a20ae709d23"><![CDATA[{
            // *** Absolute path - just return
            var indexOfSlashes = originalUrl.IndexOf("://");
            var indexOfQuestionMarks = originalUrl.IndexOf("?");

            if (indexOfSlashes > -1 &&
                 (indexOfQuestionMarks < 0 ||
                  (indexOfQuestionMarks > -1 && indexOfQuestionMarks > indexOfSlashes)
                  )
                )
                return true;

            return false;
        }]]></body>
          </codeblock>
        </method>
        <method name="ResolveUrl">
          <declaration><![CDATA[public static string ResolveUrl(this HttpContextBase context, string originalUrl)]]></declaration>
          <documentation>
            <summary>
 Returns a site relative HTTP path from a partial path starting out with a ~.
 Same syntax that ASP.Net internally supports but this method can be used
 outside of the Page framework.

 Works like Control.ResolveUrl including support for ~ syntax
 but returns an absolute URL.
 </summary>
 <param name="context"></param>
 <param name="originalUrl">Any Url including those starting with ~</param>
 <returns>relative url</returns></documentation>
          <codeblock>
            <location sl="173" sc="9" el="203" ec="10">HttpContextBaseExtensions.cs</location>
            <body hash="05ea325892db3889147b55ab1baead19"><![CDATA[{
            if (string.IsNullOrEmpty(originalUrl))
                return originalUrl;

            // *** Absolute path - just return
            if (context.IsAbsolutePath(originalUrl))
                return originalUrl;

            // *** We don't start with the '~' -> we don't process the Url
            if (!originalUrl.StartsWith("~/"))
                return originalUrl;

            // *** Fix up path for ~ root app dir directory
            // VirtualPathUtility blows up if there is a 
            // query string, so we have to account for this.
            int queryStringStartIndex = originalUrl.IndexOf('?');
            if (queryStringStartIndex != -1)
            {
                string queryString = originalUrl.Substring(queryStringStartIndex);
                string baseUrl = originalUrl.Substring(0, queryStringStartIndex);

                return string.Concat(
                    VirtualPathUtility.ToAbsolute(baseUrl, context.Request.ApplicationPath),
                    queryString);
            }
            else
            {
                return VirtualPathUtility.ToAbsolute(originalUrl, context.Request.ApplicationPath);
            }

        }]]></body>
          </codeblock>
        </method>
        <method name="SetClientCachingResponse">
          <declaration><![CDATA[public static void SetClientCachingResponse(this HttpContextBase context, string etag, int fromDays = 10, string[] varyByParams = null)]]></declaration>
          <documentation>
            <summary>
 This sets the caching response to the client including custom e-tag headers
 </summary>
 <param name="context"></param>
 <param name="etag">Specify the e-tag to use - this should be consistent with this file</param>
 <param name="fromDays">default is 10</param>
 <param name="varyByParams">A list of cache parameter names to vary-by</param></documentation>
          <codeblock>
            <location sl="59" sc="9" el="95" ec="10">HttpContextBaseExtensions.cs</location>
            <body hash="66d4215eb8957ba3e9d0fd9b57f54b27"><![CDATA[{
            
            var duration = TimeSpan.FromDays(fromDays);
            var cache = context.Response.Cache;
            cache.SetCacheability(HttpCacheability.Public);

            cache.SetExpires(context.Timestamp.Add(duration));
            cache.SetMaxAge(duration);
            cache.SetProxyMaxAge(duration);                        
            cache.SetValidUntilExpires(true);
            cache.SetLastModified(context.Timestamp);

            cache.SetETag("\"" + etag + "\"");

            //var by any listed parameter names
            if (varyByParams != null)
            {
                foreach (var p in varyByParams)
                {
                    cache.VaryByParams[p] = true;
                }    
            }
            else
            {
                //if it's null we'll vary by an empty string
                cache.VaryByParams["none"] = true;
            }

            //ensure the cache is different based on the encoding specified per browser
            cache.VaryByContentEncodings["gzip"] = true;
            cache.VaryByContentEncodings["deflate"] = true;

            //don't allow varying by wildcard
            cache.SetOmitVaryStar(true);
            //ensure client browser maintains strict caching rules
            cache.AppendCacheExtension("must-revalidate, proxy-revalidate");            
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="IClientDependencyFile">
      <declaration><![CDATA[public interface IClientDependencyFile]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="DependencyType">
          <declaration><![CDATA[ClientDependencyType DependencyType]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="FilePath">
          <declaration><![CDATA[string FilePath]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="ForceBundle">
          <declaration><![CDATA[bool ForceBundle]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="ForceProvider">
          <declaration><![CDATA[string ForceProvider]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="ForceVersion">
          <declaration><![CDATA[bool ForceVersion]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Group">
          <declaration><![CDATA[int Group]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Name">
          <declaration><![CDATA[string Name]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="PathNameAlias">
          <declaration><![CDATA[string PathNameAlias]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Priority">
          <declaration><![CDATA[int Priority]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Version">
          <declaration><![CDATA[string Version]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="IClientDependencyPath">
      <declaration><![CDATA[public interface IClientDependencyPath]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="ForceBundle">
          <declaration><![CDATA[bool ForceBundle]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Name">
          <declaration><![CDATA[string Name]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Path">
          <declaration><![CDATA[string Path]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="IFileReader">
      <declaration><![CDATA[internal interface IFileReader]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="ReadFile">
          <declaration><![CDATA[string ReadFile(string filePath);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="IHaveHtmlAttributes">
      <declaration><![CDATA[public interface IHaveHtmlAttributes]]></declaration>
      <documentation>
        <summary>
 interface defining that an object has Html attributes
 </summary>
      </documentation>
      <constructors>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="HtmlAttributes">
          <declaration><![CDATA[IDictionary<string, string> HtmlAttributes]]></declaration>
          <documentation>
            <summary>
 Used to store additional attributes in the HTML markup for the item
 </summary>
 <remarks>
 Mostly used for CSS Media, but could be for anything
 </remarks></documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="IHttpProvider">
      <declaration><![CDATA[public interface IHttpProvider]]></declaration>
      <documentation>
        <summary>
 A provider that requires initialization under an Http context.
 The Http initialization will happen after the standard provider initialization.
 </summary>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="Initialize">
          <declaration><![CDATA[void Initialize(HttpContextBase http);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="IRequiresHtmlAttributesParsing">
      <declaration><![CDATA[public interface IRequiresHtmlAttributesParsing : IHaveHtmlAttributes]]></declaration>
      <documentation>
        <summary>
 interface defining that an IClientDependencyFile has html attributes applied as a string which require parsing
 </summary>
      </documentation>
      <constructors>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="HtmlAttributesAsString">
          <declaration><![CDATA[string HtmlAttributesAsString]]></declaration>
          <documentation>
            <summary>
 Used to set the HtmlAttributes on this class via a string which is parsed
 </summary>
 <remarks>
 The syntax for the string must be: key1:value1,key2:value2   etc...
 </remarks></documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="JavascriptFile">
      <declaration><![CDATA[public class JavascriptFile : BasicFile]]></declaration>
      <documentation>
        <summary>
 Represents a JS file
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public JavascriptFile(string filePath) : base(ClientDependencyType.Javascript)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="9" sc="15" el="12" ec="10">JavascriptFile.cs</location>
            <body hash="dd04bad8d1377f80057962600a4c42bd"><![CDATA[base(ClientDependencyType.Javascript)
        {
            FilePath = filePath;
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="NetworkHelper">
      <declaration><![CDATA[public class NetworkHelper]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public NetworkHelper()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="GetConfigSection">
          <declaration><![CDATA[internal static Func<ClientDependencySection> GetConfigSection;]]></declaration>
          <documentation>
            <summary>
 Generally used for unit tests to get access to the settings
 </summary>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="FileSafeMachineName">
          <declaration><![CDATA[public static string FileSafeMachineName]]></declaration>
          <documentation>
            <summary>
 Returns the machine name that is safe to use in file paths.
 </summary>
 <remarks>
 see: https://github.com/Shandem/ClientDependency/issues/4
 </remarks></documentation>
        </property>
        <property name="MachineName">
          <declaration><![CDATA[public static string MachineName]]></declaration>
          <documentation>
            <summary>
 Returns the current machine name
 </summary>
 <remarks>
 Tries to resolve the machine name, if it cannot it uses the config section.
 </remarks></documentation>
          <codeblock>
            <location sl="36" sc="13" el="63" ec="14">NetworkHelper.cs</location>
            <body hash="a6f0e7b90ff70c99b301f1e58581cdff"><![CDATA[{
                var section = GetConfigSection == null
                                  ? ClientDependencySettings.GetDefaultSection()
                                  : GetConfigSection();

                if (!string.IsNullOrEmpty(section.MachineName))
                {
                    //return the config specified machine name
                    return section.MachineName;
                }

                try
                {
                    return Environment.MachineName;
                }
                catch
                {
                    try
                    {
                        return System.Net.Dns.GetHostName();
                    }
                    catch
                    {
                        //if we get here it means we cannot access the machine name
                        throw new ApplicationException("Cannot resolve the current machine name eithe by Environment.MachineName or by Dns.GetHostname(). Because of either security restrictions applied to this server or network issues not being able to resolve the hostname you will need to specify an explicity host name in the ClientDependency config section");
                    }
                }
            }]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ObjectExtensions">
      <declaration><![CDATA[public static class ObjectExtensions]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="ToDictionary">
          <declaration><![CDATA[public static IDictionary<string, object> ToDictionary(this object o)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="10" sc="9" el="33" ec="10">ObjectExtensions.cs</location>
            <body hash="8a53f853004f72c7340913068b313806"><![CDATA[{
            var asObjectDictionary = o as IDictionary<string, object>;
            if (asObjectDictionary != null)
                return asObjectDictionary;
            var asStringDictionary = o as IDictionary<string, string>;
            if (asStringDictionary != null)
                return asStringDictionary.ToDictionary(x => x.Key, x => (object) x.Value);

            if (o != null)
            {
                var props = TypeDescriptor.GetProperties(o);
                var d = new Dictionary<string, object>();
                foreach (var prop in props.Cast<PropertyDescriptor>())
                {
                    var val = prop.GetValue(o);
                    if (val != null)
                    {
                        d.Add(prop.Name, val);
                    }
                }
                return d;
            }
            return new Dictionary<string, object>();
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="PathsCollection">
      <declaration><![CDATA[public static class PathsCollection]]></declaration>
      <documentation>
        <summary>
 Allows for globally specifying paths for path aliases when registering dependencies
 </summary>
      </documentation>
      <constructors>
        <constructor name=".cctor">
          <declaration><![CDATA[static PathsCollection()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="12" sc="9" el="13" ec="62">PathsCollection.cs</location>
            <body hash="1b2042aeac959a1902cc393b9261d80f"><![CDATA[private static readonly List<BasicPath> Paths = new List<BasicPath>();
        private static readonly object Locker = new object();]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AddPath">
          <declaration><![CDATA[public static void AddPath(string name, string path, bool forceBundle = false)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="16" sc="9" el="25" ec="10">PathsCollection.cs</location>
            <body hash="b95ff01e5430e70e9cea10fa2667af56"><![CDATA[{
            lock (Locker)
            {
                var bp = new BasicPath(name, path) {ForceBundle = forceBundle};
                if (!Paths.Contains(bp))
                {
                    Paths.Add(bp);
                }
            }            
        }]]></body>
          </codeblock>
        </method>
        <method name="GetPaths">
          <declaration><![CDATA[internal static IEnumerable<IClientDependencyPath> GetPaths()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="28" sc="9" el="30" ec="10">PathsCollection.cs</location>
            <body hash="e8838a427349941a5542ebb01806bd5c"><![CDATA[{
            return Paths.ToArray();
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="Locker">
          <declaration><![CDATA[private static readonly object Locker = new object();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Paths">
          <declaration><![CDATA[private static readonly List<BasicPath> Paths = new List<BasicPath>();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="PhysicalFileReader">
      <declaration><![CDATA[internal class PhysicalFileReader : IFileReader]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public PhysicalFileReader(HttpContextBase httpContext)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="37" sc="9" el="40" ec="10">IFileReader.cs</location>
            <body hash="4d22ea5b6e5069393fa8a94b8f63d148"><![CDATA[public PhysicalFileReader(HttpContextBase httpContext)
        {
            _httpContext = httpContext;
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ReadFile">
          <declaration><![CDATA[public string ReadFile(string filePath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="43" sc="9" el="56" ec="10">IFileReader.cs</location>
            <body hash="2acc3b0777562f71da1d5f0a753bf340"><![CDATA[{
            var physicalPath = _httpContext.Server.MapPath(filePath);
            if (physicalPath == null) return "";
            if (!File.Exists(physicalPath)) return "";
            try
            {
                return File.ReadAllText(physicalPath);
            }
            catch (Exception ex)
            {
                ClientDependencySettings.Instance.Logger.Error(string.Format("Could not read file {0}. EXCEPTION: {1}", physicalPath, ex.Message), ex);
                return "";
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_httpContext">
          <declaration><![CDATA[private readonly HttpContextBase _httpContext;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="PlaceholderParser">
      <declaration><![CDATA[internal class PlaceholderParser]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public PlaceholderParser()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="add_AllPlaceholdersReplaced">
          <declaration><![CDATA[internal static void add_AllPlaceholdersReplaced(EventHandler<PlaceholdersReplacedEventArgs> value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="add_PlaceholderReplaced">
          <declaration><![CDATA[internal static void add_PlaceholderReplaced(EventHandler<PlaceholderReplacementEventArgs> value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="OnAllPlaceholdersReplaced">
          <declaration><![CDATA[private static void OnAllPlaceholdersReplaced(PlaceholdersReplacedEventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="20" sc="9" el="23" ec="10">PlaceholderParser.cs</location>
            <body hash="1a21204476898e85b237dcd89d8b4d5c"><![CDATA[{
            var handler = AllPlaceholdersReplaced;
            if (handler != null) handler(null, e);
        }]]></body>
          </codeblock>
        </method>
        <method name="OnPlaceholderReplaced">
          <declaration><![CDATA[private static void OnPlaceholderReplaced(PlaceholderReplacementEventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="14" sc="9" el="17" ec="10">PlaceholderParser.cs</location>
            <body hash="4aef6ebcf794ea2a4dccae3955e8e655"><![CDATA[{
            var handler = PlaceholderReplaced;
            if (handler != null) handler(null, e);
        }]]></body>
          </codeblock>
        </method>
        <method name="ParseHtmlPlaceholders">
          <declaration><![CDATA[public static string ParseHtmlPlaceholders(HttpContextBase currentContext, string html, string jsMarkupRegex, string cssMarkupRegex, RendererOutput[] output)]]></declaration>
          <documentation>
            <summary>
 This replaces the HTML placeholders that we're rendered into the html
 markup before the module calls this method to update the placeholders with
 the real dependencies.
 </summary>
 <param name="currentContext"></param>
 <param name="html"></param>
 <param name="jsMarkupRegex"></param>
 <param name="cssMarkupRegex"></param>
 <param name="output"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="37" sc="9" el="97" ec="10">PlaceholderParser.cs</location>
            <body hash="7098be0d2fc969dc0a3c373f67682251"><![CDATA[{
            html = Regex.Replace(html, jsMarkupRegex,
                (m) =>
                {
                    var grp = m.Groups["renderer"];
                    if (grp != null)
                    {
                        if (output.Any())
                        {
                            var rendererOutput = output.SingleOrDefault(x => x.Name == grp.ToString());

                            var args = new PlaceholderReplacementEventArgs(currentContext, ClientDependencyType.Javascript,
                                rendererOutput != null ? rendererOutput.OutputJs : "",
                                m);
                            OnPlaceholderReplaced(args);

                            return args.ReplacedText;
                        }
                        else
                        {
                            //output a message saying that there were no refs
                            return "<!-- CDF: No JS dependencies were declared //-->";   
                        }                        
                    }
                    
                    return m.ToString();

                });

            html = Regex.Replace(html, cssMarkupRegex,
                (m) =>
                {
                    var grp = m.Groups["renderer"];
                    if (grp != null)
                    {
                        if (output.Any())
                        {
                            var rendererOutput = output.SingleOrDefault(x => x.Name == grp.ToString());

                            var args = new PlaceholderReplacementEventArgs(currentContext, ClientDependencyType.Css,
                                rendererOutput != null ? rendererOutput.OutputCss : "",
                                m);
                            OnPlaceholderReplaced(args);
                            return args.ReplacedText;
                        }
                        else
                        {
                            //output a message saying that there were no refs
                            return "<!-- CDF: No CSS dependencies were declared //-->";
                        }                        
                    }

                    return m.ToString();

                });


            var replacedArgs = new PlaceholdersReplacedEventArgs(currentContext, html);
            OnAllPlaceholdersReplaced(replacedArgs);
            return replacedArgs.ReplacedText;
        }]]></body>
          </codeblock>
        </method>
        <method name="remove_AllPlaceholdersReplaced">
          <declaration><![CDATA[internal static void remove_AllPlaceholdersReplaced(EventHandler<PlaceholdersReplacedEventArgs> value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="remove_PlaceholderReplaced">
          <declaration><![CDATA[internal static void remove_PlaceholderReplaced(EventHandler<PlaceholderReplacementEventArgs> value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="AllPlaceholdersReplaced">
          <declaration><![CDATA[private static EventHandler<PlaceholdersReplacedEventArgs> AllPlaceholdersReplaced;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="PlaceholderReplaced">
          <declaration><![CDATA[private static EventHandler<PlaceholderReplacementEventArgs> PlaceholderReplaced;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
        <event name="AllPlaceholdersReplaced">
          <declaration><![CDATA[internal static event EventHandler<PlaceholdersReplacedEventArgs> AllPlaceholdersReplaced;]]></declaration>
          <documentation>
          </documentation>
        </event>
        <event name="PlaceholderReplaced">
          <declaration><![CDATA[internal static event EventHandler<PlaceholderReplacementEventArgs> PlaceholderReplaced;]]></declaration>
          <documentation>
          </documentation>
        </event>
      </events>
    </class>
    <class name="PlaceholderReplacementEventArgs">
      <declaration><![CDATA[internal class PlaceholderReplacementEventArgs : PlaceholdersReplacedEventArgs]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public PlaceholderReplacementEventArgs(HttpContextBase httpContext, ClientDependencyType type, string replacedText, Match regexMatch) : base(httpContext, replacedText)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="16" sc="15" el="20" ec="10">PlaceholderReplacementEventArgs.cs</location>
            <body hash="455e98b7791e2faa98798e8111921511"><![CDATA[base(httpContext, replacedText)
        {
            Type = type;
            RegexMatch = regexMatch;
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="RegexMatch">
          <declaration><![CDATA[public Match RegexMatch]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="9" sc="35" el="9" ec="39">PlaceholderReplacementEventArgs.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="9" sc="40" el="9" ec="52">PlaceholderReplacementEventArgs.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
        <property name="Type">
          <declaration><![CDATA[public ClientDependencyType Type]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="8" sc="44" el="8" ec="48">PlaceholderReplacementEventArgs.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="8" sc="49" el="8" ec="61">PlaceholderReplacementEventArgs.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="PlaceholdersReplacedEventArgs">
      <declaration><![CDATA[internal class PlaceholdersReplacedEventArgs : EventArgs]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public PlaceholdersReplacedEventArgs(HttpContextBase httpContext, string replacedText)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="11" sc="9" el="15" ec="10">PlaceholdersReplacedEventArgs.cs</location>
            <body hash="996ac8e48337903b908511267f2ec9b2"><![CDATA[public PlaceholdersReplacedEventArgs(HttpContextBase httpContext, string replacedText)
        {
            HttpContext = httpContext;
            ReplacedText = replacedText;
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="HttpContext">
          <declaration><![CDATA[public HttpContextBase HttpContext]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="8" sc="46" el="8" ec="50">PlaceholdersReplacedEventArgs.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="8" sc="51" el="8" ec="63">PlaceholdersReplacedEventArgs.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
        <property name="ReplacedText">
          <declaration><![CDATA[public string ReplacedText]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="9" sc="38" el="9" ec="42">PlaceholdersReplacedEventArgs.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="9" sc="43" el="9" ec="47">PlaceholdersReplacedEventArgs.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ProviderDependencyList">
      <declaration><![CDATA[internal class ProviderDependencyList]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[internal ProviderDependencyList(BaseFileRegistrationProvider provider)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="12" sc="3" el="16" ec="4">ProviderDependencyList.cs</location>
            <body hash="183a02b180a5a3fb73b327b052c183e5"><![CDATA[internal ProviderDependencyList(BaseFileRegistrationProvider provider)
		{
			Provider = provider;
            Dependencies = new List<IClientDependencyFile>();
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AddDependencies">
          <declaration><![CDATA[internal void AddDependencies(IEnumerable<IClientDependencyFile> list)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="24" sc="3" el="26" ec="4">ProviderDependencyList.cs</location>
            <body hash="64fb1aa64784285089393c1eeaf03c15"><![CDATA[{
			Dependencies.AddRange(list);
		}]]></body>
          </codeblock>
        </method>
        <method name="AddDependency">
          <declaration><![CDATA[internal void AddDependency(IClientDependencyFile file)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="29" sc="3" el="31" ec="4">ProviderDependencyList.cs</location>
            <body hash="9156c1b9a0b770b64704e8d3885fdb6e"><![CDATA[{
			Dependencies.Add(file);
		}]]></body>
          </codeblock>
        </method>
        <method name="ProviderIs">
          <declaration><![CDATA[internal bool ProviderIs(BaseFileRegistrationProvider provider)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="19" sc="3" el="21" ec="4">ProviderDependencyList.cs</location>
            <body hash="6d662a71a0a3279bb55b140b94616d7f"><![CDATA[{
			return Provider.Name == provider.Name;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Dependencies">
          <declaration><![CDATA[internal List<IClientDependencyFile> Dependencies]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="33" sc="61" el="33" ec="65">ProviderDependencyList.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="33" sc="66" el="33" ec="78">ProviderDependencyList.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
        <property name="Provider">
          <declaration><![CDATA[internal BaseFileRegistrationProvider Provider]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="34" sc="52" el="34" ec="56">ProviderDependencyList.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="34" sc="57" el="34" ec="69">ProviderDependencyList.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="RendererOutput">
      <declaration><![CDATA[internal class RendererOutput]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public RendererOutput()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Name">
          <declaration><![CDATA[public string Name]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="5" sc="30" el="5" ec="34">RendererOutput.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="5" sc="35" el="5" ec="39">RendererOutput.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="OutputCss">
          <declaration><![CDATA[public string OutputCss]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="7" sc="35" el="7" ec="39">RendererOutput.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="7" sc="40" el="7" ec="44">RendererOutput.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="OutputJs">
          <declaration><![CDATA[public string OutputJs]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="6" sc="34" el="6" ec="38">RendererOutput.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="6" sc="39" el="6" ec="43">RendererOutput.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="RequestHelper">
      <declaration><![CDATA[internal class RequestHelper]]></declaration>
      <documentation>
        <summary>
 A utility class for getting the string result from an URL resource
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public RequestHelper()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static RequestHelper()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="17" sc="9" el="17" ec="113">RequestHelper.cs</location>
            <body hash="95613f4bcca4872a8bc7ffe73c8e484e"><![CDATA[private static readonly string ByteOrderMarkUtf8 = Encoding.UTF8.GetString(Encoding.UTF8.GetPreamble())]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="GetXmlResponse">
          <declaration><![CDATA[internal static string GetXmlResponse(Uri resource)]]></declaration>
          <documentation>
            <summary>
 Gets the web response and ensures that the BOM is not present not matter what encoding is specified.
 </summary>
 <param name="resource"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="130" sc="9" el="146" ec="10">RequestHelper.cs</location>
            <body hash="44c401a77c7fb2b1b4c5ede7e3a4f460"><![CDATA[{
            string xml;

            using (var client = new WebClient())
            {
                client.Credentials = CredentialCache.DefaultNetworkCredentials;
                client.Encoding = Encoding.UTF8;
                xml = client.DownloadString(resource);
            }

            if (xml.StartsWith(ByteOrderMarkUtf8))
            {
                xml = xml.Remove(0, ByteOrderMarkUtf8.Length - 1);
            }

            return xml;
        }]]></body>
          </codeblock>
        </method>
        <method name="TryReadUri">
          <declaration><![CDATA[internal static bool TryReadUri(string url, HttpContextBase http, IEnumerable<string> approvedDomains, out string requestContents, out Uri resultUri)]]></declaration>
          <documentation>
            <summary>
 Tries to convert the url to a uri, then read the request into a string and return it.
 This takes into account relative vs absolute URI's
 </summary>
 <param name="url"></param>
 <param name="approvedDomains">a list of domains approved to make requests to in order to get a response</param>
 <param name="requestContents"></param>
 <param name="http"></param>
 <param name="resultUri">
 The Uri that was used to get the result. Depending on the extension this may be absolute and might not be.
 If it is an aspx request, then it will be relative.
 </param>
 <returns>true if successful, false if not successful</returns>
 <remarks>
 if the path is a relative local path, the we use Server.Execute to get the request output, otherwise
 if it is an absolute path, a WebClient request is made to fetch the contents.
 </remarks></documentation>
          <codeblock>
            <location sl="42" sc="9" el="122" ec="10">RequestHelper.cs</location>
            <body hash="972f5509cf314dd5a98772af9a91025a"><![CDATA[{
            Uri uri;
            if (Uri.TryCreate(url, UriKind.RelativeOrAbsolute, out uri))
            {
                //flag of whether or not to make a request to get the external resource (used below)
                var bundleExternalUri = false;

                //if its a relative path, then check if we should execute/retreive contents,
                //otherwise change it to an absolute path and try to request it.
                if (!uri.IsAbsoluteUri)
                {
                    //if this is an ASPX page, we should execute it instead of http getting it.
                    if (uri.ToString().EndsWith(".aspx", StringComparison.InvariantCultureIgnoreCase))
                    {
                        var sw = new StringWriter();
                        try
                        {
                            http.Server.Execute(url, sw);
                            requestContents = sw.ToString();
                            sw.Close();
                            resultUri = uri;
                            return true;
                        }
                        catch (Exception ex)
                        {
                            ClientDependencySettings.Instance.Logger.Error(string.Format("Could not load file contents from {0}. EXCEPTION: {1}", url, ex.Message), ex);
                            requestContents = "";
                            resultUri = null;
                            return false;
                        }
                    }

                    //if this is a call for a web resource, we should http get it
                    if (url.StartsWith(http.Request.ApplicationPath.TrimEnd('/') + "/webresource.axd", StringComparison.InvariantCultureIgnoreCase))
                    {
                        bundleExternalUri = true;
                    }
                }

                try
                {
                    //we've gotten this far, make the URI absolute and try to load it
                    uri = uri.MakeAbsoluteUri(http);

                    if (uri.IsWebUri())
                    {
                        //if this isn't a web resource, we need to check if its approved
                        if (!bundleExternalUri)
                        {
                            // get the domain to test, with starting dot and trailing port, then compare with
                            // declared (authorized) domains. the starting dot is here to allow for subdomain
                            // approval, eg '.maps.google.com:80' will be approved by rule '.google.com:80', yet
                            // '.roguegoogle.com:80' will not.
                            var domain = string.Format(".{0}:{1}", uri.Host, uri.Port);

                            if (approvedDomains.Any(bundleDomain => domain.EndsWith(bundleDomain)))
                            {
                                bundleExternalUri = true;
                            }
                        }

                        if (bundleExternalUri)
                        {
                            requestContents = GetXmlResponse(uri);
                            resultUri = uri;
                            return true;
                        }

                        ClientDependencySettings.Instance.Logger.Error(string.Format("Could not load file contents from {0}. Domain is not white-listed.", url), null);
                    }
                    
                }
                catch (Exception ex)
                {
                    ClientDependencySettings.Instance.Logger.Error(string.Format("Could not load file contents from {0}. EXCEPTION: {1}", url, ex.Message), ex);
                }   
            }
            requestContents = "";
            resultUri = null;
            return false;
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="ByteOrderMarkUtf8">
          <declaration><![CDATA[private static readonly string ByteOrderMarkUtf8 = Encoding.UTF8.GetString(Encoding.UTF8.GetPreamble());]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="SimpleCompressor">
      <declaration><![CDATA[public class SimpleCompressor]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public SimpleCompressor()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CompressBytes">
          <declaration><![CDATA[public static byte[] CompressBytes(CompressionType type, byte[] fileBytes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="13" sc="9" el="40" ec="10">SimpleCompressor.cs</location>
            <body hash="e295d8a0cd384e566c54ad7723a3fa5f"><![CDATA[{
            using (var ms = new MemoryStream())
            {
                Stream compressedStream = null;

                if (type == CompressionType.deflate)
                {
                    compressedStream = new DeflateStream(ms, CompressionMode.Compress, true);
                }
                else if (type == CompressionType.gzip)
                {
                    compressedStream = new GZipStream(ms, CompressionMode.Compress, true);
                }

                if (type != CompressionType.none && compressedStream != null)
                {
                    //write the bytes to the compressed stream
                    compressedStream.Write(fileBytes, 0, fileBytes.Length);
                    compressedStream.Close();
                    byte[] output = ms.ToArray();
                    ms.Close();
                    return output;
                }

                //not compressed
                return fileBytes;
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="DecompressBytes">
          <declaration><![CDATA[public static byte[] DecompressBytes(CompressionType type, byte[] compressedBytes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="43" sc="9" el="71" ec="10">SimpleCompressor.cs</location>
            <body hash="00ea01eacca34e463201f1fda98a4c79"><![CDATA[{
            using (var ms = new MemoryStream())
            {
                Stream decompressedStream = null;

                if (type == CompressionType.deflate)
                {
                    decompressedStream = new DeflateStream(ms, CompressionMode.Decompress, true);
                }
                else if (type == CompressionType.gzip)
                {
                    decompressedStream = new GZipStream(ms, CompressionMode.Decompress, true);
                }

                if (type != CompressionType.none && decompressedStream != null)
                {
                    //write the bytes to the compressed stream
                    decompressedStream.Write(compressedBytes, 0, compressedBytes.Length);
                    decompressedStream.Close();
                    byte[] output = ms.ToArray();
                    ms.Close();
                    return output;
                }

                //not compressed
                return compressedBytes;
            }
            
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="StringExtensions">
      <declaration><![CDATA[public static class StringExtensions]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="DecodeFrom64">
          <declaration><![CDATA[public static string DecodeFrom64(this string toDecode)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="80" sc="9" el="83" ec="10">StringExtensions.cs</location>
            <body hash="de17ac2cea720edd8af69f480cd696f9"><![CDATA[{
            byte[] toDecodeAsBytes = System.Convert.FromBase64String(toDecode);
            return Encoding.UTF8.GetString(toDecodeAsBytes);
        }]]></body>
          </codeblock>
        </method>
        <method name="DecodeFrom64Url">
          <declaration><![CDATA[public static string DecodeFrom64Url(this string toDecode)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="67" sc="9" el="77" ec="10">StringExtensions.cs</location>
            <body hash="55475a984df461d482c94aeeacd5a590"><![CDATA[{
            // see BaseFileRegistrationProvider.EncodeTo64Url
            //
            toDecode = toDecode.Replace("-", "+");
            toDecode = toDecode.Replace("_", "/");
            int rem = toDecode.Length % 4; // 0 (aligned), 1, 2 or 3 (not aligned)
            if (rem > 0)
                toDecode = toDecode.PadRight(toDecode.Length + 4 - rem, '='); // align

            return DecodeFrom64(toDecode);
        }]]></body>
          </codeblock>
        </method>
        <method name="EncodeTo64">
          <declaration><![CDATA[public static string EncodeTo64(this string toEncode)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="61" sc="9" el="65" ec="10">StringExtensions.cs</location>
            <body hash="789d7e950606f06d8151759c5b9088fb"><![CDATA[{
            byte[] toEncodeAsBytes = Encoding.UTF8.GetBytes(toEncode);
            string returnValue = System.Convert.ToBase64String(toEncodeAsBytes);
            return returnValue;
        }]]></body>
          </codeblock>
        </method>
        <method name="EncodeTo64Url">
          <declaration><![CDATA[public static string EncodeTo64Url(this string toEncode)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="46" sc="9" el="58" ec="10">StringExtensions.cs</location>
            <body hash="e86e160f4db50603a0696fbadbbba406"><![CDATA[{
            string returnValue = EncodeTo64(toEncode);

            // returnValue is base64 = may contain a-z, A-Z, 0-9, +, /, and =.
            // the = at the end is just a filler, can remove
            // then convert the + and / to "base64url" equivalent
            //
            returnValue = returnValue.TrimEnd(new char[] { '=' });
            returnValue = returnValue.Replace("+", "-");
            returnValue = returnValue.Replace("/", "_");

            return returnValue;
        }]]></body>
          </codeblock>
        </method>
        <method name="EndsWithOneOf">
          <declaration><![CDATA[public static bool EndsWithOneOf(this string str, string[] ext)]]></declaration>
          <documentation>
            <summary>
 checks if the string ends with one of the strings specified. This ignores case.
 </summary>
 <param name="str"></param>
 <param name="ext"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="137" sc="9" el="149" ec="10">StringExtensions.cs</location>
            <body hash="1e1183071e719d49cfc0b65645620a9a"><![CDATA[{
            var upper = str.ToUpper();
            bool isExt = false;
            foreach (var e in ext)
            {
                if (upper.EndsWith(e.ToUpper()))
                {
                    isExt = true;
                    break;
                }
            }
            return isExt;
        }]]></body>
          </codeblock>
        </method>
        <method name="GenerateHash">
          <declaration><![CDATA[public static string GenerateHash(this string str)]]></declaration>
          <documentation>
            <summary>
 Generates a hash of a string based on the FIPS compliance setting.
 </summary>
 <param name="str"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="91" sc="9" el="103" ec="10">StringExtensions.cs</location>
            <body hash="ac28799553472cdd5cdb54bf2fdca97b"><![CDATA[{
            try
            {                
                return CryptoConfig.AllowOnlyFipsAlgorithms
                    ? str.GenerateSha256Hash()
                    : str.GenerateMd5();
            }
            catch (Exception)
            {
                //default to MD5
                return str.GenerateMd5();
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="GenerateMd5">
          <declaration><![CDATA[public static string GenerateMd5(this string str)]]></declaration>
          <documentation>
            <summary>Generate a MD5 hash of a string
 </summary>
          </documentation>
          <codeblock>
            <location sl="122" sc="9" el="128" ec="10">StringExtensions.cs</location>
            <body hash="3c6c079983338e4102b46356b5a36928"><![CDATA[{
            using (var hasher = new MD5CryptoServiceProvider())
            {
                var byteArray = hasher.ComputeHash(Encoding.Unicode.GetBytes(str));
                return byteArray.Aggregate("", (current, b) => current + b.ToString("x2"));    
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="GenerateSha256Hash">
          <declaration><![CDATA[public static string GenerateSha256Hash(this string str)]]></declaration>
          <documentation>
            <summary>
 Generate a SHA256 hash of a string
 </summary>
 <param name="str"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="111" sc="9" el="117" ec="10">StringExtensions.cs</location>
            <body hash="a418b6648d43e48d62669d229003da24"><![CDATA[{
            using (var hasher = new SHA256CryptoServiceProvider())
            {
                var byteArray = hasher.ComputeHash(Encoding.Unicode.GetBytes(str));
                return byteArray.Aggregate("", (current, b) => current + b.ToString("x2"));
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="ReplaceFirst">
          <declaration><![CDATA[public static string ReplaceFirst(this string text, string search, string replace)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="36" sc="9" el="43" ec="10">StringExtensions.cs</location>
            <body hash="4fa1653096b006d506d1ebc3bc4e66bf"><![CDATA[{
            int pos = text.IndexOf(search);
            if (pos < 0)
            {
                return text;
            }
            return text.Substring(0, pos) + replace + text.Substring(pos + search.Length);
        }]]></body>
          </codeblock>
        </method>
        <method name="ReplaceNonAlphanumericChars">
          <declaration><![CDATA[internal static string ReplaceNonAlphanumericChars(this string input, char replacement)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="18" sc="9" el="26" ec="10">StringExtensions.cs</location>
            <body hash="515a2f35e7468286289d1ca9baca9d44"><![CDATA[{
            //any character that is not alphanumeric, convert to a hyphen
            var mName = input;
            foreach (var c in mName.ToCharArray().Where(c => !char.IsLetterOrDigit(c)))
            {
                mName = mName.Replace(c, replacement);
            }
            return mName;
        }]]></body>
          </codeblock>
        </method>
        <method name="ReverseString">
          <declaration><![CDATA[public static string ReverseString(this string s)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="29" sc="9" el="33" ec="10">StringExtensions.cs</location>
            <body hash="614a85e494b0fdc750f91b546d360e82"><![CDATA[{
            char[] charArray = s.ToCharArray();
            Array.Reverse(charArray);
            return new string(charArray);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="GetConfigSection">
          <declaration><![CDATA[internal static Func<ClientDependencySection> GetConfigSection;]]></declaration>
          <documentation>
            <summary>
 Generally used for unit tests to get access to the settings
 </summary>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="UriExtensions">
      <declaration><![CDATA[public static class UriExtensions]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="IsLocalUri">
          <declaration><![CDATA[public static bool IsLocalUri(this Uri uri, HttpContextBase http)]]></declaration>
          <documentation>
            <summary>
 Determines if the uri is a locally based web file
 </summary>
 <param name="uri"></param>
 <param name="http"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="59" sc="9" el="73" ec="10">UriExtensions.cs</location>
            <body hash="261fb55e4bd74421cf26e64aae3af9e9"><![CDATA[{
            if (http.Request == null)
            {
                throw new InvalidOperationException("The Request must be assigned to the context");
            }
            if (http.Request.Url == null)
            {
                throw new InvalidOperationException("The Url must be assigned to the Request");
            }           
            if (!uri.IsAbsoluteUri)
            {
                uri = uri.MakeAbsoluteUri(http);
            }
            return uri.IsWebUri() && string.Equals(http.Request.Url.Host, uri.Host, StringComparison.OrdinalIgnoreCase);
        }]]></body>
          </codeblock>
        </method>
        <method name="IsWebUri">
          <declaration><![CDATA[public static bool IsWebUri(this Uri uri)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="15" sc="9" el="18" ec="10">UriExtensions.cs</location>
            <body hash="4c328e35d85cbbb3c4fb3b119f57f226"><![CDATA[{
            return uri.Scheme.Equals("http", StringComparison.InvariantCultureIgnoreCase)
                   || uri.Scheme.Equals("https", StringComparison.InvariantCultureIgnoreCase);
        }]]></body>
          </codeblock>
        </method>
        <method name="MakeAbsoluteUri">
          <declaration><![CDATA[public static Uri MakeAbsoluteUri(this Uri uri, HttpContextBase http)]]></declaration>
          <documentation>
            <summary>
 Checks if the url is a local/relative uri, if it is, it makes it absolute based on the
 current request uri.
 </summary>
 <param name="uri"></param>
 <param name="http"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="39" sc="9" el="50" ec="10">UriExtensions.cs</location>
            <body hash="b338b17da9035e1a17af1ee25aa59fe4"><![CDATA[{
            if (!uri.IsAbsoluteUri)
            {
                if (http.Request.Url != null)
                {
                    var left = http.Request.Url.GetLeftPart(UriPartial.Authority);
                    var absoluteUrl = new Uri(new Uri(left), uri);
                    return absoluteUrl;
                }
            }
            return uri;
        }]]></body>
          </codeblock>
        </method>
        <method name="ToAbsolutePath">
          <declaration><![CDATA[internal static string ToAbsolutePath(this Uri originalUri, string path)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="21" sc="9" el="29" ec="10">UriExtensions.cs</location>
            <body hash="dc337647856dfeb8ac5b9c84bb82086c"><![CDATA[{
            var hashSplit = path.Split(new[] { '#' }, StringSplitOptions.RemoveEmptyEntries);

            return string.Format(@"{0}{1}",
                                 (path.StartsWith("http://", StringComparison.InvariantCultureIgnoreCase)
                                 || path.StartsWith("https://", StringComparison.InvariantCultureIgnoreCase)
                                 || path.StartsWith("//", StringComparison.InvariantCultureIgnoreCase)) ? path : new Uri(originalUri, path).PathAndQuery,
                                 hashSplit.Length > 1 ? ("#" + hashSplit[1]) : "");
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="VirtualPathFileReader">
      <declaration><![CDATA[internal class VirtualPathFileReader : IFileReader]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public VirtualPathFileReader()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="ReadFile">
          <declaration><![CDATA[public string ReadFile(string filePath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="20" sc="9" el="30" ec="10">IFileReader.cs</location>
            <body hash="5cfac95d28d76c306e0489af5b1f6155"><![CDATA[{
            var file = HostingEnvironment.VirtualPathProvider.GetFile(filePath);
            if (file == null) return string.Empty;
            string output;
            using (var reader = new StreamReader(file.Open()))
            {
                output = reader.ReadToEnd();
                reader.Close();
            }
            return output;
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="ClientDependency.Core.CompositeFiles">
    <class name="CompositeDependencyHandler">
      <declaration><![CDATA[public class CompositeDependencyHandler : IHttpHandler]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public CompositeDependencyHandler()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static CompositeDependencyHandler()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="19" sc="9" el="29" ec="54">CompositeFiles\CompositeDependencyHandler.cs</location>
            <body hash="e051f6d4c598cdb596e4ec0ef9c61fef"><![CDATA[private readonly static object Lock = new object();
        private static DnnConfiguration dnnConfig = new DnnConfiguration();
        /// <summary>
        /// When building composite includes, it creates a Base64 encoded string of all of the combined dependency file paths
        /// for a given composite group. If this group contains too many files, then the file path with the query string will be very long.
        /// This is the maximum allowed number of characters that there is allowed, otherwise an exception is thrown.
        /// </summary>
        /// <remarks>
        /// If this handler path needs to change, it can be changed by setting it in the global.asax on application start
        /// </remarks>
        public static int MaxHandlerUrlLength = 2048;]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="GetCombinedFiles">
          <declaration><![CDATA[private byte[] GetCombinedFiles(HttpContextBase context, string fileset, ClientDependencyType type, out List<CompositeFileDefinition> fDefs)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="217" sc="9" el="222" ec="10">CompositeFiles\CompositeDependencyHandler.cs</location>
            <body hash="ed864ada88f859bffdd180fb8feabff4"><![CDATA[{
            //get the file list
            string[] filePaths = fileset.DecodeFrom64Url().Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
            //combine files and get the definition types of them (internal vs external resources)
            return ClientDependencySettings.Instance.DefaultCompositeFileProcessingProvider.CombineFiles(filePaths, context, type, out fDefs);
        }]]></body>
          </codeblock>
        </method>
        <method name="ProcessFromFile">
          <declaration><![CDATA[private void ProcessFromFile(HttpContextBase context, CompositeFileMap map, out string compositeFileName, out byte[] outputBytes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="225" sc="9" el="231" ec="10">CompositeFiles\CompositeDependencyHandler.cs</location>
            <body hash="0a2eb54cb0e73b62d4056aa7b5acff83"><![CDATA[{
            //the saved file's bytes are already compressed.
            outputBytes = map.GetCompositeFileBytes();
            compositeFileName = map.CompositeFileName;
            var cType = (CompressionType)Enum.Parse(typeof(CompressionType), map.CompressionType);
            context.AddCompressionResponseHeader(cType);
        }]]></body>
          </codeblock>
        </method>
        <method name="ProcessRequestInternal">
          <declaration><![CDATA[internal byte[] ProcessRequestInternal(HttpContextBase context, string fileset, ClientDependencyType type, int version, byte[] outputBytes, CompositeDependencyHandler.OutputCachedPage page)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="126" sc="9" el="214" ec="10">CompositeFiles\CompositeDependencyHandler.cs</location>
            <body hash="14af4acc7274412873bd024c8adf32d6"><![CDATA[{
            //get the compression type supported
            var clientCompression = context.GetClientCompression();

			var x1 = ClientDependencySettings.Instance;
			if (x1 == null) throw new Exception("x1");
			var x2 = x1.DefaultFileMapProvider;
			if (x2 == null) throw new Exception("x2");

            //get the map to the composite file for this file set, if it exists.
            var map = ClientDependencySettings.Instance.DefaultFileMapProvider.GetCompositeFile(fileset, version, clientCompression.ToString());

            string compositeFileName = "";
            if (map != null && map.HasFileBytes)
            {
                ProcessFromFile(context, map, out compositeFileName, out outputBytes);
            }
            else
            {
                lock (Lock)
                {
                    //check again...
                    if (map != null && map.HasFileBytes)
                    {
                        //there's files there now, so process them
                        ProcessFromFile(context, map, out compositeFileName, out outputBytes);
                    }
                    else
                    {
                        List<CompositeFileDefinition> fileDefinitions;
                        byte[] fileBytes;

                        if (ClientDependencySettings.Instance.DefaultCompositeFileProcessingProvider.UrlType == CompositeUrlType.MappedId)
                        {
                            //need to try to find the map by it's id/version (not compression)
                            var filePaths = ClientDependencySettings.Instance.DefaultFileMapProvider.GetDependentFiles(fileset, version);

                            if (filePaths == null)
                            {
                                if (context.IsDebuggingEnabled || dnnConfig.IsDebugMode())
                                {
                                    throw new KeyNotFoundException("no map was found for the dependency key: " + fileset +
                                                               " ,CompositeUrlType.MappedId requires that a map is found");
                                }

                                throw new HttpException(404, "File not found");
                            }

                            //combine files and get the definition types of them (internal vs external resources)
                            fileBytes = ClientDependencySettings.Instance.DefaultCompositeFileProcessingProvider
                                .CombineFiles(filePaths.ToArray(), context, type, out fileDefinitions);
                        }
                        else
                        {
                            //need to do the combining, etc... and save the file map                            
                            fileBytes = GetCombinedFiles(context, fileset, type, out fileDefinitions);                           
                        }

                        //compress data                        
                        outputBytes = ClientDependencySettings.Instance.DefaultCompositeFileProcessingProvider.CompressBytes(clientCompression, fileBytes);
                        context.AddCompressionResponseHeader(clientCompression);

                        //save combined file
                        var compositeFile = ClientDependencySettings.Instance
                            .DefaultCompositeFileProcessingProvider
                            .SaveCompositeFile(outputBytes, type, context.Server);

                        if (compositeFile != null)
                        {
                            compositeFileName = compositeFile.FullName;
                            if (!string.IsNullOrEmpty(compositeFileName))
                            {
                                //Update the XML file map
                                ClientDependencySettings.Instance.DefaultFileMapProvider.CreateUpdateMap(fileset, clientCompression.ToString(),
                                    fileDefinitions.Select(x => new BasicFile(type) { FilePath = x.Uri }),
                                        compositeFileName,
                                        //TODO: We should probably use the passed in version param?
                                        ClientDependencySettings.Instance.Version);
                            }
                        }
                    }
                }
            }
            
            //set our caching params 
            SetCaching(context, compositeFileName, fileset, clientCompression, page);

            return outputBytes;
        }]]></body>
          </codeblock>
        </method>
        <method name="SetCaching">
          <declaration><![CDATA[private void SetCaching(HttpContextBase context, string fileName, string fileset, CompressionType compressionType, CompositeDependencyHandler.OutputCachedPage page)]]></declaration>
          <documentation>
            <summary>
 Sets the output cache parameters and also the client side caching parameters
 </summary>
 <param name="context"></param>
 <param name="fileName">The name of the file that has been saved to disk</param>
 <param name="fileset">The Base64 encoded string supplied in the query string for the handler</param>
 <param name="compressionType"></param>
 <param name="page">The outputcache page - ensures server side output cache is stored</param></documentation>
          <codeblock>
            <location sl="242" sc="9" el="259" ec="10">CompositeFiles\CompositeDependencyHandler.cs</location>
            <body hash="025d2d426ab796e78096b72ffdedf436"><![CDATA[{
            //this initializes the webforms page part to get outputcaching working server side
            page.ProcessRequest(HttpContext.Current);

            // in any case, cache already varies by pathInfo (build-in) so for path formats, we do not need anything
            // just add params for querystring format, just in case...
            context.SetClientCachingResponse(
                //the e-tag to use
                (fileset + compressionType.ToString()).GenerateHash(), 
                //10 days
                10, 
                //vary-by params
                new[] { "t", "s", "cdv" });

            //make this output cache dependent on the file if there is one.
            if (!string.IsNullOrEmpty(fileName))
                context.Response.AddFileDependency(fileName);
        }]]></body>
          </codeblock>
        </method>
        <method name="System.Web.IHttpHandler.ProcessRequest">
          <declaration><![CDATA[void IHttpHandler.ProcessRequest(HttpContext context)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="40" sc="9" el="123" ec="10">CompositeFiles\CompositeDependencyHandler.cs</location>
            <body hash="9b68b68d9625776495d754c5a8c1bf34"><![CDATA[{
            var contextBase = new HttpContextWrapper(context);
            
            ClientDependencyType type;
            string fileKey;
            int version = 0;

            if (string.IsNullOrEmpty(context.Request.PathInfo))
            {
                // querystring format
                fileKey = context.Request["s"];
                if (!string.IsNullOrEmpty(context.Request["cdv"]) && !Int32.TryParse(context.Request["cdv"], out version))
                    throw new ArgumentException("Could not parse the version in the request");
                try
                {
                    type = (ClientDependencyType)Enum.Parse(typeof(ClientDependencyType), context.Request["t"], true);
                }
                catch
                {
                    throw new ArgumentException("Could not parse the type set in the request");
                }
            }
            else
            {

                //get path to parse
                var path = context.Request.PathInfo.TrimStart('/');
                var pathFormat = ClientDependencySettings.Instance.DefaultCompositeFileProcessingProvider.PathBasedUrlFormat;
                //parse using the parser
                if (!PathBasedUrlFormatter.Parse(pathFormat, path, out fileKey, out type, out version))
                {
                    if (context.IsDebuggingEnabled || dnnConfig.IsDebugMode())
                    {
                        throw new FormatException("Could not parse the URL path: " + path + " with the format specified: " + pathFormat);
                    }

                    throw new HttpException(404, "File not found");
                }
            }

            fileKey = context.Server.UrlDecode(fileKey);

            if (string.IsNullOrEmpty(fileKey))
                throw new ArgumentException("Must specify a fileset in the request");

            byte[] outputBytes = null;

            //create the webforms page to perform the server side output cache, ensure
            // the parameters are the same that we are going to use when setting our own custom
            // caching parameters. Unfortunately server side output cache is tied so directly to 
            // webforms this seems to be the only way to to this.
            var page = new OutputCachedPage(new OutputCacheParameters
            {
                Duration = Convert.ToInt32(TimeSpan.FromDays(10).TotalSeconds),
                Enabled = true,
                VaryByParam = "t;s;cdv",
                VaryByContentEncoding = "gzip;deflate",
                Location = OutputCacheLocation.Any
            });

            //retry up to 5 times... this is only here due to a bug found in another website that was returning a blank 
            //result. To date, it can't be replicated in VS, but we'll leave it here for error handling support... can't hurt
            for (int i = 0; i < 5; i++)
            {
                outputBytes = ProcessRequestInternal(contextBase, fileKey, type, version, outputBytes, page);
                if (outputBytes != null && outputBytes.Length > 0)
                    break;

                ClientDependencySettings.Instance.Logger.Error(string.Format("No bytes were returned, this is attempt {0}. Fileset: {1}, Type: {2}, Version: {3}", i, fileKey, type, version), null);
            }

            if (outputBytes == null || outputBytes.Length == 0)
            {
                ClientDependencySettings.Instance.Logger.Fatal(string.Format("No bytes were returned after 5 attempts. Fileset: {0}, Type: {1}, Version: {2}", fileKey, type, version), null);
                List<CompositeFileDefinition> fDefs;
                outputBytes = GetCombinedFiles(contextBase, fileKey, type, out fDefs);
            }

            context.Response.ContentType = type == ClientDependencyType.Javascript ? "application/x-javascript" : "text/css";
            context.Response.OutputStream.Write(outputBytes, 0, outputBytes.Length);

            //dispose the webforms page used to do ensure server side output cache
            page.Dispose();
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="dnnConfig">
          <declaration><![CDATA[private static DnnConfiguration dnnConfig = new DnnConfiguration();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Lock">
          <declaration><![CDATA[private static readonly object Lock = new object();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="MaxHandlerUrlLength">
          <declaration><![CDATA[public static int MaxHandlerUrlLength = 2048;]]></declaration>
          <documentation>
            <summary>
 When building composite includes, it creates a Base64 encoded string of all of the combined dependency file paths
 for a given composite group. If this group contains too many files, then the file path with the query string will be very long.
 This is the maximum allowed number of characters that there is allowed, otherwise an exception is thrown.
 </summary>
 <remarks>
 If this handler path needs to change, it can be changed by setting it in the global.asax on application start
 </remarks></documentation>
        </field>
      </fields>
      <properties>
        <property name="System.Web.IHttpHandler.IsReusable">
          <declaration><![CDATA[bool IHttpHandler.IsReusable]]></declaration>
          <documentation>
            <summary>
 Re-usable is true, this is a thread safe class
 </summary>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="CompositeFileDefinition">
      <declaration><![CDATA[public class CompositeFileDefinition]]></declaration>
      <documentation>
        <summary>
 A simple class defining a Uri string and whether or not it is a local application file
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public CompositeFileDefinition(string uri, bool isLocalFile)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="18" sc="3" el="22" ec="4">CompositeFiles\CompositeFileDefinition.cs</location>
            <body hash="eaefa2dd9a956d9e644b30e1b5ef939d"><![CDATA[public CompositeFileDefinition(string uri, bool isLocalFile)
		{
			IsLocalFile = isLocalFile;
			Uri = uri;
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Equals">
          <declaration><![CDATA[public override bool Equals(object obj)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="27" sc="3" el="31" ec="4">CompositeFiles\CompositeFileDefinition.cs</location>
            <body hash="b23778e0684a87539ad1f5f60e0af16a"><![CDATA[{
			return (obj.GetType() == this.GetType()
				&& ((CompositeFileDefinition)obj).IsLocalFile.Equals(IsLocalFile)
				&& ((CompositeFileDefinition)obj).Uri.Equals(Uri));
		}]]></body>
          </codeblock>
        </method>
        <method name="GetHashCode">
          <declaration><![CDATA[public override int GetHashCode()]]></declaration>
          <documentation>
            <summary>
 overrides hash code to ensure that it is unique per machine
 </summary>
 <returns></returns></documentation>
          <codeblock>
            <location sl="38" sc="3" el="40" ec="4">CompositeFiles\CompositeFileDefinition.cs</location>
            <body hash="874a70d4d5ab9820b69ac97ad6a516c0"><![CDATA[{
            return (NetworkHelper.MachineName + Uri).GetHashCode();
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="IsLocalFile">
          <declaration><![CDATA[public bool IsLocalFile]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="23" sc="29" el="23" ec="33">CompositeFiles\CompositeFileDefinition.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="23" sc="34" el="23" ec="38">CompositeFiles\CompositeFileDefinition.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Uri">
          <declaration><![CDATA[public string Uri]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="24" sc="23" el="24" ec="27">CompositeFiles\CompositeFileDefinition.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="24" sc="28" el="24" ec="32">CompositeFiles\CompositeFileDefinition.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="CompositeFileMap">
      <declaration><![CDATA[public class CompositeFileMap]]></declaration>
      <documentation>
        <summary>
 Deserialized structure of the XML stored in the map file
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[internal CompositeFileMap(string key, string compressionType, string file, IEnumerable<string> filePaths, int version)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="16" sc="3" el="23" ec="4">CompositeFiles\CompositeFileMap.cs</location>
            <body hash="bb26b9cd8ff86384a919e04953db031e"><![CDATA[internal CompositeFileMap(string key, string compressionType, string file, IEnumerable<string> filePaths, int version)
		{
            DependentFiles = filePaths;
			FileKey = key;
			CompositeFileName = file;
			CompressionType = compressionType;
            Version = version;
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="GetCompositeFileBytes">
          <declaration><![CDATA[public byte[] GetCompositeFileBytes()]]></declaration>
          <documentation>
            <summary>
 Returns the file's bytes
 </summary>
          </documentation>
          <codeblock>
            <location sl="49" sc="3" el="72" ec="4">CompositeFiles\CompositeFileMap.cs</location>
            <body hash="c9f5ca05970a6fd357481e91991afe17"><![CDATA[{
			if (m_FileBytes == null)
			{
                if (string.IsNullOrEmpty(CompositeFileName))
                {
                    return null;
                }

				try
				{
					FileInfo fi = new FileInfo(CompositeFileName);
					FileStream fs = fi.OpenRead();
					byte[] fileBytes = new byte[fs.Length];
					fs.Read(fileBytes, 0, fileBytes.Length);
					fs.Close();
					m_FileBytes = fileBytes;
				}
				catch
				{
					m_FileBytes = null;
				}				
			}
			return m_FileBytes;
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_FileBytes">
          <declaration><![CDATA[private byte[] m_FileBytes;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="CompositeFileName">
          <declaration><![CDATA[public string CompositeFileName]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="26" sc="37" el="26" ec="41">CompositeFiles\CompositeFileMap.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="26" sc="42" el="26" ec="54">CompositeFiles\CompositeFileMap.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
        <property name="CompressionType">
          <declaration><![CDATA[public string CompressionType]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="27" sc="35" el="27" ec="39">CompositeFiles\CompositeFileMap.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="27" sc="40" el="27" ec="52">CompositeFiles\CompositeFileMap.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
        <property name="DependentFiles">
          <declaration><![CDATA[public IEnumerable<string> DependentFiles]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="29" sc="53" el="29" ec="57">CompositeFiles\CompositeFileMap.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="29" sc="58" el="29" ec="70">CompositeFiles\CompositeFileMap.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
        <property name="FileKey">
          <declaration><![CDATA[public string FileKey]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="25" sc="27" el="25" ec="31">CompositeFiles\CompositeFileMap.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="25" sc="32" el="25" ec="44">CompositeFiles\CompositeFileMap.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
        <property name="HasFileBytes">
          <declaration><![CDATA[public bool HasFileBytes]]></declaration>
          <documentation>
            <summary>
 If for some reason the file doesn't exist any more or we cannot read the file, this will return false.
 </summary>
          </documentation>
          <codeblock>
            <location sl="39" sc="4" el="42" ec="5">CompositeFiles\CompositeFileMap.cs</location>
            <body hash="a301ab84288b016fd2a55df259b503a6"><![CDATA[{
				GetCompositeFileBytes();
				return m_FileBytes != null;
			}]]></body>
          </codeblock>
        </property>
        <property name="Version">
          <declaration><![CDATA[public int Version]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="28" sc="30" el="28" ec="34">CompositeFiles\CompositeFileMap.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="28" sc="35" el="28" ec="47">CompositeFiles\CompositeFileMap.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="CssMin">
      <deprecation>Use CssHelper instead</deprecation>
      <declaration><![CDATA[public class CssMin]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public CssMin()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CompressCSS">
          <declaration><![CDATA[public static string CompressCSS(string body)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="10" sc="9" el="12" ec="10">CompositeFiles\CSSMin.cs</location>
            <body hash="0f15e6e6df965dbd72b8d1ebea3f0478"><![CDATA[{
            return CssHelper.MinifyCss(body);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="DefaultFileWriter">
      <declaration><![CDATA[public class DefaultFileWriter : IFileWriter]]></declaration>
      <documentation>
        <summary>
 The default file local file writer in CDF
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public DefaultFileWriter()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="WriteContentToStream">
          <declaration><![CDATA[public static void WriteContentToStream(BaseCompositeFileProcessingProvider provider, StreamWriter sw, string content, ClientDependencyType type, HttpContextBase context, string originalUrl)]]></declaration>
          <documentation>
            <summary>
 Writes the actual contents of a file or request result to the stream and ensures the contents are minified if necessary
 </summary>
 <param name="provider"></param>
 <param name="sw"></param>
 <param name="content"></param>
 <param name="type"></param>
 <param name="context"></param>
 <param name="originalUrl">The original Url that the content is related to</param></documentation>
          <codeblock>
            <location sl="42" sc="9" el="67" ec="10">CompositeFiles\DefaultFileWriter.cs</location>
            <body hash="bef469045e34d5f52e77684c9c860c27"><![CDATA[{
            if (type == ClientDependencyType.Css)
            {
                IEnumerable<string> importedPaths;
                var removedImports = CssHelper.ParseImportStatements(content, out importedPaths);

                //need to write the imported sheets first since these theoretically should *always* be at the top for browser to support them
                foreach (var importPath in importedPaths)
                {
                    var uri = new Uri(originalUrl, UriKind.RelativeOrAbsolute)
                        .MakeAbsoluteUri(context);
                    var absolute = uri.ToAbsolutePath(importPath);
                    provider.WritePathToStream(ClientDependencyType.Css, absolute, context, sw);
                }

                //ensure the Urls in the css are changed to absolute
                var parsedUrls = CssHelper.ReplaceUrlsWithAbsolutePaths(removedImports, originalUrl, context);

                //then we write the css with the removed import statements
                sw.WriteLine(provider.MinifyFile(parsedUrls, ClientDependencyType.Css));
            }
            else
            {
                sw.WriteLine(provider.MinifyFile(content, type));
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="WriteToStream">
          <declaration><![CDATA[public bool WriteToStream(BaseCompositeFileProcessingProvider provider, StreamWriter sw, FileInfo fi, ClientDependencyType type, string origUrl, HttpContextBase http)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="17" sc="9" el="30" ec="10">CompositeFiles\DefaultFileWriter.cs</location>
            <body hash="cb62156ecf7f4d824d37384dfd6f4d8e"><![CDATA[{
            try
            {
                //if it is a file based dependency then read it				
                var fileContents = File.ReadAllText(fi.FullName, Encoding.UTF8); //read as utf 8
                WriteContentToStream(provider, sw, fileContents, type, http, origUrl);
                return true;
            }
            catch (Exception ex)
            {
                ClientDependencySettings.Instance.Logger.Error(string.Format("Could not write file {0} contents to stream. EXCEPTION: {1}", fi.FullName, ex.Message), ex);
                return false;
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="IFileWriter">
      <declaration><![CDATA[public interface IFileWriter]]></declaration>
      <documentation>
        <summary>
 An interface defining a file writer for a local file
 </summary>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="WriteToStream">
          <declaration><![CDATA[bool WriteToStream(BaseCompositeFileProcessingProvider provider, StreamWriter sw, FileInfo fi, ClientDependencyType type, string origUrl, HttpContextBase http);]]></declaration>
          <documentation>
            <summary>
 writes the file to the stream and returns true if it was successful, false if not successful
 </summary>
 <param name="provider"></param>
 <param name="sw"></param>
 <param name="fi"></param>
 <param name="type"></param>
 <param name="origUrl"></param>
 <param name="http"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="IVirtualFile">
      <declaration><![CDATA[public interface IVirtualFile]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="Open">
          <declaration><![CDATA[Stream Open();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Path">
          <declaration><![CDATA[string Path]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="IVirtualFileProvider">
      <declaration><![CDATA[public interface IVirtualFileProvider]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="FileExists">
          <declaration><![CDATA[bool FileExists(string virtualPath);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetFile">
          <declaration><![CDATA[IVirtualFile GetFile(string virtualPath);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="IVirtualFileWriter">
      <declaration><![CDATA[public interface IVirtualFileWriter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="WriteToStream">
          <declaration><![CDATA[bool WriteToStream(BaseCompositeFileProcessingProvider provider, StreamWriter sw, IVirtualFile vf, ClientDependencyType type, string origUrl, HttpContextBase http);]]></declaration>
          <documentation>
            <summary>
 writes the file to the stream and returns true if it was successful, false if not successful
 </summary>
 <param name="provider"></param>
 <param name="sw"></param>
 <param name="vf"></param>
 <param name="type"></param>
 <param name="origUrl"></param>
 <param name="http"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="FileProvider">
          <declaration><![CDATA[IVirtualFileProvider FileProvider]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="JSMin">
      <declaration><![CDATA[public class JSMin]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private int theLookahead = -1;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="46" sc="9" el="46" ec="32">CompositeFiles\JSMin.cs</location>
            <body hash="7899911ea084837ca3a3b432f37c19b8"><![CDATA[int theLookahead = EOF]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static JSMin()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="47" sc="9" el="48" ec="31">CompositeFiles\JSMin.cs</location>
            <body hash="3961d9cc010a7acc18789827c529bb2a"><![CDATA[static int theX = EOF;
        static int theY = EOF;]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="action">
          <declaration><![CDATA[private void action(int d)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="150" sc="9" el="254" ec="10">CompositeFiles\JSMin.cs</location>
            <body hash="eaabab662f70549c41c0222acb4ec00f"><![CDATA[{
            switch (d)
            {
                case 1:
                    put(theA);
                    if (
                        (theY == '\n' || theY == ' ') &&
                        (theA == '+' || theA == '-' || theA == '*' || theA == '/') &&
                        (theB == '+' || theB == '-' || theB == '*' || theB == '/')
                        )
                    {
                        put(theY);
                    }
                    goto case 2;
                case 2:
                    theA = theB;
                    if (theA == '\'' || theA == '"' || theA == '`')
                    {
                        for (;;)
                        {
                            put(theA);
                            theA = get();
                            if (theA == theB)
                            {
                                break;
                            }
                            if (theA == '\\')
                            {
                                put(theA);
                                theA = get();
                            }
                            if (theA == EOF)
                            {
                                throw new Exception(string.Format("Error: JSMIN unterminated string literal: {0}\n", theA));
                            }
                        }
                    }
                    goto case 3;
                case 3:
                    theB = next();
                    if (theB == '/' && (
                                           theA == '(' || theA == ',' || theA == '=' || theA == ':' ||
                                           theA == '[' || theA == '!' || theA == '&' || theA == '|' ||
                                           theA == '?' || theA == '+' || theA == '-' || theA == '~' ||
                                           theA == '*' || theA == '/' || theA == '{' || theA == '\n'
                                       ))
                    {
                        put(theA);
                        if (theA == '/' || theA == '*')
                        {
                            put(' ');
                        }
                        put(theB);
                        for (;;)
                        {
                            theA = get();
                            if (theA == '[')
                            {
                                for (;;)
                                {
                                    put(theA);
                                    theA = get();
                                    if (theA == ']')
                                    {
                                        break;
                                    }
                                    if (theA == '\\')
                                    {
                                        put(theA);
                                        theA = get();
                                    }
                                    if (theA == EOF)
                                    {
                                        throw new Exception(string.Format("Error: JSMIN Unterminated set in Regular Expression literal: {0}\n", theA));
                                    }
                                }
                            }
                            else if (theA == '/')
                            {
                                switch (peek())
                                {
                                    case '/':
                                    case '*':
                                        throw new Exception(string.Format("Error: JSMIN Unterminated set in Regular Expression literal: {0}\n", theA));
                                }
                                break;
                            }
                            else if (theA == '\\')
                            {
                                put(theA);
                                theA = get();
                            }
                            if (theA == EOF)
                            {
                                throw new Exception(string.Format("Error: JSMIN Unterminated Regular Expression literal: {0}\n", theA));
                            }
                            put(theA);
                        }
                        theB = next();
                    }
                    goto default;
                default:
                    break;
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="CompressJS">
          <declaration><![CDATA[public static string CompressJS(string body)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="51" sc="9" el="53" ec="10">CompositeFiles\JSMin.cs</location>
            <body hash="026a45e0446eca04d3e6145ed8d6fdac"><![CDATA[{
            return new JSMin().Minify(body);
        }]]></body>
          </codeblock>
        </method>
        <method name="get">
          <declaration><![CDATA[private int get()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="335" sc="9" el="351" ec="10">CompositeFiles\JSMin.cs</location>
            <body hash="1aa8bc6733ace5d2ba7609b6151417d1"><![CDATA[{
            int c = theLookahead;
            theLookahead = EOF;
            if (c == EOF)
            {
                c = sr.Read();
            }
            if (c >= ' ' || c == '\n' || c == EOF)
            {
                return c;
            }
            if (c == '\r')
            {
                return '\n';
            }
            return ' ';
        }]]></body>
          </codeblock>
        </method>
        <method name="isAlphanum">
          <declaration><![CDATA[private bool isAlphanum(int c)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="360" sc="9" el="364" ec="10">CompositeFiles\JSMin.cs</location>
            <body hash="9ecb3adf748520722720dacc419b4683"><![CDATA[{
            return ((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') ||
                    (c >= 'A' && c <= 'Z') || c == '_' || c == '$' || c == '\\' ||
                    c > 126);
        }]]></body>
          </codeblock>
        </method>
        <method name="jsmin">
          <declaration><![CDATA[private void jsmin()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="74" sc="9" el="141" ec="10">CompositeFiles\JSMin.cs</location>
            <body hash="0ec5d198414666b717382aa2f569de8f"><![CDATA[{
            if (peek() == 0xEF)
            {
                get();
                get();
                get();
            }
            theA = '\n';
            action(3);
            while (theA != EOF)
            {
                switch (theA)
                {
                    case ' ':
                        action(isAlphanum(theB) ? 1 : 2);
                        break;
                    case '\n':
                        switch (theB)
                        {
                            case '{':
                            case '[':
                            case '(':
                            case '+':
                            case '-':
                            case '!':
                            case '~':
                                action(1);
                                break;
                            case ' ':
                                action(3);
                                break;
                            default:
                                action(isAlphanum(theB) ? 1 : 2);
                                break;
                        }
                        break;
                    default:
                        switch (theB)
                        {
                            case ' ':
                                action(isAlphanum(theA) ? 1 : 3);
                                break;
                            case '\n':
                                switch (theA)
                                {
                                    case '}':
                                    case ']':
                                    case ')':
                                    case '+':
                                    case '-':
                                    case '"':
                                    case '\'':
                                    case '`':
                                        action(1);
                                        break;
                                    default:
                                        action(isAlphanum(theA) ? 1 : 3);
                                        break;
                                }
                                break;
                            default:
                                action(1);
                                break;
                        }
                        break;
                }
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="Minify">
          <declaration><![CDATA[public string Minify(string src)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="56" sc="9" el="66" ec="10">CompositeFiles\JSMin.cs</location>
            <body hash="d2a4945e36ed850469d6a189daff2902"><![CDATA[{
            StringBuilder sb = new StringBuilder();
            using (sr = new StringReader(src))
            {                
                using (sw = new StringWriter(sb))
                {
                    jsmin();
                }
            }
            return sb.ToString();
        }]]></body>
          </codeblock>
        </method>
        <method name="next">
          <declaration><![CDATA[private int next()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="260" sc="9" el="321" ec="10">CompositeFiles\JSMin.cs</location>
            <body hash="f123748d2e5f7b99d9682974fee9bb4c"><![CDATA[{
            int c = get();
            if (c == '/')
            {
                switch (peek())
                {
                    case '/':
                        for (;;)
                        {
                            c = get();
                            if (c <= '\n')
                            {
                                break;
                            }
                        }
                        break;
                    case '*':
                        get();
                        while (c != ' ')
                        {
                            switch (get())
                            {
                                case '*':
                                    var currPeek = peek();
                                    if (currPeek == '/')
                                    {
                                        get();
                                        c = ' ';

                                        //In one very peculiar circumstance, if the JS value is like:
                                        // val(1 /* Calendar */.toString());
                                        // if we strip the comment out, JS will produce an error because
                                        // 1.toString() is not valid, however 1..toString() is valid and 
                                        // similarly keeping the comment is valid. So we can check if the next value
                                        // is a '.' and if the current value is numeric and perform this operation.
                                        // The reason why .. works is because the JS parser cannot do 1.toString() because it 
                                        // sees the '.' as a decimal

                                        if (char.IsDigit((char) theY))
                                        {
                                            currPeek = peek();
                                            if (currPeek == '.')
                                            {
                                                //we actually want to write another '.'
                                                return '.';
                                            }
                                        }
                                       
                                    }
                                    break;
                                case EOF:
                                    throw new Exception("Error: JSMIN Unterminated comment.\n");
                            }
                        }
                        break;
                }
            }
            //return c;
            theY = theX;
            theX = c;
            return c;
        }]]></body>
          </codeblock>
        </method>
        <method name="peek">
          <declaration><![CDATA[private int peek()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="326" sc="9" el="329" ec="10">CompositeFiles\JSMin.cs</location>
            <body hash="42c71b2d4ee694897f7934b8e52ffb1f"><![CDATA[{
            theLookahead = get();
            return theLookahead;
        }]]></body>
          </codeblock>
        </method>
        <method name="put">
          <declaration><![CDATA[private void put(int c)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="353" sc="9" el="355" ec="10">CompositeFiles\JSMin.cs</location>
            <body hash="c387da5264daa012761adc7444406be3"><![CDATA[{
            sw.Write((char)c);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="EOF">
          <declaration><![CDATA[private const int EOF = -1;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="sr">
          <declaration><![CDATA[private StringReader sr;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="sw">
          <declaration><![CDATA[private StringWriter sw;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="theA">
          <declaration><![CDATA[private int theA;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="theB">
          <declaration><![CDATA[private int theB;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="theLookahead">
          <declaration><![CDATA[private int theLookahead = -1;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="theX">
          <declaration><![CDATA[private static int theX = -1;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="theY">
          <declaration><![CDATA[private static int theY = -1;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="ClientDependency.Core.CompositeFiles.Providers">
    <class name="BaseCompositeFileProcessingProvider">
      <declaration><![CDATA[public abstract class BaseCompositeFileProcessingProvider : ProviderBase, IHttpProvider]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[protected BaseCompositeFileProcessingProvider()]]></declaration>
          <documentation>
            <summary>
 constructor sets defaults
 </summary>
          </documentation>
          <codeblock>
            <location sl="33" sc="9" el="41" ec="10">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="df2970bb1626fee30070345c95656d63"><![CDATA[protected BaseCompositeFileProcessingProvider()
        {
            PersistCompositeFiles = true;
            EnableCssMinify = true;
            EnableJsMinify = true;
            UrlType = UrlTypeDefault;
            PathBasedUrlFormat = "{dependencyId}/{version}/{type}";
            CompositeFilePathAsString = DefaultDependencyPath;
        }]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static BaseCompositeFileProcessingProvider()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="23" sc="9" el="23" ec="83">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="a14ea0608cf492491dc5a9add510414e"><![CDATA[public static CompositeUrlType UrlTypeDefault = CompositeUrlType.MappedId]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CanProcessLocally">
          <declaration><![CDATA[protected bool CanProcessLocally(HttpContextBase context, string filePath, out IVirtualFileWriter virtualFileWriter)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="100" sc="9" el="117" ec="10">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="ed6f024f65bd0f56c5789e021fdf7e18"><![CDATA[{
            //First check if there's any virtual file providers that can handle this
            var writer = FileWriters.GetVirtualWriterForFile(filePath);
            if (writer == null)
            {
                var ext = Path.GetExtension(filePath);
                writer = FileWriters.GetVirtualWriterForExtension(ext);                
            }
            if (writer != null)
            {
                virtualFileWriter = writer;
                return writer.FileProvider.FileExists(filePath);
            }

            //can process if it exists locally
            virtualFileWriter = null;
            return File.Exists(context.Server.MapPath(filePath));
        }]]></body>
          </codeblock>
        </method>
        <method name="CombineFiles">
          <declaration><![CDATA[public abstract byte[] CombineFiles(string[] filePaths, HttpContextBase context, ClientDependencyType type, out List<CompositeFileDefinition> fileDefs);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="CompressBytes">
          <declaration><![CDATA[public abstract byte[] CompressBytes(CompressionType type, byte[] fileBytes);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetCompositeFileUrl">
          <declaration><![CDATA[public virtual string GetCompositeFileUrl(string fileKey, ClientDependencyType type, HttpContextBase http, CompositeUrlType urlType, string compositeFileHandlerPath, int version)]]></declaration>
          <documentation>
            <summary>
 Returns the url for the composite file handler for the filePath specified.
 </summary>
 <param name="fileKey">The Base64 encoded file paths or the file map key used to lookup the required dependencies</param>
 <param name="type"></param>
 <param name="http"></param>
 <param name="urlType"></param>
 <param name="compositeFileHandlerPath"> </param>
 <param name="version"> </param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="471" sc="9" el="503" ec="10">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="1ee972833959e9246c1652f70069a55c"><![CDATA[{
            var url = new StringBuilder();
            switch (urlType)
            {
                case CompositeUrlType.Base64QueryStrings:

                    //Create a URL with a base64 query string

                    const string handler = "{0}?s={1}&t={2}";
                    url.Append(string.Format(handler,
                                             compositeFileHandlerPath,
                                             http.Server.UrlEncode(fileKey), type));
                    url.Append("&cdv=");
                    url.Append(version.ToString());
                    break;
                default:

                    //Create a URL based on base64 paths instead of a query string

                    url.Append(compositeFileHandlerPath);
                    url.Append('/');

                    //create the path based on the path format...
                    var pathUrl = PathBasedUrlFormatter.CreatePath(PathBasedUrlFormat, fileKey, type, version);

                    //append the path formatted
                    url.Append(pathUrl);

                    break;
            }

            return url.ToString();
        }]]></body>
          </codeblock>
        </method>
        <method name="GetCompositeFileUrls">
          <declaration><![CDATA[internal IEnumerable<string> GetCompositeFileUrls(ClientDependencyType type, IClientDependencyFile[] dependencies, string compositeFileHandlerPath, HttpContextBase http, int maxLength, int version)]]></declaration>
          <documentation>
            <summary>
 When the path type is one of the base64 paths, this will create the composite file urls for all of the dependencies.
 </summary>
 <param name="type"></param>
 <param name="dependencies"></param>
 <param name="compositeFileHandlerPath"></param>
 <param name="http"></param>
 <param name="maxLength">the max length each url can be</param>
 <param name="version">the current cdf version</param>
 <returns></returns>
 <remarks>
 Generally there will only be one path returned but his depends on how many dependencies there are and whether the base64 created path will exceed the max url length parameter.
 If the string length exceeds it, then we need to creaet multiple paths all of which must be less length than the maximum provided.
 </remarks></documentation>
          <codeblock>
            <location sl="327" sc="9" el="412" ec="10">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="fc4a9ea0d39d1b4982f567f0f8d9a57b"><![CDATA[{
            var files = new List<string>();
            var currBuilder = new StringBuilder();
            var base64Builder = new StringBuilder();
            var builderCount = 1;
            var stringType = type.ToString();

            var remaining = new Queue<IClientDependencyFile>(dependencies);
            while (remaining.Any())
            {
                var current = remaining.Peek();

                //update the base64 output to get the length
                base64Builder.Append(current.FilePath.EncodeTo64());

                //test if the current base64 string exceeds the max length, if so we need to split
                if ((base64Builder.Length
                     + compositeFileHandlerPath.Length
                     + stringType.Length
                     + version.ToString(CultureInfo.InvariantCulture).Length
                    //this number deals with the ampersands, etc...
                     + 10)
                    >= (maxLength))
                {
                    //we need to do a check here, this is the first one and it's already exceeded the max length we cannot continue
                    if (currBuilder.Length == 0)
                    {
                        throw new InvalidOperationException("The path for the single dependency: '" + current.FilePath + "' exceeds the max length (" + maxLength + "), either reduce the single dependency's path length or increase the CompositeDependencyHandler.MaxHandlerUrlLength value");
                    }

                    //flush the current output to the array
                    files.Add(currBuilder.ToString());
                    //create some new output
                    currBuilder = new StringBuilder();
                    base64Builder = new StringBuilder();
                    builderCount++;
                }
                else
                {
                    //update the normal builder
                    currBuilder.Append(current.FilePath + ";");
                    //remove from the queue
                    remaining.Dequeue();
                }
            }

            //foreach (var a in dependencies)
            //{
            //    //update the base64 output to get the length
            //    base64Builder.Append(a.FilePath.EncodeTo64());

            //    //test if the current base64 string exceeds the max length, if so we need to split
            //    if ((base64Builder.Length
            //        + compositeFileHandlerPath.Length
            //        + stringType.Length
            //        + version.Length
            //        + 10)
            //        >= (maxLength))
            //    {
            //        //add the current output to the array
            //        files.Add(currBuilder.ToString());
            //        //create some new output
            //        currBuilder = new StringBuilder();
            //        base64Builder = new StringBuilder();
            //        builderCount++;
            //    }

            //    //update the normal builder
            //    currBuilder.Append(a.FilePath + ";");
            //}

            if (builderCount > files.Count)
            {
                files.Add(currBuilder.ToString());
            }

            //now, compress each url
            for (var i = 0; i < files.Count; i++)
            {
                //append our version to the combined url 
                var encodedFile = files[i].EncodeTo64Url();
                files[i] = GetCompositeFileUrl(encodedFile, type, http, UrlType, compositeFileHandlerPath, version);
            }

            return files.ToArray();
        }]]></body>
          </codeblock>
        </method>
        <method name="GetVirtualFile">
          <declaration><![CDATA[protected virtual VirtualFile GetVirtualFile(HttpContextBase context, string filePath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="120" sc="9" el="125" ec="10">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="16068101229562496486034ca27cf0ff"><![CDATA[{
            var vf = HostingEnvironment.VirtualPathProvider.GetFile(filePath);
            if (vf == null) return null;
            if (vf.IsDirectory) return null;
            return vf;
        }]]></body>
          </codeblock>
        </method>
        <method name="Initialize">
          <declaration><![CDATA[public void Initialize(HttpContextBase http)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="89" sc="9" el="91" ec="10">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="7ea07e85e486ec9e1020f437552c97ac"><![CDATA[{
            CompositeFilePath = new DirectoryInfo(http.Server.MapPath(CompositeFilePathAsString));
        }]]></body>
          </codeblock>
        </method>
        <method name="Initialize">
          <declaration><![CDATA[public override void Initialize(string name, NameValueCollection config)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="506" sc="9" el="572" ec="10">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="d10fd617bd9dd48f2251c011397fc1ac"><![CDATA[{
            base.Initialize(name, config);

            if (config == null)
                return;

            if (config["enableCssMinify"] != null)
            {
                bool enableCssMinify = true;
                if (bool.TryParse(config["enableCssMinify"], out enableCssMinify))
                    EnableCssMinify = enableCssMinify;
            }
            if (config["enableJsMinify"] != null)
            {
                bool enableJsMinify = true;
                if (bool.TryParse(config["enableJsMinify"], out enableJsMinify))
                    EnableJsMinify = enableJsMinify;
            }

            if (config["persistFiles"] != null)
            {
                bool persistFiles;
                if (bool.TryParse(config["persistFiles"], out persistFiles))
                    PersistCompositeFiles = persistFiles;
            }

            if (config["urlType"] != null)
            {
                try
                {
                    UrlType = (CompositeUrlType)Enum.Parse(typeof(CompositeUrlType), config["urlType"]);
                }
                catch (ArgumentException)
                {
                    //swallow exception, we've set the default
                }
            }
            if (config["pathUrlFormat"] != null)
            {
                PathBasedUrlFormat = config["pathUrlFormat"];
                PathBasedUrlFormatter.Validate(PathBasedUrlFormat);
            }

            CompositeFilePathAsString = config["compositeFilePath"] ?? DefaultDependencyPath;

            string bundleDomains = config["bundleDomains"];
            if (bundleDomains != null)
                bundleDomains = bundleDomains.Trim();
            if (string.IsNullOrEmpty(bundleDomains))
            {
                BundleDomains = new List<string>();
            }
            else
            {
                string[] domains = bundleDomains.Split(new char[] { ',' });
                for (int i = 0; i < domains.Length; i++)
                {
                    // make sure we have a starting dot and a trailing port
                    // ie 'maps.google.com' will be stored as '.maps.google.com:80'
                    if (domains[i].IndexOf(':') < 0)
                        domains[i] = domains[i] + ":80";
                    if (!domains[i].StartsWith("."))
                        domains[i] = "." + domains[i];
                }
                BundleDomains = new List<string>(domains);
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="MinifyFile">
          <declaration><![CDATA[public virtual string MinifyFile(string fileContents, ClientDependencyType type)]]></declaration>
          <documentation>
            <summary>
 Minifies the file
 </summary>
 <param name="fileContents"></param>
 <param name="type"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="581" sc="9" el="591" ec="10">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="73809b600993cee9f683446973ad6e3d"><![CDATA[{
            switch (type)
            {
                case ClientDependencyType.Css:
                    return EnableCssMinify ? CssHelper.MinifyCss(fileContents) : fileContents;
                case ClientDependencyType.Javascript:
                    return EnableJsMinify ? JSMin.CompressJS(fileContents) : fileContents;
                default:
                    return fileContents;
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="ParseCssFilePaths">
          <declaration><![CDATA[protected virtual string ParseCssFilePaths(string fileContents, ClientDependencyType type, string url, HttpContextBase http)]]></declaration>
          <documentation>
            <summary>
 This ensures that all paths (i.e. images) in a CSS file have their paths change to absolute paths.
 </summary>
 <param name="fileContents"></param>
 <param name="type"></param>
 <param name="url"></param>
 <param name="http"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="602" sc="9" el="609" ec="10">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="487fa579d341fe0f404ce1d1afd8d7aa"><![CDATA[{
            //if it is a CSS file we need to parse the URLs
            if (type == ClientDependencyType.Css)
            {
                fileContents = CssHelper.ReplaceUrlsWithAbsolutePaths(fileContents, url, http);
            }
            return fileContents;
        }]]></body>
          </codeblock>
        </method>
        <method name="ProcessCompositeList">
          <declaration><![CDATA[public virtual string[] ProcessCompositeList(IEnumerable<IClientDependencyFile> dependencies, ClientDependencyType type, HttpContextBase http)]]></declaration>
          <documentation>
            <summary>
 Returns a URL used to return a compbined/compressed/optimized version of all dependencies.
 <remarks>
 The full url with the encoded query strings for the handler which will process the composite list
 of dependencies. The handler will compbine, compress, minify, and output cache the results
 on the base64 encoded string.
 </remarks>
 </summary>
 <param name="dependencies"></param>
 <param name="type"></param>
 <param name="http"></param>
 <returns>An array containing the list of composite file URLs. This will generally only contain 1 value unless
 the number of files registered exceeds the maximum length, then it will return more than one file.</returns></documentation>
          <codeblock>
            <location sl="302" sc="9" el="304" ec="10">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="ee524033d6957efb4a001bca0111f641"><![CDATA[{
            return ProcessCompositeList(dependencies, type, http, null);
        }]]></body>
          </codeblock>
        </method>
        <method name="ProcessCompositeList">
          <declaration><![CDATA[public virtual string[] ProcessCompositeList(IEnumerable<IClientDependencyFile> dependencies, ClientDependencyType type, HttpContextBase http, string compositeFileHandlerPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="419" sc="9" el="452" ec="10">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="53a2b77f8f41dd8881e6fdd195683c1c"><![CDATA[{
            var asArray = dependencies.ToArray();

            if (!asArray.Any())
                return new string[] { };

            compositeFileHandlerPath = compositeFileHandlerPath ?? ClientDependencySettings.Instance.CompositeFileHandlerPath;

            switch (UrlType)
            {
                case CompositeUrlType.MappedId:

                    //use the file mapper to create us a file key/id for the file set
                    var fileKey = ClientDependencySettings.Instance.DefaultFileMapProvider.CreateNewMap(
                        http,
                        asArray,
                        ClientDependencySettings.Instance.Version);

                    //create the url
                    return new[] { GetCompositeFileUrl(
                        fileKey, 
                        type, 
                        http, 
                        CompositeUrlType.MappedId, 
                        compositeFileHandlerPath,
                        ClientDependencySettings.Instance.Version) };

                default:

                    //build the combined composite list urls          

                    return GetCompositeFileUrls(type, asArray, compositeFileHandlerPath, http, CompositeDependencyHandler.MaxHandlerUrlLength, ClientDependencySettings.Instance.Version).ToArray();
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="SaveCompositeFile">
          <declaration><![CDATA[public abstract FileInfo SaveCompositeFile(byte[] fileContents, ClientDependencyType type, HttpServerUtilityBase server);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="TryReadUri">
          <deprecation>This is no longer used in the codebase and will be removed in future versions</deprecation>
          <declaration><![CDATA[protected bool TryReadUri(string url, out string requestContents, HttpContextBase http)]]></declaration>
          <documentation>
            <summary>
 Tries to convert the url to a uri, then read the request into a string and return it.
 This takes into account relative vs absolute URI's
 </summary>
 <param name="url"></param>
 <param name="requestContents"></param>
 <param name="http"></param>
 <returns>true if successful, false if not successful</returns>
 <remarks>
 if the path is a relative local path, the we use Server.Execute to get the request output, otherwise
 if it is an absolute path, a WebClient request is made to fetch the contents.
 </remarks></documentation>
          <codeblock>
            <location sl="625" sc="9" el="628" ec="10">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="f264304a24f9afebb070fdd1d388fc57"><![CDATA[{
            Uri uri;
            return RequestHelper.TryReadUri(url, http, BundleDomains, out requestContents, out uri);
        }]]></body>
          </codeblock>
        </method>
        <method name="WriteFileToStream">
          <declaration><![CDATA[protected virtual CompositeFileDefinition WriteFileToStream(StreamWriter sw, string url, ClientDependencyType type, HttpContextBase http)]]></declaration>
          <documentation>
            <summary>
 Writes the output of an external request to the stream
 </summary>
 <param name="sw"></param>
 <param name="url"></param>
 <param name="type"></param>
 <param name="http"></param></documentation>
          <codeblock>
            <location sl="233" sc="9" el="242" ec="10">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="610cbad435687b94a3ddb939be786183"><![CDATA[{
            string requestOutput;
            Uri resultUri;
            var rVal = RequestHelper.TryReadUri(url, http, BundleDomains, out requestOutput, out resultUri);
            if (!rVal) return null;

            //write the contents of the external request.
            DefaultFileWriter.WriteContentToStream(this, sw, requestOutput, type, http, url);
            return new CompositeFileDefinition(url, false);
        }]]></body>
          </codeblock>
        </method>
        <method name="WriteFileToStream">
          <declaration><![CDATA[protected virtual CompositeFileDefinition WriteFileToStream(StreamWriter sw, FileInfo fi, ClientDependencyType type, string origUrl, HttpContextBase http)]]></declaration>
          <documentation>
            <summary>
 Writes the output of a local file to the stream
 </summary>
 <param name="sw"></param>
 <param name="fi"></param>
 <param name="type"></param>
 <param name="origUrl"></param>
 <param name="http"></param></documentation>
          <codeblock>
            <location sl="253" sc="9" el="265" ec="10">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="72f6ecad56d483099137690ed57fc419"><![CDATA[{
            //get a writer for the file, first check if there's a specific file writer
            //then check for an extension writer.
            var writer = FileWriters.GetWriterForFile(origUrl);
            if (writer is DefaultFileWriter)
            {
                writer = FileWriters.GetWriterForExtension(fi.Extension);
                if (writer == null) return null;
            }
            return writer.WriteToStream(this, sw, fi, type, origUrl, http)
                ? new CompositeFileDefinition(origUrl, true)
                : null;
        }]]></body>
          </codeblock>
        </method>
        <method name="WritePathToStream">
          <declaration><![CDATA[public CompositeFileDefinition WritePathToStream(ClientDependencyType type, string path, HttpContextBase context, StreamWriter sw)]]></declaration>
          <documentation>
            <summary>
 Writes a given path to the stream
 </summary>
 <param name="type"></param>
 <param name="path">The path could be a local url or an absolute url</param>
 <param name="context"></param>
 <param name="sw"></param>
 <returns>If successful returns a CompositeFileDefinition, otherwise returns null</returns></documentation>
          <codeblock>
            <location sl="136" sc="9" el="223" ec="10">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="59656c446df6c8dd1890769bfdd49856"><![CDATA[{
            CompositeFileDefinition def = null;
            if (!string.IsNullOrEmpty(path))
            {
                try
                {
                    //var fi = new FileInfo(context.Server.MapPath(path));

                    var extension = Path.GetExtension(path);

                    //all config based extensions and all extensions registered by file writers
                    var fileBasedExtensions = ClientDependencySettings.Instance.FileBasedDependencyExtensionList
                                                                      .Union(FileWriters.GetRegisteredExtensions());

                    if (fileBasedExtensions.Contains(extension.ToUpper()))
                    {
                        IVirtualFileWriter virtualWriter;
                        if (CanProcessLocally(context, path, out virtualWriter))
                        {
                            //internal request
                            if (virtualWriter != null)
                            {
                                var vf = virtualWriter.FileProvider.GetFile(path);
                                WriteVirtualFileToStream(sw, vf, virtualWriter, type, context);
                            }
                            else
                            {
                                var fi = new FileInfo(context.Server.MapPath(path));
                                WriteFileToStream(sw, fi, type, path, context);
                            }                            
                        }
                        else
                        {
                            //external request
                            def = WriteFileToStream(sw, path, type, context);
                        }
                    }
                    else
                    {
                        //if it's not a file based dependency, try to get the request output.
                        def = WriteFileToStream(sw, path, type, context);
                    }
                }
                catch (Exception ex)
                {
                    if (ex is NotSupportedException
                        || ex is ArgumentException
                        || ex is HttpException)
                    {
                        //could not parse the string into a fileinfo or couldn't mappath, so we assume it is a URI

                        //before we try to load it by URI, we want to check if the URI is a local request, we'll try to detect if it is and
                        // then try to load it from the file system, if the file isn't there then we'll continue trying to load it via the URI.
                        Uri uri;
                        if (Uri.TryCreate(path, UriKind.RelativeOrAbsolute, out uri) && uri.IsLocalUri(context))
                        {
                            var localPath = uri.PathAndQuery;
                            var fi = new FileInfo(context.Server.MapPath(localPath));
                            if (fi.Exists)
                            {
                                try
                                {
                                    WriteFileToStream(sw, fi, type, path, context); //internal request
                                }
                                catch (Exception ex1)
                                {
                                    ClientDependencySettings.Instance.Logger.Error(string.Format("Could not load file contents from {0}. EXCEPTION: {1}", path, ex1.Message), ex1);
                                }
                            }
                        }

                        def = WriteFileToStream(sw, path, type, context);
                    }
                    else
                    {
                        //if this fails, log the exception, but continue
                        ClientDependencySettings.Instance.Logger.Error(string.Format("Could not load file contents from {0}. EXCEPTION: {1}", path, ex.Message), ex);
                    }
                }
            }

            if (type == ClientDependencyType.Javascript)
            {
                sw.Write(";;;"); //write semicolons in case the js isn't formatted correctly. This also helps for debugging.
            }

            return def;
        }]]></body>
          </codeblock>
        </method>
        <method name="WriteVirtualFileToStream">
          <declaration><![CDATA[protected virtual CompositeFileDefinition WriteVirtualFileToStream(StreamWriter sw, IVirtualFile vf, IVirtualFileWriter virtualWriter, ClientDependencyType type, HttpContextBase http)]]></declaration>
          <documentation>
            <summary>
 Writes the output of a local file to the stream
 </summary>
 <param name="sw"></param>
 <param name="vf"></param>
 <param name="virtualWriter"></param>
 <param name="type"></param>
 <param name="http"></param></documentation>
          <codeblock>
            <location sl="276" sc="9" el="283" ec="10">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="1dc415613e4bea7beed7d507ebf55dc4"><![CDATA[{
            if (virtualWriter == null) throw new ArgumentNullException("virtualWriter");
            if (vf == null) return null;

            return virtualWriter.WriteToStream(this, sw, vf, type, vf.Path, http)
                ? new CompositeFileDefinition(vf.Path, true)
                : null;
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="CompositeFilePathAsString">
          <declaration><![CDATA[internal string CompositeFilePathAsString;]]></declaration>
          <documentation>
            <summary>
 The path specified in the config
 </summary>
          </documentation>
        </field>
        <field name="DefaultDependencyPath">
          <declaration><![CDATA[private const string DefaultDependencyPath = "~/App_Data/ClientDependency";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="UrlTypeDefault">
          <declaration><![CDATA[public static CompositeUrlType UrlTypeDefault = CompositeUrlType.MappedId;]]></declaration>
          <documentation>
            <summary>
 Defines the UrlType default value, this can be set at startup
 </summary>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="BundleDomains">
          <declaration><![CDATA[public IList<string> BundleDomains]]></declaration>
          <documentation>
            <summary>
 Returns the set of white listed domains
 </summary>
          </documentation>
          <codeblock>
            <location sl="82" sc="46" el="82" ec="50">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="82" sc="51" el="82" ec="65">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="5c1ddebc298d4e3118617b1afe7e95eb"><![CDATA[protected set]]></body>
          </codeblock>
        </property>
        <property name="CompositeFilePath">
          <declaration><![CDATA[public DirectoryInfo CompositeFilePath]]></declaration>
          <documentation>
            <summary>
 Returns the CompositeFilePath
 </summary>
 <returns></returns></documentation>
          <codeblock>
            <location sl="77" sc="50" el="77" ec="54">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="77" sc="55" el="77" ec="69">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="5c1ddebc298d4e3118617b1afe7e95eb"><![CDATA[protected set]]></body>
          </codeblock>
        </property>
        <property name="EnableCssMinify">
          <declaration><![CDATA[public bool EnableCssMinify]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="52" sc="39" el="52" ec="43">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="52" sc="44" el="52" ec="48">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="EnableJsMinify">
          <declaration><![CDATA[public bool EnableJsMinify]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="53" sc="38" el="53" ec="42">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="53" sc="43" el="53" ec="47">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="PathBasedUrlFormat">
          <declaration><![CDATA[public string PathBasedUrlFormat]]></declaration>
          <documentation>
            <summary>
 The format of a path based URL (either a MappedId or a Base64Paths URL). The string format is a tokenized string such as:
 {dependencyId}.{version}.{type}
 or
 {dependencyId}/{version}/{type}
 </summary>
 <remarks>
 By defaut this is just:
 {dependencyId}.{version}.{type}
 but Cassini doesn't support '.' in the URL so some people may want to change this to use '/'
 </remarks></documentation>
          <codeblock>
            <location sl="71" sc="44" el="71" ec="48">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="71" sc="49" el="71" ec="63">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="5c1ddebc298d4e3118617b1afe7e95eb"><![CDATA[protected set]]></body>
          </codeblock>
        </property>
        <property name="PersistCompositeFiles">
          <declaration><![CDATA[public bool PersistCompositeFiles]]></declaration>
          <documentation>
            <summary>
 Flags whether or not to enable composite file script creation/persistence.
 Composite file persistence will increase performance in the case of cache turnover or application
 startup since the files are already combined and compressed.
 This also allows for the ability to easily clear the cache so the files are refreshed.
 </summary>
          </documentation>
          <codeblock>
            <location sl="51" sc="45" el="51" ec="49">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="51" sc="50" el="51" ec="54">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="UrlType">
          <declaration><![CDATA[public CompositeUrlType UrlType]]></declaration>
          <documentation>
            <summary>
 The Url type to use for the dependency handler
 </summary>
          </documentation>
          <codeblock>
            <location sl="58" sc="43" el="58" ec="47">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="58" sc="48" el="58" ec="62">CompositeFiles\Providers\BaseCompositeFileProcessingProvider.cs</location>
            <body hash="5c1ddebc298d4e3118617b1afe7e95eb"><![CDATA[protected set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="BaseFileMapProvider">
      <declaration><![CDATA[public abstract class BaseFileMapProvider : ProviderBase, IHttpProvider]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[protected BaseFileMapProvider()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CreateNewMap">
          <declaration><![CDATA[public abstract string CreateNewMap(HttpContextBase http, IEnumerable<IClientDependencyFile> dependentFiles, int version);]]></declaration>
          <documentation>
            <summary>
 Creates a new file map and file key for the dependent file list, this is used to create URLs with CompositeUrlType.MappedId
 </summary>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="CreateUpdateMap">
          <declaration><![CDATA[public abstract void CreateUpdateMap(string fileKey, string compressionType, IEnumerable<IClientDependencyFile> dependentFiles, string compositeFile, int version);]]></declaration>
          <documentation>
            <summary>
 Creates a map for the version/compression type/dependent file listing
 </summary>
 <param name="fileKey"></param>
 <param name="compressionType"></param>
 <param name="dependentFiles"></param>
 <param name="compositeFile"></param>
 <param name="version"></param></documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetCompositeFile">
          <declaration><![CDATA[public abstract CompositeFileMap GetCompositeFile(string fileKey, int version, string compression);]]></declaration>
          <documentation>
            <summary>
 Retreives the file map for the key/version/compression type specified
 </summary>
 <param name="fileKey"></param>
 <param name="version"></param>
 <param name="compression"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="GetDependentFiles">
          <declaration><![CDATA[public abstract IEnumerable<string> GetDependentFiles(string fileKey, int version);]]></declaration>
          <documentation>
            <summary>
 Retreives the dependent file paths for the filekey/version (regardless of compression)
 </summary>
 <param name="fileKey"></param>
 <param name="version"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Initialize">
          <declaration><![CDATA[public abstract void Initialize(HttpContextBase http);]]></declaration>
          <documentation>
            <summary>
 Runs initialization with an Http context, this occurs after the initial provider config initialization
 </summary>
 <param name="http"></param></documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="CompositeFileProcessingProvider">
      <declaration><![CDATA[public class CompositeFileProcessingProvider : BaseCompositeFileProcessingProvider]]></declaration>
      <documentation>
        <summary>
 A provider for combining, minifying, compressing and saving composite scripts/css files
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public CompositeFileProcessingProvider()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CombineFiles">
          <declaration><![CDATA[public override byte[] CombineFiles(string[] filePaths, HttpContextBase context, ClientDependencyType type, out List<CompositeFileDefinition> fileDefs)]]></declaration>
          <documentation>
            <summary>
 combines all files to a byte array
 </summary>
 <param name="filePaths"></param>
 <param name="context"></param>
 <param name="type"></param>
 <param name="fileDefs"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="72" sc="3" el="85" ec="4">CompositeFiles\Providers\CompositeFileProcessingProvider.cs</location>
            <body hash="938cd68de8274b48e3f1fd15718ac3fd"><![CDATA[{
            using (var ms = new MemoryStream(5000))
            using (var sw = new StreamWriter(ms, Encoding.UTF8))
            {
                var fDefs = filePaths.Select(s => WritePathToStream(type, s, context, sw)).Where(def => def != null).ToList();

                sw.Flush();
                byte[] outputBytes = ms.ToArray();
                sw.Close();
                ms.Close();
                fileDefs = fDefs;
                return outputBytes;
            }
		}]]></body>
          </codeblock>
        </method>
        <method name="CompressBytes">
          <declaration><![CDATA[public override byte[] CompressBytes(CompressionType type, byte[] fileBytes)]]></declaration>
          <documentation>
            <summary>
 Compresses the bytes if the browser supports it
 </summary>
          </documentation>
          <codeblock>
            <location sl="91" sc="3" el="93" ec="4">CompositeFiles\Providers\CompositeFileProcessingProvider.cs</location>
            <body hash="65db660ab9857ff778b5b050fce67010"><![CDATA[{
            return SimpleCompressor.CompressBytes(type, fileBytes);
		}]]></body>
          </codeblock>
        </method>
        <method name="SaveCompositeFile">
          <declaration><![CDATA[public override FileInfo SaveCompositeFile(byte[] fileContents, ClientDependencyType type, HttpServerUtilityBase server)]]></declaration>
          <documentation>
            <summary>
 Saves the file's bytes to disk with a hash of the byte array
 </summary>
 <param name="fileContents"></param>
 <param name="type"></param>
 <param name="server"></param>
 <returns>The new file path</returns>
 <remarks>
 the extension will be: .cdj for JavaScript and .cdc for CSS
 </remarks></documentation>
          <codeblock>
            <location sl="39" sc="3" el="61" ec="4">CompositeFiles\Providers\CompositeFileProcessingProvider.cs</location>
            <body hash="cb134c26e663f2038b59656b44fce09f"><![CDATA[{
            //don't save the file if composite files are disabled.
            if (!PersistCompositeFiles)
                return null;

            if (!CompositeFilePath.Exists)
                CompositeFilePath.Create();
			
            var fi = new FileInfo(
                Path.Combine(CompositeFilePath.FullName,
					ClientDependencySettings.Instance.Version + "_"
                        + Guid.NewGuid().ToString("N") + ".cd" + type.ToString().Substring(0, 1).ToUpper()));
			
            if (fi.Exists)
				fi.Delete();

            using (var fs = fi.Create())
            {
                fs.Write(fileContents, 0, fileContents.Length);
                fs.Close();
            }
            return fi;
		}]]></body>
          </codeblock>
        </method>
        <method name="WriteFileToStream">
          <deprecation>Use the equivalent method without the 'ref' parameters</deprecation>
          <declaration><![CDATA[protected virtual void WriteFileToStream(ref StreamWriter sw, string url, ClientDependencyType type, ref List<CompositeFileDefinition> fileDefs, HttpContextBase http)]]></declaration>
          <documentation>
            <summary>
 Writes the output of an external request to the stream
 </summary>
 <param name="sw"></param>
 <param name="url"></param>
 <param name="type"></param>
 <param name="fileDefs"></param>
 <param name="http"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="107" sc="6" el="113" ec="7">CompositeFiles\Providers\CompositeFileProcessingProvider.cs</location>
            <body hash="4409935dcda2853a1722823dcd2e7d5a"><![CDATA[{
	        var def = WriteFileToStream(sw, url, type, http);
            if (def != null)
            {
                fileDefs.Add(def);
            }
	    }]]></body>
          </codeblock>
        </method>
        <method name="WriteFileToStream">
          <deprecation>Use the equivalent method without the 'ref' parameters</deprecation>
          <declaration><![CDATA[protected virtual void WriteFileToStream(ref StreamWriter sw, FileInfo fi, ClientDependencyType type, string origUrl, ref List<CompositeFileDefinition> fileDefs, HttpContextBase http)]]></declaration>
          <documentation>
            <summary>
  Writes the output of a local file to the stream
 </summary>
 <param name="sw"></param>
 <param name="fi"></param>
 <param name="type"></param>
 <param name="origUrl"></param>
 <param name="fileDefs"></param>
 <param name="http"></param></documentation>
          <codeblock>
            <location sl="127" sc="9" el="133" ec="10">CompositeFiles\Providers\CompositeFileProcessingProvider.cs</location>
            <body hash="4dfcb3f92f77d9bb1594ae1850fc501d"><![CDATA[{
            var def = WriteFileToStream(sw, fi, type, origUrl, http);
            if (def != null)
            {
                fileDefs.Add(def);
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="DefaultName">
          <declaration><![CDATA[public const string DefaultName = "CompositeFileProcessor";]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="CompositeFileProcessingProviderCollection">
      <declaration><![CDATA[public class CompositeFileProcessingProviderCollection : ProviderCollection]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public CompositeFileProcessingProviderCollection()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Add">
          <declaration><![CDATA[public override void Add(ProviderBase provider)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="16" sc="3" el="24" ec="4">CompositeFiles\Providers\CompositeFileProcessingProviderCollection.cs</location>
            <body hash="97cd7ecc4de530f967d100c7180f0b0f"><![CDATA[{
			if (provider == null)
				throw new ArgumentNullException("provider");

			if (!(provider is BaseCompositeFileProcessingProvider))
				throw new ArgumentException("Invalid provider type", "provider");

			base.Add(provider);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Item">
          <declaration><![CDATA[public new BaseCompositeFileProcessingProvider this[string name]]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="CompositeUrlType">
      <declaration><![CDATA[public enum CompositeUrlType]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="Base64Paths">
          <declaration><![CDATA[public const CompositeUrlType Base64Paths = 1;]]></declaration>
          <documentation>
            <summary>
 Creates a URL in which the full dependency paths are base64 encoded as URL paths, however because
 paths can get quite large, this requires that .Net 4 is running and that you increase the maxUrlLength
 configuration property in the httpRuntime section in your web.config
 </summary>
          </documentation>
        </field>
        <field name="Base64QueryStrings">
          <declaration><![CDATA[public const CompositeUrlType Base64QueryStrings = 0;]]></declaration>
          <documentation>
            <summary>
 The original URL type in which full dependency paths are base64 encoded as query strings
 </summary>
          </documentation>
        </field>
        <field name="MappedId">
          <declaration><![CDATA[public const CompositeUrlType MappedId = 2;]]></declaration>
          <documentation>
            <summary>
 Uses the file map provider to store and map the dependency paths with a reference to an ID it generates
 </summary>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="FileMapProviderCollection">
      <declaration><![CDATA[public class FileMapProviderCollection : ProviderCollection]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public FileMapProviderCollection()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Add">
          <declaration><![CDATA[public override void Add(ProviderBase provider)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="14" sc="9" el="22" ec="10">CompositeFiles\Providers\FileMapProviderCollection.cs</location>
            <body hash="ff58b7ea19c73687b12b48ae46cc0bb0"><![CDATA[{
            if (provider == null)
                throw new ArgumentNullException("provider");

            if (!(provider is BaseFileMapProvider))
                throw new ArgumentException("Invalid provider type", "provider");

            base.Add(provider);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Item">
          <declaration><![CDATA[public new BaseFileMapProvider this[string name]]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="PathBasedUrlFormatter">
      <declaration><![CDATA[internal static class PathBasedUrlFormatter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="CreatePath">
          <declaration><![CDATA[public static string CreatePath(string pathBasedUrlFormat, string fileKey, ClientDependencyType type, int version)]]></declaration>
          <documentation>
            <summary>
 Creates a path based on the format, fileKey, type and version specified.
 </summary>
 <param name="pathBasedUrlFormat"></param>
 <param name="fileKey"></param>
 <param name="type"></param>
 <param name="version"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="69" sc="9" el="96" ec="10">CompositeFiles\Providers\PathBasedUrlFormatter.cs</location>
            <body hash="f43f5874a7a5ca8b71ddbece77d29110"><![CDATA[{            
            var pathUrl = pathBasedUrlFormat;
            var dependencyId = new StringBuilder();
            int pos = 0;
            //split paths at a max of 240 chars to not exceed the max path length of a URL
            while (fileKey.Length > pos)
            {
                if (dependencyId.Length > 0)
                {
                    dependencyId.Append('/');
                }
                var len = Math.Min(fileKey.Length - pos, 240);
                dependencyId.Append(fileKey.Substring(pos, len));
                pos += 240;
            }
            pathUrl = pathUrl.Replace("{dependencyId}", dependencyId.ToString());
            pathUrl = pathUrl.Replace("{version}", version.ToString());
            switch (type)
            {
                case ClientDependencyType.Css:
                    pathUrl = pathUrl.Replace("{type}", "css");
                    break;
                case ClientDependencyType.Javascript:
                    pathUrl = pathUrl.Replace("{type}", "js");
                    break;
            }
            return pathUrl;
        }]]></body>
          </codeblock>
        </method>
        <method name="Parse">
          <declaration><![CDATA[public static bool Parse(string pathBasedUrlFormat, string path, out string fileKey, out ClientDependencyType type, out int version)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="12" sc="9" el="58" ec="10">CompositeFiles\Providers\PathBasedUrlFormatter.cs</location>
            <body hash="fa828e80e1c68abda8b07070fd701dde"><![CDATA[{
            try
            {
                //start parsing from the end
                var typeIndex = pathBasedUrlFormat.IndexOf("{type}");
                var versionIndex = pathBasedUrlFormat.IndexOf("{version}");

                var typeDelimiter = pathBasedUrlFormat.Substring(versionIndex + "{version}".Length, typeIndex - (versionIndex + "{version}".Length));
                var typeAsString = "";
                for (var i = path.Length - 1; i > path.LastIndexOf(typeDelimiter) + (typeDelimiter.Length - 1); i--)
                {
                    typeAsString += path[i];
                }
                typeAsString = typeAsString.ReverseString().ToUpper();

                var versionDelimiter = pathBasedUrlFormat.Substring("{dependencyId}".Length, versionIndex - ("{dependencyId}".Length));
                var versionAsString = "";
                for (var i = path.LastIndexOf(typeDelimiter) - 1;
                    i > path.Substring(0, path.LastIndexOf(typeDelimiter)).LastIndexOf(versionDelimiter) + (typeDelimiter.Length - 1); i--)
                {
                    versionAsString += path[i];
                }
                versionAsString = versionAsString.ReverseString();

				//var p = path.IndexOf(versionDelimiter);
				//fileKey = p > 0 ? path.Substring(0, p) : "";
                fileKey = path.Substring(0, path.Substring(0, path.LastIndexOf(typeDelimiter)).LastIndexOf(versionDelimiter));
                //there may be '/' in the fileKey since we add additional paths when the max path length is exceeded
                fileKey = fileKey.Replace("/", "");

                type = typeAsString == "js".ToUpper() ? ClientDependencyType.Javascript : ClientDependencyType.Css;
                if (!int.TryParse(versionAsString, out version))
                {
                    return false;
                }

                return true;
            }
            catch (ArgumentOutOfRangeException)
            {
                fileKey = "";
                version = -1;
                type = ClientDependencyType.Javascript;
                return false;
            }

        }]]></body>
          </codeblock>
        </method>
        <method name="Validate">
          <declaration><![CDATA[public static void Validate(string pathBasedUrl)]]></declaration>
          <documentation>
            <summary>
 Ensures the url format is valid, if not an exception is thrown
 </summary>
 <param name="pathBasedUrl"></param></documentation>
          <codeblock>
            <location sl="103" sc="9" el="149" ec="10">CompositeFiles\Providers\PathBasedUrlFormatter.cs</location>
            <body hash="93df277ca9c5f427b93e6c044fbd678e"><![CDATA[{
            if (string.IsNullOrEmpty(pathBasedUrl))
            {
                throw new FormatException("The value specified for pathUrlFormat cannot be null or empty");
            }
            var pathBasedUrlFormat = pathBasedUrl;
            var pathChars = pathBasedUrlFormat.ToCharArray();
            //now we need to validate it:
            var requiredTokens = new[] { "{dependencyId}", "{version}", "{type}" };
            var latestIndex = -1;
            foreach (var r in requiredTokens)
            {
                var newIndex = pathBasedUrlFormat.IndexOf(r);
                if (latestIndex > -1 && newIndex < latestIndex)
                {
                    throw new FormatException("The ordering of the tokens in the pathUrlFormat must be in the order: dependencyId, version, type");
                }
                latestIndex = newIndex;
                if (!pathBasedUrlFormat.Contains(r))
                    throw new FormatException("The value specified for pathUrlFormat does not contain an " + r + " token");
            }
            if (!pathBasedUrl.EndsWith("{type}"))
            {
                throw new FormatException("The pathUrlFormat must end with the {type} token");
            }
            if (!pathBasedUrl.StartsWith("{dependencyId}"))
            {
                throw new FormatException("The pathUrlFormat must start with the {dependencyId} token");
            }
            if (pathChars.Count(x => x == '{') > 3)
            {
                throw new FormatException("The value specified for pathUrlFormat contains a '{' character outside of the token declaration which is invalid");
            }
            if (pathChars.Count(x => x == '}') > 3)
            {
                throw new FormatException("The value specified for pathUrlFormat contains a '}' character outside of the token declaration which is invalid");
            }
            //ensure that each token is delimited by something
            if (pathChars[pathBasedUrlFormat.IndexOf('}') + 1] == '{' || pathChars[pathBasedUrlFormat.IndexOf('}') + 1] == '}')
            {
                throw new FormatException("The {dependencyId} and {version} tokens must be seperated by a valid character");
            }
            if (pathChars[pathBasedUrlFormat.IndexOf('}', pathBasedUrlFormat.IndexOf('}') + 1) + 1] == '{' || pathChars[pathBasedUrlFormat.IndexOf('}', pathBasedUrlFormat.IndexOf('}') + 1) + 1] == '}')
            {
                throw new FormatException("The {version} and {type} tokens must be seperated by a valid character");
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="XmlFileMapper">
      <declaration><![CDATA[public class XmlFileMapper : BaseFileMapProvider]]></declaration>
      <documentation>
        <summary>
 Creates an XML file to map a saved composite file to the URL requested for the
 dependency handler.
 This is used in order to determine which individual files are dependant on what composite file so
 a user can remove it to clear the cache, and also if the cache expires but the file still exists
 this allows the system to simply read the one file again instead of compiling all of the other files
 into one again.
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public XmlFileMapper()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static XmlFileMapper()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="34" sc="9" el="39" ec="81">CompositeFiles\Providers\XmlFileMapper.cs</location>
            <body hash="402828b9c1d3fede064c562f38207ac6"><![CDATA[private static readonly object Locker = new object();

        /// <summary>
        /// Specifies the default folder to store the file map in, this allows for dynamically changing the folder on startup
        /// </summary>
        public static string FileMapVirtualFolder = FileMapVirtualFolderDefault;]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CreateFileNode">
          <declaration><![CDATA[private XElement CreateFileNode(IEnumerable<IClientDependencyFile> dependentFiles)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="299" sc="9" el="309" ec="10">CompositeFiles\Providers\XmlFileMapper.cs</location>
            <body hash="1df559239df60bd3a147d68845407dc8"><![CDATA[{
            var x = new XElement("files");

            //add all of the files
            foreach (var d in dependentFiles)
            {
                x.Add(new XElement("file", new XAttribute("name", d.FilePath)));
            }

            return x;
        }]]></body>
          </codeblock>
        </method>
        <method name="CreateNewMap">
          <declaration><![CDATA[public override string CreateNewMap(HttpContextBase http, IEnumerable<IClientDependencyFile> dependentFiles, int version)]]></declaration>
          <documentation>
            <summary>
 Creates a new file map and file key for the dependent file list, this is used to create URLs with CompositeUrlType.MappedId
 </summary>
             <example>
 <![CDATA[
 <map>
             		<item key="123xsy"
             			file=""
             			compresion="deflate"
         version="1234">
             			<files>
             				<file name="C:\asdf\JS\jquery.js" />
             				<file name="C:\asdf\JS\jquery.ui.js" />
             			</files>
             		</item>
 </map>
 ]]>
 </example></documentation>
          <codeblock>
            <location sl="173" sc="9" el="201" ec="10">CompositeFiles\Providers\XmlFileMapper.cs</location>
            <body hash="07827c1968d4bbe05c983b883da13c37"><![CDATA[{
            if (http == null) throw new ArgumentNullException("http");

            var builder = new StringBuilder();
            foreach (var d in dependentFiles)
            {
                builder.Append(d.FilePath);
                builder.Append(";");
            }
            var combinedFiles = builder.ToString();
            combinedFiles = combinedFiles.TrimEnd(new[] { ';' });

            var fileKey = (combinedFiles + version).GenerateHash();

            var x = FindItem(fileKey, version);
            
            //if no map exists, create one
            if (x == null)
            {
                //now, create a map with the file key so that it can be filled out later with the actual composite file that is created by the handler
                CreateUpdateMap(fileKey,
                    string.Empty,
                    dependentFiles,
                    string.Empty,
                    version);
            }

            return fileKey;
        }]]></body>
          </codeblock>
        </method>
        <method name="CreateNewXmlFile">
          <declaration><![CDATA[private void CreateNewXmlFile()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="331" sc="9" el="351" ec="10">CompositeFiles\Providers\XmlFileMapper.cs</location>
            <body hash="fb5545a4e902393632a9435bb656e132"><![CDATA[{
            if (File.Exists(_xmlFile.FullName))
            {
                File.Delete(_xmlFile.FullName);
            }

            if (_doc == null)
            {
                _doc = new XDocument(new XDeclaration("1.0", "UTF-8", "yes"),
                                                new XElement("map"));
                Directory.CreateDirectory(_xmlFile.DirectoryName);
                _doc.Save(_xmlFile.FullName);    
            }
            else
            {
                //if there's xml in memory, then the file has been deleted so write out the file
                Directory.CreateDirectory(_xmlFile.DirectoryName);
                _doc.Save(_xmlFile.FullName);
            }
            
        }]]></body>
          </codeblock>
        </method>
        <method name="CreateUpdateMap">
          <declaration><![CDATA[public override void CreateUpdateMap(string fileKey, string compressionType, IEnumerable<IClientDependencyFile> dependentFiles, string compositeFile, int version)]]></declaration>
          <documentation>
            <summary>
 Adds/Updates an entry to the file map with the key specified, the version and dependent files listed with a map
 to the composite file created for the files.
 </summary>
 <param name="fileKey"></param>
             <param name="compressionType"></param>
             <param name="dependentFiles"></param>
 <param name="compositeFile"></param>
             <param name="version"></param>
             <example>
 <![CDATA[
 <map>
             		<item key="XSDFSDKJHLKSDIOUEYWCDCDSDOIUPOIUEROIJDSFHG"
             			file="C:\asdf\App_Data\ClientDependency\123456.cdj"
             			compresion="deflate"
         version="1234">
             			<files>
             				<file name="C:\asdf\JS\jquery.js" />
             				<file name="C:\asdf\JS\jquery.ui.js" />
             			</files>
             		</item>
 </map>
 ]]>
 </example></documentation>
          <codeblock>
            <location sl="232" sc="9" el="263" ec="10">CompositeFiles\Providers\XmlFileMapper.cs</location>
            <body hash="06d93008290396be7b2b812128996003"><![CDATA[{
            if (string.IsNullOrEmpty(fileKey)) throw new ArgumentNullException("fileKey");

            lock (Locker)
            {
                //see if we can find an item with the key/version/compression that exists
                var x = FindItem(fileKey, version, compressionType);

                if (x != null)
                {
                    x.Attribute("file").Value = compositeFile;
                    //remove all of the files so we can re-add them.
                    x.Element("files").Remove();

                    x.Add(CreateFileNode(dependentFiles));
                }
                else
                {
                    //if it doesn't exist, create it
                    _doc.Root.Add(new XElement("item",
                        new XAttribute("key", fileKey),
                        new XAttribute("file", compositeFile),
                        new XAttribute("compression", compressionType),
                        new XAttribute("version", version),
                        CreateFileNode(dependentFiles)));
                }

                //ensure folder exists
                Directory.CreateDirectory(_xmlFile.DirectoryName);
                _doc.Save(_xmlFile.FullName);
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="EnsureXmlFile">
          <declaration><![CDATA[private void EnsureXmlFile()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="354" sc="9" el="368" ec="10">CompositeFiles\Providers\XmlFileMapper.cs</location>
            <body hash="2edd07143703144ce16d851e523f6218"><![CDATA[{
            if (!File.Exists(_xmlFile.FullName))
            {
                lock (Locker)
                {
                    //double check
                    if (!File.Exists(_xmlFile.FullName))
                    {
                        if (!XmlMapFolder.Exists)
                            XmlMapFolder.Create();
                        CreateNewXmlFile();
                    }
                }
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="FindItem">
          <declaration><![CDATA[private XElement FindItem(string key, int version, string compression)]]></declaration>
          <documentation>
            <summary>
 Finds an element in the map matching the key and version/compression
 </summary>
 <param name="key"></param>
 <param name="version"></param>
 <param name="compression"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="273" sc="9" el="280" ec="10">CompositeFiles\Providers\XmlFileMapper.cs</location>
            <body hash="d6e3474fd835cefde693c688032ace76"><![CDATA[{
            if (string.IsNullOrEmpty(key)) throw new ArgumentNullException("key");           

            var items = _doc.Root.Elements("item")
                .Where(e => (string) e.Attribute("key") == key
                            && (string) e.Attribute("version") == version.ToString());
            return items.Where(e => (string)e.Attribute("compression") == compression).SingleOrDefault();
        }]]></body>
          </codeblock>
        </method>
        <method name="FindItem">
          <declaration><![CDATA[private XElement FindItem(string key, int version)]]></declaration>
          <documentation>
            <summary>
 Finds a element in the map matching key/version
 </summary>
 <param name="key"></param>
 <param name="version"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="289" sc="9" el="296" ec="10">CompositeFiles\Providers\XmlFileMapper.cs</location>
            <body hash="4cf2dffae2f1bffcbda5e6274bc71e53"><![CDATA[{
            if (string.IsNullOrEmpty(key)) throw new ArgumentNullException("key");

            var items = _doc.Root.Elements("item")
                .Where(e => (string)e.Attribute("key") == key
                            && (string)e.Attribute("version") == version.ToString());
            return items.FirstOrDefault();
        }]]></body>
          </codeblock>
        </method>
        <method name="GetCompositeFile">
          <declaration><![CDATA[public override CompositeFileMap GetCompositeFile(string fileKey, int version, string compression)]]></declaration>
          <documentation>
            <summary>
 Returns the composite file map associated with the file key, the version and the compression type
 </summary>
 <param name="fileKey"></param>
 <param name="version"></param>
 <param name="compression"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="100" sc="9" el="119" ec="10">CompositeFiles\Providers\XmlFileMapper.cs</location>
            <body hash="5dfff020c9050360fc1483093801a90e"><![CDATA[{
            if (string.IsNullOrEmpty(fileKey)) throw new ArgumentNullException("fileKey");

            EnsureXmlFile();

            var x = FindItem(fileKey, version, compression);
            try
            {
                return (x == null ? null : new CompositeFileMap(fileKey,
                    (string)x.Attribute("compression"),
                    (string)x.Attribute("file"),
                    x.Descendants("file")
                        .Select(f => ((string)f.Attribute("name"))).ToArray(), 
                        int.Parse((string)x.Attribute("version"))));
            }
            catch
            {
                return null;
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="GetDependentFiles">
          <declaration><![CDATA[public override IEnumerable<string> GetDependentFiles(string fileKey, int version)]]></declaration>
          <documentation>
            <summary>
 Retreives the dependent file paths for the filekey/version (regardless of compression)
 </summary>
 <param name="fileKey"></param>
 <param name="version"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="128" sc="9" el="150" ec="10">CompositeFiles\Providers\XmlFileMapper.cs</location>
            <body hash="d328ca2fe45fdff2338477649bab2bfb"><![CDATA[{
            if (string.IsNullOrEmpty(fileKey)) throw new ArgumentNullException("fileKey");

            var x = FindItem(fileKey, version);
            try
            {                
                if (x != null)
                {
                    var file = new CompositeFileMap(fileKey,
                                                    (string) x.Attribute("compression"),
                                                    (string) x.Attribute("file"),
                                                    x.Descendants("file")
                                                        .Select(f => ((string) f.Attribute("name"))).ToArray(),
                                                    int.Parse((string) x.Attribute("version")));
                    return file.DependentFiles;
                }
            }
            catch
            {
                return null;
            }
            return null;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetXmlMapPath">
          <declaration><![CDATA[private string GetXmlMapPath()]]></declaration>
          <documentation>
            <summary>
 Returns the full path the map xml file for the current machine and install folder.
 </summary>
 <remarks>
 We need to create the map based on the combination of both machine name and install folder because
 this deals with issues for load balanced environments and file locking and also
 deals with issues when the ClientDependency folder is deployed between environments
 since you would want your staging ClientDependencies in your live and vice versa.
 This is however based on the theory that each website you have will have a unique combination
 of folder path and machine name.
 </remarks>
 <returns></returns></documentation>
          <codeblock>
            <location sl="324" sc="9" el="328" ec="10">CompositeFiles\Providers\XmlFileMapper.cs</location>
            <body hash="1b625f21a2c2374a29cd818257d357f5"><![CDATA[{
            var folder = XmlMapFolder.FullName;
            var folderHash = folder.GenerateHash();
            return Path.Combine(folder, NetworkHelper.FileSafeMachineName + "-" + folderHash + "-" + MapFileName);
        }]]></body>
          </codeblock>
        </method>
        <method name="Initialize">
          <declaration><![CDATA[public override void Initialize(HttpContextBase http)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="44" sc="9" el="67" ec="10">CompositeFiles\Providers\XmlFileMapper.cs</location>
            <body hash="5f02a8f700fcec491ec1fbc39abc2b2e"><![CDATA[{
            if (http == null) throw new ArgumentNullException("http");

            XmlMapFolder = new DirectoryInfo(http.Server.MapPath(FileMapVirtualFolder));    

            //Name the map file according to the machine name
            _xmlFile = new FileInfo(GetXmlMapPath());

            EnsureXmlFile();

            lock (Locker)
            {
                try
                {
                    _doc = XDocument.Load(_xmlFile.FullName);
                }
                catch (XmlException)
                {
                    //if it's an xml exception, create a new one and try one more time... should always work.
                    CreateNewXmlFile();
                    _doc = XDocument.Load(_xmlFile.FullName);
                }
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="Initialize">
          <declaration><![CDATA[public override void Initialize(string name, NameValueCollection config)]]></declaration>
          <documentation>
            <summary>
 Initializes the provider, loads in the existing file contents. If the file doesn't exist, it creates one.
 </summary>
          </documentation>
          <codeblock>
            <location sl="73" sc="9" el="90" ec="10">CompositeFiles\Providers\XmlFileMapper.cs</location>
            <body hash="a102509ede80a8b84e6c2bb7d846aabf"><![CDATA[{
            base.Initialize(name, config);

            if (config == null)
                return;

            if (config["mapPath"] != null)
            {
                //use the config setting if it has not been dynamically set OR
                //when the config section doesn't equal the default
                if (FileMapVirtualFolder == FileMapVirtualFolderDefault
                    || config["mapPath"] != FileMapVirtualFolderDefault)
                {
                    FileMapVirtualFolder = config["mapPath"];   
                }                
            }

        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_doc">
          <declaration><![CDATA[private XDocument _doc;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_xmlFile">
          <declaration><![CDATA[private FileInfo _xmlFile;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DefaultName">
          <declaration><![CDATA[public const string DefaultName = "XmlFileMap";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="FileMapVirtualFolder">
          <declaration><![CDATA[public static string FileMapVirtualFolder = "~/App_Data/ClientDependency";]]></declaration>
          <documentation>
            <summary>
 Specifies the default folder to store the file map in, this allows for dynamically changing the folder on startup
 </summary>
          </documentation>
        </field>
        <field name="FileMapVirtualFolderDefault">
          <declaration><![CDATA[private const string FileMapVirtualFolderDefault = "~/App_Data/ClientDependency";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Locker">
          <declaration><![CDATA[private static readonly object Locker = new object();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="MapFileName">
          <declaration><![CDATA[private const string MapFileName = "map.xml";]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="XmlMapFolder">
          <declaration><![CDATA[private DirectoryInfo XmlMapFolder]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="41" sc="46" el="41" ec="50">CompositeFiles\Providers\XmlFileMapper.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="41" sc="51" el="41" ec="55">CompositeFiles\Providers\XmlFileMapper.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="ClientDependency.Core.Config">
    <class name="ClientDependencySection">
      <declaration><![CDATA[public class ClientDependencySection : ConfigurationSection]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ClientDependencySection()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="_filters">
          <declaration><![CDATA[private ProviderSettingsCollection _filters;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="AllowOnlyFipsAlgorithms">
          <deprecation>Use the built in .Net CryptoConfig.AllowOnlyFipsAlgorithms</deprecation>
          <declaration><![CDATA[public bool AllowOnlyFipsAlgorithms]]></declaration>
          <documentation>
            <summary>
 Indicates whether CDF should enforce the policy to create only Federal Information Processing Standard (FIPS) certified algorithms.
 </summary>
          </documentation>
          <codeblock>
            <location sl="123" sc="13" el="125" ec="14">Config\ClientDependencySection.cs</location>
            <body hash="e997b7ac748c22938c408976aa2c9072"><![CDATA[{
                //this does nothing now                
            }]]></body>
          </codeblock>
        </property>
        <property name="CompositeFileElement">
          <declaration><![CDATA[public CompositeFileSection CompositeFileElement]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="39" sc="7" el="41" ec="8">Config\ClientDependencySection.cs</location>
            <body hash="e58ecbf9392ba3dc2861a0b4c31fa8d8"><![CDATA[{
				return (CompositeFileSection)this["compositeFiles"];
		    }]]></body>
          </codeblock>
        </property>
        <property name="FileBasedDepdendenyExtensions">
          <declaration><![CDATA[public string FileBasedDepdendenyExtensions]]></declaration>
          <documentation>
            <summary>
 The configuration section to set the FileBasedDependencyExtensionList. This is a comma separated list.
 </summary>
 <remarks>
 If this is not explicitly set, then the extensions 'js' and 'css' are the defaults.
 </remarks></documentation>
        </property>
        <property name="FileBasedDependencyExtensionList">
          <declaration><![CDATA[public IEnumerable<string> FileBasedDependencyExtensionList]]></declaration>
          <documentation>
            <summary>
 The file extensions of Client Dependencies that are file based as opposed to request based.
 Any file that doesn't have the extensions listed here will be request based, request based is
 more overhead for the server to process.
 </summary>
 <example>
 A request based JavaScript file may be  a .ashx that dynamically creates JavaScript server side.
 Or an asmx/js request based on the proxied javascript created by web services.
 </example>
 <remarks>
 If this is not explicitly set, then the extensions 'js' and 'css' are the defaults.
 </remarks></documentation>
          <codeblock>
            <location sl="143" sc="13" el="146" ec="14">Config\ClientDependencySection.cs</location>
            <body hash="dfbed5501137bfa7ea2d82a83d182365"><![CDATA[{
                return FileBasedDepdendenyExtensions.Split(',')
                    .Select(x => x.Trim().ToUpper());
            }]]></body>
          </codeblock>
        </property>
        <property name="FileRegistrationElement">
          <declaration><![CDATA[public FileRegistrationSection FileRegistrationElement]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="48" sc="4" el="50" ec="5">Config\ClientDependencySection.cs</location>
            <body hash="0f699f6e39d9e0ff4738985d43f0eef0"><![CDATA[{
				return (FileRegistrationSection)this["fileRegistration"];
			}]]></body>
          </codeblock>
        </property>
        <property name="Filters">
          <declaration><![CDATA[public ProviderSettingsCollection Filters]]></declaration>
          <documentation>
            <summary>
 Not really supposed to be used by public, but can implement at your own risk!
 This by default assigns the MvcFilter and RogueFileFilter.
 </summary>
          </documentation>
          <codeblock>
            <location sl="80" sc="13" el="98" ec="14">Config\ClientDependencySection.cs</location>
            <body hash="694d873aef52692e0d2850f8898d01bd"><![CDATA[{
                if (_filters == null)
                {
                    var obj = base["filters"];

                    if (obj == null || ((obj is ConfigurationElementCollection) && ((ConfigurationElementCollection)obj).Count == 0))
                    {
                        var col = new ProviderSettingsCollection();
                        col.Add(new ProviderSettings("MvcFilter", "ClientDependency.Core.Mvc.MvcFilter, ClientDependency.Core.Mvc"));
                        col.Add(new ProviderSettings("RogueFileFilter", "ClientDependency.Core.Module.RogueFileFilter, ClientDependency.Core"));
                        _filters = col;
                    }
                    else
                    {
                        _filters = (ProviderSettingsCollection)obj;
                    }
                }
                return _filters;
            }]]></body>
          </codeblock>
        </property>
        <property name="LoggerType">
          <declaration><![CDATA[public string LoggerType]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="66" sc="13" el="68" ec="14">Config\ClientDependencySection.cs</location>
            <body hash="c5e7f6c5e11e19979054930ea6b20242"><![CDATA[{
                return (string)this["loggerType"];
            }]]></body>
          </codeblock>
        </property>
        <property name="MachineName">
          <declaration><![CDATA[public string MachineName]]></declaration>
          <documentation>
            <summary>
 explicitly sets the machine name if it cannot be resolved
 </summary>
          </documentation>
        </property>
        <property name="MvcElement">
          <declaration><![CDATA[public MvcSection MvcElement]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="57" sc="13" el="59" ec="14">Config\ClientDependencySection.cs</location>
            <body hash="96f33b8e8089b1d6ed53259b6c7cec13"><![CDATA[{
                return (MvcSection)this["mvc"];
            }]]></body>
          </codeblock>
        </property>
        <property name="Version">
          <declaration><![CDATA[public int Version]]></declaration>
          <documentation>
            <summary>
 Set the version for the files, this will reset all composite file caching, and if
 composite files are disabled will add a query string to each request so that
 any client side cached files will be re-downloaded.
 </summary>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ClientDependencySettings">
      <declaration><![CDATA[public class ClientDependencySettings]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private ClientDependencySettings()]]></declaration>
          <documentation>
            <summary>
 Default constructor for use with the Singletone instance with a web context app
 </summary>
          </documentation>
          <codeblock>
            <location sl="28" sc="9" el="43" ec="10">Config\ClientDependencySettings.cs</location>
            <body hash="b5653c220789312ef4b8f03f56dcf8ea"><![CDATA[private ClientDependencySettings()
        {
            if (HttpContext.Current == null)
            {
                throw new InvalidOperationException(
                    "HttpContext.Current must exist when using the empty constructor for ClientDependencySettings, otherwise use the alternative constructor");
            }

            ConfigSection = GetDefaultSection();
            //default
            CompositeFileHandlerPath = "~/DependencyHandler.axd";

            _loadProviders = () =>
                LoadProviders(new HttpContextWrapper(HttpContext.Current));

        }]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[internal ClientDependencySettings(FileSystemInfo configFile, HttpContextBase ctx)]]></declaration>
          <documentation>
            <summary>
 Generally for unit testing when not using the singleton instance
 </summary>
 <param name="configFile"></param>
 <param name="ctx"></param></documentation>
          <codeblock>
            <location sl="50" sc="9" el="61" ec="10">Config\ClientDependencySettings.cs</location>
            <body hash="c7c97b1721f5ed2a6e16a93de1555d8c"><![CDATA[internal ClientDependencySettings(FileSystemInfo configFile, HttpContextBase ctx)
        {
            var fileMap = new ExeConfigurationFileMap { ExeConfigFilename = configFile.FullName };
            var configuration = ConfigurationManager.OpenMappedExeConfiguration(fileMap, ConfigurationUserLevel.None);

            ConfigSection = (ClientDependencySection)configuration.GetSection("clientDependency");

            _loadProviders = () =>
                LoadProviders(ctx);

            _loadProviders();
        }]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[internal ClientDependencySettings(ClientDependencySection section, HttpContextBase ctx)]]></declaration>
          <documentation>
            <summary>
 Generally for unit testing when not using the singleton instance
 </summary>
 <param name="section"></param>
 <param name="ctx"></param></documentation>
          <codeblock>
            <location sl="68" sc="9" el="76" ec="10">Config\ClientDependencySettings.cs</location>
            <body hash="77d5c35a8ce933ff836e068d9d3ee818"><![CDATA[internal ClientDependencySettings(ClientDependencySection section, HttpContextBase ctx)
        {
            ConfigSection = section;

            _loadProviders = () =>
                LoadProviders(ctx);

            _loadProviders();
        }]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static ClientDependencySettings()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="22" sc="9" el="23" ec="53">Config\ClientDependencySettings.cs</location>
            <body hash="e952e300d8ec39e850eb47f782314f78"><![CDATA[private static readonly object Lock = new object();
        private static Action _loadProviders = null;]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="GetDefaultSection">
          <declaration><![CDATA[internal static ClientDependencySection GetDefaultSection()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="102" sc="9" el="104" ec="10">Config\ClientDependencySettings.cs</location>
            <body hash="159f752954e3406e71254929f766dc30"><![CDATA[{
            return (ClientDependencySection)ConfigurationManager.GetSection("clientDependency");
        }]]></body>
          </codeblock>
        </method>
        <method name="LoadDefaultCompositeFileConfig">
          <declaration><![CDATA[private void LoadDefaultCompositeFileConfig(ClientDependencySection section, HttpContextBase http)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="381" sc="9" el="399" ec="10">Config\ClientDependencySettings.cs</location>
            <body hash="42e5760a6877d33f5ee35e803ecbde78"><![CDATA[{
            if (section.CompositeFileElement.FileProcessingProviders.Count == 0)
            {
                var cfpp = new CompositeFileProcessingProvider();
                cfpp.Initialize(CompositeFileProcessingProvider.DefaultName, null);
                cfpp.Initialize(http);
                CompositeFileProcessingProviderCollection.Add(cfpp);
            }
            else
            {
                ProvidersHelper.InstantiateProviders(section.CompositeFileElement.FileProcessingProviders, CompositeFileProcessingProviderCollection, typeof(BaseCompositeFileProcessingProvider));
                //since the BaseCompositeFileProcessingProvider is an IHttpProvider, we need to do the http init
                foreach (var p in CompositeFileProcessingProviderCollection.Cast<BaseCompositeFileProcessingProvider>())
                {
                    p.Initialize(http);
                }
            }

        }]]></body>
          </codeblock>
        </method>
        <method name="LoadDefaultFileMapConfig">
          <declaration><![CDATA[private void LoadDefaultFileMapConfig(ClientDependencySection section, HttpContextBase http)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="359" sc="9" el="378" ec="10">Config\ClientDependencySettings.cs</location>
            <body hash="788aa4a832106dd7868a3a2aeb0e6804"><![CDATA[{
            if (section.CompositeFileElement.FileMapProviders.Count == 0)
            {
                //if not specified, create default
                var fmp = new XmlFileMapper();
                fmp.Initialize(XmlFileMapper.DefaultName, null);
                fmp.Initialize(http);
                FileMapProviderCollection.Add(fmp);
            }
            else
            {
                ProvidersHelper.InstantiateProviders(section.CompositeFileElement.FileMapProviders, FileMapProviderCollection, typeof(BaseFileMapProvider));
                //since the BaseFileMapProvider is an IHttpProvider, we need to do the http init
                foreach (var p in FileMapProviderCollection.Cast<BaseFileMapProvider>())
                {
                    p.Initialize(http);
                }
            }

        }]]></body>
          </codeblock>
        </method>
        <method name="LoadDefaultFileRegConfig">
          <declaration><![CDATA[private void LoadDefaultFileRegConfig(ClientDependencySection section)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="331" sc="9" el="356" ec="10">Config\ClientDependencySettings.cs</location>
            <body hash="54554336538bebdfca8fda861e955e87"><![CDATA[{
            if (section.FileRegistrationElement.Providers.Count == 0)
            {
                //create new providers
                var php = new PageHeaderProvider();
                php.Initialize(PageHeaderProvider.DefaultName, null);
                FileRegistrationProviderCollection.Add(php);

                var csrp = new LazyLoadProvider();
                csrp.Initialize(LazyLoadProvider.DefaultName, null);
                FileRegistrationProviderCollection.Add(csrp);

                var lcp = new LoaderControlProvider();
                lcp.Initialize(LoaderControlProvider.DefaultName, null);
                FileRegistrationProviderCollection.Add(lcp);

                var plhp = new PlaceHolderProvider();
                plhp.Initialize(PlaceHolderProvider.DefaultName, null);
                FileRegistrationProviderCollection.Add(plhp);
            }
            else
            {
                ProvidersHelper.InstantiateProviders(section.FileRegistrationElement.Providers, FileRegistrationProviderCollection, typeof(BaseFileRegistrationProvider));
            }

        }]]></body>
          </codeblock>
        </method>
        <method name="LoadDefaultMvcFileConfig">
          <declaration><![CDATA[private void LoadDefaultMvcFileConfig(ClientDependencySection section)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="402" sc="9" el="414" ec="10">Config\ClientDependencySettings.cs</location>
            <body hash="4c466b8a7f6116e9b27545df9947aed0"><![CDATA[{
            if (section.MvcElement.Renderers.Count == 0)
            {
                var mvc = new StandardRenderer();
                mvc.Initialize(StandardRenderer.DefaultName, null);
                MvcRendererCollection.Add(mvc);
            }
            else
            {
                ProvidersHelper.InstantiateProviders(section.MvcElement.Renderers, MvcRendererCollection, typeof(BaseRenderer));
            }

        }]]></body>
          </codeblock>
        </method>
        <method name="LoadProviders">
          <declaration><![CDATA[internal void LoadProviders(HttpContextBase http)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="253" sc="9" el="328" ec="10">Config\ClientDependencySettings.cs</location>
            <body hash="999264fb532cb9f68c6806de38d0c830"><![CDATA[{

            // if there is no section found, then create one
            if (ConfigSection == null)
            {
                //create a new section with the default settings
                ConfigSection = new ClientDependencySection();
            }

            //Load in the path first
            var rootPath = HttpRuntime.AppDomainAppVirtualPath ?? "/";
            //need to check if it's an http path or a lambda path
            var path = ConfigSection.CompositeFileElement.CompositeFileHandlerPath;
            CompositeFileHandlerPath = path.StartsWith("~/")
                ? VirtualPathUtility.ToAbsolute(ConfigSection.CompositeFileElement.CompositeFileHandlerPath, rootPath)
                : ConfigSection.CompositeFileElement.CompositeFileHandlerPath;

            FileRegistrationProviderCollection = new FileRegistrationProviderCollection();
            CompositeFileProcessingProviderCollection = new CompositeFileProcessingProviderCollection();
            MvcRendererCollection = new RendererCollection();
            FileMapProviderCollection = new FileMapProviderCollection();
            
            //load the providers from the config, if there isn't config sections then add default providers
            // and then load the defaults.

            LoadDefaultCompositeFileConfig(ConfigSection, http);

            ////Here we need to detect legacy settings
            //if (ConfigSection.CompositeFileElement.DefaultFileProcessingProviderLegacy != "CompositeFileProcessor"
            //    && ConfigSection.CompositeFileElement.DefaultFileProcessingProvider == "CompositeFileProcessor")
            //{
            //    //if the legacy section is not the default and the non-legacy section IS the default, then use the legacy section
            //    DefaultCompositeFileProcessingProvider = CompositeFileProcessingProviderCollection[ConfigSection.CompositeFileElement.DefaultFileProcessingProviderLegacy];
            //}
            //else
            //{
            //    DefaultCompositeFileProcessingProvider = CompositeFileProcessingProviderCollection[ConfigSection.CompositeFileElement.DefaultFileProcessingProvider];   
            //}            
            DefaultCompositeFileProcessingProvider = CompositeFileProcessingProviderCollection[ConfigSection.CompositeFileElement.DefaultFileProcessingProvider];
            if (DefaultCompositeFileProcessingProvider == null)
                throw new ProviderException("Unable to load default composite file provider");

            LoadDefaultFileMapConfig(ConfigSection, http);

            DefaultFileMapProvider = FileMapProviderCollection[ConfigSection.CompositeFileElement.DefaultFileMapProvider];
            if (DefaultFileMapProvider == null)
                throw new ProviderException("Unable to load default file map provider");

            LoadDefaultMvcFileConfig(ConfigSection);

            DefaultMvcRenderer = MvcRendererCollection[ConfigSection.MvcElement.DefaultRenderer];
            if (DefaultMvcRenderer == null)
                throw new ProviderException("Unable to load default mvc renderer");

            LoadDefaultFileRegConfig(ConfigSection);

            DefaultFileRegistrationProvider = FileRegistrationProviderCollection[ConfigSection.FileRegistrationElement.DefaultProvider];
            if (DefaultFileRegistrationProvider == null)
                throw new ProviderException("Unable to load default file registration provider");

            if (string.IsNullOrEmpty(ConfigSection.LoggerType))
            {
                Logger = new TraceLogger();
            }
            else
            {
                var t = Type.GetType(ConfigSection.LoggerType);
                if (!typeof(ILogger).IsAssignableFrom(t))
                {
                    throw new ArgumentException("The loggerType '" + ConfigSection.LoggerType + "' does not inherit from ClientDependency.Core.Logging.ILogger");
                }

                Logger = (ILogger)Activator.CreateInstance(t);
            }

        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_allowOnlyFipsAlgorithms">
          <declaration><![CDATA[private bool? _allowOnlyFipsAlgorithms;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_configSection">
          <declaration><![CDATA[private ClientDependencySection _configSection;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_fileBasedDependencyExtensionList">
          <declaration><![CDATA[private List<string> _fileBasedDependencyExtensionList;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_loadProviders">
          <declaration><![CDATA[private static Action _loadProviders = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_settings">
          <declaration><![CDATA[private static volatile ClientDependencySettings _settings;]]></declaration>
          <documentation>
            <summary>
 used for singleton
 </summary>
          </documentation>
        </field>
        <field name="_version">
          <declaration><![CDATA[private int? _version;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Lock">
          <declaration><![CDATA[private static readonly object Lock = new object();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="AllowOnlyFipsAlgorithms">
          <declaration><![CDATA[public bool AllowOnlyFipsAlgorithms]]></declaration>
          <documentation>
            <summary>
 Indicates whether CDF should enforce the policy to create only Federal Information Processing Standard (FIPS) certified algorithms.
 </summary>
          </documentation>
          <codeblock>
            <location sl="175" sc="13" el="181" ec="14">Config\ClientDependencySettings.cs</location>
            <body hash="ff0a92af9ed81a120bc796e1d0c16a38"><![CDATA[{
                if (!_allowOnlyFipsAlgorithms.HasValue)
                {
					_allowOnlyFipsAlgorithms = CryptoConfig.AllowOnlyFipsAlgorithms;
                }
                return _allowOnlyFipsAlgorithms.Value;
            }]]></body>
          </codeblock>
        </property>
        <property name="CompositeFileHandlerPath">
          <declaration><![CDATA[public string CompositeFileHandlerPath]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="250" sc="50" el="250" ec="54">Config\ClientDependencySettings.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="250" sc="55" el="250" ec="59">Config\ClientDependencySettings.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="CompositeFileProcessingProviderCollection">
          <declaration><![CDATA[public CompositeFileProcessingProviderCollection CompositeFileProcessingProviderCollection]]></declaration>
          <documentation>
            <summary>
 Returns the composite file processing provider collection
 </summary>
          </documentation>
          <codeblock>
            <location sl="238" sc="102" el="238" ec="106">Config\ClientDependencySettings.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="238" sc="107" el="238" ec="119">Config\ClientDependencySettings.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
        <property name="ConfigSection">
          <declaration><![CDATA[public ClientDependencySection ConfigSection]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="111" sc="13" el="116" ec="14">Config\ClientDependencySettings.cs</location>
            <body hash="ce0a521baa1330b9723582349e94fef6"><![CDATA[{
                lock (Lock)
                {
                    _configSection = value;
                }
            }]]></body>
          </codeblock>
        </property>
        <property name="DefaultCompositeFileProcessingProvider">
          <declaration><![CDATA[public BaseCompositeFileProcessingProvider DefaultCompositeFileProcessingProvider]]></declaration>
          <documentation>
            <summary>
 Returns the default composite file processing provider
 </summary>
          </documentation>
          <codeblock>
            <location sl="233" sc="93" el="233" ec="97">Config\ClientDependencySettings.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="233" sc="98" el="233" ec="110">Config\ClientDependencySettings.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
        <property name="DefaultFileMapProvider">
          <declaration><![CDATA[public BaseFileMapProvider DefaultFileMapProvider]]></declaration>
          <documentation>
            <summary>
 Returns the default file map provider
 </summary>
          </documentation>
          <codeblock>
            <location sl="243" sc="61" el="243" ec="65">Config\ClientDependencySettings.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="243" sc="66" el="243" ec="78">Config\ClientDependencySettings.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
        <property name="DefaultFileRegistrationProvider">
          <declaration><![CDATA[public WebFormsFileRegistrationProvider DefaultFileRegistrationProvider]]></declaration>
          <documentation>
            <summary>
 Returns the default file registration provider
 </summary>
          </documentation>
          <codeblock>
            <location sl="223" sc="83" el="223" ec="87">Config\ClientDependencySettings.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="223" sc="88" el="223" ec="100">Config\ClientDependencySettings.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
        <property name="DefaultMvcRenderer">
          <declaration><![CDATA[public BaseRenderer DefaultMvcRenderer]]></declaration>
          <documentation>
            <summary>
 Returns the default MVC renderer
 </summary>
          </documentation>
          <codeblock>
            <location sl="213" sc="50" el="213" ec="54">Config\ClientDependencySettings.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="213" sc="55" el="213" ec="67">Config\ClientDependencySettings.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
        <property name="FileBasedDependencyExtensionList">
          <declaration><![CDATA[public List<string> FileBasedDependencyExtensionList]]></declaration>
          <documentation>
            <summary>
 The file extensions of Client Dependencies that are file based as opposed to request based.
 Any file that doesn't have the extensions listed here will be request based, request based is
 more overhead for the server to process.
 </summary>
 <example>
 A request based JavaScript file may be  a .ashx that dynamically creates JavaScript server side.
 </example>
 <remarks>
 If this is not explicitly set, then the extensions 'js' and 'css' are the defaults.
 </remarks></documentation>
          <codeblock>
            <location sl="137" sc="4" el="159" ec="14">Config\ClientDependencySettings.cs</location>
            <body hash="9c00d6ac1ddb44cdc164ffa234cd3277"><![CDATA[{
#pragma warning disable 618
				if (_fileBasedDependencyExtensionList == null)
                {
                    //Here we are checking for backwards compatibility config sections.
                    if (ConfigSection.FileRegistrationElement.FileBasedDependencyExtensions != ".js,.css"
                        && ConfigSection.FileBasedDepdendenyExtensions == ".js,.css")
                    {
                        //if the legacy section is not the default and the non-legacy section IS the default, 
                        //then we will use the legacy settings.
                        _fileBasedDependencyExtensionList = ConfigSection.FileRegistrationElement.FileBasedDependencyExtensionList.ToList();
                    }
                    else
                    {
                        _fileBasedDependencyExtensionList = ConfigSection.FileBasedDependencyExtensionList.ToList();
                    }

                    //always force uppercase
                    _fileBasedDependencyExtensionList = _fileBasedDependencyExtensionList.Select(x => x.ToUpper()).Distinct().ToList();
				}
#pragma warning restore 618
				return _fileBasedDependencyExtensionList;
            }]]></body>
          </codeblock>
          <codeblock>
            <location sl="161" sc="13" el="164" ec="14">Config\ClientDependencySettings.cs</location>
            <body hash="9724fcdf90fbb3f7fb73c0a09d9cae27"><![CDATA[{
                //always force uppercase
                _fileBasedDependencyExtensionList = value.Select(x => x.ToUpper()).Distinct().ToList();
            }]]></body>
          </codeblock>
        </property>
        <property name="FileMapProviderCollection">
          <declaration><![CDATA[public FileMapProviderCollection FileMapProviderCollection]]></declaration>
          <documentation>
            <summary>
 Returns the collection of file map providers
 </summary>
          </documentation>
          <codeblock>
            <location sl="248" sc="70" el="248" ec="74">Config\ClientDependencySettings.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="248" sc="75" el="248" ec="87">Config\ClientDependencySettings.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
        <property name="FileRegistrationProviderCollection">
          <declaration><![CDATA[public FileRegistrationProviderCollection FileRegistrationProviderCollection]]></declaration>
          <documentation>
            <summary>
 Returns the file registration provider collection
 </summary>
          </documentation>
          <codeblock>
            <location sl="228" sc="88" el="228" ec="92">Config\ClientDependencySettings.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="228" sc="93" el="228" ec="105">Config\ClientDependencySettings.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
        <property name="Instance">
          <declaration><![CDATA[public static ClientDependencySettings Instance]]></declaration>
          <documentation>
            <summary>
 Singleton, used for web apps
 </summary>
          </documentation>
          <codeblock>
            <location sl="84" sc="13" el="98" ec="14">Config\ClientDependencySettings.cs</location>
            <body hash="1ae48fcdd16b953137dbda5c1c893795"><![CDATA[{
                if (_settings == null)
                {
                    lock (Lock)
                    {
                        //double check
                        if (_settings == null)
                        {
                            _settings = new ClientDependencySettings();
                            _loadProviders();
                        }
                    }
                }
                return _settings;
            }]]></body>
          </codeblock>
        </property>
        <property name="Logger">
          <declaration><![CDATA[public ILogger Logger]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="208" sc="33" el="208" ec="37">Config\ClientDependencySettings.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="208" sc="38" el="208" ec="50">Config\ClientDependencySettings.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
        <property name="MvcRendererCollection">
          <declaration><![CDATA[public RendererCollection MvcRendererCollection]]></declaration>
          <documentation>
            <summary>
 Returns the MVC renderer provider collection
 </summary>
          </documentation>
          <codeblock>
            <location sl="218" sc="59" el="218" ec="63">Config\ClientDependencySettings.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="218" sc="64" el="218" ec="76">Config\ClientDependencySettings.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
        <property name="Version">
          <declaration><![CDATA[public int Version]]></declaration>
          <documentation>
            <summary>
 Gets/sets the file version
 </summary>
          </documentation>
          <codeblock>
            <location sl="193" sc="13" el="204" ec="14">Config\ClientDependencySettings.cs</location>
            <body hash="db70e455e17f7836d9f0d26ffe9719fd"><![CDATA[{
                if (!_version.HasValue)
                {
                    _version = ConfigSection.Version;
                }

                //grab any settings from dnn
                var dnnConfig = new DnnConfiguration();
                var dnnVersion = dnnConfig.GetVersion();

                return dnnVersion == null ? _version.Value : dnnVersion.Value;
            }]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="CompositeFileSection">
      <declaration><![CDATA[public class CompositeFileSection : ConfigurationElement]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public CompositeFileSection()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="CompositeFileHandlerPath">
          <declaration><![CDATA[public string CompositeFileHandlerPath]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="DefaultFileMapProvider">
          <declaration><![CDATA[public string DefaultFileMapProvider]]></declaration>
          <documentation>
            <summary>
 The default file map provider
 </summary>
          </documentation>
        </property>
        <property name="DefaultFileProcessingProvider">
          <declaration><![CDATA[public string DefaultFileProcessingProvider]]></declaration>
          <documentation>
            <summary>
 The default File processing provider
 </summary>
          </documentation>
        </property>
        <property name="DefaultFileProcessingProviderLegacy">
          <deprecation>Use DefaultFileProcessingProvider instead</deprecation>
          <declaration><![CDATA[public string DefaultFileProcessingProviderLegacy]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="65" sc="13" el="67" ec="14">Config\CompositeFileSection.cs</location>
            <body hash="c9bfa1466f47aca9b8650fb85f810339"><![CDATA[{
                return (string)base["defaultProvider"];
            }]]></body>
          </codeblock>
          <codeblock>
            <location sl="69" sc="13" el="71" ec="14">Config\CompositeFileSection.cs</location>
            <body hash="703ed3f63aa94f99d7d27fa72100123e"><![CDATA[{
                base["defaultProvider"] = value;
            }]]></body>
          </codeblock>
        </property>
        <property name="FileMapProviders">
          <declaration><![CDATA[public ProviderSettingsCollection FileMapProviders]]></declaration>
          <documentation>
            <summary>
 All of the File map providers registered
 </summary>
          </documentation>
        </property>
        <property name="FileProcessingProviders">
          <declaration><![CDATA[public ProviderSettingsCollection FileProcessingProviders]]></declaration>
          <documentation>
            <summary>
 All of the file processing providers registered
 </summary>
          </documentation>
          <codeblock>
            <location sl="19" sc="13" el="30" ec="14">Config\CompositeFileSection.cs</location>
            <body hash="032d2223eac8af16c23eaa158f9dc22e"><![CDATA[{
                //We need to check for legacy settings here:
                var collection = (ProviderSettingsCollection)base["fileProcessingProviders"];
                var legacyCollection = (ProviderSettingsCollection)base["providers"];
                if (collection.Count == 0 && legacyCollection.Count > 0)
                {
                    //need to return the legacy collection
                    return legacyCollection;
                }

                return collection;
            }]]></body>
          </codeblock>
        </property>
        <property name="FileProcessingProvidersLegacy">
          <deprecation>Use FileProcessingProviders instead</deprecation>
          <declaration><![CDATA[public ProviderSettingsCollection FileProcessingProvidersLegacy]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="MimeTypeCompression">
          <declaration><![CDATA[public MimeTypeCompressionCollection MimeTypeCompression]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="96" sc="13" el="98" ec="14">Config\CompositeFileSection.cs</location>
            <body hash="ea814387eed387f6f3eebebfea0839f8"><![CDATA[{
                return (MimeTypeCompressionCollection)base["mimeTypeCompression"];
            }]]></body>
          </codeblock>
        </property>
        <property name="RogueFileCompression">
          <declaration><![CDATA[public RogueFileCompressionCollection RogueFileCompression]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="105" sc="13" el="107" ec="14">Config\CompositeFileSection.cs</location>
            <body hash="fa31824bddf3a0c9857836451385207e"><![CDATA[{
                return (RogueFileCompressionCollection)base["rogueFileCompression"];
            }]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="DnnConfiguration">
      <declaration><![CDATA[public class DnnConfiguration]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".cctor">
          <declaration><![CDATA[static DnnConfiguration()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="14" sc="9" el="43" ec="10">Config\DnnConfiguration.cs</location>
            <body hash="a70e2364179c5edfa95c8ae3d27e068e"><![CDATA[public static readonly string HostSettingsDictionaryKey = "HostSettingsDictionary";
        public static readonly string PortalSettingsDictionaryKey = "PortalSettingsDictionary";

        // public keys used to identify the various host and portal level settings
        public static readonly string EnableCompositeFilesKey = "CrmEnableCompositeFiles";
        public static readonly string MinifyCssKey = "CrmMinifyCss";
        public static readonly string MinifyJsKey = "CrmMinifyJs";
        public static readonly string OverrideDefaultSettingsKey = "CrmUseApplicationSettings";
        public static readonly string VersionKey = "CrmVersion";
        public static readonly string DebugModeKey = "DebugMode";

        private static readonly Type _portalControllerType;
        private static readonly Type _portalAliasControllerType;
        private static readonly Type _hostControllerType;
        private static readonly Type _commonGlobalsType;

        static DnnConfiguration()
        {
            try
            {
                // all these types are part of the same library, so we don't need a separate catch for each one
                _commonGlobalsType = Type.GetType("DotNetNuke.Common.Globals, DotNetNuke");
                _portalControllerType = Type.GetType("DotNetNuke.Entities.Portals.PortalController, DotNetNuke");
                _portalAliasControllerType = Type.GetType("DotNetNuke.Entities.Portals.PortalAliasController, DotNetNuke");
                _hostControllerType = Type.GetType("DotNetNuke.Entities.Controllers.HostController, DotNetNuke");
            }
            catch (Exception)
            {
            }
        }]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public DnnConfiguration()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AreCompositeFilesEnabled">
          <declaration><![CDATA[public bool? AreCompositeFilesEnabled()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="65" sc="9" el="67" ec="10">Config\DnnConfiguration.cs</location>
            <body hash="3ee2e29b4a4c3b1b6f038c66becd938a"><![CDATA[{
            return IsBooleanSettingEnabled(EnableCompositeFilesKey);
        }]]></body>
          </codeblock>
        </method>
        <method name="EnableCssMinification">
          <declaration><![CDATA[public bool? EnableCssMinification()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="70" sc="9" el="72" ec="10">Config\DnnConfiguration.cs</location>
            <body hash="35e7dd8355e74ad2046c456c6915440c"><![CDATA[{
            return IsBooleanSettingEnabled(MinifyCssKey);
        }]]></body>
          </codeblock>
        </method>
        <method name="EnableJsMinification">
          <declaration><![CDATA[public bool? EnableJsMinification()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="75" sc="9" el="77" ec="10">Config\DnnConfiguration.cs</location>
            <body hash="b96f52b9a09d208fdc8a854824c5dc63"><![CDATA[{
            return IsBooleanSettingEnabled(MinifyJsKey);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetBooleanSetting">
          <declaration><![CDATA[private static bool? GetBooleanSetting(string dictionaryKey, string settingKey)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="118" sc="9" el="126" ec="10">Config\DnnConfiguration.cs</location>
            <body hash="2c0439f8ab9c43e3f9988c141361e623"><![CDATA[{
            var setting = GetSetting(dictionaryKey, settingKey);
            bool result;
            if (setting != null && bool.TryParse(setting, out result))
            {
                return result;
            }
            return null;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetHostSettingThroughReflection">
          <declaration><![CDATA[private static string GetHostSettingThroughReflection(string settingKey)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="212" sc="9" el="229" ec="10">Config\DnnConfiguration.cs</location>
            <body hash="27e87db711be442bc227141c8fcb1ab7"><![CDATA[{
            try
            {
                var method = _hostControllerType.GetMethod("GetSettingsDictionary");
                var property = _hostControllerType.BaseType.GetProperty("Instance", BindingFlags.Static | BindingFlags.Public);
                var instance = property.GetValue(null, Type.EmptyTypes);
                var dictionary = (Dictionary<string, string>)method.Invoke(instance, Type.EmptyTypes);
                string value;
                if (dictionary.TryGetValue(settingKey, out value))
                {
                    return value;
                }
            }
            catch (Exception)
            {
            }
            return null;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetIntegerSetting">
          <declaration><![CDATA[private static int? GetIntegerSetting(string dictionaryKey, string settingKey)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="129" sc="9" el="140" ec="10">Config\DnnConfiguration.cs</location>
            <body hash="6556ddd242c4dd19a7899400bc9676dc"><![CDATA[{
            var setting = GetSetting(dictionaryKey, settingKey);
            int version;
            if (setting != null && int.TryParse(setting, out version))
            {
                if (version > -1)
                {
                    return version;
                }
            }
            return null;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetPortalIdThroughReflection">
          <declaration><![CDATA[private static int? GetPortalIdThroughReflection()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="187" sc="9" el="209" ec="10">Config\DnnConfiguration.cs</location>
            <body hash="cc8b8aafccf0fafe7456e2ce1aadd042"><![CDATA[{
            try
            {
                var method = _portalAliasControllerType.GetMethod("GetPortalAliasInfo");
                var requestedDomainNameMethod = _commonGlobalsType.GetMethod("GetDomainName", new[] { typeof(HttpRequest) });
                if (requestedDomainNameMethod != null)
                {
                    var requestedDomainName = requestedDomainNameMethod.Invoke(null, new object[] { HttpContext.Current.Request });

                    var portalAliasInfo = method.Invoke(null, new object[] { requestedDomainName });
                    if (portalAliasInfo != null)
                    {
                        object portalId = portalAliasInfo.GetType().GetProperty("PortalID").GetValue(portalAliasInfo, new object[] { });
                        return (int)portalId;
                    }
                }
                
            }
            catch (Exception)
            {
            }
            return null;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetPortalSettingThroughReflection">
          <declaration><![CDATA[private static string GetPortalSettingThroughReflection(string settingKey)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="165" sc="9" el="184" ec="10">Config\DnnConfiguration.cs</location>
            <body hash="b34c6204b71766db388b2be5ad996208"><![CDATA[{
            try
            {
                int? portalId = GetPortalIdThroughReflection();
                if (portalId.HasValue)
                {
                    var method = _portalControllerType.GetMethod("GetPortalSettingsDictionary");
                    var dictionary = (Dictionary<string, string>)method.Invoke(null, new object[] { portalId.Value });
                    string value;
                    if (dictionary.TryGetValue(settingKey, out value))
                    {
                        return value;
                    }
                }
            }
            catch (Exception)
            {
            }
            return null;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetSetting">
          <declaration><![CDATA[private static string GetSetting(string dictionaryKey, string settingKey)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="143" sc="9" el="162" ec="10">Config\DnnConfiguration.cs</location>
            <body hash="62f82b00caa07911404a431b0478ffa8"><![CDATA[{
            var settings = HttpContext.Current.Items[dictionaryKey];
            if (settings == null)
            {
                if (dictionaryKey == HostSettingsDictionaryKey)
                    return GetHostSettingThroughReflection(settingKey);

                return GetPortalSettingThroughReflection(settingKey);
            }

            string value;
            var dictionary = (Dictionary<string, string>)settings;
            if (dictionary.TryGetValue(settingKey, out value))
            {
                return value;
            }

            // no valid setting was found
            return null;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetStatusByReflection">
          <declaration><![CDATA[private DnnConfiguration.UpgradeStatus GetStatusByReflection()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="249" sc="9" el="260" ec="10">Config\DnnConfiguration.cs</location>
            <body hash="5ccdd537bbbbe1182e4c6bd2e4378fd1"><![CDATA[{
            try
            {
                var property = _commonGlobalsType.GetProperty("Status", BindingFlags.Static | BindingFlags.Public);
                var status = (UpgradeStatus)property.GetValue(null, null);
                return status;
            }
            catch (Exception)
            {
                return UpgradeStatus.Unknown;
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="GetVersion">
          <declaration><![CDATA[public int? GetVersion()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="46" sc="9" el="62" ec="10">Config\DnnConfiguration.cs</location>
            <body hash="b31fa837895eee7671bffaf72279193a"><![CDATA[{
            var portalVersion = GetIntegerSetting(PortalSettingsDictionaryKey, VersionKey);
            var overrideDefaultSettings = GetBooleanSetting(PortalSettingsDictionaryKey, OverrideDefaultSettingsKey);

            // if portal version is set
            // and the portal "override default settings" flag is set and set to true
            if (portalVersion.HasValue && overrideDefaultSettings.HasValue && overrideDefaultSettings.Value)
                return portalVersion.Value;

            // otherwise return the host setting
            var hostVersion = GetIntegerSetting(HostSettingsDictionaryKey, VersionKey);
            if (hostVersion.HasValue)
                return hostVersion.Value;

            // otherwise tell the calling method that nothing is set
            return null;
        }]]></body>
          </codeblock>
        </method>
        <method name="IsBooleanSettingEnabled">
          <declaration><![CDATA[private bool? IsBooleanSettingEnabled(string settingKey)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="94" sc="9" el="115" ec="10">Config\DnnConfiguration.cs</location>
            <body hash="ae54d87dbc8f5c8986beef30d1c0ba04"><![CDATA[{
            if(Status != UpgradeStatus.None)
            {
                return false;
            }
            
            var portalEnabled = GetBooleanSetting(PortalSettingsDictionaryKey, settingKey);
            var overrideDefaultSettings = GetBooleanSetting(PortalSettingsDictionaryKey, OverrideDefaultSettingsKey);

            // if portal version is set
            // and the portal "override default settings" flag is set and set to true
            if (portalEnabled.HasValue && overrideDefaultSettings.HasValue && overrideDefaultSettings.Value)
                return portalEnabled.Value;

            // otherwise return the host setting
            var hostEnabled = GetBooleanSetting(HostSettingsDictionaryKey, settingKey);
            if (hostEnabled.HasValue)
                return hostEnabled.Value;

            // otherwise tell the calling method that nothing is set
            return null;
        }]]></body>
          </codeblock>
        </method>
        <method name="IsDebugMode">
          <declaration><![CDATA[public bool IsDebugMode()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="80" sc="9" el="91" ec="10">Config\DnnConfiguration.cs</location>
            <body hash="dbf2b722453813410af34d92fd274c75"><![CDATA[{
            if (Status != UpgradeStatus.None)
            {
                return true;
            }

            var hostEnabled = GetBooleanSetting(HostSettingsDictionaryKey, DebugModeKey);
            if (hostEnabled.HasValue)
                return hostEnabled.Value;

            return false;
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_commonGlobalsType">
          <declaration><![CDATA[private static readonly Type _commonGlobalsType;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_hostControllerType">
          <declaration><![CDATA[private static readonly Type _hostControllerType;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_portalAliasControllerType">
          <declaration><![CDATA[private static readonly Type _portalAliasControllerType;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_portalControllerType">
          <declaration><![CDATA[private static readonly Type _portalControllerType;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_status">
          <declaration><![CDATA[private DnnConfiguration.UpgradeStatus _status;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_statusChecked">
          <declaration><![CDATA[private bool _statusChecked;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DebugModeKey">
          <declaration><![CDATA[public static readonly string DebugModeKey;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="EnableCompositeFilesKey">
          <declaration><![CDATA[public static readonly string EnableCompositeFilesKey;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="HostSettingsDictionaryKey">
          <declaration><![CDATA[public static readonly string HostSettingsDictionaryKey;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="MinifyCssKey">
          <declaration><![CDATA[public static readonly string MinifyCssKey;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="MinifyJsKey">
          <declaration><![CDATA[public static readonly string MinifyJsKey;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="OverrideDefaultSettingsKey">
          <declaration><![CDATA[public static readonly string OverrideDefaultSettingsKey;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="PortalSettingsDictionaryKey">
          <declaration><![CDATA[public static readonly string PortalSettingsDictionaryKey;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="VersionKey">
          <declaration><![CDATA[public static readonly string VersionKey;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Status">
          <declaration><![CDATA[private DnnConfiguration.UpgradeStatus Status]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="237" sc="13" el="245" ec="14">Config\DnnConfiguration.cs</location>
            <body hash="4045ded74fcd33ac39c5b5330f96b599"><![CDATA[{
                if (!_statusChecked)
                {
                    _status = GetStatusByReflection();
                    _statusChecked = true;
                }

                return _status;
            }]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="FileRegistrationSection">
      <declaration><![CDATA[public class FileRegistrationSection : ConfigurationElement]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public FileRegistrationSection()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="DefaultProvider">
          <declaration><![CDATA[public string DefaultProvider]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="FileBasedDependencyExtensionList">
          <deprecation>Use the ClientDependencySection.FileBasedDependencyExtensionList instead</deprecation>
          <declaration><![CDATA[public IEnumerable<string> FileBasedDependencyExtensionList]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="44" sc="13" el="47" ec="14">Config\FileRegistrationSection.cs</location>
            <body hash="463b11933d48302800f4bfcf47365444"><![CDATA[{
                return FileBasedDependencyExtensions.Split(',')
                    .Select(x => x.Trim().ToUpper());
            }]]></body>
          </codeblock>
        </property>
        <property name="FileBasedDependencyExtensions">
          <deprecation>Use the ClientDependencySection.FileBasedDepdendenyExtensions instead</deprecation>
          <declaration><![CDATA[public string FileBasedDependencyExtensions]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="31" sc="13" el="33" ec="14">Config\FileRegistrationSection.cs</location>
            <body hash="beb9d5b7c8c58ad0e26aa69a99da7663"><![CDATA[{
                return (string)base["fileDependencyExtensions"];
            }]]></body>
          </codeblock>
          <codeblock>
            <location sl="35" sc="13" el="37" ec="14">Config\FileRegistrationSection.cs</location>
            <body hash="1fb7b67fc392b9b53cc9fd618460ac99"><![CDATA[{
                base["fileDependencyExtensions"] = value;
            }]]></body>
          </codeblock>
        </property>
        <property name="Providers">
          <declaration><![CDATA[public ProviderSettingsCollection Providers]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="MimeTypeCompressionCollection">
      <declaration><![CDATA[public class MimeTypeCompressionCollection : ConfigurationElementCollection]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public MimeTypeCompressionCollection()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CreateNewElement">
          <declaration><![CDATA[protected override ConfigurationElement CreateNewElement()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="22" sc="9" el="25" ec="10">Config\MimeTypeCompressionCollection.cs</location>
            <body hash="052896074678aff1527f2de749f3d7a2"><![CDATA[{
            var e = new MimeTypeCompressionElement();
            return e;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetElementKey">
          <declaration><![CDATA[protected override object GetElementKey(ConfigurationElement element)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="28" sc="9" el="30" ec="10">Config\MimeTypeCompressionCollection.cs</location>
            <body hash="fab4262ed04359d80c2b1574cbf692ed"><![CDATA[{
            return ((MimeTypeCompressionElement)element);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="ThrowOnDuplicate">
          <declaration><![CDATA[protected override bool ThrowOnDuplicate]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="16" sc="13" el="18" ec="14">Config\MimeTypeCompressionCollection.cs</location>
            <body hash="f5368e81f663038061ec388beff126aa"><![CDATA[{
                return true;
            }]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="MimeTypeCompressionElement">
      <declaration><![CDATA[public class MimeTypeCompressionElement : ConfigurationElement]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public MimeTypeCompressionElement()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Equals">
          <declaration><![CDATA[public override bool Equals(object compareTo)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="35" sc="9" el="42" ec="10">Config\MimeTypeCompressionElement.cs</location>
            <body hash="58270e6932cdfa3933e6e2d362f74a48"><![CDATA[{
            var e = compareTo as MimeTypeCompressionElement;
            if (e != null)
            {
                return (e.GetHashCode().Equals(this.GetHashCode()));
            }
            return false;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetHashCode">
          <declaration><![CDATA[public override int GetHashCode()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="30" sc="9" el="32" ec="10">Config\MimeTypeCompressionElement.cs</location>
            <body hash="d23e26137988b5b2797ed246d4c2a624"><![CDATA[{
            return (this.MimeType + this.FilePath).GetHashCode();
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="FilePath">
          <declaration><![CDATA[public string FilePath]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="24" sc="13" el="26" ec="14">Config\MimeTypeCompressionElement.cs</location>
            <body hash="c5234eeaf538453e19ed565f6ee9af99"><![CDATA[{
                return (string)this["path"];
            }]]></body>
          </codeblock>
        </property>
        <property name="MimeType">
          <declaration><![CDATA[public string MimeType]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="15" sc="13" el="17" ec="14">Config\MimeTypeCompressionElement.cs</location>
            <body hash="655ce9b0ae3c4375446579e7a943fbbf"><![CDATA[{
                return (string)this["type"];
            }]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="MvcSection">
      <declaration><![CDATA[public class MvcSection : ConfigurationElement]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public MvcSection()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="DefaultRenderer">
          <declaration><![CDATA[public string DefaultRenderer]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Renderers">
          <declaration><![CDATA[public ProviderSettingsCollection Renderers]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="RogueFileCompressionCollection">
      <declaration><![CDATA[public class RogueFileCompressionCollection : ConfigurationElementCollection]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public RogueFileCompressionCollection()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CreateNewElement">
          <declaration><![CDATA[protected override ConfigurationElement CreateNewElement()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="20" sc="9" el="23" ec="10">Config\RogueFileCompressionCollection.cs</location>
            <body hash="9192cc0dc005e6259cc1e91a001b98b8"><![CDATA[{
            var e = new RogueFileCompressionElement();
            return e;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetElementKey">
          <declaration><![CDATA[protected override object GetElementKey(ConfigurationElement element)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="26" sc="9" el="28" ec="10">Config\RogueFileCompressionCollection.cs</location>
            <body hash="c2cb782e99bd7ed6e9823ad31792fc83"><![CDATA[{
            return ((RogueFileCompressionElement)element);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="ThrowOnDuplicate">
          <declaration><![CDATA[protected override bool ThrowOnDuplicate]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="14" sc="13" el="16" ec="14">Config\RogueFileCompressionCollection.cs</location>
            <body hash="f5368e81f663038061ec388beff126aa"><![CDATA[{
                return true;
            }]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="RogueFileCompressionElement">
      <declaration><![CDATA[internal class RogueFileCompressionElement : ConfigurationElement]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public RogueFileCompressionElement()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="GetHashCode">
          <declaration><![CDATA[public override int GetHashCode()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="74" sc="9" el="76" ec="10">Config\RogueFileCompressionElement.cs</location>
            <body hash="774ccc2e1d3a5030707c38b197f04004"><![CDATA[{
            return this.FilePath.GetHashCode();
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="CompressCss">
          <declaration><![CDATA[public bool CompressCss]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="24" sc="13" el="26" ec="14">Config\RogueFileCompressionElement.cs</location>
            <body hash="79dc0fb3957f7700c073c34ee002130e"><![CDATA[{
                return (bool)this["compressCss"];
            }]]></body>
          </codeblock>
        </property>
        <property name="CompressJs">
          <declaration><![CDATA[public bool CompressJs]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="15" sc="13" el="17" ec="14">Config\RogueFileCompressionElement.cs</location>
            <body hash="795588ec97da6acade377ff4b17ad32a"><![CDATA[{
                return (bool)this["compressJs"];
            }]]></body>
          </codeblock>
        </property>
        <property name="CssRequestExtension">
          <declaration><![CDATA[public string CssRequestExtension]]></declaration>
          <documentation>
            <summary>
 a collection of file extensions that must match on the rogue file for it to
 be replaced with the composite handler
 </summary>
          </documentation>
          <codeblock>
            <location sl="59" sc="13" el="61" ec="14">Config\RogueFileCompressionElement.cs</location>
            <body hash="c580a3b7da38a53d4f9c98859fecc65d"><![CDATA[{
                return (string)this["cssExt"];
            }]]></body>
          </codeblock>
        </property>
        <property name="ExcludePaths">
          <declaration><![CDATA[public RogueFileCompressionExcludeCollection ExcludePaths]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="68" sc="13" el="70" ec="14">Config\RogueFileCompressionElement.cs</location>
            <body hash="d0cc185487a867776d5db89cbacd9237"><![CDATA[{
                return (RogueFileCompressionExcludeCollection)base["exclusions"];
            }]]></body>
          </codeblock>
        </property>
        <property name="FilePath">
          <declaration><![CDATA[public string FilePath]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="33" sc="13" el="35" ec="14">Config\RogueFileCompressionElement.cs</location>
            <body hash="c5234eeaf538453e19ed565f6ee9af99"><![CDATA[{
                return (string)this["path"];
            }]]></body>
          </codeblock>
        </property>
        <property name="JsRequestExtension">
          <declaration><![CDATA[public string JsRequestExtension]]></declaration>
          <documentation>
            <summary>
 a collection of file extensions that must match on the rogue file for it to
 be replaced with the composite handler
 </summary>
          </documentation>
          <codeblock>
            <location sl="46" sc="13" el="48" ec="14">Config\RogueFileCompressionElement.cs</location>
            <body hash="ba9f95831b9404d758c05c7b5058de76"><![CDATA[{
                return (string)this["jsExt"];
            }]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="RogueFileCompressionExcludeCollection">
      <declaration><![CDATA[public class RogueFileCompressionExcludeCollection : ConfigurationElementCollection]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public RogueFileCompressionExcludeCollection()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CreateNewElement">
          <declaration><![CDATA[protected override ConfigurationElement CreateNewElement()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="20" sc="9" el="23" ec="10">Config\RogueFileCompressionExcludeCollection.cs</location>
            <body hash="22b0c3f7f631ba85204c4f51801edf4d"><![CDATA[{
            var e = new RogueFileCompressionExcludeElement();
            return e;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetElementKey">
          <declaration><![CDATA[protected override object GetElementKey(ConfigurationElement element)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="26" sc="9" el="28" ec="10">Config\RogueFileCompressionExcludeCollection.cs</location>
            <body hash="6776940759b378c4dab22c151994e30e"><![CDATA[{
            return ((RogueFileCompressionExcludeElement)element);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="ThrowOnDuplicate">
          <declaration><![CDATA[protected override bool ThrowOnDuplicate]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="14" sc="13" el="16" ec="14">Config\RogueFileCompressionExcludeCollection.cs</location>
            <body hash="f5368e81f663038061ec388beff126aa"><![CDATA[{
                return true;
            }]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="RogueFileCompressionExcludeElement">
      <declaration><![CDATA[public class RogueFileCompressionExcludeElement : ConfigurationElement]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public RogueFileCompressionExcludeElement()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="GetHashCode">
          <declaration><![CDATA[public override int GetHashCode()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="22" sc="9" el="24" ec="10">Config\RogueFileCompressionExcludeElement.cs</location>
            <body hash="774ccc2e1d3a5030707c38b197f04004"><![CDATA[{
            return this.FilePath.GetHashCode();
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="FilePath">
          <declaration><![CDATA[public string FilePath]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="16" sc="13" el="18" ec="14">Config\RogueFileCompressionExcludeElement.cs</location>
            <body hash="c5234eeaf538453e19ed565f6ee9af99"><![CDATA[{
                return (string)this["path"];
            }]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="ClientDependency.Core.Controls">
    <class name="ClientDependencyInclude">
      <declaration><![CDATA[public abstract class ClientDependencyInclude : Control, IClientDependencyFile, IRequiresHtmlAttributesParsing, IHaveHtmlAttributes]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[protected ClientDependencyInclude()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="10" sc="9" el="19" ec="10">Controls\ClientDependencyInclude.cs</location>
            <body hash="79196b67f7f6495332fd144c13c871cd"><![CDATA[protected ClientDependencyInclude()
        {
            Priority = Constants.DefaultPriority;
            Group = Constants.DefaultGroup;
            PathNameAlias = "";
            HtmlAttributes = new Dictionary<string, string>();
            AddTag = true;
            Name = "";
            Version = "";
        }]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[protected ClientDependencyInclude(IClientDependencyFile file)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="21" sc="9" el="33" ec="10">Controls\ClientDependencyInclude.cs</location>
            <body hash="8c64157098e1b6b114b55b0c987c874b"><![CDATA[protected ClientDependencyInclude(IClientDependencyFile file)
        {
            Priority = file.Priority;
            PathNameAlias = file.PathNameAlias;
            FilePath = file.FilePath;
            DependencyType = file.DependencyType;
            Group = file.Group;
            HtmlAttributes = new Dictionary<string, string>();
            AddTag = true;
            Name = "";
            Version = "";
            ForceVersion = false;
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Equals">
          <declaration><![CDATA[protected bool Equals(ClientDependencyInclude other)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="89" sc="9" el="91" ec="10">Controls\ClientDependencyInclude.cs</location>
            <body hash="a6023baaf1caa9a2a898282ab4c29378"><![CDATA[{
            return string.Equals(FilePath, other.FilePath, StringComparison.InvariantCultureIgnoreCase) && DependencyType == other.DependencyType && Priority == other.Priority && Group == other.Group && string.Equals(PathNameAlias, other.PathNameAlias, StringComparison.InvariantCultureIgnoreCase) && string.Equals(ForceProvider, other.ForceProvider) && Equals(HtmlAttributes, other.HtmlAttributes);
        }]]></body>
          </codeblock>
        </method>
        <method name="Equals">
          <declaration><![CDATA[public override bool Equals(object obj)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="94" sc="9" el="99" ec="10">Controls\ClientDependencyInclude.cs</location>
            <body hash="3ad363df12402fb848d53ffdc2d0e064"><![CDATA[{
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            if (obj.GetType() != this.GetType()) return false;
            return Equals((ClientDependencyInclude)obj);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetHashCode">
          <declaration><![CDATA[public override int GetHashCode()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="102" sc="9" el="114" ec="10">Controls\ClientDependencyInclude.cs</location>
            <body hash="4ffa17b75293b3c09efe53bb1ce94895"><![CDATA[{
            unchecked
            {
                int hashCode = (FilePath != null ? FilePath.GetHashCode() : 0);
                hashCode = (hashCode * 397) ^ (int)DependencyType;
                hashCode = (hashCode * 397) ^ Priority;
                hashCode = (hashCode * 397) ^ Group;
                hashCode = (hashCode * 397) ^ (PathNameAlias != null ? PathNameAlias.GetHashCode() : 0);
                hashCode = (hashCode * 397) ^ (ForceProvider != null ? ForceProvider.GetHashCode() : 0);
                hashCode = (hashCode * 397) ^ (HtmlAttributes != null ? HtmlAttributes.GetHashCode() : 0);
                return hashCode;
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="OnPreRender">
          <declaration><![CDATA[protected override void OnPreRender(EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="70" sc="9" el="76" ec="10">Controls\ClientDependencyInclude.cs</location>
            <body hash="50d06374336ecec6e1ee815109d9eed0"><![CDATA[{
            base.OnPreRender(e);
            if (string.IsNullOrEmpty(FilePath))
            {
                throw new NullReferenceException("Both File and Type properties must be set");
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="Render">
          <declaration><![CDATA[protected override void Render(HtmlTextWriter writer)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="79" sc="9" el="86" ec="10">Controls\ClientDependencyInclude.cs</location>
            <body hash="cd6705b3fbee6cd1e5cc08b62b750235"><![CDATA[{
            if (AddTag || this.Context.IsDebuggingEnabled)
            {
                writer.Write("<!--CDF({0}|{1})-->", DependencyType, FilePath);
            }

            base.Render(writer);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="AddTag">
          <declaration><![CDATA[public bool AddTag]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="41" sc="30" el="41" ec="34">Controls\ClientDependencyInclude.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="41" sc="35" el="41" ec="39">Controls\ClientDependencyInclude.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="DependencyType">
          <declaration><![CDATA[public ClientDependencyType DependencyType]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="35" sc="54" el="35" ec="58">Controls\ClientDependencyInclude.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="35" sc="59" el="35" ec="72">Controls\ClientDependencyInclude.cs</location>
            <body hash="547cefb3c0c83e070f9d7cd0975f10de"><![CDATA[internal set]]></body>
          </codeblock>
        </property>
        <property name="FilePath">
          <declaration><![CDATA[public string FilePath]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="37" sc="34" el="37" ec="38">Controls\ClientDependencyInclude.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="37" sc="39" el="37" ec="43">Controls\ClientDependencyInclude.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ForceBundle">
          <declaration><![CDATA[public bool ForceBundle]]></declaration>
          <documentation>
            <summary>
 If the resources is an external resource then normally it will be rendered as it's own download unless
 this is set to true. In that case the system will download the external resource and include it in the local bundle.
 </summary>
          </documentation>
          <codeblock>
            <location sl="59" sc="35" el="59" ec="39">Controls\ClientDependencyInclude.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="59" sc="40" el="59" ec="44">Controls\ClientDependencyInclude.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ForceProvider">
          <declaration><![CDATA[public string ForceProvider]]></declaration>
          <documentation>
            <summary>This can be empty and will use default provider</summary>
          </documentation>
          <codeblock>
            <location sl="53" sc="39" el="53" ec="43">Controls\ClientDependencyInclude.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="53" sc="44" el="53" ec="48">Controls\ClientDependencyInclude.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ForceVersion">
          <declaration><![CDATA[public bool ForceVersion]]></declaration>
          <documentation>
            <summary>Force this version to be used. Meant for skin designers that wish to override choices made by module developers or the framework.</summary>
          </documentation>
          <codeblock>
            <location sl="50" sc="36" el="50" ec="40">Controls\ClientDependencyInclude.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="50" sc="41" el="50" ec="45">Controls\ClientDependencyInclude.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Group">
          <declaration><![CDATA[public int Group]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="40" sc="28" el="40" ec="32">Controls\ClientDependencyInclude.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="40" sc="33" el="40" ec="37">Controls\ClientDependencyInclude.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="HtmlAttributes">
          <declaration><![CDATA[public IDictionary<string, string> HtmlAttributes]]></declaration>
          <documentation>
            <summary>Used to store additional attributes in the HTML markup for the item</summary>
 <remarks>Mostly used for CSS Media, but could be for anything</remarks></documentation>
          <codeblock>
            <location sl="63" sc="61" el="63" ec="65">Controls\ClientDependencyInclude.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="63" sc="66" el="63" ec="78">Controls\ClientDependencyInclude.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
        <property name="HtmlAttributesAsString">
          <declaration><![CDATA[public string HtmlAttributesAsString]]></declaration>
          <documentation>
            <summary>Used to set the HtmlAttributes on this class via a string which is parsed</summary>
 <remarks>The syntax for the string must be: <c>key1:value1,key2:value2</c> etc.</remarks></documentation>
          <codeblock>
            <location sl="67" sc="48" el="67" ec="52">Controls\ClientDependencyInclude.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="67" sc="53" el="67" ec="57">Controls\ClientDependencyInclude.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Name">
          <declaration><![CDATA[public string Name]]></declaration>
          <documentation>
            <summary>Name of the script (e.g. <c>jQuery</c>, <c>Bootstrap</c>, <c>Angular</c>, etc.</summary>
          </documentation>
          <codeblock>
            <location sl="44" sc="30" el="44" ec="34">Controls\ClientDependencyInclude.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="44" sc="35" el="44" ec="39">Controls\ClientDependencyInclude.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="PathNameAlias">
          <declaration><![CDATA[public string PathNameAlias]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="38" sc="39" el="38" ec="43">Controls\ClientDependencyInclude.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="38" sc="44" el="38" ec="48">Controls\ClientDependencyInclude.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Priority">
          <declaration><![CDATA[public int Priority]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="39" sc="31" el="39" ec="35">Controls\ClientDependencyInclude.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="39" sc="36" el="39" ec="40">Controls\ClientDependencyInclude.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Version">
          <declaration><![CDATA[public string Version]]></declaration>
          <documentation>
            <summary>Version of this resource if it is a named resources. Note this field is only used when <see cref="P:ClientDependency.Core.Controls.ClientDependencyInclude.Name" /> is specified</summary>
          </documentation>
          <codeblock>
            <location sl="47" sc="33" el="47" ec="37">Controls\ClientDependencyInclude.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="47" sc="38" el="47" ec="42">Controls\ClientDependencyInclude.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ClientDependencyLoader">
      <declaration><![CDATA[public class ClientDependencyLoader : Control]]></declaration>
      <documentation>
        <summary>
 This is the master control for loading in dependencies in web forms
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ClientDependencyLoader()]]></declaration>
          <documentation>
            <summary>
 Constructor sets the defaults.
 </summary>
          </documentation>
          <codeblock>
            <location sl="22" sc="3" el="31" ec="4">Controls\ClientDependencyLoader.cs</location>
            <body hash="a4084eb72465b0e0eca826d48b6d3744"><![CDATA[public ClientDependencyLoader()
		{
			Paths = new ClientDependencyPathCollection();

		    _base = new BaseLoader(new HttpContextWrapper(Context))
		                 {
                             //by default the provider is the default provider 
		                     Provider = ClientDependencySettings.Instance.DefaultFileRegistrationProvider
		                 };
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static ClientDependencyLoader()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="69" sc="9" el="69" ec="62">Controls\ClientDependencyLoader.cs</location>
            <body hash="051d266d9463c94476d91f447315bb9f"><![CDATA[private static readonly object Locker = new object()]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AddPath">
          <declaration><![CDATA[public ClientDependencyLoader AddPath(string pathNameAlias, string path)]]></declaration>
          <documentation>
            <summary>
 Adds a path to the current loader
 </summary>
 <param name="pathNameAlias"></param>
 <param name="path"></param></documentation>
          <codeblock>
            <location sl="269" sc="3" el="272" ec="4">Controls\ClientDependencyLoader.cs</location>
            <body hash="21a050b8ee5c2f0812bbe5895f3c3a89"><![CDATA[{
		    _base.AddPath(pathNameAlias, path);
			return this;
		}]]></body>
          </codeblock>
        </method>
        <method name="AddPath">
          <declaration><![CDATA[public ClientDependencyLoader AddPath(IClientDependencyPath path)]]></declaration>
          <documentation>
            <summary>
 Adds a path to the current loader
 </summary>
 <param name="path"></param></documentation>
          <codeblock>
            <location sl="279" sc="6" el="282" ec="7">Controls\ClientDependencyLoader.cs</location>
            <body hash="b8853e8488119d474de4cd575bca3049"><![CDATA[{
	        _base.AddPath(path);
	        return this;
	    }]]></body>
          </codeblock>
        </method>
        <method name="CreateChildControls">
          <declaration><![CDATA[protected override void CreateChildControls()]]></declaration>
          <documentation>
            <summary>
 Need to set the container for each of the paths to support databinding.
 </summary>
          </documentation>
          <codeblock>
            <location sl="108" sc="3" el="114" ec="4">Controls\ClientDependencyLoader.cs</location>
            <body hash="c0e9aec8f5290890a9966e9bb374bdc7"><![CDATA[{
			base.CreateChildControls();
			foreach (var path in Paths)
			{
				path.Parent = this;
			}	
		}]]></body>
          </codeblock>
        </method>
        <method name="FindDependencies">
          <declaration><![CDATA[private static IEnumerable<IClientDependencyFile> FindDependencies(Control control)]]></declaration>
          <documentation>
            <summary>
 Find all dependencies of this control and it's entire child control heirarchy.
 </summary>
 <param name="control"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="333" sc="3" el="358" ec="4">Controls\ClientDependencyLoader.cs</location>
            <body hash="398d6cd9162388df4c01eeb5b71a8e83"><![CDATA[{
            var ctls = new List<Control>(control.FlattenChildren()) { control };

		    var dependencies = new List<IClientDependencyFile>();
			
            // add child dependencies
			var iClientDependency = typeof(IClientDependencyFile);
            foreach (var ctl in ctls)
			{
       //         // find dependencies
       //         var controlType = ctl.GetType();

	   //         dependencies.AddRange(Attribute.GetCustomAttributes(controlType)
       //             .OfType<ClientDependencyAttribute>()
       //             .Cast<IClientDependencyFile>());

			    if (iClientDependency.IsInstanceOfType(ctl))
                {
                    var include = (IClientDependencyFile)ctl;
                    dependencies.Add(include);
                }
                
			}

			return dependencies;
		}]]></body>
          </codeblock>
        </method>
        <method name="GetInstance">
          <declaration><![CDATA[public static ClientDependencyLoader GetInstance(HttpContextBase ctx)]]></declaration>
          <documentation>
            <summary>
 Singleton per request instance.
 </summary>
 <exception cref="T:System.NullReferenceException">
 If no ClientDependencyLoader control exists on the current page, an exception is thrown.
 </exception></documentation>
          <codeblock>
            <location sl="96" sc="3" el="100" ec="4">Controls\ClientDependencyLoader.cs</location>
            <body hash="e1e14abb1db0cd086e66f7a12b92a7d2"><![CDATA[{
            if (!ctx.Items.Contains(ContextKey))
				return null;
            return ctx.Items[ContextKey] as ClientDependencyLoader;
		}]]></body>
          </codeblock>
        </method>
        <method name="OnDataBinding">
          <declaration><![CDATA[protected override void OnDataBinding(EventArgs e)]]></declaration>
          <documentation>
            <summary>
 Need to bind all children paths.
 </summary>
 <param name="e"></param></documentation>
          <codeblock>
            <location sl="121" sc="3" el="127" ec="4">Controls\ClientDependencyLoader.cs</location>
            <body hash="9fc015dde17a0f36249780acbba274d1"><![CDATA[{
			base.OnDataBinding(e);
			foreach (var path in Paths)
			{
				path.DataBind();
			}				
		}]]></body>
          </codeblock>
        </method>
        <method name="OnInit">
          <declaration><![CDATA[protected override void OnInit(EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="34" sc="9" el="64" ec="10">Controls\ClientDependencyLoader.cs</location>
            <body hash="f0694cf68710ee2b74b2b0dd44b6a2cc"><![CDATA[{
            base.OnInit(e);

            //add this object to the context and validate the context type
            if (Context != null)
            {
                if (!Context.Items.Contains(ContextKey))
                {
                    lock (Locker)
                    {
                        if (!Context.Items.Contains(ContextKey))
                        {
                            //The context needs to be a page
                            var page = Context.Handler as Page;
                            if (page == null)
                                throw new InvalidOperationException("ClientDependencyLoader only works with Page based handlers.");
                            Context.Items[ContextKey] = this;
                        }                        
                    }                    
                }
                else
                {
                    if (Context.Items[ContextKey] != this)
                    {
                        throw new InvalidOperationException("Only one ClientDependencyLoader may exist on a page");    
                    }
                }                               
            }
            else
                throw new InvalidOperationException("ClientDependencyLoader requires an HttpContext");
        }]]></body>
          </codeblock>
        </method>
        <method name="OnPreRender">
          <declaration><![CDATA[protected override void OnPreRender(EventArgs e)]]></declaration>
          <documentation>
            <summary>
 Finds all dependencies on the page and renders them
 </summary>
 <param name="e"></param></documentation>
          <codeblock>
            <location sl="134" sc="3" el="141" ec="4">Controls\ClientDependencyLoader.cs</location>
            <body hash="26770a24157b69ef32446dff2631a79c"><![CDATA[{
			base.OnPreRender(e);

            _base.Paths.UnionWith(Paths);

            RegisterClientDependencies((WebFormsFileRegistrationProvider)_base.Provider, Page, _base.Paths);
			RenderDependencies();
		}]]></body>
          </codeblock>
        </method>
        <method name="RegisterClientDependencies">
          <declaration><![CDATA[public void RegisterClientDependencies(Control control, ClientDependencyPathCollection paths)]]></declaration>
          <documentation>
            <summary>
 Registers dependencies
 </summary>
 <param name="control"></param>
 <param name="paths"></param></documentation>
          <codeblock>
            <location sl="290" sc="3" el="292" ec="4">Controls\ClientDependencyLoader.cs</location>
            <body hash="787c2a5cccaeb387d9072ed3d8ea098f"><![CDATA[{
            RegisterClientDependencies((WebFormsFileRegistrationProvider)_base.Provider, control, paths.Cast<IClientDependencyPath>());
		}]]></body>
          </codeblock>
        </method>
        <method name="RegisterClientDependencies">
          <declaration><![CDATA[public void RegisterClientDependencies(string providerName, Control control, IEnumerable<IClientDependencyPath> paths)]]></declaration>
          <documentation>
            <summary>
 Registers dependencies with the provider name specified
 </summary>
 <param name="providerName"></param>
 <param name="control"></param>
 <param name="paths"></param></documentation>
          <codeblock>
            <location sl="301" sc="3" el="303" ec="4">Controls\ClientDependencyLoader.cs</location>
            <body hash="7959659e2411c0ed85be9d9c6e4f29fd"><![CDATA[{
			RegisterClientDependencies(ClientDependencySettings.Instance.FileRegistrationProviderCollection[providerName], control, paths);
		}]]></body>
          </codeblock>
        </method>
        <method name="RegisterClientDependencies">
          <declaration><![CDATA[public void RegisterClientDependencies<T>(Control control, List<IClientDependencyPath> paths) where T : WebFormsFileRegistrationProvider]]></declaration>
          <documentation>
            <summary>
 Registers dependencies with the provider specified by T
 </summary>
          </documentation>
          <codeblock>
            <location sl="310" sc="3" el="319" ec="4">Controls\ClientDependencyLoader.cs</location>
            <body hash="e9943f66568772e023f197d485b43d01"><![CDATA[{
			//need to find the provider with the type
			var found = ClientDependencySettings.Instance.FileRegistrationProviderCollection
                .Cast<WebFormsFileRegistrationProvider>()
                .FirstOrDefault(p => p.GetType().Equals(typeof (T)));
		    if (found == null)
				throw new ArgumentException("Could not find the ClientDependencyProvider specified by T");

			RegisterClientDependencies(found, control, paths);
		}]]></body>
          </codeblock>
        </method>
        <method name="RegisterClientDependencies">
          <declaration><![CDATA[public void RegisterClientDependencies(WebFormsFileRegistrationProvider provider, Control control, IEnumerable<IClientDependencyPath> paths)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="322" sc="3" el="325" ec="4">Controls\ClientDependencyLoader.cs</location>
            <body hash="6889a43ba47fd6e05a747b7805172566"><![CDATA[{
            var dependencies = FindDependencies(control);
            _base.RegisterClientDependencies(provider, dependencies, paths, ClientDependencySettings.Instance.FileRegistrationProviderCollection);
		}]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependency">
          <declaration><![CDATA[public ClientDependencyLoader RegisterDependency(string filePath, ClientDependencyType type)]]></declaration>
          <documentation>
            <summary>
 Registers a file dependency
 </summary>
 <param name="filePath"></param>
 <param name="type"></param></documentation>
          <codeblock>
            <location sl="184" sc="3" el="187" ec="4">Controls\ClientDependencyLoader.cs</location>
            <body hash="ba9e6b3473f3f99110ffa3e821117f3a"><![CDATA[{
            _base.RegisterDependency(filePath, type);
			return this;
		}]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependency">
          <declaration><![CDATA[public ClientDependencyLoader RegisterDependency(int priority, string filePath, ClientDependencyType type)]]></declaration>
          <documentation>
            <summary>
 Registers a file dependency
 </summary>
          </documentation>
          <codeblock>
            <location sl="193" sc="9" el="196" ec="10">Controls\ClientDependencyLoader.cs</location>
            <body hash="73bd09d513da8d3baf4eb888a6cf16bb"><![CDATA[{
            _base.RegisterDependency(priority, filePath, type);
            return this;
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependency">
          <declaration><![CDATA[public ClientDependencyLoader RegisterDependency(int group, int priority, string filePath, ClientDependencyType type)]]></declaration>
          <documentation>
            <summary>
 Registers a file dependency
 </summary>
          </documentation>
          <codeblock>
            <location sl="202" sc="3" el="205" ec="4">Controls\ClientDependencyLoader.cs</location>
            <body hash="7f91aa52ea752de822efa184af760ace"><![CDATA[{
			_base.RegisterDependency(group, priority, filePath, type);
			return this;
		}]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependency">
          <declaration><![CDATA[public ClientDependencyLoader RegisterDependency(int priority, string filePath, string pathNameAlias, ClientDependencyType type)]]></declaration>
          <documentation>
            <summary>
 Registers a file dependency
 </summary>
          </documentation>
          <codeblock>
            <location sl="211" sc="9" el="214" ec="10">Controls\ClientDependencyLoader.cs</location>
            <body hash="bd614ce9b01ee86131b8f12047c9e443"><![CDATA[{
            _base.RegisterDependency(priority, filePath, pathNameAlias, type);
            return this;
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependency">
          <declaration><![CDATA[public ClientDependencyLoader RegisterDependency(int group, int priority, string filePath, string pathNameAlias, ClientDependencyType type)]]></declaration>
          <documentation>
            <summary>
 Registers a file dependency
 </summary>
          </documentation>
          <codeblock>
            <location sl="220" sc="3" el="223" ec="4">Controls\ClientDependencyLoader.cs</location>
            <body hash="2156f6cd87e4009ee7c7b96a32274562"><![CDATA[{
			_base.RegisterDependency(group, priority, filePath, pathNameAlias, type);
			return this;
		}]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependency">
          <declaration><![CDATA[public ClientDependencyLoader RegisterDependency(int group, int priority, string filePath, string pathNameAlias, ClientDependencyType type, string provider)]]></declaration>
          <documentation>
            <summary>
 Registers a file dependency
 </summary>
          </documentation>
          <codeblock>
            <location sl="229" sc="3" el="232" ec="4">Controls\ClientDependencyLoader.cs</location>
            <body hash="bf895b29f1aa9b96451f40a6c0cfaa2b"><![CDATA[{
			_base.RegisterDependency(group, priority, filePath, pathNameAlias, type, provider);
			return this;
		}]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependency">
          <declaration><![CDATA[public ClientDependencyLoader RegisterDependency(int group, int priority, string filePath, string pathNameAlias, ClientDependencyType type, object htmlAttributes, string provider)]]></declaration>
          <documentation>
            <summary>
 Registers a file dependency
 </summary>
 <param name="group"></param>
 <param name="priority"></param>
 <param name="filePath"></param>
 <param name="pathNameAlias"></param>
 <param name="type"></param>
 <param name="htmlAttributes"></param>
 <param name="provider"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="246" sc="9" el="249" ec="10">Controls\ClientDependencyLoader.cs</location>
            <body hash="6a4a585804fc69dab3ec96667fde6f9b"><![CDATA[{
            _base.RegisterDependency(group, priority, filePath, pathNameAlias, type, htmlAttributes, provider);
            return this;
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependency">
          <declaration><![CDATA[public ClientDependencyLoader RegisterDependency(string filePath, string pathNameAlias, ClientDependencyType type)]]></declaration>
          <documentation>
            <summary>
 Registers a file dependency
 </summary>
 <param name="filePath"></param>
 <param name="pathNameAlias"></param>
 <param name="type"></param></documentation>
          <codeblock>
            <location sl="258" sc="3" el="261" ec="4">Controls\ClientDependencyLoader.cs</location>
            <body hash="f9e98fec9babecabaf83e1d89c417b54"><![CDATA[{
            _base.RegisterDependency(Constants.DefaultGroup, Constants.DefaultPriority, filePath, pathNameAlias, type);
			return this;
		}]]></body>
          </codeblock>
        </method>
        <method name="RenderDependencies">
          <declaration><![CDATA[private void RenderDependencies()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="144" sc="3" el="147" ec="4">Controls\ClientDependencyLoader.cs</location>
            <body hash="7c3f829b32c3eb49b22bb9b51e9a36ef"><![CDATA[{
            _base.Dependencies.ForEach(x => ((WebFormsFileRegistrationProvider)x.Provider)
                                                   .RegisterDependencies(Page, x.Dependencies, _base.Paths, new HttpContextWrapper(Context)));
		}]]></body>
          </codeblock>
        </method>
        <method name="TryCreate">
          <declaration><![CDATA[public static ClientDependencyLoader TryCreate(Control parent, HttpContextBase http, out bool isNew)]]></declaration>
          <documentation>
            <summary>
 Checks if a loader already exists, if it does, it returns it, otherwise it will
 create a new one in the control specified.
 isNew will be true if a loader was created, otherwise false if it already existed.
 </summary>
 <param name="parent"></param>
 <param name="http"></param>
 <param name="isNew"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="164" sc="3" el="174" ec="4">Controls\ClientDependencyLoader.cs</location>
            <body hash="2f53d1379105d21723bfa445a45fa69c"><![CDATA[{
            if (GetInstance(http) == null)
			{
				var loader = new ClientDependencyLoader();
				parent.Controls.Add(loader);
				isNew = true;
				return loader;
			}
	        isNew = false;
            return GetInstance(http);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_base">
          <declaration><![CDATA[private readonly BaseLoader _base;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ContextKey">
          <declaration><![CDATA[public const string ContextKey = "ClientDependencyLoader";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Locker">
          <declaration><![CDATA[private static readonly object Locker = new object();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="Instance">
          <deprecation>Use the GetInstance() method instead to pass in an HttpContext object</deprecation>
          <declaration><![CDATA[public static ClientDependencyLoader Instance]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Paths">
          <declaration><![CDATA[public ClientDependencyPathCollection Paths]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="150" sc="49" el="150" ec="53">Controls\ClientDependencyLoader.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="150" sc="54" el="150" ec="66">Controls\ClientDependencyLoader.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
        <property name="ProviderName">
          <declaration><![CDATA[public string ProviderName]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="74" sc="13" el="76" ec="14">Controls\ClientDependencyLoader.cs</location>
            <body hash="54c9826f08c61757e5bbcf95e303557d"><![CDATA[{
                return _base.Provider.Name;
            }]]></body>
          </codeblock>
          <codeblock>
            <location sl="78" sc="13" el="80" ec="14">Controls\ClientDependencyLoader.cs</location>
            <body hash="1be9422c38a982ff950a7c02a69861dd"><![CDATA[{
                _base.Provider = ClientDependencySettings.Instance.FileRegistrationProviderCollection[value];
            }]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ClientDependencyPath">
      <declaration><![CDATA[public class ClientDependencyPath : IClientDependencyPath]]></declaration>
      <documentation>
        <summary>
 A path object for the client dependency loader. Used to specify all of the base paths (name and path) to
 be used with the client dependencies.
 Databinding support has been enabled.
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private string _name = "";]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="17" sc="3" el="18" ec="21">Controls\ClientDependencyPath.cs</location>
            <body hash="040b608deb973ad5cc1407462e65b084"><![CDATA[string _name = "";
		string _path = "";]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="add_DataBinding">
          <declaration><![CDATA[public void add_DataBinding(EventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="DataBind">
          <declaration><![CDATA[public void DataBind()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="28" sc="3" el="30" ec="4">Controls\ClientDependencyPath.cs</location>
            <body hash="9efa2947e397eb1dec4822a333d7da44"><![CDATA[{
			OnDataBinding(new EventArgs());
		}]]></body>
          </codeblock>
        </method>
        <method name="Equals">
          <declaration><![CDATA[protected bool Equals(ClientDependencyPath other)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="61" sc="9" el="64" ec="10">Controls\ClientDependencyPath.cs</location>
            <body hash="f6a3becd475a6cab8d0a28919eb3d193"><![CDATA[{
            return string.Equals(_name, other._name, StringComparison.InvariantCultureIgnoreCase)
                   && string.Equals(_path, other._path, StringComparison.InvariantCultureIgnoreCase);
        }]]></body>
          </codeblock>
        </method>
        <method name="Equals">
          <declaration><![CDATA[public override bool Equals(object obj)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="67" sc="6" el="72" ec="7">Controls\ClientDependencyPath.cs</location>
            <body hash="01fd462ab28dd5df6b1550ec945e79be"><![CDATA[{
	        if (ReferenceEquals(null, obj)) return false;
	        if (ReferenceEquals(this, obj)) return true;
	        if (obj.GetType() != this.GetType()) return false;
	        return Equals((ClientDependencyPath) obj);
	    }]]></body>
          </codeblock>
        </method>
        <method name="GetHashCode">
          <declaration><![CDATA[public override int GetHashCode()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="75" sc="6" el="80" ec="7">Controls\ClientDependencyPath.cs</location>
            <body hash="6d55e973d04c14185f963f6146e245ee"><![CDATA[{
	        unchecked
	        {
	            return ((_name != null ? _name.GetHashCode() : 0)*397) ^ (_path != null ? _path.GetHashCode() : 0);
	        }
	    }]]></body>
          </codeblock>
        </method>
        <method name="OnDataBinding">
          <declaration><![CDATA[protected void OnDataBinding(EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="32" sc="3" el="35" ec="4">Controls\ClientDependencyPath.cs</location>
            <body hash="9726b76b802880daa15e15bd032ae3ad"><![CDATA[{
			if (DataBinding != null)
				DataBinding(this, e);
		}]]></body>
          </codeblock>
        </method>
        <method name="remove_DataBinding">
          <declaration><![CDATA[public void remove_DataBinding(EventHandler value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_name">
          <declaration><![CDATA[private string _name = "";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_path">
          <declaration><![CDATA[private string _path = "";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DataBinding">
          <declaration><![CDATA[private EventHandler DataBinding;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="BindingContainer">
          <declaration><![CDATA[public Control BindingContainer]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="39" sc="4" el="41" ec="5">Controls\ClientDependencyPath.cs</location>
            <body hash="17dc7f48449c4d375e05ab8c82b0cdec"><![CDATA[{
				return Parent;
			}]]></body>
          </codeblock>
        </property>
        <property name="ForceBundle">
          <declaration><![CDATA[public bool ForceBundle]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="23" sc="29" el="23" ec="33">Controls\ClientDependencyPath.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="23" sc="34" el="23" ec="38">Controls\ClientDependencyPath.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Name">
          <declaration><![CDATA[public string Name]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="Parent">
          <declaration><![CDATA[public ClientDependencyLoader Parent]]></declaration>
          <documentation>
            <summary>
 This is set at runtime to set the load for this path object. this is required for databinding.
 </summary>
          </documentation>
          <codeblock>
            <location sl="48" sc="42" el="48" ec="46">Controls\ClientDependencyPath.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="48" sc="47" el="48" ec="60">Controls\ClientDependencyPath.cs</location>
            <body hash="547cefb3c0c83e070f9d7cd0975f10de"><![CDATA[internal set]]></body>
          </codeblock>
        </property>
        <property name="Path">
          <declaration><![CDATA[public string Path]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="ResolvedPath">
          <declaration><![CDATA[public string ResolvedPath]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="53" sc="4" el="57" ec="5">Controls\ClientDependencyPath.cs</location>
            <body hash="77fce81161b3e4714fab26c87c05472a"><![CDATA[{
				if (string.IsNullOrEmpty(Path))
					throw new ArgumentNullException("Path has not been set");
				return Parent.ResolveUrl(Path);
			}]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
        <event name="DataBinding">
          <declaration><![CDATA[public event EventHandler DataBinding;]]></declaration>
          <documentation>
          </documentation>
        </event>
      </events>
    </class>
    <class name="ClientDependencyPathCollection">
      <declaration><![CDATA[public class ClientDependencyPathCollection : List<ClientDependencyPath>]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ClientDependencyPathCollection()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="CssFolderInclude">
      <declaration><![CDATA[public class CssFolderInclude : DependencyFolderInclude]]></declaration>
      <documentation>
        <summary>
 A control used to specify a Css folder dependency
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public CssFolderInclude()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="10" sc="37" el="13" ec="10">Controls\CssFolderInclude.cs</location>
            <body hash="c7d0603238c99bbca0153b63149e02cf"><![CDATA[base()
        {
            FileSearchPattern = SearchPattern;
        }]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public CssFolderInclude(string folderVirtualPath) : base(folderVirtualPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="15" sc="61" el="18" ec="10">Controls\CssFolderInclude.cs</location>
            <body hash="725b7dd2bdb84ff6dca1e93c5346ebbc"><![CDATA[base(folderVirtualPath)
        {
            FileSearchPattern = SearchPattern;         
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="SearchPattern">
          <declaration><![CDATA[private const string SearchPattern = "*.css";]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="DependencyType">
          <declaration><![CDATA[protected override ClientDependencyType DependencyType]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="CssInclude">
      <declaration><![CDATA[public class CssInclude : ClientDependencyInclude]]></declaration>
      <documentation>
        <summary>
 A control used to add a Css file dependency
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public CssInclude()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="15" sc="3" el="19" ec="4">Controls\CssInclude.cs</location>
            <body hash="4d4c0f7d9cec89aa79a081f9a014a160"><![CDATA[public CssInclude()
		{
			DependencyType = ClientDependencyType.Css;
		    CssMedia = CssMediaType.All;
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public CssInclude(IClientDependencyFile file) : base(file)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="21" sc="6" el="25" ec="4">Controls\CssInclude.cs</location>
            <body hash="53ab5dd42bcb3df6d4506ce506513e5d"><![CDATA[base(file)
		{
			DependencyType = ClientDependencyType.Css;
            CssMedia = CssMediaType.All;
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public CssInclude(IClientDependencyFile file, CssMediaType mediaType) : base(file)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="27" sc="15" el="31" ec="10">Controls\CssInclude.cs</location>
            <body hash="c652415e5c3a848ea1c3192fb7816aa8"><![CDATA[base(file)
        {
            DependencyType = ClientDependencyType.Css;
            CssMedia = mediaType;
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="_cssMedia">
          <declaration><![CDATA[private CssMediaType _cssMedia;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="CssMedia">
          <declaration><![CDATA[public CssMediaType CssMedia]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="37" sc="13" el="45" ec="14">Controls\CssInclude.cs</location>
            <body hash="24135485347b8045f4db28d23316ecd0"><![CDATA[{
                if (value != CssMediaType.All)
                {
                    HtmlAttributes.Remove("media");
                    HtmlAttributes.Remove("Media");
                    HtmlAttributes["media"] = value.ToString().ToLowerInvariant();
                }
                _cssMedia = value;
            }]]></body>
          </codeblock>
        </property>
        <property name="EncodeImages">
          <declaration><![CDATA[internal bool EncodeImages]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="13" sc="35" el="13" ec="39">Controls\CssInclude.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="13" sc="40" el="13" ec="44">Controls\CssInclude.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="DependencyFolderInclude">
      <declaration><![CDATA[public abstract class DependencyFolderInclude : Control]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[protected DependencyFolderInclude()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="9" sc="9" el="12" ec="10">Controls\DependencyFolderInclude.cs</location>
            <body hash="6880bcf2e24c619303746d8b425e6e3a"><![CDATA[protected DependencyFolderInclude()
        {
            
        }]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[protected DependencyFolderInclude(string folderVirtualPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="14" sc="9" el="18" ec="10">Controls\DependencyFolderInclude.cs</location>
            <body hash="ba5da35b74b33c8911ea2c9d4bf901d8"><![CDATA[protected DependencyFolderInclude(string folderVirtualPath)
        {            
            if (folderVirtualPath == null) throw new ArgumentNullException("folderVirtualPath");
            FolderVirtualPath = folderVirtualPath;
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="OnLoad">
          <declaration><![CDATA[protected override void OnLoad(EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="41" sc="9" el="66" ec="10">Controls\DependencyFolderInclude.cs</location>
            <body hash="ef32a3677917c9fc6187bc46cf392f32"><![CDATA[{
            base.OnLoad(e);

            //create CssInclude controls for each file found
            var systemRootPath = Context.Server.MapPath("~/");
            var folderMappedPath = Context.Server.MapPath(FolderVirtualPath);

            if (folderMappedPath.StartsWith(systemRootPath))
            {
                var files = Directory.GetFiles(folderMappedPath, FileSearchPattern, SearchOption.TopDirectoryOnly);
                foreach (var file in files)
                {
                    var absoluteFilePath = "~/" + file.Substring(systemRootPath.Length).Replace("\\", "/");

                    Controls.Add(new CssInclude()
                        {
                            Priority = Priority,
                            FilePath = absoluteFilePath,
                            DependencyType = DependencyType,
                            ForceProvider = ForceProvider,
                            Group = Group,
                            HtmlAttributesAsString = HtmlAttributesAsString
                        });
                }
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="DependencyType">
          <declaration><![CDATA[protected abstract ClientDependencyType DependencyType]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="FileSearchPattern">
          <declaration><![CDATA[protected string FileSearchPattern]]></declaration>
          <documentation>
            <summary>
 Gets/sets the search pattern for css files
 </summary>
          </documentation>
          <codeblock>
            <location sl="30" sc="46" el="30" ec="50">Controls\DependencyFolderInclude.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="30" sc="51" el="30" ec="55">Controls\DependencyFolderInclude.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="FolderVirtualPath">
          <declaration><![CDATA[public string FolderVirtualPath]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="20" sc="43" el="20" ec="47">Controls\DependencyFolderInclude.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="20" sc="48" el="20" ec="52">Controls\DependencyFolderInclude.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="ForceProvider">
          <declaration><![CDATA[public string ForceProvider]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="21" sc="39" el="21" ec="43">Controls\DependencyFolderInclude.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="21" sc="44" el="21" ec="48">Controls\DependencyFolderInclude.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Group">
          <declaration><![CDATA[public int Group]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="23" sc="28" el="23" ec="32">Controls\DependencyFolderInclude.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="23" sc="33" el="23" ec="37">Controls\DependencyFolderInclude.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="HtmlAttributesAsString">
          <declaration><![CDATA[public string HtmlAttributesAsString]]></declaration>
          <documentation>
            <summary>
 Used to set the HtmlAttributes on this class via a string which is parsed
 </summary>
 <remarks>
 The syntax for the string must be: key1:value1,key2:value2   etc...
 </remarks></documentation>
          <codeblock>
            <location sl="38" sc="48" el="38" ec="52">Controls\DependencyFolderInclude.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="38" sc="53" el="38" ec="57">Controls\DependencyFolderInclude.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Priority">
          <declaration><![CDATA[public int Priority]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="22" sc="31" el="22" ec="35">Controls\DependencyFolderInclude.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="22" sc="36" el="22" ec="40">Controls\DependencyFolderInclude.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="HtmlInclude">
      <declaration><![CDATA[public class HtmlInclude : Literal]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public HtmlInclude()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="25" sc="9" el="30" ec="10">Controls\HtmlInclude.cs</location>
            <body hash="b6676e847130667d9ac5ac635b8e4219"><![CDATA[public HtmlInclude()
        {
            Priority = Constants.DefaultPriority;
            Group = Constants.DefaultGroup;
            ForceProvider = null;
        }]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static HtmlInclude()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="18" sc="9" el="19" ec="184">Controls\HtmlInclude.cs</location>
            <body hash="734a27d9b694f1dc1f824c29c19a6d0d"><![CDATA[private static readonly Regex LinkTagRegex = new Regex(string.Format(TagPattern, "link"), RegexOptions.IgnoreCase | RegexOptions.CultureInvariant | RegexOptions.Compiled);
        private static readonly Regex ScriptTagRegex = new Regex(string.Format(TagPattern, "script"), RegexOptions.IgnoreCase | RegexOptions.CultureInvariant | RegexOptions.Compiled);]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="GetIncludes">
          <declaration><![CDATA[internal IEnumerable<BasicFile> GetIncludes(string innerHtml, ClientDependencyType dependencyType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="59" sc="9" el="118" ec="10">Controls\HtmlInclude.cs</location>
            <body hash="d8b0ddaece025a4baa4069b898725309"><![CDATA[{
            Regex tagRegex;
            string sourceAttribute, mime;
            if (dependencyType == ClientDependencyType.Css)
            {
                tagRegex = LinkTagRegex;
                sourceAttribute = "href";
                mime = "text/css";
            }
            else
            {
                tagRegex = ScriptTagRegex;
                sourceAttribute = "src";
                mime = "text/javascript";
            }

            var files = new List<BasicFile>();
            foreach (Match match in tagRegex.Matches(innerHtml))
            {
                var allAttributes = Regex.Matches(match.Value, MatchAllAttributes, RegexOptions.IgnoreCase | RegexOptions.CultureInvariant)
                                         .Cast<Match>()
                                         .ToArray();

                var type = allAttributes.FirstOrDefault(x =>
                {
                    if (x.Groups.Count < 3) return false;
                    return x.Groups[1].Value == "type";
                });

                var href = allAttributes.FirstOrDefault(x =>
                {
                    if (x.Groups.Count < 3) return false;
                    return x.Groups[1].Value == sourceAttribute;
                });

                if (type == null || href == null || type.Groups[2].Value != mime) continue;

                var attributes = allAttributes.Where(x =>
                {
                    if (x.Groups.Count < 3) return false;
                    return x.Groups[1].Value != sourceAttribute && x.Groups[1].Value != "type";
                }).ToDictionary(x => x.Groups[1].Value, x => x.Groups[2].Value);

                var file = new BasicFile(dependencyType)
                    {
                        FilePath = href.Groups[2].Value,
                        Group = Group,
                        Priority = Priority,
                        ForceProvider = ForceProvider
                    };

                foreach (var a in attributes)
                {
                    file.HtmlAttributes.Add(a.Key, a.Value);
                }

                files.Add(file);
            }
            return files;
        }]]></body>
          </codeblock>
        </method>
        <method name="OnInit">
          <declaration><![CDATA[protected override void OnInit(EventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="33" sc="9" el="42" ec="10">Controls\HtmlInclude.cs</location>
            <body hash="ca980bdffb523fe26abab03b0eea965c"><![CDATA[{
            base.OnInit(e);

            var isNew = false;
            var loader = ClientDependencyLoader.TryCreate(Page, new HttpContextWrapper(Context), out isNew);

            RegisterIncludes(Text, loader);

            Text = string.Empty;
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterIncludes">
          <declaration><![CDATA[private void RegisterIncludes(string innerHtml, ClientDependencyLoader loader)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="45" sc="9" el="48" ec="10">Controls\HtmlInclude.cs</location>
            <body hash="22e4dc242b6030a64b2b0a167f1720eb"><![CDATA[{
            RegisterIncludes(GetIncludes(innerHtml, ClientDependencyType.Css), loader, ClientDependencyType.Css);
            RegisterIncludes(GetIncludes(innerHtml, ClientDependencyType.Javascript), loader, ClientDependencyType.Javascript);
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterIncludes">
          <declaration><![CDATA[private void RegisterIncludes(IEnumerable<BasicFile> files, ClientDependencyLoader loader, ClientDependencyType dependencyType)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="51" sc="9" el="56" ec="10">Controls\HtmlInclude.cs</location>
            <body hash="f55c5281b411a348f6095341923c04da"><![CDATA[{
            foreach (var file in files)
            {
                loader.RegisterDependency(file.Group, file.Priority, file.FilePath, "", dependencyType, file.HtmlAttributes, file.ForceProvider);
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="AttributePattern">
          <declaration><![CDATA[public const string AttributePattern = "{0}(\\s*=\\s*(?:\"(?<val>.*?)\"|'(?<val>.*?)'|(?<val>[^'\">\\s]+)))";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="LinkTagRegex">
          <declaration><![CDATA[private static readonly Regex LinkTagRegex = new Regex(string.Format("<{0}((\\s+\\w+(\\s*=\\s*(?:\".*?\"|'.*?'|[^'\">\\s]+))?)+\\s*|\\s*)/?>", "link"), RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.CultureInvariant);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="MatchAllAttributes">
          <declaration><![CDATA[private const string MatchAllAttributes = "(\\S+)=[\"']?((?:.(?![\"']?\\s+(?:\\S+)=|[>\"']))+.)[\"']?";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ScriptTagRegex">
          <declaration><![CDATA[private static readonly Regex ScriptTagRegex = new Regex(string.Format("<{0}((\\s+\\w+(\\s*=\\s*(?:\".*?\"|'.*?'|[^'\">\\s]+))?)+\\s*|\\s*)/?>", "script"), RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.CultureInvariant);]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="TagPattern">
          <declaration><![CDATA[public const string TagPattern = "<{0}((\\s+\\w+(\\s*=\\s*(?:\".*?\"|'.*?'|[^'\">\\s]+))?)+\\s*|\\s*)/?>";]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="ForceProvider">
          <declaration><![CDATA[public string ForceProvider]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="21" sc="39" el="21" ec="43">Controls\HtmlInclude.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="21" sc="44" el="21" ec="48">Controls\HtmlInclude.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Group">
          <declaration><![CDATA[public int Group]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="23" sc="28" el="23" ec="32">Controls\HtmlInclude.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="23" sc="33" el="23" ec="37">Controls\HtmlInclude.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="Priority">
          <declaration><![CDATA[public int Priority]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="22" sc="31" el="22" ec="35">Controls\HtmlInclude.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="22" sc="36" el="22" ec="40">Controls\HtmlInclude.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="JsFolderInclude">
      <declaration><![CDATA[public class JsFolderInclude : DependencyFolderInclude]]></declaration>
      <documentation>
        <summary>
 A control used to specify a Js folder dependency
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public JsFolderInclude()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="10" sc="9" el="13" ec="10">Controls\JsFolderInclude.cs</location>
            <body hash="88fee4f39b2add338b89e5abb64fb723"><![CDATA[public JsFolderInclude()
        {
            FileSearchPattern = SearchPattern;
        }]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public JsFolderInclude(string folderVirtualPath) : base(folderVirtualPath)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="16" sc="15" el="19" ec="10">Controls\JsFolderInclude.cs</location>
            <body hash="00ee4df532b031a007014460b8ac70ca"><![CDATA[base(folderVirtualPath)
        {
            FileSearchPattern = SearchPattern;
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="SearchPattern">
          <declaration><![CDATA[private const string SearchPattern = "*.js";]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="DependencyType">
          <declaration><![CDATA[protected override ClientDependencyType DependencyType]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="JsInclude">
      <declaration><![CDATA[public class JsInclude : ClientDependencyInclude]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public JsInclude()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="5" sc="3" el="8" ec="4">Controls\JsInclude.cs</location>
            <body hash="aaba8f79584deee945f4f77f1dcde53a"><![CDATA[public JsInclude()
		{
			DependencyType = ClientDependencyType.Javascript;
		}]]></body>
          </codeblock>
        </constructor>
        <constructor name=".ctor">
          <declaration><![CDATA[public JsInclude(IClientDependencyFile file) : base(file)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="11" sc="15" el="14" ec="4">Controls\JsInclude.cs</location>
            <body hash="152271aa622fc2efc3c46b3edccb0dbc"><![CDATA[base(file)
		{
			DependencyType = ClientDependencyType.Javascript;
		}]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="ClientDependency.Core.FileRegistration.Providers">
    <class name="BaseFileRegistrationProvider">
      <declaration><![CDATA[public abstract class BaseFileRegistrationProvider : ProviderBase]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private string _compositeFileHandlerPath = "~/DependencyHandler.axd";]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="20" sc="9" el="81" ec="76">FileRegistration\Providers\BaseFileRegistrationProvider.cs</location>
            <body hash="69fc96f8e472f2451553b454a43cd610"><![CDATA[protected BaseFileRegistrationProvider()
        {
            EnableCompositeFiles = true;
            EnableDebugVersionQueryString = true;
        }

        /// <summary>
        /// By default this is true but can be overriden (in either config or code). 
        /// Composite files are never enabled with compilation debug="true" however.
        /// </summary>
        public virtual bool EnableCompositeFiles { get; set; }

        /// <summary>
        /// By default this is true but can be disabled (in either config or code). When this
        /// is enabled a query string like ?cdv=1235 of the current CDF version will be appended
        /// to dependencies when debugging is enabled or when composite files are disabled
        /// </summary>
        public bool EnableDebugVersionQueryString { get; set; }

        #region Abstract methods/properties

        /// <summary>
        /// This is called when rendering many js dependencies
        /// </summary>
        /// <param name="jsDependencies"></param>
        /// <param name="http"></param>
        /// <param name="htmlAttributes"></param>
        /// <returns></returns>
        protected abstract string RenderJsDependencies(IEnumerable<IClientDependencyFile> jsDependencies, HttpContextBase http, IDictionary<string, string> htmlAttributes);

        /// <summary>
        /// This is called when rendering many css dependencies
        /// </summary>
        /// <param name="cssDependencies"></param>
        /// <param name="http"></param>
        /// <param name="htmlAttributes"></param>
        /// <returns></returns>
        protected abstract string RenderCssDependencies(IEnumerable<IClientDependencyFile> cssDependencies, HttpContextBase http, IDictionary<string, string> htmlAttributes);

        /// <summary>
        /// Called to render a single js file
        /// </summary>
        /// <param name="js"></param>
        /// <param name="htmlAttributes"></param>
        /// <returns></returns>
        protected abstract string RenderSingleJsFile(string js, IDictionary<string, string> htmlAttributes);

        /// <summary>
        /// Called to render a single css file
        /// </summary>
        /// <param name="css"></param>
        /// <param name="htmlAttributes"></param>
        /// <returns></returns>
        protected abstract string RenderSingleCssFile(string css, IDictionary<string, string> htmlAttributes);

        #endregion

        #region CompositeFileHandlerPath config

        //set the default
        private string _compositeFileHandlerPath = "~/DependencyHandler.axd";
        private volatile bool _compositeFileHandlerPathInitialized = false;]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AppendVersion">
          <declaration><![CDATA[private string AppendVersion(string url, HttpContextBase http)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="333" sc="9" el="362" ec="10">FileRegistration\Providers\BaseFileRegistrationProvider.cs</location>
            <body hash="ed055dfe74fde3cfc6fdfd62d89a78dd"><![CDATA[{
            if (ClientDependencySettings.Instance.Version == 0)
                return url;
            if ((http.IsDebuggingEnabled || !EnableCompositeFiles)
                || ClientDependencySettings.Instance.DefaultCompositeFileProcessingProvider.UrlType == CompositeUrlType.Base64QueryStrings)
            {
                //don't append if it is already there!
                if (url.Contains("cdv=" + ClientDependencySettings.Instance.Version))
                    return url;

                //move hash to the end of the file name if present. Eg: /s/myscript.js?cdv=3#myhash
                var hash = url.Contains("#") ? "#" + url.Split(new[] { '#' }, 2)[1] : "";
                if (!String.IsNullOrEmpty(hash))
                    url = url.Split(new[] { '#' }, 2)[0];

                //ensure there's not duplicated query string syntax
                url += url.Contains('?') ? "&" : "?";
                //append a version
                url += "cdv=" + ClientDependencySettings.Instance.Version + hash;
            }
            else
            {
                if (url.EndsWith(ClientDependencySettings.Instance.Version.ToString()))
                    return url;

                //the URL should end with a '0'
                url = url.TrimEnd('0') + ClientDependencySettings.Instance.Version;
            }
            return url;
        }]]></body>
          </codeblock>
        </method>
        <method name="EnsureNoDuplicates">
          <declaration><![CDATA[protected virtual void EnsureNoDuplicates(List<IClientDependencyFile> dependencies, HashSet<IClientDependencyPath> folderPaths)]]></declaration>
          <documentation>
            <summary>
 This will ensure that no duplicates have made it into the collection.
 Duplicates WILL occur if the same dependency is registered in 2 different ways:
 one with a global path and one with a full path. This is because paths may not be defined
 until we render so we cannot de-duplicate at the time of registration.
 De-duplication will remove the dependency with a lower priority or later in the list.
 This also must be called after UpdatePaths are called since we need to full path filled in.
 </summary>
 <param name="dependencies">The dependencies list for which duplicates will be removed</param>
 <param name="folderPaths"></param></documentation>
          <codeblock>
            <location sl="291" sc="9" el="330" ec="10">FileRegistration\Providers\BaseFileRegistrationProvider.cs</location>
            <body hash="e695844be5199ccdd3335f1ac5e7bb9a"><![CDATA[{
            var toKeep = new HashSet<IClientDependencyFile>();

            foreach (var d in dependencies)
            {
                //check if it is a duplicate
                if (dependencies.Count(x => x.FilePath.ToUpper().Trim().Equals(d.FilePath.ToUpper().Trim())) > 1)
                {
                    //find the dups and return an object with the associated index
                    var dups = dependencies
                        .Where(x => x.FilePath.ToUpper().Trim().Equals(d.FilePath.ToUpper().Trim()))
                        .Select((x, index) => new { Index = index, File = x })
                        .ToList();

                    var priorities = dups.Select(x => x.File.Priority).Distinct().ToList();

                    //if there's more than 1 priority defined, we know we need to remove by priority
                    //instead of by index
                    if (priorities.Count() > 1)
                    {
                        toKeep.Add(dups.First(x => x.File.Priority == priorities.Min()).File);
                    }
                    else
                    {
                        //if not by priority, we just need to keep the first on in the list
                        toKeep.Add(dups.First(x => x.Index == dups.Select(p => p.Index).Min()).File);
                    }
                }
                else
                {
                    //if there's only one found, then just add it to our output
                    toKeep.Add(d);
                }
            }

            dependencies.Clear();
            dependencies.AddRange(toKeep);


        }]]></body>
          </codeblock>
        </method>
        <method name="GetCompositeFileHandlerPath">
          <deprecation>The GetCompositeFileHandlerPath should be retrieved from the compositeFiles element in config: ClientDependencySettings.Instance.CompositeFileHandlerPath</deprecation>
          <declaration><![CDATA[protected internal string GetCompositeFileHandlerPath(HttpContextBase http)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="85" sc="9" el="104" ec="10">FileRegistration\Providers\BaseFileRegistrationProvider.cs</location>
            <body hash="2a0284c27e9322fdf1609b4dff40e16f"><![CDATA[{
            if (!_compositeFileHandlerPathInitialized)
            {
                lock (this)
                {
                    //double check
                    if (!_compositeFileHandlerPathInitialized)
                    {
                        //we may need to convert this to a real path
                        if (_compositeFileHandlerPath.StartsWith("~/"))
                        {
                            _compositeFileHandlerPath = VirtualPathUtility.ToAbsolute(_compositeFileHandlerPath, http.Request.ApplicationPath);
                        }
                        //set the flag, we're done
                        _compositeFileHandlerPathInitialized = true;
                    }
                }
            }
            return _compositeFileHandlerPath;
        }]]></body>
          </codeblock>
        </method>
        <method name="GetHtmlAttributes">
          <declaration><![CDATA[private static IDictionary<string, string> GetHtmlAttributes(IClientDependencyFile file)]]></declaration>
          <documentation>
            <summary>
 Checks if the current file implements the html attribute interfaces and returns the appropriate html attributes
 </summary>
 <param name="file"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="372" sc="9" el="412" ec="10">FileRegistration\Providers\BaseFileRegistrationProvider.cs</location>
            <body hash="1fcc844df1877ec974b7abc947f79429"><![CDATA[{
            IDictionary<string, string> attributes = new Dictionary<string, string>();

            var htmlAttributes = file as IHaveHtmlAttributes;
            if (htmlAttributes != null)
            {
                var fileWithAttributes = htmlAttributes;
                attributes = fileWithAttributes.HtmlAttributes;

                var parsing = file as IRequiresHtmlAttributesParsing;
                if (parsing != null)
                {
                    //we need to parse the attributes into the dictionary
                    HtmlAttributesStringParser.ParseIntoDictionary(parsing.HtmlAttributesAsString, attributes);
                }
            }

            //now we must ensure that the correct js/css attribute exist!
            switch (file.DependencyType)
            {
                case ClientDependencyType.Javascript:
                    if (!attributes.ContainsKey("type"))
                        attributes.Add("type", "text/javascript");
                    if (attributes.ContainsKey("src"))
                        attributes.Remove("src");
                    break;
                case ClientDependencyType.Css:
                    if (!attributes.ContainsKey("type"))
                        attributes.Add("type", "text/css");
                    if (!attributes.ContainsKey("rel"))
                        attributes.Add("rel", "stylesheet");
                    if (attributes.ContainsKey("href"))
                        attributes.Remove("href");
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            //just return an empty dictionary
            return attributes;
        }]]></body>
          </codeblock>
        </method>
        <method name="Initialize">
          <declaration><![CDATA[public override void Initialize(string name, NameValueCollection config)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="111" sc="9" el="123" ec="10">FileRegistration\Providers\BaseFileRegistrationProvider.cs</location>
            <body hash="0f2d8ed5a6f86879cfdbe1013b6f7c35"><![CDATA[{
            base.Initialize(name, config);

            if (config != null && config["enableCompositeFiles"] != null && !string.IsNullOrEmpty(config["enableCompositeFiles"]))
            {
                EnableCompositeFiles = bool.Parse(config["enableCompositeFiles"]);
            }

            if (config != null && config["enableDebugVersionQueryString"] != null && !string.IsNullOrEmpty(config["enableDebugVersionQueryString"]))
            {
                EnableDebugVersionQueryString = bool.Parse(config["enableDebugVersionQueryString"]);
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="RenderCssDependencies">
          <declaration><![CDATA[protected abstract string RenderCssDependencies(IEnumerable<IClientDependencyFile> cssDependencies, HttpContextBase http, IDictionary<string, string> htmlAttributes);]]></declaration>
          <documentation>
            <summary>
 This is called when rendering many css dependencies
 </summary>
 <param name="cssDependencies"></param>
 <param name="http"></param>
 <param name="htmlAttributes"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="RenderJsDependencies">
          <declaration><![CDATA[protected abstract string RenderJsDependencies(IEnumerable<IClientDependencyFile> jsDependencies, HttpContextBase http, IDictionary<string, string> htmlAttributes);]]></declaration>
          <documentation>
            <summary>
 This is called when rendering many js dependencies
 </summary>
 <param name="jsDependencies"></param>
 <param name="http"></param>
 <param name="htmlAttributes"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="RenderSingleCssFile">
          <declaration><![CDATA[protected abstract string RenderSingleCssFile(string css, IDictionary<string, string> htmlAttributes);]]></declaration>
          <documentation>
            <summary>
 Called to render a single css file
 </summary>
 <param name="css"></param>
 <param name="htmlAttributes"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="RenderSingleJsFile">
          <declaration><![CDATA[protected abstract string RenderSingleJsFile(string js, IDictionary<string, string> htmlAttributes);]]></declaration>
          <documentation>
            <summary>
 Called to render a single js file
 </summary>
 <param name="js"></param>
 <param name="htmlAttributes"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="StaggerOnDifferentAttributes">
          <declaration><![CDATA[private void StaggerOnDifferentAttributes(HttpContextBase http, StringBuilder builder, IEnumerable<IClientDependencyFile> list, Func<IEnumerable<IClientDependencyFile>, HttpContextBase, IDictionary<string, string>, string> renderCompositeFiles)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="134" sc="9" el="159" ec="10">FileRegistration\Providers\BaseFileRegistrationProvider.cs</location>
            <body hash="274bbaee803722e06f367afc247108b6"><![CDATA[{
            var sameAttributes = new List<IClientDependencyFile>();
            var currHtmlAttr = GetHtmlAttributes(list.ElementAt(0));
            foreach (var c in list)
            {
                if (!currHtmlAttr.IsEqualTo(GetHtmlAttributes(c)))
                {
                    //if the attributes are different we need to stagger
                    if (sameAttributes.Any())
                    {
                        //render the current buffer
                        builder.Append(renderCompositeFiles(sameAttributes, http, currHtmlAttr));
                        //clear the buffer
                        sameAttributes.Clear();
                    }
                }

                //add the item to the buffer and set the current html attributes
                sameAttributes.Add(c);
                currHtmlAttr = GetHtmlAttributes(c);
            }

            //if there's anything in the buffer then write the remaining
            if (sameAttributes.Any())
                builder.Append(renderCompositeFiles(sameAttributes, http, currHtmlAttr));
        }]]></body>
          </codeblock>
        </method>
        <method name="UpdateFilePaths">
          <declaration><![CDATA[protected virtual void UpdateFilePaths(IEnumerable<IClientDependencyFile> dependencies, HashSet<IClientDependencyPath> folderPaths, HttpContextBase http)]]></declaration>
          <documentation>
            <summary>
 Ensures the correctly resolved file path is set for each dependency (i.e. so that ~ are taken care of) and also
 prefixes the file path with the correct base path specified for the PathNameAlias if specified.
 </summary>
 <param name="dependencies">The dependencies list for which file paths will be updated</param>
 <param name="folderPaths"></param>
 <param name="http"></param></documentation>
          <codeblock>
            <location sl="248" sc="9" el="277" ec="10">FileRegistration\Providers\BaseFileRegistrationProvider.cs</location>
            <body hash="fd59300f30f2e51f517274a5c6cb2235"><![CDATA[{
            var paths = folderPaths.ToList();
            foreach (var dependency in dependencies)
            {
                if (!string.IsNullOrEmpty(dependency.PathNameAlias))
                {
                    var d = dependency;
                    var path = paths.Find(p => p.Name == d.PathNameAlias);
                    if (path == null)
                    {
                        throw new NullReferenceException("The PathNameAlias specified for dependency " + dependency.FilePath + " does not exist in the ClientDependencyPathCollection");
                    }
                    var resolvedPath = path.ResolvePath(http);
                    var basePath = resolvedPath.EndsWith("/") ? resolvedPath : resolvedPath + "/";
                    dependency.FilePath = basePath + dependency.FilePath;
                    dependency.ForceBundle = (dependency.ForceBundle | path.ForceBundle);
                }
                else
                {
                    dependency.FilePath = dependency.ResolveFilePath(http);
                }

                //append query strings to each file if we are in debug mode
                if (EnableDebugVersionQueryString &&
                    (http.IsDebuggingEnabled || !EnableCompositeFiles))
                {
                    dependency.FilePath = AppendVersion(dependency.FilePath, http);
                }
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="WriteDependencies">
          <declaration><![CDATA[internal void WriteDependencies(List<IClientDependencyFile> allDependencies, HashSet<IClientDependencyPath> paths, out string jsOutput, out string cssOutput, HttpContextBase http)]]></declaration>
          <documentation>
            <summary>
 Called to write the js and css to string output
 </summary>
 <param name="allDependencies"></param>
 <param name="paths"></param>
 <param name="jsOutput"></param>
 <param name="cssOutput"></param>
 <param name="http"></param></documentation>
          <codeblock>
            <location sl="429" sc="9" el="477" ec="10">FileRegistration\Providers\BaseFileRegistrationProvider.cs</location>
            <body hash="2df093c95fb9072198c35a2729b739b9"><![CDATA[{
            //create the hash to see if we've already stored it
            var hashCodeCombiner = new HashCodeCombiner();
            foreach (var d in allDependencies)
            {
                hashCodeCombiner.AddObject(d);
            }
            var hash = hashCodeCombiner.GetCombinedHashCode();

            //we may have already processed this so don't do it again
            if (http.Items["BaseRenderer.RegisterDependencies." + hash] == null)
            {
                var folderPaths = paths;
                UpdateFilePaths(allDependencies, folderPaths, http);
                EnsureNoDuplicates(allDependencies, folderPaths);

                //now we regenerate the hash since dependencies have been removed/etc.. 
                // and update the context items so it's not run again
                hashCodeCombiner = new HashCodeCombiner();
                foreach (var d in allDependencies)
                {
                    hashCodeCombiner.AddObject(d);
                }
                hash = hashCodeCombiner.GetCombinedHashCode();
                http.Items["BaseRenderer.RegisterDependencies." + hash] = true;
            }

            var cssBuilder = new StringBuilder();
            var jsBuilder = new StringBuilder();

            //group by the group and order by the value
            foreach (var group in allDependencies.GroupBy(x => x.Group).OrderBy(x => x.Key))
            {
                //sort both the js and css dependencies properly

                var jsDependencies = DependencySorter.SortItems(DependencySorter.FilterDependencies(
                    group.Where(x => x.DependencyType == ClientDependencyType.Javascript).ToList()));

                var cssDependencies = DependencySorter.SortItems(DependencySorter.FilterDependencies(
                    group.Where(x => x.DependencyType == ClientDependencyType.Css).ToList()));

                //render
                WriteStaggeredDependencies(cssDependencies, http, cssBuilder, RenderCssDependencies, RenderSingleCssFile);
                WriteStaggeredDependencies(jsDependencies, http, jsBuilder, RenderJsDependencies, RenderSingleJsFile);
            }

            cssOutput = cssBuilder.ToString();
            jsOutput = jsBuilder.ToString();
        }]]></body>
          </codeblock>
        </method>
        <method name="WriteStaggeredDependencies">
          <declaration><![CDATA[protected void WriteStaggeredDependencies(IEnumerable<IClientDependencyFile> dependencies, HttpContextBase http, StringBuilder builder, Func<IEnumerable<IClientDependencyFile>, HttpContextBase, IDictionary<string, string>, string> renderCompositeFiles, Func<string, IDictionary<string, string>, string> renderSingle)]]></declaration>
          <documentation>
            <summary>
 Because we can have both internal and external dependencies rendered, we need to stagger the script tag output... if they are external, we need to stop the compressing/combining
 and write out the external dependency, then resume the compressing/combining handler.
 </summary>
 <param name="dependencies"></param>
 <param name="http"></param>
 <param name="builder"></param>
 <param name="renderCompositeFiles"></param>
 <param name="renderSingle"></param></documentation>
          <codeblock>
            <location sl="176" sc="9" el="237" ec="10">FileRegistration\Providers\BaseFileRegistrationProvider.cs</location>
            <body hash="aebdc6a341e55baa4998b7d4014477dd"><![CDATA[{
            var fileBasedExtensions = ClientDependencySettings.Instance.FileBasedDependencyExtensionList
                                                              .Union(FileWriters.GetRegisteredExtensions())
                                                              .ToArray();

            var currNonRemoteFiles = new List<IClientDependencyFile>();
            foreach (var f in dependencies)
            {
                //need to parse out the request's extensions and remove query strings
                //need to force non-bundled lines for items with query parameters or a hash value.
                var extension = f.FilePath.Contains('?') || f.FilePath.Contains('#') ? "" : Path.GetExtension(f.FilePath);
                var stringExt = "";
                if (!string.IsNullOrWhiteSpace(extension))
                {
                    stringExt = extension.ToUpper().Split(new[] { '?' }, StringSplitOptions.RemoveEmptyEntries)[0];
                }

                //if this is a protocol-relative/protocol-less uri, then we need to add the protocol for the remaining
                // logic to work properly
                if (f.FilePath.StartsWith("//"))
                {
                    f.FilePath = Regex.Replace(f.FilePath, @"^\/\/", http.Request.Url.GetLeftPart(UriPartial.Scheme));
                }


                // if it is an external resource OR
                // if it is a non-standard JS/CSS resource (i.e. a server request)
                // then we need to break the sequence
                // unless it has been explicitely required that the dependency be bundled
                if ((!http.IsAbsolutePath(f.FilePath) && !fileBasedExtensions.Contains(stringExt))
                    //now check for external resources
                    || (http.IsAbsolutePath(f.FilePath)
                        //remote dependencies aren't local
                        && !new Uri(f.FilePath, UriKind.RelativeOrAbsolute).IsLocalUri(http)
                        // not required to be bundled
                        && !f.ForceBundle))
                {
                    //we've encountered an external dependency, so we need to break the sequence and restart it after
                    //we output the raw script tag
                    if (currNonRemoteFiles.Count > 0)
                    {
                        //render the current buffer
                        StaggerOnDifferentAttributes(http, builder, currNonRemoteFiles, renderCompositeFiles);
                        //clear the buffer
                        currNonRemoteFiles.Clear();
                    }
                    //write out the single script tag
                    builder.Append(renderSingle(f.FilePath, GetHtmlAttributes(f)));
                }
                else
                {
                    //its a normal registration, add to the buffer
                    currNonRemoteFiles.Add(f);
                }
            }
            //now check if there's anything in the buffer to render
            if (currNonRemoteFiles.Count > 0)
            {
                //render the current buffer
                StaggerOnDifferentAttributes(http, builder, currNonRemoteFiles, renderCompositeFiles);
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_compositeFileHandlerPath">
          <declaration><![CDATA[private string _compositeFileHandlerPath = "~/DependencyHandler.axd";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_compositeFileHandlerPathInitialized">
          <declaration><![CDATA[private volatile bool _compositeFileHandlerPathInitialized = false;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="EnableCompositeFiles">
          <declaration><![CDATA[public virtual bool EnableCompositeFiles]]></declaration>
          <documentation>
            <summary>
 By default this is true but can be overriden (in either config or code).
 Composite files are never enabled with compilation debug="true" however.
 </summary>
          </documentation>
          <codeblock>
            <location sl="30" sc="52" el="30" ec="56">FileRegistration\Providers\BaseFileRegistrationProvider.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="30" sc="57" el="30" ec="61">FileRegistration\Providers\BaseFileRegistrationProvider.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="EnableDebugVersionQueryString">
          <declaration><![CDATA[public bool EnableDebugVersionQueryString]]></declaration>
          <documentation>
            <summary>
 By default this is true but can be disabled (in either config or code). When this
 is enabled a query string like ?cdv=1235 of the current CDF version will be appended
 to dependencies when debugging is enabled or when composite files are disabled
 </summary>
          </documentation>
          <codeblock>
            <location sl="37" sc="53" el="37" ec="57">FileRegistration\Providers\BaseFileRegistrationProvider.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="37" sc="58" el="37" ec="62">FileRegistration\Providers\BaseFileRegistrationProvider.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="BaseRenderer">
      <declaration><![CDATA[public abstract class BaseRenderer : BaseFileRegistrationProvider]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[protected BaseRenderer()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="RegisterDependencies">
          <declaration><![CDATA[public virtual void RegisterDependencies(List<IClientDependencyFile> allDependencies, HashSet<IClientDependencyPath> paths, out string jsOutput, out string cssOutput, HttpContextBase http)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="21" sc="9" el="23" ec="10">FileRegistration\Providers\BaseRenderer.cs</location>
            <body hash="d271c886219849f82d17d8677f687240"><![CDATA[{
            WriteDependencies(allDependencies, paths, out jsOutput, out cssOutput, http);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="FileRegistrationProviderCollection">
      <declaration><![CDATA[public class FileRegistrationProviderCollection : ProviderCollection]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public FileRegistrationProviderCollection()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Add">
          <declaration><![CDATA[public override void Add(ProviderBase provider)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="16" sc="3" el="24" ec="4">FileRegistration\Providers\FileRegistrationProviderCollection.cs</location>
            <body hash="80b0ff12e48ea1011f34432e5812698d"><![CDATA[{
			if (provider == null)
				throw new ArgumentNullException("provider");

            if (!(provider is WebFormsFileRegistrationProvider))
				throw new ArgumentException("Invalid provider type", "provider");

			base.Add(provider);
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Item">
          <declaration><![CDATA[public new WebFormsFileRegistrationProvider this[string name]]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="HtmlEmbedContants">
      <declaration><![CDATA[public class HtmlEmbedContants]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public HtmlEmbedContants()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
        <field name="CssEmbedWithSource">
          <declaration><![CDATA[public const string CssEmbedWithSource = "<link href=\"{0}\" {1}/>";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ScriptEmbedWithCode">
          <declaration><![CDATA[public const string ScriptEmbedWithCode = "<script type=\"text/javascript\">{0}</script>";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="ScriptEmbedWithSource">
          <declaration><![CDATA[public const string ScriptEmbedWithSource = "<script src=\"{0}\" {1}></script>";]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="LazyLoadProvider">
      <declaration><![CDATA[public class LazyLoadProvider : WebFormsFileRegistrationProvider]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public LazyLoadProvider()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Initialize">
          <declaration><![CDATA[public override void Initialize(string name, NameValueCollection config)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="17" sc="3" el="23" ec="4">FileRegistration\Providers\LazyLoadProvider.cs</location>
            <body hash="074671393749bfd131ddb5abdc957e16"><![CDATA[{
			// Assign the provider a default name if it doesn't have one
			if (string.IsNullOrEmpty(name))
				name = DefaultName;

			base.Initialize(name, config);
		}]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependencies">
          <declaration><![CDATA[protected override void RegisterDependencies(HttpContextBase http, string js, string css)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="114" sc="9" el="125" ec="10">FileRegistration\Providers\LazyLoadProvider.cs</location>
            <body hash="7bd81d318156c81049a07a47b09591a8"><![CDATA[{
            if (!(http.CurrentHandler is Page))
            {
                throw new InvalidOperationException("The current HttpHandler in a WebFormsFileRegistrationProvider must be of type Page");
            }
            var page = (Page)http.CurrentHandler;

            page.ClientScript.RegisterClientScriptResource(typeof(LazyLoadProvider), DependencyLoaderResourceName);

            RegisterScript(js, page);
            RegisterScript(css, page);
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterScript">
          <declaration><![CDATA[private void RegisterScript(string strScript, Page page)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="128" sc="3" el="141" ec="4">FileRegistration\Providers\LazyLoadProvider.cs</location>
            <body hash="d23a97f76a5b831cac5b3cc9c18fb3a4"><![CDATA[{
            var mgr = ScriptManager.GetCurrent(page);

			if (mgr == null)
			{
                if (page.Form == null)
                    throw new InvalidOperationException("A form tag must be present on the page with a runat='server' attribute specified");
                page.ClientScript.RegisterStartupScript(GetType(), strScript.GetHashCode().ToString(), strScript, true);
			}
			else
			{
                ScriptManager.RegisterStartupScript(page, GetType(), strScript.GetHashCode().ToString(), strScript, true);
			}
		}]]></body>
          </codeblock>
        </method>
        <method name="RenderCssDependencies">
          <declaration><![CDATA[protected override string RenderCssDependencies(IEnumerable<IClientDependencyFile> cssDependencies, HttpContextBase http, IDictionary<string, string> htmlAttributes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="73" sc="9" el="103" ec="4">FileRegistration\Providers\LazyLoadProvider.cs</location>
            <body hash="5b047b7ec669f0ffb8f12443451f3dc7"><![CDATA[{
            var asArray = cssDependencies.ToArray();

            if (!asArray.Any())
                return string.Empty;

            var sb = new StringBuilder();

            if (http.IsDebuggingEnabled || !EnableCompositeFiles)
			{
                foreach (var dependency in asArray)
				{
                    sb.Append(RenderSingleCssFile(dependency.FilePath, htmlAttributes));
				}
			}
			else
			{
                var comp = ClientDependencySettings.Instance.DefaultCompositeFileProcessingProvider.ProcessCompositeList(
                    asArray, 
                    ClientDependencyType.Css, 
                    http,
                    ClientDependencySettings.Instance.CompositeFileHandlerPath);

                foreach (var s in comp)
                {
                    sb.Append(RenderSingleCssFile(s, htmlAttributes));
                }    
			}

            return sb.ToString();
		}]]></body>
          </codeblock>
        </method>
        <method name="RenderJsDependencies">
          <declaration><![CDATA[protected override string RenderJsDependencies(IEnumerable<IClientDependencyFile> jsDependencies, HttpContextBase http, IDictionary<string, string> htmlAttributes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="29" sc="9" el="59" ec="4">FileRegistration\Providers\LazyLoadProvider.cs</location>
            <body hash="604bb431ee45b0d8fc02337b66933e08"><![CDATA[{
            var asArray = jsDependencies.ToArray();

            if (!asArray.Any())
				return string.Empty;

            var sb = new StringBuilder();

            if (http.IsDebuggingEnabled || !EnableCompositeFiles)
			{
                foreach (var dependency in asArray)
				{
                    sb.Append(RenderSingleJsFile(string.Format("'{0}','{1}'", dependency.FilePath, string.Empty), htmlAttributes));
				}
			}
			else
			{
                var comp = ClientDependencySettings.Instance.DefaultCompositeFileProcessingProvider.ProcessCompositeList(
                    asArray, 
                    ClientDependencyType.Javascript, 
                    http,
                    ClientDependencySettings.Instance.CompositeFileHandlerPath);

                foreach (var s in comp)
                {
                    sb.Append(RenderSingleJsFile(string.Format("'{0}','{1}'", s, string.Empty), htmlAttributes));
                }   
			}

            return sb.ToString();
		}]]></body>
          </codeblock>
        </method>
        <method name="RenderSingleCssFile">
          <declaration><![CDATA[protected override string RenderSingleCssFile(string css, IDictionary<string, string> htmlAttributes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="106" sc="3" el="111" ec="4">FileRegistration\Providers\LazyLoadProvider.cs</location>
            <body hash="4724c90daa17689ff3e17b9ea690d014"><![CDATA[{
            var strClientLoader = new StringBuilder("CDLazyLoader");
			strClientLoader.AppendFormat(".AddCss('{0}')", css);
			strClientLoader.Append(';');
            return strClientLoader.ToString();
		}]]></body>
          </codeblock>
        </method>
        <method name="RenderSingleJsFile">
          <declaration><![CDATA[protected override string RenderSingleJsFile(string js, IDictionary<string, string> htmlAttributes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="62" sc="3" el="70" ec="4">FileRegistration\Providers\LazyLoadProvider.cs</location>
            <body hash="c171b96a88c0c33fd9d22ee0ecbada70"><![CDATA[{
            if(!js.StartsWith("'"))
                js = string.Format("'{0}'", js);

            var strClientLoader = new StringBuilder("CDLazyLoader");
			strClientLoader.AppendFormat(".AddJs({0})", js);
			strClientLoader.Append(';');
            return strClientLoader.ToString();
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="DefaultName">
          <declaration><![CDATA[public const string DefaultName = "LazyLoadProvider";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DependencyLoaderResourceName">
          <declaration><![CDATA[protected const string DependencyLoaderResourceName = "ClientDependency.Core.Resources.LazyLoader.js";]]></declaration>
          <documentation>
            <summary>Path to the dependency loader we need for adding control dependencies.</summary>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="LazyLoadRenderer">
      <declaration><![CDATA[public class LazyLoadRenderer : BaseRenderer]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public LazyLoadRenderer()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="14" sc="9" el="18" ec="10">FileRegistration\Providers\LazyLoadRenderer.cs</location>
            <body hash="33f5389778788f6225399b8fcf41cb8c"><![CDATA[public LazyLoadRenderer()
        {
            PlaceholderParser.PlaceholderReplaced += PlaceholderParserPlaceholderReplaced;
            PlaceholderParser.AllPlaceholdersReplaced += PlaceholdersReplaced;
        }]]></body>
          </codeblock>
        </constructor>
        <constructor name=".cctor">
          <declaration><![CDATA[static LazyLoadRenderer()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="86" sc="9" el="86" ec="62">FileRegistration\Providers\LazyLoadRenderer.cs</location>
            <body hash="051d266d9463c94476d91f447315bb9f"><![CDATA[private static readonly object Locker = new object()]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="GetWebResourceUrl">
          <declaration><![CDATA[private static string GetWebResourceUrl(Type type, string resourceId)]]></declaration>
          <documentation>
            <summary>
 This is silly to have to do this but MS don't give you a way in MVC to do this
 </summary>
 <param name="type"></param>
 <param name="resourceId"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="95" sc="9" el="99" ec="10">FileRegistration\Providers\LazyLoadRenderer.cs</location>
            <body hash="17b655785799dd2fbfe1d6f7c14ef44b"><![CDATA[{
            if (type == null) throw new ArgumentNullException("type");
            var page = new Page();
            return page.ClientScript.GetWebResourceUrl(type, resourceId);
        }]]></body>
          </codeblock>
        </method>
        <method name="Initialize">
          <declaration><![CDATA[public override void Initialize(string name, NameValueCollection config)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="75" sc="9" el="81" ec="10">FileRegistration\Providers\LazyLoadRenderer.cs</location>
            <body hash="4707389e73a898e6ec59bdf29d09471a"><![CDATA[{
            // Assign the provider a default name if it doesn't have one
            if (string.IsNullOrEmpty(name))
                name = DefaultName;

            base.Initialize(name, config);
        }]]></body>
          </codeblock>
        </method>
        <method name="PlaceholderParserPlaceholderReplaced">
          <declaration><![CDATA[private static void PlaceholderParserPlaceholderReplaced(object sender, PlaceholderReplacementEventArgs e)]]></declaration>
          <documentation>
            <summary>
 This is used to ensure we render the lazy load script once before either the lazy js or css is rendered.
 </summary>
 <param name="sender"></param>
 <param name="e"></param>
 <remarks>
 See comments in PlaceholdersReplaced for more details
 </remarks></documentation>
          <codeblock>
            <location sl="29" sc="9" el="38" ec="10">FileRegistration\Providers\LazyLoadRenderer.cs</location>
            <body hash="4dc27d279643a89f0fbea04fbedb91bb"><![CDATA[{
            //if the replacement was for this renderer
            if (e.RegexMatch.Groups.Count > 1 && e.RegexMatch.Groups[1].ToString() == DefaultName)
            {
                //we will pre-pend a special token above this output so we can detect it in the PlaceholdersReplaced event
                // and we'll tag the current http context with a key so we can detect that this reques is for us
                e.HttpContext.Items[PlaceholderReplacementProcessing] = true;
                e.ReplacedText = LazyLoadScriptPlaceholder + e.ReplacedText;
            }   
        }]]></body>
          </codeblock>
        </method>
        <method name="PlaceholdersReplaced">
          <declaration><![CDATA[private static void PlaceholdersReplaced(object sender, PlaceholdersReplacedEventArgs e)]]></declaration>
          <documentation>
            <summary>
 This allows us to ensure that the lazy load script is placed higher in the rendered html than either the css or the js rendered to the page.
 </summary>
 <param name="sender"></param>
 <param name="e"></param>
 <remarks>
 TO accomplish this we detect if the http context has a special key (PlaceholderReplacementProcessing), if so we'll replace the first encountered
 token with the lazy load script and replace any other ones with empty text (so it is only loaded once). We need to do this because we have no
 idea if the developer has rendered the lazy css or lazy js first.
 </remarks></documentation>
          <codeblock>
            <location sl="51" sc="9" el="67" ec="10">FileRegistration\Providers\LazyLoadRenderer.cs</location>
            <body hash="a3a07d27b4021b7556379a1fbf6a96ee"><![CDATA[{

            if (e.HttpContext.Items[PlaceholderReplacementProcessing] is bool 
                && (bool)e.HttpContext.Items[PlaceholderReplacementProcessing])
            {
                var url = GetWebResourceUrl(typeof(LazyLoadProvider), DependencyLoaderResourceName);
                var lazyScriptTag = string.Format(HtmlEmbedContants.ScriptEmbedWithSource, url, "");

                //replace the first occurance
                e.ReplacedText = e.ReplacedText.ReplaceFirst(LazyLoadScriptPlaceholder, lazyScriptTag);
                //replace the rest with nothing
                e.ReplacedText = e.ReplacedText.Replace(LazyLoadScriptPlaceholder, "");

                //set the flag to null so we don't process again
                e.HttpContext.Items[PlaceholderReplacementProcessing] = null;
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="RenderCssDependencies">
          <declaration><![CDATA[protected override string RenderCssDependencies(IEnumerable<IClientDependencyFile> cssDependencies, HttpContextBase http, IDictionary<string, string> htmlAttributes)]]></declaration>
          <documentation>
            <summary>
 Renders many Css dependencies.
 </summary>
 <param name="cssDependencies"></param>
 <param name="http"></param>
 <param name="htmlAttributes"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="157" sc="9" el="194" ec="10">FileRegistration\Providers\LazyLoadRenderer.cs</location>
            <body hash="9116ab9c0bc13f0423099d568ec72673"><![CDATA[{
            var asArray = cssDependencies.ToArray();

            if (!asArray.Any())
                return string.Empty;

            var sb = new StringBuilder();
            var strClientLoader = new StringBuilder();

            if (http.IsDebuggingEnabled || !EnableCompositeFiles)
            {
                foreach (var dependency in asArray)
                {
                    strClientLoader.Append("CDLazyLoader");
                    strClientLoader.AppendFormat(".AddCss('{0}')", dependency.FilePath);
                    strClientLoader.AppendLine(";");
                }
            }
            else
            {
                var comp = ClientDependencySettings.Instance.DefaultCompositeFileProcessingProvider.ProcessCompositeList(
                    asArray, 
                    ClientDependencyType.Css, 
                    http,
                    ClientDependencySettings.Instance.CompositeFileHandlerPath);

                foreach (var s in comp)
                {
                    strClientLoader.Append("CDLazyLoader");
                    strClientLoader.AppendFormat(".AddCss('{0}')", s);
                    strClientLoader.AppendLine(";");
                }
            }

            sb.Append(string.Format(HtmlEmbedContants.ScriptEmbedWithCode, strClientLoader.ToString()));

            return sb.ToString();
        }]]></body>
          </codeblock>
        </method>
        <method name="RenderJsDependencies">
          <declaration><![CDATA[protected override string RenderJsDependencies(IEnumerable<IClientDependencyFile> jsDependencies, HttpContextBase http, IDictionary<string, string> htmlAttributes)]]></declaration>
          <documentation>
            <summary>
 Renders many Js dependencies.
 </summary>
 <param name="jsDependencies"></param>
 <param name="http"></param>
 <param name="htmlAttributes"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="109" sc="9" el="147" ec="10">FileRegistration\Providers\LazyLoadRenderer.cs</location>
            <body hash="60ce5124931c25a8502a7624f55ca495"><![CDATA[{
            var asArray = jsDependencies.ToArray();

            if (!asArray.Any())
				return string.Empty;

            var sb = new StringBuilder();   
            var strClientLoader = new StringBuilder();


            if (http.IsDebuggingEnabled || !EnableCompositeFiles)
			{
                foreach (var dependency in asArray)
				{
                    strClientLoader.Append("CDLazyLoader");
                    strClientLoader.AppendFormat(".AddJs('{0}')", dependency.FilePath);
                    strClientLoader.AppendLine(";");
				}
			}
			else
			{
                var comp = ClientDependencySettings.Instance.DefaultCompositeFileProcessingProvider.ProcessCompositeList(
                    asArray, 
                    ClientDependencyType.Javascript, 
                    http,
                    ClientDependencySettings.Instance.CompositeFileHandlerPath);

                foreach (var s in comp)
                {
                    strClientLoader.Append("CDLazyLoader");
                    strClientLoader.AppendFormat(".AddJs('{0}')", s);
                    strClientLoader.AppendLine(";");
                }   
			}

            sb.Append(string.Format(HtmlEmbedContants.ScriptEmbedWithCode, strClientLoader.ToString()));

            return sb.ToString();
        }]]></body>
          </codeblock>
        </method>
        <method name="RenderSingleCssFile">
          <declaration><![CDATA[protected override string RenderSingleCssFile(string css, IDictionary<string, string> htmlAttributes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="209" sc="9" el="215" ec="10">FileRegistration\Providers\LazyLoadRenderer.cs</location>
            <body hash="ee23f05a8c11075cd3db2696d24c1585"><![CDATA[{
            var strClientLoader = new StringBuilder("CDLazyLoader");
            strClientLoader.AppendFormat(".AddCss('{0}')", css);
            strClientLoader.Append(';');

            return string.Format(HtmlEmbedContants.ScriptEmbedWithCode, strClientLoader);
        }]]></body>
          </codeblock>
        </method>
        <method name="RenderSingleJsFile">
          <declaration><![CDATA[protected override string RenderSingleJsFile(string js, IDictionary<string, string> htmlAttributes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="197" sc="9" el="206" ec="10">FileRegistration\Providers\LazyLoadRenderer.cs</location>
            <body hash="53c95bf8cf80ed87fd49278116447d01"><![CDATA[{
            if (!js.StartsWith("'"))
                js = string.Format("'{0}'", js);

            var strClientLoader = new StringBuilder("CDLazyLoader");
            strClientLoader.AppendFormat(".AddJs({0})", js);
            strClientLoader.Append(';');

            return string.Format(HtmlEmbedContants.ScriptEmbedWithCode, strClientLoader.ToString());
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="DefaultName">
          <declaration><![CDATA[public const string DefaultName = "LazyLoadRenderer";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="DependencyLoaderResourceName">
          <declaration><![CDATA[protected const string DependencyLoaderResourceName = "ClientDependency.Core.Resources.LazyLoader.js";]]></declaration>
          <documentation>
            <summary>Path to the dependency loader we need for adding control dependencies.</summary>
          </documentation>
        </field>
        <field name="LazyLoadScriptPlaceholder">
          <declaration><![CDATA[private const string LazyLoadScriptPlaceholder = "<!--[Javascript:Name=\"LazyLoadRenderer_LazyLoadScript\"]//-->";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="Locker">
          <declaration><![CDATA[private static readonly object Locker = new object();]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="PlaceholderReplacementProcessing">
          <declaration><![CDATA[private const string PlaceholderReplacementProcessing = "LazyLoadRenderer_Processing";]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="LoaderControlProvider">
      <declaration><![CDATA[public class LoaderControlProvider : WebFormsFileRegistrationProvider]]></declaration>
      <documentation>
        <summary>
 Uses the LoaderControl to render the CSS and JS specified.
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public LoaderControlProvider()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AddToControl">
          <declaration><![CDATA[private static void AddToControl(HttpContextBase http, string literal)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="122" sc="9" el="125" ec="10">FileRegistration\Providers\LoaderControlProvider.cs</location>
            <body hash="b5c219b1cc795e473f8c73e53c7a6c31"><![CDATA[{
            var dCtl = new LiteralControl(literal);
            ClientDependencyLoader.GetInstance(http).Controls.Add(dCtl);
        }]]></body>
          </codeblock>
        </method>
        <method name="Initialize">
          <declaration><![CDATA[public override void Initialize(string name, NameValueCollection config)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="21" sc="9" el="27" ec="10">FileRegistration\Providers\LoaderControlProvider.cs</location>
            <body hash="4707389e73a898e6ec59bdf29d09471a"><![CDATA[{
            // Assign the provider a default name if it doesn't have one
            if (string.IsNullOrEmpty(name))
                name = DefaultName;

            base.Initialize(name, config);
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependencies">
          <declaration><![CDATA[protected override void RegisterDependencies(HttpContextBase http, string js, string css)]]></declaration>
          <documentation>
            <summary>
 Registers the dependencies as controls of the LoaderControl controls collection
 </summary>
 <param name="http"></param>
 <param name="js"></param>
 <param name="css"></param>
 <remarks>
 For some reason ampersands that aren't html escaped are not compliant to HTML standards when they exist in 'link' or 'script' tags in URLs,
 we need to replace the ampersands with &amp; . This is only required for this one w3c compliancy, the URL itself is a valid URL.
 </remarks></documentation>
          <codeblock>
            <location sl="116" sc="9" el="119" ec="10">FileRegistration\Providers\LoaderControlProvider.cs</location>
            <body hash="eb4f739bed273c433ddf1ec2a5dd6a31"><![CDATA[{
            AddToControl(http, css.Replace("&", "&amp;"));
            AddToControl(http, js.Replace("&", "&amp;"));
        }]]></body>
          </codeblock>
        </method>
        <method name="RenderCssDependencies">
          <declaration><![CDATA[protected override string RenderCssDependencies(IEnumerable<IClientDependencyFile> cssDependencies, HttpContextBase http, IDictionary<string, string> htmlAttributes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="63" sc="9" el="93" ec="10">FileRegistration\Providers\LoaderControlProvider.cs</location>
            <body hash="05142d9bedf664f5c784abe551cf07a2"><![CDATA[{
            var asArray = cssDependencies.ToArray();

            if (!asArray.Any())
                return string.Empty;

            var sb = new StringBuilder();

            if (http.IsDebuggingEnabled || !EnableCompositeFiles)
            {
                foreach (var dependency in asArray)
                {
                    sb.Append(RenderSingleCssFile(dependency.FilePath, htmlAttributes));
                }
            }
            else
            {
                var comp = ClientDependencySettings.Instance.DefaultCompositeFileProcessingProvider.ProcessCompositeList(
                    asArray, 
                    ClientDependencyType.Css, 
                    http,
                    ClientDependencySettings.Instance.CompositeFileHandlerPath);

                foreach (var s in comp)
                {
                    sb.Append(RenderSingleCssFile(s, htmlAttributes));
                }
            }

            return sb.ToString();
        }]]></body>
          </codeblock>
        </method>
        <method name="RenderJsDependencies">
          <declaration><![CDATA[protected override string RenderJsDependencies(IEnumerable<IClientDependencyFile> jsDependencies, HttpContextBase http, IDictionary<string, string> htmlAttributes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="30" sc="9" el="60" ec="10">FileRegistration\Providers\LoaderControlProvider.cs</location>
            <body hash="b9692cb18f478f17c20b94e1ff9ee905"><![CDATA[{
            var asArray = jsDependencies.ToArray();

            if (!asArray.Any())
                return string.Empty;

            var sb = new StringBuilder();

            if (http.IsDebuggingEnabled || !EnableCompositeFiles)
            {
                foreach (var dependency in asArray)
                {
                    sb.Append(RenderSingleJsFile(dependency.FilePath, htmlAttributes));
                }
            }
            else
            {
                var comp = ClientDependencySettings.Instance.DefaultCompositeFileProcessingProvider.ProcessCompositeList(
                    asArray, 
                    ClientDependencyType.Javascript, 
                    http,
                    ClientDependencySettings.Instance.CompositeFileHandlerPath);

                foreach (var s in comp)
                {
                    sb.Append(RenderSingleJsFile(s, htmlAttributes));
                }
            }

            return sb.ToString();
        }]]></body>
          </codeblock>
        </method>
        <method name="RenderSingleCssFile">
          <declaration><![CDATA[protected override string RenderSingleCssFile(string css, IDictionary<string, string> htmlAttributes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="101" sc="9" el="103" ec="10">FileRegistration\Providers\LoaderControlProvider.cs</location>
            <body hash="68504481af4e99585c5f90d1cddce381"><![CDATA[{
            return string.Format(HtmlEmbedContants.CssEmbedWithSource, css, htmlAttributes.ToHtmlAttributes());
        }]]></body>
          </codeblock>
        </method>
        <method name="RenderSingleJsFile">
          <declaration><![CDATA[protected override string RenderSingleJsFile(string js, IDictionary<string, string> htmlAttributes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="96" sc="9" el="98" ec="10">FileRegistration\Providers\LoaderControlProvider.cs</location>
            <body hash="5e1ab9f30143180a918960f9a74f7674"><![CDATA[{
            return string.Format(HtmlEmbedContants.ScriptEmbedWithSource, js, htmlAttributes.ToHtmlAttributes());
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="DefaultName">
          <declaration><![CDATA[public const string DefaultName = "LoaderControlProvider";]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="PageHeaderProvider">
      <declaration><![CDATA[public class PageHeaderProvider : WebFormsFileRegistrationProvider]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public PageHeaderProvider()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Initialize">
          <declaration><![CDATA[public override void Initialize(string name, NameValueCollection config)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="18" sc="3" el="24" ec="4">FileRegistration\Providers\PageHeaderProvider.cs</location>
            <body hash="456325999987e29dc8f7087ea3885409"><![CDATA[{			
			// Assign the provider a default name if it doesn't have one
			if (string.IsNullOrEmpty(name))
				name = DefaultName;

			base.Initialize(name, config);
		}]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependencies">
          <declaration><![CDATA[protected override void RegisterDependencies(HttpContextBase http, string js, string css)]]></declaration>
          <documentation>
            <summary>
 Registers the dependencies in the page header
 </summary>
 <param name="http"></param>
 <param name="js"></param>
 <param name="css"></param>
 <remarks>
 For some reason ampersands that aren't html escaped are not compliant to HTML standards when they exist in 'link' or 'script' tags in URLs,
 we need to replace the ampersands with &amp; . This is only required for this one w3c compliancy, the URL itself is a valid URL.

 </remarks></documentation>
          <codeblock>
            <location sl="114" sc="9" el="128" ec="10">FileRegistration\Providers\PageHeaderProvider.cs</location>
            <body hash="9ead0e473e53435d4c423c3516efed22"><![CDATA[{
            if (!(http.CurrentHandler is Page))
            {
                throw new InvalidOperationException("The current HttpHandler in a WebFormsFileRegistrationProvider must be of type Page");
            }
            var page = (Page) http.CurrentHandler;

            if (page.Header == null)
                throw new NullReferenceException("PageHeaderProvider requires a runat='server' tag in the page's header tag");

            var jsScriptBlock = new LiteralControl(js.Replace("&", "&amp;"));
            var cssStyleBlock = new LiteralControl(css.Replace("&", "&amp;"));
            page.Header.Controls.Add(cssStyleBlock);
            page.Header.Controls.Add(jsScriptBlock);
        }]]></body>
          </codeblock>
        </method>
        <method name="RenderCssDependencies">
          <declaration><![CDATA[protected override string RenderCssDependencies(IEnumerable<IClientDependencyFile> cssDependencies, HttpContextBase http, IDictionary<string, string> htmlAttributes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="65" sc="9" el="95" ec="4">FileRegistration\Providers\PageHeaderProvider.cs</location>
            <body hash="5b047b7ec669f0ffb8f12443451f3dc7"><![CDATA[{
            var asArray = cssDependencies.ToArray();

            if (!asArray.Any())
                return string.Empty;

            var sb = new StringBuilder();

            if (http.IsDebuggingEnabled || !EnableCompositeFiles)
			{
                foreach (var dependency in asArray)
				{
                    sb.Append(RenderSingleCssFile(dependency.FilePath, htmlAttributes));
				}
			}
			else
			{
                var comp = ClientDependencySettings.Instance.DefaultCompositeFileProcessingProvider.ProcessCompositeList(
                    asArray, 
                    ClientDependencyType.Css, 
                    http,
                    ClientDependencySettings.Instance.CompositeFileHandlerPath);

                foreach (var s in comp)
                {
                    sb.Append(RenderSingleCssFile(s, htmlAttributes));
                }    
			}

            return sb.ToString();
		}]]></body>
          </codeblock>
        </method>
        <method name="RenderJsDependencies">
          <declaration><![CDATA[protected override string RenderJsDependencies(IEnumerable<IClientDependencyFile> jsDependencies, HttpContextBase http, IDictionary<string, string> htmlAttributes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="27" sc="3" el="57" ec="4">FileRegistration\Providers\PageHeaderProvider.cs</location>
            <body hash="b8dd3f6d384ec0ddc8f913783c517fda"><![CDATA[{
            var asArray = jsDependencies.ToArray();

            if (!asArray.Any())
				return string.Empty;

            var sb = new StringBuilder();

            if (http.IsDebuggingEnabled || !EnableCompositeFiles)
			{
                foreach (var dependency in asArray)
				{
                    sb.Append(RenderSingleJsFile(dependency.FilePath, htmlAttributes));
				}
			}
			else
			{
                var comp = ClientDependencySettings.Instance.DefaultCompositeFileProcessingProvider.ProcessCompositeList(
                    asArray, 
                    ClientDependencyType.Javascript, 
                    http,
                    ClientDependencySettings.Instance.CompositeFileHandlerPath);

                foreach (var s in comp)
                {
                    sb.Append(RenderSingleJsFile(s, htmlAttributes));
                }    
			}

            return sb.ToString();
		}]]></body>
          </codeblock>
        </method>
        <method name="RenderSingleCssFile">
          <declaration><![CDATA[protected override string RenderSingleCssFile(string css, IDictionary<string, string> htmlAttributes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="98" sc="3" el="100" ec="4">FileRegistration\Providers\PageHeaderProvider.cs</location>
            <body hash="71a3d605892531612777148108ae5f7a"><![CDATA[{
            return string.Format(HtmlEmbedContants.CssEmbedWithSource, css, htmlAttributes.ToHtmlAttributes());
		}]]></body>
          </codeblock>
        </method>
        <method name="RenderSingleJsFile">
          <declaration><![CDATA[protected override string RenderSingleJsFile(string js, IDictionary<string, string> htmlAttributes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="60" sc="3" el="62" ec="4">FileRegistration\Providers\PageHeaderProvider.cs</location>
            <body hash="02a60aeeee1d24e1ae7e7e543cbb6b46"><![CDATA[{
            return string.Format(HtmlEmbedContants.ScriptEmbedWithSource, js, htmlAttributes.ToHtmlAttributes());
		}]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="DefaultName">
          <declaration><![CDATA[public const string DefaultName = "PageHeaderProvider";]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="PlaceHolderProvider">
      <declaration><![CDATA[public class PlaceHolderProvider : LoaderControlProvider]]></declaration>
      <documentation>
        <summary>
 Uses PlaceHolder controls to render the CSS and JavaScript
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public PlaceHolderProvider()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="17" sc="9" el="21" ec="10">FileRegistration\Providers\PlaceHolderProvider.cs</location>
            <body hash="3d4d4a983c16f283e9775bea230173b5"><![CDATA[public PlaceHolderProvider()
        {
            JavaScriptPlaceHolderId = "JavaScriptPlaceHolder";
            CssPlaceHolderId = "CssPlaceHolder";
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AddToControl">
          <declaration><![CDATA[private static void AddToControl(HttpContextBase http, string literal, Control parent)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="80" sc="9" el="83" ec="10">FileRegistration\Providers\PlaceHolderProvider.cs</location>
            <body hash="7fde8b8ec580de5d4ed597a4e19ec385"><![CDATA[{
            var dCtl = new LiteralControl(literal);
            parent.Controls.Add(dCtl);
        }]]></body>
          </codeblock>
        </method>
        <method name="Initialize">
          <declaration><![CDATA[public override void Initialize(string name, NameValueCollection config)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="30" sc="9" el="48" ec="10">FileRegistration\Providers\PlaceHolderProvider.cs</location>
            <body hash="85c57e2887751fc60f9b205056bde12a"><![CDATA[{
            // Assign the provider a default name if it doesn't have one
            if (string.IsNullOrEmpty(name))
                name = DefaultName;

            base.Initialize(name, config);

            //for some stupid reason r# says this will never be null, but it certainly can be!
            if (config == null) return;

            if (config["javascriptPlaceHolderId"] != null)
            {
                JavaScriptPlaceHolderId = config["javascriptPlaceHolderId"];
            }
            if (config["cssPlaceHolderId"] != null)
            {
                CssPlaceHolderId = config["cssPlaceHolderId"];
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependencies">
          <declaration><![CDATA[protected override void RegisterDependencies(HttpContextBase http, string js, string css)]]></declaration>
          <documentation>
            <summary>
 Registers the dependencies as controls of the placeholder controls specified
 </summary>
 <param name="http"></param>
 <param name="js"></param>
 <param name="css"></param>
 <remarks>
 For some reason ampersands that aren't html escaped are not compliant to HTML standards when they exist in 'link' or 'script' tags in URLs,
 we need to replace the ampersands with &amp; . This is only required for this one w3c compliancy, the URL itself is a valid URL.
 </remarks></documentation>
          <codeblock>
            <location sl="61" sc="9" el="77" ec="10">FileRegistration\Providers\PlaceHolderProvider.cs</location>
            <body hash="dcafe9af9f1d8a559769dd7d9632f697"><![CDATA[{
            var jsPlaceholder = ClientDependencyLoader.GetInstance(http).Page.FlattenChildren()
                .FirstOrDefault(x => x.ID == JavaScriptPlaceHolderId);
            if (jsPlaceholder == null || (!(jsPlaceholder is PlaceHolder)))
            {
                throw new NullReferenceException("Could not find the placeholder control to render the JavaScript:" + JavaScriptPlaceHolderId);
            }
            AddToControl(http, js.Replace("&", "&amp;"), jsPlaceholder);

            var cssPlaceholder = ClientDependencyLoader.GetInstance(http).Page.FlattenChildren()
                .FirstOrDefault(x => x.ID == CssPlaceHolderId);
            if (cssPlaceholder == null || (!(cssPlaceholder is PlaceHolder)))
            {
                throw new NullReferenceException("Could not find the placeholder control to render the CSS:" + CssPlaceHolderId);
            }
            AddToControl(http, css.Replace("&", "&amp;"), cssPlaceholder);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="DefaultName">
          <declaration><![CDATA[public new const string DefaultName = "PlaceHolderProvider";]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="CssPlaceHolderId">
          <declaration><![CDATA[public string CssPlaceHolderId]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="27" sc="42" el="27" ec="46">FileRegistration\Providers\PlaceHolderProvider.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="27" sc="47" el="27" ec="51">FileRegistration\Providers\PlaceHolderProvider.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
        <property name="JavaScriptPlaceHolderId">
          <declaration><![CDATA[public string JavaScriptPlaceHolderId]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="26" sc="49" el="26" ec="53">FileRegistration\Providers\PlaceHolderProvider.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="26" sc="54" el="26" ec="58">FileRegistration\Providers\PlaceHolderProvider.cs</location>
            <body hash="cdaeeeba9b4a4c5ebf042c0215a7bb0e"><![CDATA[set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="RendererCollection">
      <declaration><![CDATA[public class RendererCollection : ProviderCollection]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public RendererCollection()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Add">
          <declaration><![CDATA[public override void Add(ProviderBase provider)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="17" sc="9" el="25" ec="10">FileRegistration\Providers\RendererCollection.cs</location>
            <body hash="59abac8ceee721e99f8d1bec6bd9a9d7"><![CDATA[{
            if (provider == null)
                throw new ArgumentNullException("provider");

            if (!(provider is BaseRenderer))
                throw new ArgumentException("Invalid provider type", "provider");

            base.Add(provider);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="Item">
          <declaration><![CDATA[public new BaseRenderer this[string name]]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="StandardRenderer">
      <declaration><![CDATA[public class StandardRenderer : BaseRenderer]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public StandardRenderer()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Initialize">
          <declaration><![CDATA[public override void Initialize(string name, NameValueCollection config)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="17" sc="9" el="23" ec="10">FileRegistration\Providers\StandardRenderer.cs</location>
            <body hash="4707389e73a898e6ec59bdf29d09471a"><![CDATA[{
            // Assign the provider a default name if it doesn't have one
            if (string.IsNullOrEmpty(name))
                name = DefaultName;

            base.Initialize(name, config);
        }]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependencies">
          <declaration><![CDATA[public override void RegisterDependencies(List<IClientDependencyFile> allDependencies, HashSet<IClientDependencyPath> paths, out string jsOutput, out string cssOutput, HttpContextBase http)]]></declaration>
          <documentation>
            <summary>
 Override because we need to ensure the &amp; is replaced with &amp; This is only required for this one w3c compliancy, the URL itself is a valid URL.
 </summary>
 <param name="allDependencies"></param>
 <param name="paths"></param>
 <param name="jsOutput"></param>
 <param name="cssOutput"></param>
 <param name="http"></param></documentation>
          <codeblock>
            <location sl="34" sc="9" el="39" ec="10">FileRegistration\Providers\StandardRenderer.cs</location>
            <body hash="2b78208a7f14ec434eda297dd29f103a"><![CDATA[{
            base.RegisterDependencies(allDependencies, paths, out jsOutput, out cssOutput, http);

            jsOutput = jsOutput.Replace("&", "&amp;");
            cssOutput = cssOutput.Replace("&", "&amp;");
        }]]></body>
          </codeblock>
        </method>
        <method name="RenderCssDependencies">
          <declaration><![CDATA[protected override string RenderCssDependencies(IEnumerable<IClientDependencyFile> cssDependencies, HttpContextBase http, IDictionary<string, string> htmlAttributes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="75" sc="9" el="105" ec="10">FileRegistration\Providers\StandardRenderer.cs</location>
            <body hash="23dad557aaafbe5ec2b6a35be539a563"><![CDATA[{
            var asArray = cssDependencies.ToArray();

            if (!asArray.Any())
                return string.Empty;

            var sb = new StringBuilder();

            if (http.IsDebuggingEnabled || !EnableCompositeFiles)
            {
                foreach (var dependency in asArray)
                {
                    sb.Append(RenderSingleCssFile(dependency.FilePath, htmlAttributes));
                }
            }
            else
            {
                var comp = ClientDependencySettings.Instance.DefaultCompositeFileProcessingProvider.ProcessCompositeList(
                    asArray, 
                    ClientDependencyType.Css, 
                    http,
                    ClientDependencySettings.Instance.CompositeFileHandlerPath);

                foreach (var s in comp)
                {
                    sb.Append(RenderSingleCssFile(s, htmlAttributes));
                }    
            }

            return sb.ToString();
        }]]></body>
          </codeblock>
        </method>
        <method name="RenderJsDependencies">
          <declaration><![CDATA[protected override string RenderJsDependencies(IEnumerable<IClientDependencyFile> jsDependencies, HttpContextBase http, IDictionary<string, string> htmlAttributes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="42" sc="9" el="72" ec="10">FileRegistration\Providers\StandardRenderer.cs</location>
            <body hash="18260f5f9d434b36c9f59092158f0b0a"><![CDATA[{
            var asArray = jsDependencies.ToArray();

            if (!asArray.Any())
                return string.Empty;

            var sb = new StringBuilder();

            if (http.IsDebuggingEnabled || !EnableCompositeFiles)
            {
                foreach (var dependency in asArray)
                {
                    sb.Append(RenderSingleJsFile(dependency.FilePath, htmlAttributes));
                }
            }
            else
            {
				var comp = ClientDependencySettings.Instance.DefaultCompositeFileProcessingProvider.ProcessCompositeList(
                    asArray, 
                    ClientDependencyType.Javascript, 
                    http, 
                    ClientDependencySettings.Instance.CompositeFileHandlerPath);

                foreach (var s in comp)
                {
                    sb.Append(RenderSingleJsFile(s, htmlAttributes));
                }                
            }

            return sb.ToString();
        }]]></body>
          </codeblock>
        </method>
        <method name="RenderSingleCssFile">
          <declaration><![CDATA[protected override string RenderSingleCssFile(string css, IDictionary<string, string> htmlAttributes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="113" sc="9" el="115" ec="10">FileRegistration\Providers\StandardRenderer.cs</location>
            <body hash="68504481af4e99585c5f90d1cddce381"><![CDATA[{
            return string.Format(HtmlEmbedContants.CssEmbedWithSource, css, htmlAttributes.ToHtmlAttributes());
        }]]></body>
          </codeblock>
        </method>
        <method name="RenderSingleJsFile">
          <declaration><![CDATA[protected override string RenderSingleJsFile(string js, IDictionary<string, string> htmlAttributes)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="108" sc="9" el="110" ec="10">FileRegistration\Providers\StandardRenderer.cs</location>
            <body hash="5e1ab9f30143180a918960f9a74f7674"><![CDATA[{
            return string.Format(HtmlEmbedContants.ScriptEmbedWithSource, js, htmlAttributes.ToHtmlAttributes());
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="DefaultName">
          <declaration><![CDATA[public const string DefaultName = "StandardRenderer";]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="WebFormsFileRegistrationProvider">
      <declaration><![CDATA[public abstract class WebFormsFileRegistrationProvider : BaseFileRegistrationProvider]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[protected WebFormsFileRegistrationProvider()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="RegisterDependencies">
          <declaration><![CDATA[protected abstract void RegisterDependencies(HttpContextBase http, string js, string css);]]></declaration>
          <documentation>
            <summary>
 Called to register the js and css into the page/control/output.
 </summary>
 <param name="http"></param>
 <param name="js"></param>
 <param name="css"></param></documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="RegisterDependencies">
          <declaration><![CDATA[public void RegisterDependencies(Control dependantControl, List<IClientDependencyFile> allDependencies, HashSet<IClientDependencyPath> paths, HttpContextBase http)]]></declaration>
          <documentation>
            <summary>
 Called to register the dependencies into the page/control/output
 </summary>
 <param name="dependantControl"></param>
 <param name="allDependencies"></param>
 <param name="paths"></param>
 <param name="http"></param></documentation>
          <codeblock>
            <location sl="35" sc="9" el="40" ec="10">FileRegistration\Providers\WebFormsFileRegistrationProvider.cs</location>
            <body hash="1ae7124bd9fc8afe9c8bf4dc9dbbc2fb"><![CDATA[{
            string js;
            string css;
            WriteDependencies(allDependencies, paths, out js, out css, http);
            RegisterDependencies(http, js, css);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="ClientDependency.Core.Logging">
    <class name="ILogger">
      <declaration><![CDATA[public interface ILogger]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="Debug">
          <declaration><![CDATA[void Debug(string msg);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Error">
          <declaration><![CDATA[void Error(string msg, Exception ex);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Fatal">
          <declaration><![CDATA[void Fatal(string msg, Exception ex);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Info">
          <declaration><![CDATA[void Info(string msg);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Warn">
          <declaration><![CDATA[void Warn(string msg);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="NullLogger">
      <declaration><![CDATA[internal class NullLogger : ILogger]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public NullLogger()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Debug">
          <declaration><![CDATA[public void Debug(string msg)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="13" sc="9" el="14" ec="10">Logging\NullLogger.cs</location>
            <body hash="539fa760ca172337a931519768c64187"><![CDATA[{
        }]]></body>
          </codeblock>
        </method>
        <method name="Error">
          <declaration><![CDATA[public void Error(string msg, Exception ex)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="25" sc="9" el="26" ec="10">Logging\NullLogger.cs</location>
            <body hash="539fa760ca172337a931519768c64187"><![CDATA[{
        }]]></body>
          </codeblock>
        </method>
        <method name="Fatal">
          <declaration><![CDATA[public void Fatal(string msg, Exception ex)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="29" sc="9" el="30" ec="10">Logging\NullLogger.cs</location>
            <body hash="539fa760ca172337a931519768c64187"><![CDATA[{
        }]]></body>
          </codeblock>
        </method>
        <method name="Info">
          <declaration><![CDATA[public void Info(string msg)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="17" sc="9" el="18" ec="10">Logging\NullLogger.cs</location>
            <body hash="539fa760ca172337a931519768c64187"><![CDATA[{
        }]]></body>
          </codeblock>
        </method>
        <method name="Warn">
          <declaration><![CDATA[public void Warn(string msg)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="21" sc="9" el="22" ec="10">Logging\NullLogger.cs</location>
            <body hash="539fa760ca172337a931519768c64187"><![CDATA[{
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="TraceLogger">
      <declaration><![CDATA[internal class TraceLogger : ILogger]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public TraceLogger()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="Debug">
          <declaration><![CDATA[public void Debug(string msg)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="30" sc="9" el="32" ec="10">Logging\TraceLogger.cs</location>
            <body hash="e664121cdc5220b2950bbcff1354ed1a"><![CDATA[{
            Trace(msg);
        }]]></body>
          </codeblock>
        </method>
        <method name="Error">
          <declaration><![CDATA[public void Error(string msg, Exception ex)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="45" sc="9" el="47" ec="10">Logging\TraceLogger.cs</location>
            <body hash="38c65b6dd082790bd8ed8c5175696f89"><![CDATA[{
            Trace(msg, true);
        }]]></body>
          </codeblock>
        </method>
        <method name="Fatal">
          <declaration><![CDATA[public void Fatal(string msg, Exception ex)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="50" sc="9" el="52" ec="10">Logging\TraceLogger.cs</location>
            <body hash="38c65b6dd082790bd8ed8c5175696f89"><![CDATA[{
            Trace(msg, true);
        }]]></body>
          </codeblock>
        </method>
        <method name="GetHttpContext">
          <declaration><![CDATA[private HttpContextBase GetHttpContext()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="9" sc="9" el="13" ec="10">Logging\TraceLogger.cs</location>
            <body hash="f033decc11483cea40ed8a104df7f623"><![CDATA[{
            if (HttpContext.Current == null)
                return null;
            return new HttpContextWrapper(HttpContext.Current);
        }]]></body>
          </codeblock>
        </method>
        <method name="Info">
          <declaration><![CDATA[public void Info(string msg)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="35" sc="9" el="37" ec="10">Logging\TraceLogger.cs</location>
            <body hash="e664121cdc5220b2950bbcff1354ed1a"><![CDATA[{
            Trace(msg);
        }]]></body>
          </codeblock>
        </method>
        <method name="Trace">
          <declaration><![CDATA[private void Trace(string msg, bool isWarn = false, string category = "ClientDependency")]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="16" sc="9" el="27" ec="10">Logging\TraceLogger.cs</location>
            <body hash="4692d490c39d19120a7391bb5a2061b7"><![CDATA[{
            var http = GetHttpContext();
            if (http == null) return;
            if (isWarn)
            {
                http.Trace.Warn(category, msg);
            }
            else
            {
                http.Trace.Write(category, msg);
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="Warn">
          <declaration><![CDATA[public void Warn(string msg)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="40" sc="9" el="42" ec="10">Logging\TraceLogger.cs</location>
            <body hash="38c65b6dd082790bd8ed8c5175696f89"><![CDATA[{
            Trace(msg, true);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
  <namespace name="ClientDependency.Core.Module">
    <class name="ApplyingResponseFilterEventArgs">
      <declaration><![CDATA[public class ApplyingResponseFilterEventArgs : CancelEventArgs]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public ApplyingResponseFilterEventArgs(HttpContextBase httpContext)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="10" sc="9" el="13" ec="10">Module\ApplyingResponseFilterEventArgs.cs</location>
            <body hash="274269679ecde5c71cbae37747c8da00"><![CDATA[public ApplyingResponseFilterEventArgs(HttpContextBase httpContext)
        {
            HttpContext = httpContext;
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="HttpContext">
          <declaration><![CDATA[public HttpContextBase HttpContext]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="8" sc="46" el="8" ec="50">Module\ApplyingResponseFilterEventArgs.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="8" sc="51" el="8" ec="63">Module\ApplyingResponseFilterEventArgs.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="ClientDependencyModule">
      <declaration><![CDATA[public class ClientDependencyModule : IHttpModule]]></declaration>
      <documentation>
        <summary>
 This module currently replaces rogue scripts with composite scripts.
 Eventually it will handle css files and MVC implementation
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private List<Type> m_FilterTypes = new List<Type>();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="81" sc="9" el="81" ec="61">Module\ClientDependencyModule.cs</location>
            <body hash="408cb02a484a2c616843db18d213ccf6"><![CDATA[private List<Type> m_FilterTypes = new List<Type>()]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="add_ApplyingResponseFilter">
          <declaration><![CDATA[public static void add_ApplyingResponseFilter(EventHandler<ApplyingResponseFilterEventArgs> value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="ExecuteFilter">
          <declaration><![CDATA[private void ExecuteFilter(HttpContextBase http, IEnumerable<IFilter> filters)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="127" sc="9" el="142" ec="10">Module\ClientDependencyModule.cs</location>
            <body hash="5c34a1fe8123f848e8b581afb9f558da"><![CDATA[{
            //raise event, deverlopers can cancel the filter from being applied depending on what is on the http context.
            var args = new ApplyingResponseFilterEventArgs(http);
            OnApplyingResponseFilter(args);

            if (!args.Cancel)
            {
                var filter = new ResponseFilterStream(http.Response.Filter, http);
                foreach (var f in filters.Where(f => f.CanExecute()))
                {
                    filter.TransformString += f.UpdateOutputHtml;
                }
                http.Response.Filter = filter;    
            }
            
        }]]></body>
          </codeblock>
        </method>
        <method name="HandleRequest">
          <declaration><![CDATA[private void HandleRequest(object sender, EventArgs e)]]></declaration>
          <documentation>
            <summary>
 Checks if any assigned filters validate the current handler, if so then assigns any filter
 that CanExecute to the response filter chain.

 Checks if the request MIME type matches the list of mime types specified in the config,
 if it does, then it compresses it.
 </summary>
 <param name="sender"></param>
 <param name="e"></param></documentation>
          <codeblock>
            <location sl="52" sc="9" el="77" ec="10">Module\ClientDependencyModule.cs</location>
            <body hash="0110b37efdc9888e43d3649681c7ed20"><![CDATA[{
            var app = (HttpApplication)sender;
            var http = new HttpContextWrapper(app.Context);

            //if debug is on, then don't compress
            if (!http.IsDebuggingEnabled)
            {
                //IMPORTANT: Compression must be assigned before any other filters are executed!
                // if compression is applied after the response has been modified then we will end
                // up getting encoding errors.
                // The compressor will not attempt to compress if the current filter is not ASP.Net's 
                // original filter. The filter could be changed by developers or perhaps even hosting
                // providers (based on their machine.config with their own modules.
                var c = new MimeTypeCompressor(new HttpContextWrapper(app.Context));
                c.AddCompression();
            }

            var filters = LoadFilters(http);

            if (ValidateCurrentHandler(filters))
            {
                ExecuteFilter(http, filters);
            }

            
        }]]></body>
          </codeblock>
        </method>
        <method name="LoadFilters">
          <declaration><![CDATA[private IEnumerable<IFilter> LoadFilters(HttpContextBase http)]]></declaration>
          <documentation>
            <summary>
 loads instances of all registered filters.
 </summary>
 <param name="http"></param></documentation>
          <codeblock>
            <location sl="102" sc="9" el="114" ec="10">Module\ClientDependencyModule.cs</location>
            <body hash="89d97d25428a58543ae8bb5e9bbdbe3b"><![CDATA[{
            var loadedFilters = new List<IFilter>();

            foreach (var t in m_FilterTypes)
            {
                var filter = (IFilter)Activator.CreateInstance(t);
                filter.SetHttpContext(http);
                loadedFilters.Add(filter);

            }

            return loadedFilters;
        }]]></body>
          </codeblock>
        </method>
        <method name="LoadFilterTypes">
          <declaration><![CDATA[private void LoadFilterTypes()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="86" sc="9" el="95" ec="10">Module\ClientDependencyModule.cs</location>
            <body hash="4cf7f46e52664dd952da9ee2bb70abbe"><![CDATA[{
            foreach (var f in ClientDependencySettings.Instance.ConfigSection.Filters.Cast<ProviderSettings>())
            {
                var t = BuildManager.GetType(f.Type, false, true);
                if (t != null)
                {
                    m_FilterTypes.Add(t);
                }
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="OnApplyingResponseFilter">
          <declaration><![CDATA[private void OnApplyingResponseFilter(ApplyingResponseFilterEventArgs e)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="20" sc="9" el="23" ec="10">Module\ClientDependencyModule.cs</location>
            <body hash="bc8b176338f7c75cd6078026052520d5"><![CDATA[{
            var handler = ApplyingResponseFilter;
            if (handler != null) handler(this, e);
        }]]></body>
          </codeblock>
        </method>
        <method name="remove_ApplyingResponseFilter">
          <declaration><![CDATA[public static void remove_ApplyingResponseFilter(EventHandler<ApplyingResponseFilterEventArgs> value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="System.Web.IHttpModule.Dispose">
          <declaration><![CDATA[void IHttpModule.Dispose()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="27" sc="36" el="27" ec="37">Module\ClientDependencyModule.cs</location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="System.Web.IHttpModule.Init">
          <declaration><![CDATA[void IHttpModule.Init(HttpApplication app)]]></declaration>
          <documentation>
            <summary>
 Binds the events
 </summary>
 <param name="app"></param></documentation>
          <codeblock>
            <location sl="34" sc="9" el="40" ec="10">Module\ClientDependencyModule.cs</location>
            <body hash="038c6eef373ce6b92787834e5d60c60e"><![CDATA[{
            //This event is late enough that the ContentType of the request is set
            //but not too late that we've lost the ability to change the response
            //app.BeginRequest += new EventHandler(HandleRequest);
            app.PostRequestHandlerExecute += HandleRequest;
            LoadFilterTypes();
        }]]></body>
          </codeblock>
        </method>
        <method name="ValidateCurrentHandler">
          <declaration><![CDATA[private static bool ValidateCurrentHandler(IEnumerable<IFilter> filters)]]></declaration>
          <documentation>
            <summary>
 Ensure the current running handler is valid in order to proceed with the module filter.
 </summary>
 <param name="filters"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="122" sc="9" el="124" ec="10">Module\ClientDependencyModule.cs</location>
            <body hash="7158cb0ad5b5e3c4d7e8bd6bdbcf6361"><![CDATA[{
            return filters.Any(f => f.ValidateCurrentHandler());
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="ApplyingResponseFilter">
          <declaration><![CDATA[private static EventHandler<ApplyingResponseFilterEventArgs> ApplyingResponseFilter;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_FilterTypes">
          <declaration><![CDATA[private List<Type> m_FilterTypes = new List<Type>();]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
        <event name="ApplyingResponseFilter">
          <declaration><![CDATA[public static event EventHandler<ApplyingResponseFilterEventArgs> ApplyingResponseFilter;]]></declaration>
          <documentation>
          </documentation>
        </event>
      </events>
    </class>
    <class name="IFilter">
      <declaration><![CDATA[public interface IFilter]]></declaration>
      <documentation>
      </documentation>
      <constructors>
      </constructors>
      <methods>
        <method name="CanExecute">
          <declaration><![CDATA[bool CanExecute();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="SetHttpContext">
          <declaration><![CDATA[void SetHttpContext(HttpContextBase ctx);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="UpdateOutputHtml">
          <declaration><![CDATA[string UpdateOutputHtml(string html);]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="ValidateCurrentHandler">
          <declaration><![CDATA[bool ValidateCurrentHandler();]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
      </fields>
      <properties>
        <property name="CurrentContext">
          <declaration><![CDATA[HttpContextBase CurrentContext]]></declaration>
          <documentation>
          </documentation>
        </property>
      </properties>
      <events>
      </events>
    </class>
    <class name="MimeTypeCompressor">
      <declaration><![CDATA[public class MimeTypeCompressor]]></declaration>
      <documentation>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[public MimeTypeCompressor(HttpContextBase ctx)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="14" sc="9" el="23" ec="10">Module\MimeTypeCompressor.cs</location>
            <body hash="b3887f2653e82b77a61d0551c5a1d54f"><![CDATA[public MimeTypeCompressor(HttpContextBase ctx)
        {
            Context = ctx;
            MatchedTypes = ClientDependencySettings.Instance
                .ConfigSection
                .CompositeFileElement
                .MimeTypeCompression
                .Cast<MimeTypeCompressionElement>()
                .Where(x => Context.Request.ContentType.ToUpper().Split(';').Contains(x.MimeType.ToUpper()));
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="AddCompression">
          <declaration><![CDATA[public void AddCompression()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="29" sc="9" el="53" ec="10">Module\MimeTypeCompressor.cs</location>
            <body hash="a49b63cb286150df3fe203112e132d3a"><![CDATA[{
            if (Context == null) return;

            //if debug is on, then don't compress
            if (!Context.IsDebuggingEnabled)
            {
                if (Context.Response == null) return;
                if (Context.Response.Filter == null) return;

                //if the current filter is not the default ASP.Net filter, then we will not continue.
                var filterType = Context.Response.Filter.GetType();
                //the default is normally: System.Web.HttpResponseStreamFilterSink
                //however that is internal, we'll just assume that any filter that is in the namespace
                // System.Web is the default and we can continue.
                if (filterType.Namespace != null && filterType.Namespace.StartsWith("System.Web"))
                {
                    //check if this request should be compressed based on the mime type and path
                    var m = GetSupportedPath();
                    if (IsSupportedMimeType() && m != null)
                    {
                        PerformCompression(Context);
                    }    
                }
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="GetSupportedPath">
          <declaration><![CDATA[protected MimeTypeCompressionElement GetSupportedPath()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="71" sc="9" el="89" ec="10">Module\MimeTypeCompressor.cs</location>
            <body hash="b549efad77719eddbae0e1b03f2b396d"><![CDATA[{
            //we're not supporting the ASP.Net AJAX calls for compression
            var rawUrl = Context.GetRawUrlSafe();

            if (string.IsNullOrWhiteSpace(rawUrl)) return null;

            var uRawUrl = rawUrl.ToUpper();
            if (uRawUrl.Contains("WEBRESOURCE.AXD") || uRawUrl.Contains("SCRIPTRESOURCE.AXD"))
                return null;

            foreach (var m in MatchedTypes)
            {
                //if it is only "*" then convert it to proper regex
                var reg = m.FilePath == "*" ? ".*" : m.FilePath;
                var matched = Regex.IsMatch(rawUrl, reg, RegexOptions.IgnoreCase);
                if (matched) return m;
            }
            return null;
        }]]></body>
          </codeblock>
        </method>
        <method name="IsSupportedMimeType">
          <declaration><![CDATA[protected bool IsSupportedMimeType()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="92" sc="9" el="95" ec="10">Module\MimeTypeCompressor.cs</location>
            <body hash="464ef3a16d3c3fe391e602f211adbeb0"><![CDATA[{
            return MatchedTypes.Count() > 0;

        }]]></body>
          </codeblock>
        </method>
        <method name="PerformCompression">
          <declaration><![CDATA[internal static void PerformCompression(HttpContextBase context)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="56" sc="9" el="68" ec="10">Module\MimeTypeCompressor.cs</location>
            <body hash="c6cac0b73a1303a099be134e047e9549"><![CDATA[{
            var cType = context.GetClientCompression();
            context.AddCompressionResponseHeader(cType);

            if (cType == CompressionType.deflate)
            {
                context.Response.Filter = new DeflateStream(context.Response.Filter, CompressionMode.Compress);
            }
            else if (cType == CompressionType.gzip)
            {
                context.Response.Filter = new GZipStream(context.Response.Filter, CompressionMode.Compress);
            }
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="Context">
          <declaration><![CDATA[protected HttpContextBase Context;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="MatchedTypes">
          <declaration><![CDATA[protected IEnumerable<MimeTypeCompressionElement> MatchedTypes;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
      </properties>
      <events>
      </events>
    </class>
    <class name="ResponseFilterStream">
      <declaration><![CDATA[public class ResponseFilterStream : Stream]]></declaration>
      <documentation>
        <summary>
 A semi-generic Stream implementation for Response.Filter with
 an event interface for handling Content transformations via
 Stream or String.
 <remarks>
 Use with care for large output as this implementation copies
 the output into a memory stream and so increases memory usage.
 </remarks>
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private MemoryStream _cacheStream = new MemoryStream(5000);]]></declaration>
          <documentation>
            <summary>
 Stream that original content is read into
 and then passed to TransformStream function
 </summary>
          </documentation>
          <codeblock>
            <location sl="46" sc="9" el="64" ec="10">Module\ResponseFilterStream.cs</location>
            <body hash="89ac941b2bfe3cdb70ea4c9ceda54c4d"><![CDATA[MemoryStream _cacheStream = new MemoryStream(5000);

        /// <summary>
        /// Internal pointer that that keeps track of the size
        /// of the cacheStream
        /// </summary>
        int _cachePointer = 0;


        /// <summary>
        /// 
        /// </summary>
        /// <param name="responseStream"></param>
        /// <param name="http"></param>
        public ResponseFilterStream(Stream responseStream, HttpContextBase http)
        {
            _stream = responseStream;
            _http = http;
        }]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="add_CaptureStream">
          <declaration><![CDATA[public void add_CaptureStream(Action<MemoryStream> value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="add_CaptureString">
          <declaration><![CDATA[public void add_CaptureString(Action<string> value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="add_TransformStream">
          <declaration><![CDATA[public void add_TransformStream(Func<MemoryStream, MemoryStream> value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="add_TransformString">
          <declaration><![CDATA[public void add_TransformString(Func<string, string> value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="add_TransformWrite">
          <declaration><![CDATA[public void add_TransformWrite(Func<byte[], byte[]> value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="add_TransformWriteString">
          <declaration><![CDATA[public void add_TransformWriteString(Func<string, string> value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Close">
          <declaration><![CDATA[public override void Close()]]></declaration>
          <documentation>
            <summary>

 </summary>
          </documentation>
          <codeblock>
            <location sl="315" sc="9" el="318" ec="10">Module\ResponseFilterStream.cs</location>
            <body hash="f7d9d2b5a5a94e377473f2e23f1b21d3"><![CDATA[{
            _stream.Close();
            _cacheStream.Close();
        }]]></body>
          </codeblock>
        </method>
        <method name="Dispose">
          <declaration><![CDATA[public new void Dispose()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="321" sc="9" el="325" ec="10">Module\ResponseFilterStream.cs</location>
            <body hash="74e7acc91837f78e840cafe27a69b5e0"><![CDATA[{
            base.Dispose();
            Dispose(true);
            GC.SuppressFinalize(this);
        }]]></body>
          </codeblock>
        </method>
        <method name="Dispose">
          <declaration><![CDATA[protected override void Dispose(bool disposing)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="328" sc="9" el="332" ec="10">Module\ResponseFilterStream.cs</location>
            <body hash="1910806a57f51d54b457d8fd144ae42b"><![CDATA[{
            base.Dispose(disposing);
            _stream.Dispose();
            _cacheStream.Dispose();
        }]]></body>
          </codeblock>
        </method>
        <method name="Finalize">
          <declaration><![CDATA[~ResponseFilterStream()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="67" sc="9" el="69" ec="10">Module\ResponseFilterStream.cs</location>
            <body hash="ecd1f5ddc86468e40c8c978f0220687d"><![CDATA[{
            Dispose(false);
        }]]></body>
          </codeblock>
        </method>
        <method name="Flush">
          <declaration><![CDATA[public override void Flush()]]></declaration>
          <documentation>
            <summary>
 Override flush by writing out the cached stream data
 </summary>
          </documentation>
          <codeblock>
            <location sl="338" sc="9" el="359" ec="10">Module\ResponseFilterStream.cs</location>
            <body hash="941adf25e33f0b63f25a22a04de86780"><![CDATA[{

            if (IsCaptured && _cacheStream.Length > 0)
            {
                // Check for transform implementations
                _cacheStream = OnTransformCompleteStream(_cacheStream);
                _cacheStream = OnTransformCompleteStringInternal(_cacheStream);

                OnCaptureStream(_cacheStream);
                OnCaptureStringInternal(_cacheStream);

                // write the stream back out if output was delayed
                if (IsOutputDelayed)
                    _stream.Write(_cacheStream.ToArray(), 0, (int)_cacheStream.Length);

                // Clear the cache once we've written it out
                _cacheStream.SetLength(0);
            }

            // default flush behavior
            _stream.Flush();
        }]]></body>
          </codeblock>
        </method>
        <method name="OnCaptureStream">
          <declaration><![CDATA[protected virtual void OnCaptureStream(MemoryStream ms)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="159" sc="9" el="162" ec="10">Module\ResponseFilterStream.cs</location>
            <body hash="11790c3bc18607311678cb4489a3be21"><![CDATA[{
            if (CaptureStream != null)
                CaptureStream(ms);
        }]]></body>
          </codeblock>
        </method>
        <method name="OnCaptureString">
          <declaration><![CDATA[protected virtual void OnCaptureString(string output)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="175" sc="9" el="178" ec="10">Module\ResponseFilterStream.cs</location>
            <body hash="89383516874f0a46eaa5433bf42ad264"><![CDATA[{
            if (CaptureString != null)
                CaptureString(output);
        }]]></body>
          </codeblock>
        </method>
        <method name="OnCaptureStringInternal">
          <declaration><![CDATA[private void OnCaptureStringInternal(MemoryStream ms)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="166" sc="9" el="172" ec="10">Module\ResponseFilterStream.cs</location>
            <body hash="e5272eda48a2b97c57a2059f2f1c467e"><![CDATA[{
            if (CaptureString != null)
            {
                string content = _http.Response.ContentEncoding.GetString(ms.ToArray());
                OnCaptureString(content);
            }
        }]]></body>
          </codeblock>
        </method>
        <method name="OnTransformCompleteStream">
          <declaration><![CDATA[protected virtual MemoryStream OnTransformCompleteStream(MemoryStream ms)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="203" sc="9" el="208" ec="10">Module\ResponseFilterStream.cs</location>
            <body hash="e57627d1c0f3131c6800ef6e9be4881a"><![CDATA[{
            if (TransformStream != null)
                return TransformStream(ms);

            return ms;
        }]]></body>
          </codeblock>
        </method>
        <method name="OnTransformCompleteString">
          <declaration><![CDATA[private string OnTransformCompleteString(string responseText)]]></declaration>
          <documentation>
            <summary>
 Allows transforming of strings

 Note this handler is internal and not meant to be overridden
 as the TransformString Event has to be hooked up in order
 for this handler to even fire to avoid the overhead of string
 conversion on every pass through.
 </summary>
 <param name="responseText"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="224" sc="9" el="229" ec="10">Module\ResponseFilterStream.cs</location>
            <body hash="845d557517870d625b5052bb290f1617"><![CDATA[{
            if (TransformString != null)
                TransformString(responseText);

            return responseText;
        }]]></body>
          </codeblock>
        </method>
        <method name="OnTransformCompleteStringInternal">
          <declaration><![CDATA[internal MemoryStream OnTransformCompleteStringInternal(MemoryStream ms)]]></declaration>
          <documentation>
            <summary>
 Wrapper method form OnTransformString that handles
 stream to string and vice versa conversions
 </summary>
 <param name="ms"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="238" sc="9" el="252" ec="10">Module\ResponseFilterStream.cs</location>
            <body hash="b921481b8b66859e56bf9afedf815b34"><![CDATA[{
            if (TransformString == null)
                return ms;

            //string content = ms.GetAsString();
            string content = _http.Response.ContentEncoding.GetString(ms.ToArray());

            content = TransformString(content);
            byte[] buffer = _http.Response.ContentEncoding.GetBytes(content);
            ms = new MemoryStream();
            ms.Write(buffer, 0, buffer.Length);
            //ms.WriteString(content);

            return ms;
        }]]></body>
          </codeblock>
        </method>
        <method name="OnTransformWrite">
          <declaration><![CDATA[protected virtual byte[] OnTransformWrite(byte[] buffer)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="181" sc="9" el="185" ec="10">Module\ResponseFilterStream.cs</location>
            <body hash="839527c17e5a935f67db930545ee61a0"><![CDATA[{
            if (TransformWrite != null)
                return TransformWrite(buffer);
            return buffer;
        }]]></body>
          </codeblock>
        </method>
        <method name="OnTransformWriteString">
          <declaration><![CDATA[private string OnTransformWriteString(string value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="195" sc="9" el="199" ec="10">Module\ResponseFilterStream.cs</location>
            <body hash="b512640a5d217f505a64bcbc2d7ca69f"><![CDATA[{
            if (TransformWriteString != null)
                return TransformWriteString(value);
            return value;
        }]]></body>
          </codeblock>
        </method>
        <method name="OnTransformWriteStringInternal">
          <declaration><![CDATA[private byte[] OnTransformWriteStringInternal(byte[] buffer)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="188" sc="9" el="192" ec="10">Module\ResponseFilterStream.cs</location>
            <body hash="de4b486dd041f2bb663d60adce46ed79"><![CDATA[{
            Encoding encoding = _http.Response.ContentEncoding;
            string output = OnTransformWriteString(encoding.GetString(buffer));
            return encoding.GetBytes(output);
        }]]></body>
          </codeblock>
        </method>
        <method name="Read">
          <declaration><![CDATA[public override int Read(byte[] buffer, int offset, int count)]]></declaration>
          <documentation>
            <summary>

 </summary>
 <param name="buffer"></param>
 <param name="offset"></param>
 <param name="count"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="369" sc="9" el="371" ec="10">Module\ResponseFilterStream.cs</location>
            <body hash="dffdc22e6aa331ed249ed7307c2747e1"><![CDATA[{
            return _stream.Read(buffer, offset, count);
        }]]></body>
          </codeblock>
        </method>
        <method name="remove_CaptureStream">
          <declaration><![CDATA[public void remove_CaptureStream(Action<MemoryStream> value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="remove_CaptureString">
          <declaration><![CDATA[public void remove_CaptureString(Action<string> value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="remove_TransformStream">
          <declaration><![CDATA[public void remove_TransformStream(Func<MemoryStream, MemoryStream> value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="remove_TransformString">
          <declaration><![CDATA[public void remove_TransformString(Func<string, string> value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="remove_TransformWrite">
          <declaration><![CDATA[public void remove_TransformWrite(Func<byte[], byte[]> value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="remove_TransformWriteString">
          <declaration><![CDATA[public void remove_TransformWriteString(Func<string, string> value)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="2147483647" sc="0" el="0" ec="0">
            </location>
            <body hash="d41d8cd98f00b204e9800998ecf8427e"><![CDATA[]]></body>
          </codeblock>
        </method>
        <method name="Seek">
          <declaration><![CDATA[public override long Seek(long offset, SeekOrigin direction)]]></declaration>
          <documentation>
            <summary>

 </summary>
 <param name="offset"></param>
 <param name="direction"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="298" sc="9" el="300" ec="10">Module\ResponseFilterStream.cs</location>
            <body hash="fbf1c1019da2440446430288c0ff2dac"><![CDATA[{
            return _stream.Seek(offset, direction);
        }]]></body>
          </codeblock>
        </method>
        <method name="SetLength">
          <declaration><![CDATA[public override void SetLength(long length)]]></declaration>
          <documentation>
            <summary>

 </summary>
 <param name="length"></param></documentation>
          <codeblock>
            <location sl="307" sc="9" el="309" ec="10">Module\ResponseFilterStream.cs</location>
            <body hash="cca951619bacc526571643cadd27582f"><![CDATA[{
            _stream.SetLength(length);
        }]]></body>
          </codeblock>
        </method>
        <method name="Write">
          <declaration><![CDATA[public override void Write(byte[] buffer, int offset, int count)]]></declaration>
          <documentation>
            <summary>
 Overriden to capture output written by ASP.NET and captured
 into a cached stream that is written out later when Flush()
 is called.
 </summary>
 <param name="buffer"></param>
 <param name="offset"></param>
 <param name="count"></param></documentation>
          <codeblock>
            <location sl="383" sc="9" el="400" ec="10">Module\ResponseFilterStream.cs</location>
            <body hash="dd1ea87ac9c2308a95ea8cc2c31606b5"><![CDATA[{
            if (IsCaptured)
            {
                // copy to holding buffer only - we'll write out later
                _cacheStream.Write(buffer, 0, count);
                _cachePointer += count;
            }

            // just transform this buffer
            if (TransformWrite != null)
                buffer = OnTransformWrite(buffer);
            if (TransformWriteString != null)
                buffer = OnTransformWriteStringInternal(buffer);

            if (!IsOutputDelayed)
                _stream.Write(buffer, offset, count);

        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="_cachePointer">
          <declaration><![CDATA[private int _cachePointer = 0;]]></declaration>
          <documentation>
            <summary>
 Internal pointer that that keeps track of the size
 of the cacheStream
 </summary>
          </documentation>
        </field>
        <field name="_cacheStream">
          <declaration><![CDATA[private MemoryStream _cacheStream = new MemoryStream(5000);]]></declaration>
          <documentation>
            <summary>
 Stream that original content is read into
 and then passed to TransformStream function
 </summary>
          </documentation>
        </field>
        <field name="_http">
          <declaration><![CDATA[private readonly HttpContextBase _http;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="_position">
          <declaration><![CDATA[private long _position;]]></declaration>
          <documentation>
            <summary>
 Current position in the original stream
 </summary>
          </documentation>
        </field>
        <field name="_stream">
          <declaration><![CDATA[private readonly Stream _stream;]]></declaration>
          <documentation>
            <summary>
 The original stream
 </summary>
          </documentation>
        </field>
        <field name="CaptureStream">
          <declaration><![CDATA[private Action<MemoryStream> CaptureStream;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="CaptureString">
          <declaration><![CDATA[private Action<string> CaptureString;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="TransformStream">
          <declaration><![CDATA[private Func<MemoryStream, MemoryStream> TransformStream;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="TransformString">
          <declaration><![CDATA[private Func<string, string> TransformString;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="TransformWrite">
          <declaration><![CDATA[private Func<byte[], byte[]> TransformWrite;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="TransformWriteString">
          <declaration><![CDATA[private Func<string, string> TransformWriteString;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="CanRead">
          <declaration><![CDATA[public override bool CanRead]]></declaration>
          <documentation>
            <summary>

 </summary>
          </documentation>
        </property>
        <property name="CanSeek">
          <declaration><![CDATA[public override bool CanSeek]]></declaration>
          <documentation>
          </documentation>
        </property>
        <property name="CanWrite">
          <declaration><![CDATA[public override bool CanWrite]]></declaration>
          <documentation>
            <summary>

 </summary>
          </documentation>
        </property>
        <property name="IsCaptured">
          <declaration><![CDATA[private bool IsCaptured]]></declaration>
          <documentation>
            <summary>
 Determines whether the stream is captured
 </summary>
          </documentation>
          <codeblock>
            <location sl="77" sc="13" el="84" ec="14">Module\ResponseFilterStream.cs</location>
            <body hash="ed25d9200e3a0191a47b6644b7cc8b8e"><![CDATA[{

                if (CaptureStream != null || CaptureString != null ||
                    TransformStream != null || TransformString != null)
                    return true;

                return false;
            }]]></body>
          </codeblock>
        </property>
        <property name="IsOutputDelayed">
          <declaration><![CDATA[private bool IsOutputDelayed]]></declaration>
          <documentation>
            <summary>
 Determines whether the Write method is outputting data immediately
 or delaying output until Flush() is fired.
 </summary>
          </documentation>
          <codeblock>
            <location sl="94" sc="13" el="99" ec="14">Module\ResponseFilterStream.cs</location>
            <body hash="dc06ca127648d31b828b1bdda2be8523"><![CDATA[{
                if (TransformStream != null || TransformString != null)
                    return true;

                return false;
            }]]></body>
          </codeblock>
        </property>
        <property name="Length">
          <declaration><![CDATA[public override long Length]]></declaration>
          <documentation>
            <summary>

 </summary>
          </documentation>
        </property>
        <property name="Position">
          <declaration><![CDATA[public override long Position]]></declaration>
          <documentation>
            <summary>

 </summary>
          </documentation>
        </property>
      </properties>
      <events>
        <event name="CaptureStream">
          <declaration><![CDATA[public event Action<MemoryStream> CaptureStream;]]></declaration>
          <documentation>
            <summary>
 Event that captures Response output and makes it available
 as a MemoryStream instance. Output is captured but won't
 affect Response output.
 </summary>
          </documentation>
        </event>
        <event name="CaptureString">
          <declaration><![CDATA[public event Action<string> CaptureString;]]></declaration>
          <documentation>
            <summary>
 Event that captures Response output and makes it available
 as a string. Output is captured but won't affect Response output.
 </summary>
          </documentation>
        </event>
        <event name="TransformStream">
          <declaration><![CDATA[public event Func<MemoryStream, MemoryStream> TransformStream;]]></declaration>
          <documentation>
            <summary>
 This event allows capturing and transformation of the entire
 output stream by caching all write operations and delaying final
 response output until Flush() is called on the stream.
 </summary>
          </documentation>
        </event>
        <event name="TransformString">
          <declaration><![CDATA[public event Func<string, string> TransformString;]]></declaration>
          <documentation>
            <summary>
 Event that can be hooked up to handle Response.Filter
 Transformation. Passed a string that you can modify and
 return back as a return value. The modified content
 will become the final output.
 </summary>
          </documentation>
        </event>
        <event name="TransformWrite">
          <declaration><![CDATA[public event Func<byte[], byte[]> TransformWrite;]]></declaration>
          <documentation>
            <summary>
 Event that allows you transform the stream as each chunk of
 the output is written in the Write() operation of the stream.
 This means that that it's possible/likely that the input
 buffer will not contain the full response output but only
 one of potentially many chunks.

 This event is called as part of the filter stream's Write()
 operation.
 </summary>
          </documentation>
        </event>
        <event name="TransformWriteString">
          <declaration><![CDATA[public event Func<string, string> TransformWriteString;]]></declaration>
          <documentation>
            <summary>
 Event that allows you to transform the response stream as
 each chunk of bytep[] output is written during the stream's write
 operation. This means it's possibly/likely that the string
 passed to the handler only contains a portion of the full
 output. Typical buffer chunks are around 16k a piece.

 This event is called as part of the stream's Write operation.
 </summary>
          </documentation>
        </event>
      </events>
    </class>
    <class name="RogueFileFilter">
      <declaration><![CDATA[public class RogueFileFilter : IFilter]]></declaration>
      <documentation>
        <summary>
 Used as an http response filter to modify the contents of the output html.
 This filter is used to intercept js and css rogue registrations on the html page.
 </summary>
      </documentation>
      <constructors>
        <constructor name=".ctor">
          <declaration><![CDATA[private bool? m_Runnable = null;]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="28" sc="9" el="32" ec="64">Module\RogueFileFilter.cs</location>
            <body hash="3615e04da088a309efdc21825d32f0dc"><![CDATA[private bool? m_Runnable = null;
        private string m_MatchScript = "<script(?:(?:.*(?<src>(?<=src=\")[^\"]*(?=\"))[^>]*)|[^>]*)>(?<content>(?:(?:\n|.)(?!(?:\n|.)<script))*)</script>";
        private string m_MatchLink = "<link\\s+[^>]*(href\\s*=\\s*(['\"])(?<href>.*?)\\2)";

        private RogueFileCompressionElement m_FoundPath = null;]]></body>
          </codeblock>
        </constructor>
      </constructors>
      <methods>
        <method name="CanExecute">
          <declaration><![CDATA[public bool CanExecute()]]></declaration>
          <documentation>
            <summary>
 Returns true when this filter should be applied
 </summary>
 <returns></returns></documentation>
          <codeblock>
            <location sl="62" sc="9" el="74" ec="10">Module\RogueFileFilter.cs</location>
            <body hash="621c23468d359aea07c49453436fdcf9"><![CDATA[{
            if (!ValidateCurrentHandler())
            {
                return false;
            }

            if (!m_Runnable.HasValue)
            {
                m_Runnable = (m_FoundPath != null);
            }
            return m_Runnable.Value;

        }]]></body>
          </codeblock>
        </method>
        <method name="GetSupportedPath">
          <declaration><![CDATA[private RogueFileCompressionElement GetSupportedPath()]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="94" sc="9" el="111" ec="10">Module\RogueFileFilter.cs</location>
            <body hash="95ad5e1bf28185cb017801c0104790b7"><![CDATA[{
            var rawUrl = CurrentContext.GetRawUrlSafe();
            if (string.IsNullOrWhiteSpace(rawUrl)) return null;


            var rogueFiles = ClientDependencySettings.Instance
                .ConfigSection
                .CompositeFileElement
                .RogueFileCompression;

            return (from m in rogueFiles.Cast<RogueFileCompressionElement>()
                    let reg = m.FilePath == "*" ? ".*" : m.FilePath
                    let matched = Regex.IsMatch(rawUrl, reg, RegexOptions.IgnoreCase)
                    where matched
                    let isGood = m.ExcludePaths.Cast<RogueFileCompressionExcludeElement>().Select(e => Regex.IsMatch(rawUrl, e.FilePath, RegexOptions.IgnoreCase)).All(excluded => !excluded)
                    where isGood
                    select m).FirstOrDefault();
        }]]></body>
          </codeblock>
        </method>
        <method name="ReplaceContent">
          <declaration><![CDATA[private static string ReplaceContent(string html, string namedGroup, string[] extensions, ClientDependencyType type, string regex, HttpContextBase http)]]></declaration>
          <documentation>
            <summary>
 Replaces the content with the new js/css paths
 </summary>
 <param name="html"></param>
 <param name="namedGroup"></param>
 <param name="extensions"></param>
 <param name="type"></param>
 <param name="regex"></param>
 <param name="http"></param>
 <returns></returns>
 <remarks>
 For some reason ampersands that aren't html escaped are not compliant to HTML standards when they exist in 'link' or 'script' tags in URLs,
 we need to replace the ampersands with &amp; . This is only required for this one w3c compliancy, the URL itself is a valid URL.
 </remarks></documentation>
          <codeblock>
            <location sl="161" sc="9" el="208" ec="10">Module\RogueFileFilter.cs</location>
            <body hash="1a7a67d21844ca6682a510fb38ca53eb"><![CDATA[{
            html = Regex.Replace(html, regex,
                (m) =>
                {
                    var grp = m.Groups[namedGroup];

                    //if there is no namedGroup group name or it doesn't end with a js/css extension or it's already using the composite handler,
                    //the return the existing string.
                    if (grp == null
                        || string.IsNullOrEmpty(grp.ToString())
                        || !grp.ToString().EndsWithOneOf(extensions)
                        || grp.ToString().StartsWith(ClientDependencySettings.Instance.CompositeFileHandlerPath))
                        return m.ToString();

                    
                    //make sure that it's an internal request, though we can deal with external 
                    //requests, we'll leave that up to the developer to register an external request
                    //explicitly if they want to include in the composite scripts.
                    try
                    {
                        var url = new Uri(grp.ToString(), UriKind.RelativeOrAbsolute);
                        if (!url.IsLocalUri(http))
                            return m.ToString(); //not a local uri        
                        else
                        {
                           
                            var dependency = new BasicFile(type) { FilePath = grp.ToString() };

                            var file = new[] { new BasicFile(type) { FilePath = dependency.ResolveFilePath(http) } };

                            var resolved = ClientDependencySettings.Instance.DefaultCompositeFileProcessingProvider.ProcessCompositeList(
                                file,
                                type,
								http).Single();

                            return m.ToString().Replace(grp.ToString(), resolved.Replace("&", "&amp;"));
                        }
                    }
                    catch (UriFormatException)
                    {
                        //malformed url, let's exit
                        return m.ToString();
                    }

                });

            return html;
        }]]></body>
          </codeblock>
        </method>
        <method name="ReplaceScripts">
          <declaration><![CDATA[private string ReplaceScripts(string html)]]></declaration>
          <documentation>
            <summary>
 Replaces all src attribute values for a script tag with their corresponding
 URLs as a composite script.
 </summary>
 <param name="html"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="120" sc="9" el="127" ec="10">Module\RogueFileFilter.cs</location>
            <body hash="6a50cbc5a8f93d563957582f1bf67190"><![CDATA[{
            //check if we should be processing!            
            if (CanExecute() && m_FoundPath.CompressJs)
            {
                return ReplaceContent(html, "src", m_FoundPath.JsRequestExtension.Split(','), ClientDependencyType.Javascript, m_MatchScript, CurrentContext);
            }
            return html;
        }]]></body>
          </codeblock>
        </method>
        <method name="ReplaceStyles">
          <declaration><![CDATA[private string ReplaceStyles(string html)]]></declaration>
          <documentation>
            <summary>
 Replaces all href attribute values for a link tag with their corresponding
 URLs as a composite style.
 </summary>
 <param name="html"></param>
 <returns></returns></documentation>
          <codeblock>
            <location sl="136" sc="9" el="143" ec="10">Module\RogueFileFilter.cs</location>
            <body hash="7d1f1816155d1502af472c017c288794"><![CDATA[{
            //check if we should be processing!            
            if (CanExecute() && m_FoundPath.CompressCss)
            {
                return ReplaceContent(html, "href", m_FoundPath.CssRequestExtension.Split(','), ClientDependencyType.Css, m_MatchLink, CurrentContext);
            }
            return html;
        }]]></body>
          </codeblock>
        </method>
        <method name="SetHttpContext">
          <declaration><![CDATA[public void SetHttpContext(HttpContextBase ctx)]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="39" sc="9" el="42" ec="10">Module\RogueFileFilter.cs</location>
            <body hash="f3310917cd0b5dd9ca341c6ee598bb41"><![CDATA[{
            CurrentContext = ctx;
            m_FoundPath = GetSupportedPath();
        }]]></body>
          </codeblock>
        </method>
        <method name="UpdateOutputHtml">
          <declaration><![CDATA[public string UpdateOutputHtml(string html)]]></declaration>
          <documentation>
            <summary>
 Replaces any rogue script tag's with calls to the compression handler instead
 of just the script.
 </summary>
          </documentation>
          <codeblock>
            <location sl="81" sc="9" el="85" ec="10">Module\RogueFileFilter.cs</location>
            <body hash="15d812a4ee85d4e5212cc95b6cc902e8"><![CDATA[{
            html = ReplaceScripts(html);
            html = ReplaceStyles(html);
            return html;
        }]]></body>
          </codeblock>
        </method>
        <method name="ValidateCurrentHandler">
          <declaration><![CDATA[public virtual bool ValidateCurrentHandler()]]></declaration>
          <documentation>
            <summary>
 This filter can only execute when it's a Page or MvcHandler
 </summary>
 <returns></returns></documentation>
          <codeblock>
            <location sl="49" sc="9" el="55" ec="10">Module\RogueFileFilter.cs</location>
            <body hash="525624b787cd885e5c8dbdc6a0744b1a"><![CDATA[{
            //don't filter if we're in debug mode
            if (CurrentContext.IsDebuggingEnabled || !ClientDependencySettings.Instance.DefaultFileRegistrationProvider.EnableCompositeFiles)
                return false;

            return (CurrentContext.CurrentHandler is Page);
        }]]></body>
          </codeblock>
        </method>
      </methods>
      <fields>
        <field name="m_FoundPath">
          <declaration><![CDATA[private RogueFileCompressionElement m_FoundPath = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_MatchLink">
          <declaration><![CDATA[private string m_MatchLink = "<link\\s+[^>]*(href\\s*=\\s*(['\"])(?<href>.*?)\\2)";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_MatchScript">
          <declaration><![CDATA[private string m_MatchScript = "<script(?:(?:.*(?<src>(?<=src=\")[^\"]*(?=\"))[^>]*)|[^>]*)>(?<content>(?:(?:\n|.)(?!(?:\n|.)<script))*)</script>";]]></declaration>
          <documentation>
          </documentation>
        </field>
        <field name="m_Runnable">
          <declaration><![CDATA[private bool? m_Runnable = null;]]></declaration>
          <documentation>
          </documentation>
        </field>
      </fields>
      <properties>
        <property name="CurrentContext">
          <declaration><![CDATA[public HttpContextBase CurrentContext]]></declaration>
          <documentation>
          </documentation>
          <codeblock>
            <location sl="87" sc="49" el="87" ec="53">Module\RogueFileFilter.cs</location>
            <body hash="b5eda0a74558a342cf659187f06f746f"><![CDATA[get]]></body>
          </codeblock>
          <codeblock>
            <location sl="87" sc="54" el="87" ec="66">Module\RogueFileFilter.cs</location>
            <body hash="5dbe2cc086ebbf5db6b03610487cca4c"><![CDATA[private set]]></body>
          </codeblock>
        </property>
      </properties>
      <events>
      </events>
    </class>
  </namespace>
</root>